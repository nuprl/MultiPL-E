language: scala
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        val maxBuckets = mutable.HashMap[Long,\
    \ Long]()\n        val maxWells = mutable.HashMap[Long, Long]()\n        val maxBucketsCount\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount2 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount2 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount3\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount3 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount4 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount4 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount5\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount5 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount6 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount6 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount7\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount7 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount8 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount8 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount9\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount9 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount10 = mutable.HashMap[Long, Long]()\n   \
    \     val maxWellsCount10 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount11\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount11 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount12 = mutable.HashMap[Long, Long]()\n   \
    \     val maxWellsCount12 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount13\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount13 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount14 = mutable.HashMap[\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc3by6z9w.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpc3by6z9w.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpc3by6z9w.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpc3by6z9w.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxBuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc3by6z9w.scala:29:23\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxWells\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpc3by6z9w.scala:30:30 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mmaxBucketsCount\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    ["
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n  \
    \      val bucketsCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacity =\
    \ mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpit6p7in_.scala:52:11 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpit6p7in_.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpit6p7in_.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpit6p7in_.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityC"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val bucketsMap\
    \ = buckets.map(_.toMap)\n        val bucketsMapKeys = bucketsMap.map(_.keys.toList)\n\
    \        val bucketsMapValues = bucketsMap.map(_.values.toList)\n        val bucketsMapValueSum\
    \ = bucketsMapValues.map(_.sum)\n        val bucketsMapValueSumMap = bucketsMapValueSum.map(_.toMap)\n\
    \        val bucketsMapValueSumMapKeys = bucketsMapValueSumMap.map(_.keys.toList)\n\
    \        val bucketsMapValueSumMapValues = bucketsMapValueSumMap.map(_.values.toList)\n\
    \        val bucketsMapValueSumMapValueSum = bucketsMapValueSumMapValues.map(_.sum)\n\
    \        val bucketsMapValueSumMapValueSumMap = bucketsMapValueSumMapValueSum.map(_.toMap)\n\
    \        val bucketsMapValueSumMapValueSumMapKeys = bucketsMapValueSumMapValueSumMapKeys.map(_.keys.toList)\n\
    \        val bucketsMapValueSumMapValueSumMapValues = bucketsMapValueSumMapValueSumMapValues.map(_.values.toList)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSum = bucketsMapValueSumMapValueSumMapValueSum.map(_.sum)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSumMap = bucketsMapValueSumMapValueSumMapValueSumMap.map(_.toMap)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSumMapKeys = bucketsMapValueSumMapValueSumMapValueSumMapKeys.map(_.keys.toList)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSumMapValues = bucketsMapValueSumMapValueSumMapValueSumMapValues.map(_.values.toList)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSumMapValueSum = bucketsMapValueSumMapValueSumMapValueSumMapValueSum.map(_.sum)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSumMapValueSumMap = bucketsMapValueSumMapValueSumMapValueSumMapValueSumMap.map(_.toMap)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSumMapValueSumMapKeys = bucketsMapValueSumMapValueSumMapValueSumMapValueSumMapKeys.map(_.keys.toList)\n\
    \        val bucketsMapValueSumMapValueSumMapValueSumMapValue\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7jj6uelr.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp7jj6uelr.scala:27:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbucketsMap\e[0m = buckets.map(_.toMap)\n\e[31m\e[31m  \
    \ |\e[0m                                            ^\e[0m\n\e[31m   |\e[0m  \
    \                                     Cannot prove that Long <:< (K, V)\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                       where:    K\
    \ is a type variable\n\e[31m   |\e[0m                                        \
    \         V is a type variable\n\e[31m   |\e[0m                              \
    \         .\n\e[31m\e[31m-- Error: /tmp/tmp7jj6uelr.scala:30:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsMapValueSum\e[0m\
    \ = bucketsMapValues.map(_.sum)\n\e[31m\e[31m   |\e[0m                       \
    \                                    ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e[33mobject\e[0m \e\
    [35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e\
    [0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp7jj6uelr.scala:31:61 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsMapValueSumMap\e\
    [0m = bucketsMapValueSum.map(_.toMap)\n\e[31m\e[31m   |\e[0m                 \
    \                                          ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toMap is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZ"
  stdout: ''
  timestamp: 1659794074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacitySumCountMax = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacitySumCountMin = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCountMinMax = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCountMinMaxSum = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacitySumCountMinMaxSumCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMaxMin = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMaxMinMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCountMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCountMaxMin = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCountMaxMinMax =\
    \ mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCountMaxMinMaxSum\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCountMaxMinMaxSumCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCountMaxMinMaxSumCountMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSumCountMaxMinMaxSumCountMaxMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCountMinMaxSumCountMaxMinMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4qxc9q8f.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4qxc9q8f.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4qxc9q8f.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4qxc9q8f.scala:28:30 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4qxc9q8f.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySum\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4qxc9q8f.scala:30:38 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacitySumCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m          "
  stdout: ''
  timestamp: 1659794074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity =\
    \ mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapacitySumCountMax = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySum\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuhv3czr3.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhv3czr3.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhv3czr3.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhv3czr3.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhv3czr3.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.Array"
  stdout: ''
  timestamp: 1659793746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity =\
    \ mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapacitySumCount2 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount3 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount4\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount5 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount6 = mutable.ArrayBuffer.empty[Int]\n     \
    \   val bucketsCapacitySumCount7 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount8 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount9\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount10 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount11 = mutable.ArrayBuffer.empty[Int]\n    \
    \    val bucketsCapacitySumCount12 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount13 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount14\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount15 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount16 = mutable.ArrayBuffer.empty[Int]\n    \
    \    val bucketsCapacitySumCount17 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount18 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount19\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount20 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount21 = mutable.ArrayBuffer.empty[Int]\n    \
    \    val bucketsCapacitySumCount22 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount23 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount24\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount25 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount26 = mutable.ArrayBuffer.empty[Int]\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySum\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m         \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0sykugzn.scala:30:38 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacitySumCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain"
  stdout: ''
  timestamp: 1659793700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).toList\n        val maxBucket\
    \ = buckets.maxBy(_.length)\n        val maxBucketCapacity = maxBucket.length\n\
    \        val bucketsOfMaxBucket = buckets.filter(_.length == maxBucketCapacity)\n\
    \        val bucketsOfMaxBucketCapacity = bucketsOfMaxBucket.filter(_.length ==\
    \ maxBucketCapacity)\n        val bucketsOfMaxBucketCapacityWithEmpty = bucketsOfMaxBucketCapacity.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmpty = bucketsOfMaxBucketCapacityWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmpty = bucketsOfMaxBucketCapacityWithEmptyWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmpty =\
    \ bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\
    \ = bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\
    \ = bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\
    \ = bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\
    \ = bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\
    \ = bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty.map(_.map(_.toLong))\n\
    \        val bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\
    \ = bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty.map(_.map(_.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2mj5mp7y.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2mj5mp7y.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\e\
    [0m = bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty.map(_.map(_.\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsOfMaxBucketCapacityWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmptyWithEmpty\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp2mj5mp7y.scala:41:5 ---------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- grid) {\n            val bucket = row(0).toLong\n            buckets\
    \ += bucket\n        }\n        val maxBucket = buckets.max\n        val bucketsLeft\
    \ = capacity - maxBucket\n        val bucketsLeft = bucketsLeft.toLong\n     \
    \   val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft =\
    \ bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.size)\n        val bucketsLeft = bucketsLeft.min(buckets.size)\n\
    \        val bucketsLeft = bucketsLeft.min(buckets.size)\n        val bucketsLeft\
    \ = bucketsLeft.min(buckets.\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr0w6r_r8.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpr0w6r_r8.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr0w6r_r8.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.min(buckets.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr0w6r_r8.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.min(buckets.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr0w6r_r8.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.min(buckets.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val bucketsCount\
    \ = buckets.map(_.size)\n        val bucketsSum = bucketsCount.sum\n        val\
    \ bucketsMax = bucketsCount.max\n        val bucketsMin = bucketsCount.min\n \
    \       val bucketsSumOfBuckets = bucketsSum * bucketsMax\n        val bucketsSumOfBucketsMinusOne\
    \ = bucketsSumOfBuckets - 1\n        val bucketsSumOfBucketsMinusTwo = bucketsSumOfBuckets\
    \ - 2\n        val bucketsSumOfBucketsMinusThree = bucketsSumOfBuckets - 3\n \
    \       val bucketsSumOfBucketsMinusFour = bucketsSumOfBuckets - 4\n        val\
    \ bucketsSumOfBucketsMinusFive = bucketsSumOfBuckets - 5\n        val bucketsSumOfBucketsMinusSix\
    \ = bucketsSumOfBuckets - 6\n        val bucketsSumOfBucketsMinusSeven = bucketsSumOfBuckets\
    \ - 7\n        val bucketsSumOfBucketsMinusEight = bucketsSumOfBuckets - 8\n \
    \       val bucketsSumOfBucketsMinusNine = bucketsSumOfBuckets - 9\n        val\
    \ bucketsSumOfBucketsMinusTen = bucketsSumOfBuckets - 10\n        val bucketsSumOfBucketsMinusEleven\
    \ = bucketsSumOfBuckets - 11\n        val bucketsSumOfBucketsMinusTwelve = bucketsSumOfBuckets\
    \ - 12\n        val bucketsSumOfBucketsMinusThirteen = bucketsSumOfBuckets - 13\n\
    \        val bucketsSumOfBucketsMinusFourteen = bucketsSumOfBuckets - 14\n   \
    \     val bucketsSumOfBucketsMinusFifteen = bucketsSumOfBuckets - 15\n       \
    \ val bucketsSumOfBucketsMinusSixteen = bucketsSumOfBuckets - 16\n        val\
    \ bucketsSumOfBucketsMinusSeventeen = bucketsSumOfBuckets - 17\n        val bucketsSumOfBucketsMinusEighteen\
    \ = bucketsSumOfBuckets - 18\n        val bucketsSumOfBucketsMinusNineteen = bucketsSumOfBuckets\
    \ - 19\n        val bucketsSumOfBucketsMinusTwenty = bucketsSumOfBuckets - 20\n\
    \        val bucketsSumOfBucketsMinusThirty = bucketsSumOfBucket\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbrnivqxt.scala:52:45 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfBucketsMinusThirty\e\
    [0m = bucketsSumOfBucket\n\e[31m\e[31m   |\e[0m                              \
    \               ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                      Not found: bucketsSumOfBucket\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbrnivqxt.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).map(_.toSet).map(_.toList)\n\
    \        val maxBucket = buckets.maxBy(_.length)\n        val maxBucketSize =\
    \ maxBucket.length\n        val bucketsSize = maxBucketSize * maxBucketSize\n\
    \        val bucketsCount = buckets.length\n        val bucketsCapacity = buckets.map(_.length).sum\n\
    \        val bucketsCapacityDiff = bucketsCapacity - capacity\n        val bucketsCapacityDiffToZero\
    \ = bucketsCapacityDiff - 0\n        val bucketsCapacityDiffToOne = bucketsCapacityDiff\
    \ - 1\n        val bucketsCapacityDiffToTwo = bucketsCapacityDiff - 2\n      \
    \  val bucketsCapacityDiffToThree = bucketsCapacityDiff - 3\n        val bucketsCapacityDiffToFour\
    \ = bucketsCapacityDiff - 4\n        val bucketsCapacityDiffToFive = bucketsCapacityDiff\
    \ - 5\n        val bucketsCapacityDiffToSix = bucketsCapacityDiff - 6\n      \
    \  val bucketsCapacityDiffToSeven = bucketsCapacityDiff - 7\n        val bucketsCapacityDiffToEight\
    \ = bucketsCapacityDiff - 8\n        val bucketsCapacityDiffToNine = bucketsCapacityDiff\
    \ - 9\n        val bucketsCapacityDiffToTen = bucketsCapacityDiff - 10\n     \
    \   val bucketsCapacityDiffToEleven = bucketsCapacityDiff - 11\n        val bucketsCapacityDiffToTwelve\
    \ = bucketsCapacityDiff - 12\n        val bucketsCapacityDiffToThirteen = bucketsCapacityDiff\
    \ - 13\n        val bucketsCapacityDiffToFourteen = bucketsCapacityDiff - 14\n\
    \        val bucketsCapacityDiffToFifteen = bucketsCapacityDiff - 15\n       \
    \ val bucketsCapacityDiffToSixteen = bucketsCapacityDiff - 16\n        val bucketsCapacityDiffToSeventeen\
    \ = bucketsCapacityDiff - 17\n        val bucketsCapacityDiffToEighteen = bucketsCapacityDiff\
    \ - 18\n        val bucketsCapacityDiffToNineteen = bucketsCapacityDiff - 19\n\
    \        val bucketsCapacityDiffToTwenty = bucketsCapacityDiff - 20\n        val\
    \ bucketsCapacityDiffToTwentyOne = bucketsCapacityDiff - 21\n        val bucketsCapacityDiffToTwentyTwo\
    \ = bucketsCapacityDiff - 22\n        val bucketsCapacityDiff\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgx4lph1z.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpgx4lph1z.scala:57:5 ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val maxBuckets\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxWells = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCount = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        grid.foreach(row => {\n         \
    \   val bucket = row(0)\n            val well = row(1)\n            buckets +=\
    \ bucket\n            wells += well\n            bucketsCount += bucket.asInstanceOf[Long]\n\
    \            wellsCount += well.asInstanceOf[Long]\n        })\n        val maxBucketsCount\
    \ = buckets.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxWellsCount\
    \ = wells.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxBuckets\
    \ = buckets.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxWells\
    \ = wells.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxBucketsCount\
    \ = bucketsCount.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxWellsCount\
    \ = wellsCount.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxBuckets\
    \ = buckets.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxWells\
    \ = wells.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxBucketsCount\
    \ = bucketsCount.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxWellsCount\
    \ = wellsCount.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxBuckets\
    \ = buckets.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxWells\
    \ = wells.foldLeft(0l)((a, b) => if (a > b) a else b)\n        val maxBucketsCount\
    \ = bucketsCount.foldLeft(0l)((a, b) => if (a > b) a \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnwy3v1on.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnwy3v1on.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketsCount\e[0m = buckets.foldLeft(\e[31m0l\e[0m)((\e[36ma\e[0m,\
    \ \e[36mb\e[0m) => \e[33mif\e[0m (a > b) a \e[33melse\e[0m b)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCount is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketsCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpnwy3v1on.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsCount\e[0m = wells.foldLeft(\e\
    [31m0l\e[0m)((\e[36ma\e[0m, \e[36mb\e[0m) => \e[33mif\e[0m (a > b) a \e[33melse\e\
    [0m b)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWellsCount is already defined as \e[33mvalue\e[0m \e[35mmaxWellsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnwy3v1on.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mmaxBuckets\e[0m = buckets.foldLeft(\e\
    [31m0l\e[0m)((\e[36ma\e[0m, \e[36mb\e[0m) => \e[33mif\e[0m (a > b) a \e[33melse\e\
    [0m b)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBuckets is already defined as \e[33mvalue\e[0m \e[35mmaxBuckets\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnwy3v1on.scala:45:12 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mmaxWells\e[0m = wells.foldLeft(\e[31m0l\e\
    [0m"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacitySumCount2 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount3 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount4\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount5 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount6 = mutable.ArrayBuffer.empty[Long]\n    \
    \    val bucketsCapacitySumCount7 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount8 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount9\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount10 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount11 = mutable.ArrayBuffer.empty[Long]\n   \
    \     val bucketsCapacitySumCount12 = mutable.ArrayBuffer.empty[Long]\n      \
    \  val bucketsCapacitySumCount13 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount14 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount15\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount16 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount17 = mutable.ArrayBuffer.empty[Long]\n   \
    \     val bucketsCapacitySumCount18 = mutable.ArrayBuffer.empty[Long]\n      \
    \  val bucketsCapacitySumCount19 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount20 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount21\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount22 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount23 = mutable.ArrayBuffer.empty[Long]\n   \
    \     val bucketsCapacitySumCount24 = mutable.ArrayBuffer.empty[Long]\n      \
    \  val bucketsCapacitySumCount25 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount26 = mutable.ArrayBuffer.empty[Long]\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySum\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8f0mg_za.scala:30:38 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacitySumCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-ex"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[List[Long]]\n  \
    \      val wells = mutable.ArrayBuffer.empty[List[Long]]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCount = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxBucketsCountIndex = mutable.\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpje_xibdl.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpje_xibdl.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCountIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCountIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCountIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpje_xibdl.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCountIndex\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCountIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCountIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpje_xibdl.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCountIndex\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCountIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCountIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpje_xibdl.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCountIndex\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659794072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val bucketsCount = buckets.map(_.length)\n        val bucketsSum\
    \ = bucketsCount.sum\n        val bucketsSum2 = bucketsSum * bucketsSum\n    \
    \    val bucketsSum3 = bucketsSum2 * bucketsSum\n        val bucketsSum4 = bucketsSum3\
    \ * bucketsSum\n        val bucketsSum5 = bucketsSum4 * bucketsSum\n        val\
    \ bucketsSum6 = bucketsSum5 * bucketsSum\n        val bucketsSum7 = bucketsSum6\
    \ * bucketsSum\n        val bucketsSum8 = bucketsSum7 * bucketsSum\n        val\
    \ bucketsSum9 = bucketsSum8 * bucketsSum\n        val bucketsSum10 = bucketsSum9\
    \ * bucketsSum\n        val bucketsSum11 = bucketsSum10 * bucketsSum\n       \
    \ val bucketsSum12 = bucketsSum11 * bucketsSum\n        val bucketsSum13 = bucketsSum12\
    \ * bucketsSum\n        val bucketsSum14 = bucketsSum13 * bucketsSum\n       \
    \ val bucketsSum15 = bucketsSum14 * bucketsSum\n        val bucketsSum16 = bucketsSum15\
    \ * bucketsSum\n        val bucketsSum17 = bucketsSum16 * bucketsSum\n       \
    \ val bucketsSum18 = bucketsSum17 * bucketsSum\n        val bucketsSum19 = bucketsSum18\
    \ * bucketsSum\n        val bucketsSum20 = bucketsSum19 * bucketsSum\n       \
    \ val bucketsSum21 = bucketsSum20 * bucketsSum\n        val bucketsSum22 = bucketsSum21\
    \ * bucketsSum\n        val bucketsSum23 = bucketsSum22 * bucketsSum\n       \
    \ val bucketsSum24 = bucketsSum23 * bucketsSum\n        val bucketsSum25 = bucketsSum24\
    \ * bucketsSum\n        val bucketsSum26 = bucketsSum25 * bucketsSum\n       \
    \ val bucketsSum27 = bucketsSum26 * bucketsSum\n        val bucketsSum28 = bucketsSum27\
    \ * bucketsSum\n        val bucketsSum29 = bucketsSum28 * bucketsSum\n       \
    \ val bucketsSum30 = bucketsSum29 * bucketsSum\n        val bucketsSum31 = bucketsSum30\
    \ * bucketsSum\n        val buckets\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4c1a84oe.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4c1a84oe.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).map(_.size).getOrElse(0)\n        val maxBucketSize =\
    \ maxBucket * capacity\n        val maxBucketCapacity = maxBucketSize / capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val maxBucketCapacityDiff = maxBucketCapacity\
    \ - bucketsCapacity\n        val maxBucketSizeDiff = maxBucketSize - bucketsSize\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiff - maxBucketCapacity\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiff - maxBucketSize\n     \
    \   val maxBucketCapacityDiffDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiff\n\
    \        val maxBucketCapacityDiffDiffDiff = maxBucketCapacityDiffDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiffDiff = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\
    \        val maxBucketCapacityDiffDiff = maxBucketCapacityDiffDiff - maxBucketCapacityDiffDiff\n\
    \        val maxBucketSizeDiff\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprx5am6jr.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprx5am6jr.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketSizeDiffDiff\e[0m = maxBucketSizeDiffDiff - maxBucketSizeDiff\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSizeDiffDiff is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketSizeDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprx5am6jr.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityDiffDiffDiff\e\
    [0m = maxBucketCapacityDiffDiffDiff - maxBucketCapacityDiffDiff\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityDiffDiffDiff is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityDiffDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprx5am6jr.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSizeDiffDiff\e\
    [0m = maxBucketSizeDiffDiff - maxBucketSizeDiffDiff\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSizeDiffDiff is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketSizeDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprx5am6jr.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityDiffDiff\e\
    [0m = maxBucketCapacityDiffDiff - "
  stdout: ''
  timestamp: 1659794074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBuckets\
    \ = buckets.map(_.size).max\n        val maxBucketsSize = maxBuckets.toLong\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val maxBucketsCapacity\
    \ = maxBucketsSize / capacity\n        val maxBucketsCapacity2 = maxBucketsCapacity\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity3 = maxBucketsCapacity2\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity4 = maxBucketsCapacity3\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity5 = maxBucketsCapacity4\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity6 = maxBucketsCapacity5\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity7 = maxBucketsCapacity6\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity8 = maxBucketsCapacity7\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity9 = maxBucketsCapacity8\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity10 = maxBucketsCapacity9\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity11 = maxBucketsCapacity10\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity12 = maxBucketsCapacity11\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity13 = maxBucketsCapacity12\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity14 = maxBucketsCapacity13\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity15 = maxBucketsCapacity14\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity16 = maxBucketsCapacity15\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity17 = maxBucketsCapacity16\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity18 = maxBucketsCapacity17\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity19 = maxBucketsCapacity18\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity20 = maxBucketsCapacity19\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity21 = maxBucketsCapacity20\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity22 = maxBucketsCapacity21\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity23 = maxBucketsCapacity22\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity24 = maxBucketsCapacity23\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity25 = maxBucketsCapacity24\
    \ * maxBucketsCapacity\n        val maxBucketsCapacity26 = maxBucket\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppbwn_lt4.scala:55:35 ------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity26\e[0m\
    \ = maxBucket\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: maxBucket\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppbwn_lt4.scala:56:5\
    \ ---------------------\e[0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).toSet\n        val maxBucket\
    \ = buckets.max\n        val bucketsLeft = maxBucket - capacity\n        val bucketsRight\
    \ = capacity - maxBucket\n        val bucketsLeft = bucketsLeft.toLong\n     \
    \   val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8p0m3chi.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8p0m3chi.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8p0m3chi.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8p0m3chi.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8p0m3chi.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsLe"
  stdout: ''
  timestamp: 1659794074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        val maxWells = mutable.HashMap[Long,\
    \ Long]()\n        val maxBuckets = mutable.HashMap[Long, Long]()\n        val\
    \ maxWellsCount = mutable.HashMap[Long, Long]()\n        val maxBucketsCount =\
    \ mutable.HashMap[Long, Long]()\n        val maxWellsCount2 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount2 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount3 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount3\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount4 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount4 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount5 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount5\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount6 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount6 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount7 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount7\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount8 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount8 = mutable.HashMap[Long, Long]()\n    \
    \    val maxWellsCount9 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount9\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount10 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount10 = mutable.HashMap[Long, Long]()\n   \
    \     val maxWellsCount11 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount11\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount12 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount12 = mutable.HashMap[Long, Long]()\n   \
    \     val maxWellsCount13 = mutable.HashMap[Long, Long]()\n        val maxBucketsCount13\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCount14 = mutable.HashMap[\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn1ee96xs.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpn1ee96xs.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpn1ee96xs.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpn1ee96xs.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxWells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn1ee96xs.scala:29:25\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxBuckets\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpn1ee96xs.scala:30:28 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \       ^^^^^^^\e[0m\n\e"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity =\
    \ mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCapacity = mutable.ArrayBuffer(capacity)\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnps8mdv6.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnps8mdv6.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpnps8mdv6.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnps8mdv6.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpnps8mdv6.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCou"
  stdout: ''
  timestamp: 1659793681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCounts = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_1\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_2 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_3 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_4\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_5 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_6 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_7\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_8 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_9 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_10\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_11 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_12 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_13\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_14 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_15 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_16\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_17 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_18 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_19\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_20 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_21 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_22\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_23 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_24 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_25\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_26 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_27 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_28\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_29 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_30 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_31\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_32 = mut\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpcmzyvraa.scala:27:27 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:30:30 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_1\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:31:30 ------------------------"
  stdout: ''
  timestamp: 1659793684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCounts = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_ = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCounts_1 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_2\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_3 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_4 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_5 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_6\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_7 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_8 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_9 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_10\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_11 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_12 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_13 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_14\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_15 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_16 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_17 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_18\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_19 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_20 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_21 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_22\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_23 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_24 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_25 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_26\
    \ = mutable.HashMap[\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp56s21l2d.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp56s21l2d.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp56s21l2d.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts_1\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount2 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount3 = mutable.HashMap[Long, Long]()\n       \
    \ val bucketsCount4 = mutable.HashMap[Long, Long]()\n        val bucketsCount5\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount6 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount7 = mutable.HashMap[Long, Long]()\n       \
    \ val bucketsCount8 = mutable.HashMap[Long, Long]()\n        val bucketsCount9\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount10 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount11 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount12 = mutable.HashMap[Long, Long]()\n        val bucketsCount13\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount14 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount15 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount16 = mutable.HashMap[Long, Long]()\n        val bucketsCount17\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount18 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount19 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount20 = mutable.HashMap[Long, Long]()\n        val bucketsCount21\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount22 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount23 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount24 = mutable.HashMap[Long, Long]()\n        val bucketsCount25\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount26 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount27 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount28 = mutable.HashMap[Long, Long]()\n        val bucketsCount29\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount30 = mutable.HashMap[Long,\
    \ Long]()\n        \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount2\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:30:28\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount4\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        grid.foreach(row\
    \ => {\n            row.foreach(bucket => {\n                buckets += bucket\
    \ -> bucket\n            })\n        })\n        val maxBucket = buckets.maxBy(_._2)\n\
    \        val bucketsCount = buckets.count(_._2 == maxBucket._2)\n        val bucketsCapacity\
    \ = buckets.count(_._2 == maxBucket._2)\n        val maxBucketCapacity = buckets.maxBy(_._2)._2\n\
    \        val maxBucketCapacityCount = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount2 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount3 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount4 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount5 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount6 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount7 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount8 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount9 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount10 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount11 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount12 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount13 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount14 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount15 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount16 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount17 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount18 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount19 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount20 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount21 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount22 = buckets.count(_._2 == maxBucketCapacity)\n\
    \        val maxBucketCapacityCount23\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprkwie_tm.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprkwie_tm.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprkwie_tm.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val bucketsMap\
    \ = buckets.map(_.toMap)\n        val bucketsMap2 = buckets.map(_.toMap)\n   \
    \     val bucketsMap3 = buckets.map(_.toMap)\n        val bucketsMap4 = buckets.map(_.toMap)\n\
    \        val bucketsMap5 = buckets.map(_.toMap)\n        val bucketsMap6 = buckets.map(_.toMap)\n\
    \        val bucketsMap7 = buckets.map(_.toMap)\n        val bucketsMap8 = buckets.map(_.toMap)\n\
    \        val bucketsMap9 = buckets.map(_.toMap)\n        val bucketsMap10 = buckets.map(_.toMap)\n\
    \        val bucketsMap11 = buckets.map(_.toMap)\n        val bucketsMap12 = buckets.map(_.toMap)\n\
    \        val bucketsMap13 = buckets.map(_.toMap)\n        val bucketsMap14 = buckets.map(_.toMap)\n\
    \        val bucketsMap15 = buckets.map(_.toMap)\n        val bucketsMap16 = buckets.map(_.toMap)\n\
    \        val bucketsMap17 = buckets.map(_.toMap)\n        val bucketsMap18 = buckets.map(_.toMap)\n\
    \        val bucketsMap19 = buckets.map(_.toMap)\n        val bucketsMap20 = buckets.map(_.toMap)\n\
    \        val bucketsMap21 = buckets.map(_.toMap)\n        val bucketsMap22 = buckets.map(_.toMap)\n\
    \        val bucketsMap23 = buckets.map(_.toMap)\n        val bucketsMap24 = buckets.map(_.toMap)\n\
    \        val bucketsMap25 = buckets.map(_.toMap)\n        val bucketsMap26 = buckets.map(_.toMap)\n\
    \        val bucketsMap27 = buckets.map(_.toMap)\n        val bucketsMap28 = buckets.map(_.toMap)\n\
    \        val bucketsMap29 = buckets.map(_.toMap)\n        val bucketsMap30 = buckets.map(_.toMap)\n\
    \        val bucketsMap31 = buckets.map(_.toMap)\n        val bucketsMap32 = buckets.map(_.toMap)\n\
    \        val bucketsMap33 = buckets.map(_.toMap)\n        val bucketsMap34 = buckets.map(_.toMap)\n\
    \        val buckets\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph1moa9lt.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmph1moa9lt.scala:27:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbucketsMap\e[0m = buckets.map(_.toMap)\n\e[31m\e[31m  \
    \ |\e[0m                                            ^\e[0m\n\e[31m   |\e[0m  \
    \                                     Cannot prove that Long <:< (K, V)\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                       where:    K\
    \ is a type variable\n\e[31m   |\e[0m                                        \
    \         V is a type variable\n\e[31m   |\e[0m                              \
    \         .\n\e[31m\e[31m-- Error: /tmp/tmph1moa9lt.scala:28:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap2\e[0m = buckets.map(_.toMap)\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- Error: /tmp/tmph1moa9lt.scala:29:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap3\e[0m = buckets.map(_.toMap)\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- Error: /tmp/tmph1moa9lt.scala:30:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap4\e[0m = bucke"
  stdout: ''
  timestamp: 1659978827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.map(_.size).max\n        val bucketsNeeded = maxBucket - buckets.map(_.size).sum\n\
    \        val bucketsNeededPerWell = bucketsNeeded / grid.length\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toDouble\n        val\
    \ bucketsNeededPerWell = bucketsNeededPerWell.toFloat\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toDouble\n        val\
    \ bucketsNeededPerWell = bucketsNeededPerWell.toFloat\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toDouble\n        val\
    \ bucketsNeededPerWell = bucketsNeededPerWell.toFloat\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toDouble\n        val\
    \ bucketsNeededPerWell = bucketsNeededPerWell.toFloat\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toDouble\n        val\
    \ bucketsNeededPerWell = bucketsNeededPerWell.toFloat\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toDouble\n        val\
    \ bucketsNeededPerWell = bucketsNeededPerWel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83so5w69.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsNeededPerWell\e[0m\
    \ = bucketsNeededPerWell.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp83so5w69.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsNeededPerWell\e[0m\
    \ = bucketsNeededPerWell.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp83so5w69.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsNeededPerWell\e[0m\
    \ = bucketsNeededPerWell.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp83so5w69.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsNeededPerWell\e[0m\
    \ = bucketsNeededPerWell.toFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp83so5w69.scala"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        val result = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ wellsCount = mutable.HashMap[Long, Long]()\n        val resultCount = mutable.HashMap[Long,\
    \ Long]()\n        val maxCount = mutable.HashMap[Long, Long]()\n        val maxCountIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCountValue = mutable.HashMap[Long,\
    \ Long]()\n        val maxCountIndex = mutable.HashMap[Long, Long]()\n       \
    \ val maxCountValue = mutable.HashMap[Long, Long]()\n        val maxCountIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCountValue = mutable.HashMap[Long,\
    \ Long]()\n        val maxCountIndex = mutable.HashMap[Long, Long]()\n       \
    \ val maxCountValue = mutable.HashMap[Long, Long]()\n        val maxCountIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCountValue = mutable.HashMap[Long,\
    \ Long]()\n        val maxCountIndex = mutable.HashMap[Long, Long]()\n       \
    \ val maxCountValue = mutable.HashMap[Long, Long]()\n        val maxCountIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCountValue = mutable.HashMap[Long,\
    \ Long]()\n        val maxCountIndex = mutable.HashMap[Long, Long]()\n       \
    \ val maxCountValue = mutable.HashMap[Long, Long]()\n        val maxCountIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCountValue = mutable.HashMap[Long,\
    \ Long]()\n        val maxCountIndex = mutable.HashMap[Long, Long]()\n       \
    \ val maxCountValue = mutable.HashMap[Long, Long]()\n        val maxCountIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCountValue = mutable.HashMap[Long,\
    \ Long]()\n        val maxCountIndex = mutable.HashMap[Long, Long]()\n       \
    \ val maxCountValue = mutable.HashMap[Long, Long]()\n        val maxCountIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCountValue = mutable.HashMap[Long,\
    \ Long]()\n        val maxCountIndex = mutable.HashMap[Long, Long]()\n       \
    \ val maxCountValue = mutable.Hash\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgbfngcx0.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxCountIndex\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCountIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgbfngcx0.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxCountValue\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountValue is already defined as \e[33mvalue\e[0m \e[35mmaxCountValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgbfngcx0.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxCountIndex\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCountIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgbfngcx0.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxCountValue\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountValue is already defined as \e[33mvalue\e[0m \e[35mmaxCountValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgbfngcx0.scala:39:12 ---------------------"
  stdout: ''
  timestamp: 1659978822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).toList\n        val maxBucket\
    \ = buckets.maxBy(_.size).size\n        val bucketsCount = buckets.map(_.size).sum\n\
    \        val maxBucketCapacity = maxBucket * capacity\n        val maxBucketCapacity2\
    \ = maxBucketCapacity / 2\n        val maxBucketCapacity3 = maxBucketCapacity2\
    \ / 2\n        val maxBucketCapacity4 = maxBucketCapacity3 / 2\n        val maxBucketCapacity5\
    \ = maxBucketCapacity4 / 2\n        val maxBucketCapacity6 = maxBucketCapacity5\
    \ / 2\n        val maxBucketCapacity7 = maxBucketCapacity6 / 2\n        val maxBucketCapacity8\
    \ = maxBucketCapacity7 / 2\n        val maxBucketCapacity9 = maxBucketCapacity8\
    \ / 2\n        val maxBucketCapacity10 = maxBucketCapacity9 / 2\n        val maxBucketCapacity11\
    \ = maxBucketCapacity10 / 2\n        val maxBucketCapacity12 = maxBucketCapacity11\
    \ / 2\n        val maxBucketCapacity13 = maxBucketCapacity12 / 2\n        val\
    \ maxBucketCapacity14 = maxBucketCapacity13 / 2\n        val maxBucketCapacity15\
    \ = maxBucketCapacity14 / 2\n        val maxBucketCapacity16 = maxBucketCapacity15\
    \ / 2\n        val maxBucketCapacity17 = maxBucketCapacity16 / 2\n        val\
    \ maxBucketCapacity18 = maxBucketCapacity17 / 2\n        val maxBucketCapacity19\
    \ = maxBucketCapacity18 / 2\n        val maxBucketCapacity20 = maxBucketCapacity19\
    \ / 2\n        val maxBucketCapacity21 = maxBucketCapacity20 / 2\n        val\
    \ maxBucketCapacity22 = maxBucketCapacity21 / 2\n        val maxBucketCapacity23\
    \ = maxBucketCapacity22 / 2\n        val maxBucketCapacity24 = maxBucketCapacity23\
    \ / 2\n        val maxBucketCapacity25 = maxBucketCapacity24 / 2\n        val\
    \ maxBucketCapacity26 = maxBucketCapacity25 / 2\n        val maxBucketCapacity27\
    \ = maxBucketCapacity26 / 2\n        val maxBucketCapacity28 = maxBucketCapacity27\
    \ / 2\n        val maxBucketCapacity29 = maxBucketCapacity28 / 2\n        val\
    \ maxBucketCapacity30 = maxBucketCapacity29 / 2\n        val maxBucketCapacity31\
    \ = maxBucketCapacity30 / 2\n        val maxBucketCapacity32 = maxBucketCapacity31\
    \ / 2\n        val maxBucketCapacity33 = maxBucketCapacity32 / 2\n        val\
    \ maxBucketCapacity34 = maxBucketCapacity33 / 2\n        val maxBucketCapacity35\
    \ = maxBucketCapacity34\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa48bd1o8.scala:64:5\
    \ ---------------------\e[0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n        val\
    \ bucketsSize = buckets.map(_.size).sum\n        val maxBucketCapacity = maxBucketSize\
    \ * capacity\n        val maxBucketCapacityInt = maxBucketCapacity.toInt\n   \
    \     val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacityInt\
    \ = bucketsCapacity.toInt\n        val maxBucketCapacityInt = maxBucketCapacityInt.toInt\n\
    \        val bucketsCapacityInt = bucketsCapacityInt.toInt\n        val maxBucketCapacity\
    \ = maxBucketCapacityInt * capacity\n        val maxBucketCapacityInt = maxBucketCapacityInt\
    \ * capacity\n        val bucketsCapacity = bucketsCapacityInt * capacity\n  \
    \      val bucketsCapacityInt = bucketsCapacityInt * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacityInt * capacity\n        val maxBucketCapacityInt = maxBucketCapacityInt\
    \ * capacity\n        val bucketsCapacity = bucketsCapacityInt * capacity\n  \
    \      val bucketsCapacityInt = bucketsCapacityInt * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacityInt * capacity\n        val maxBucketCapacityInt = maxBucketCapacityInt\
    \ * capacity\n        val bucketsCapacity = bucketsCapacityInt * capacity\n  \
    \      val bucketsCapacityInt = bucketsCapacityInt * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacityInt * capacity\n        val maxBucketCapacityInt = maxBucketCapacityInt\
    \ * capacity\n        val bucketsCapacity = bucketsCapacityInt * capacity\n  \
    \      val bucketsCapacityInt = bucketsCapacityInt * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacityInt * capacity\n        val maxBucketCapacityInt = maxBucketCapacityInt\
    \ * capacity\n        val bucketsCapacity = bucketsCapacityInt * capacity\n  \
    \      val bucketsCapacityInt = bucketsCapacityInt * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacityInt * capacity\n        val maxBucketCapacityInt = maxBucketCapacityInt\
    \ * capacity\n        val bucketsCapacity = bucketsCapacityInt * capacity\n  \
    \      val bucketsCapacityInt = bucketsCapacityInt * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacityInt * capacity\n        val maxBucketCapacityInt = maxBucketCapacityInt\
    \ * capacity\n        val bucketsCapacity = bucketsCapacityInt * capacity\n  \
    \      val bucketsCapacityInt = bucketsCapacityInt * capacity\n        val max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbomy3ki9.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbomy3ki9.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityInt\e[0m = maxBucketCapacityInt.toInt\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxBucketCapacityInt is already defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbomy3ki9.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityInt\e[0m = bucketsCapacityInt.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsCapacityInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbomy3ki9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacityInt * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbomy3ki9.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityInt\e[0m\
    \ = maxBucketCapacityInt * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketCapacityInt\e[0m"
  stdout: ''
  timestamp: 1659978822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer(grid.length)\n        val bucketsCount = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCount = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n        val wellsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCounts = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n        val wellsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCounts = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n        val wellsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCounts = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n        val wellsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCounts = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n        val wellsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCounts = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n        val wellsCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCounts = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCounts = mutable.ArrayBuffer(grid.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5692dpqy.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5692dpqy.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCounts is already defined as \e[33mvalue\e[0m \e[35mbucketsCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5692dpqy.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mwellsCounts\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCounts is already defined as \e[33mvalue\e[0m \e[35mwellsCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5692dpqy.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCounts is already defined as \e[33mvalue\e[0m \e[35mbucketsCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5692dpqy.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mwellsCounts\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCounts is already defined as \e[33mvalue\e[0m \e[35mwellsCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all "
  stdout: ''
  timestamp: 1659978820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        grid.foreach(row => {\n\
    \            val bucket = buckets.last\n            buckets += row(0)\n      \
    \      wells += row\n        })\n        val maxWells = wells.last\n        val\
    \ maxBuckets = buckets.last\n        val result = buckets.size - maxBuckets\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp43vltkig.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp43vltkig.scala:27:20 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.map(_.max).max\n        val maxBucketIndex\
    \ = buckets.map(_.indexOf(maxBucket)).max\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        buckets(maxBucketIndex) -= 1\n        buckets(maxBucketIndex) -=\
    \ 1\n        bucket\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx6y3tiq6.scala:29:32 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        buckets(maxBucketIndex) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ -= is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx6y3tiq6.scala:30:32 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        buckets(maxBucketIndex) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ -= is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx6y3tiq6.scala:31:32 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        buckets(maxBucketIndex) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ -= is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx6y3tiq6.scala:32:32 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        buckets(maxBucketIndex) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ -= is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx6y3tiq6.scala:33:32 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        buckets(maxBucketIndex) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ -= is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx6y3tiq6.scala:34:32 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        buckets(maxBucketIndex) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ -= is not a member of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpx6y3tiq6.scala:35:32 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        buckets(maxBucketIndex) -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ -= i"
  stdout: ''
  timestamp: 1659978829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = mutable.ArrayBuffer(capacity)\n        (1 to m).flatMap(i\
    \ => 1 to n).map(j => buckets(j) += grid(i)(j))\n        buckets.foldLeft(0l)\
    \ { (acc, b) => acc += math.min(acc, b) }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0p5gtdds.scala:28:22 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        grid.foreach(row => row.foreach(well\
    \ => wells += (well -> 1l)))\n        grid.foreach(row => row.foreach(well =>\
    \ buckets += (well -> 0)))\n        val maxBuckets = buckets.maxBy(_._2)._2\n\
    \        val maxWells = wells.maxBy(_._2)._2\n        val maxCapacity = maxBuckets\
    \ * capacity / maxWells\n        val maxBucketsNeeded = maxBuckets - maxCapacity\n\
    \        val maxWellsNeeded = maxWells - maxCapacity\n        val maxBucketsNeededPerWell\
    \ = maxBucketsNeeded / maxWells\n        val maxWellsNeededPerWell = maxWellsNeeded\
    \ / maxBuckets\n        val maxBucketsNeededPerWell = maxBucketsNeeded / maxWells\n\
    \        val maxWellsNeededPerWell = maxWellsNeeded / maxBuckets\n        val\
    \ maxBucketsNeededPerWell = maxBucketsNeeded / maxWells\n        val maxWellsNeededPerWell\
    \ = maxWellsNeeded / maxBuckets\n        val maxBucketsNeededPerWell = maxBucketsNeeded\
    \ / maxWells\n        val maxWellsNeededPerWell = maxWellsNeeded / maxBuckets\n\
    \        val maxBucketsNeededPerWell = maxBucketsNeeded / maxWells\n        val\
    \ maxWellsNeededPerWell = maxWellsNeeded / maxBuckets\n        val maxBucketsNeededPerWell\
    \ = maxBucketsNeeded / maxWells\n        val maxWellsNeededPerWell = maxWellsNeeded\
    \ / maxBuckets\n        val maxBucketsNeededPerWell = maxBucketsNeeded / maxWells\n\
    \        val maxWellsNeededPerWell = maxWellsNeeded / maxBuckets\n        val\
    \ maxBucketsNeededPerWell = maxBucketsNeeded / maxWells\n        val maxWellsNeededPerWell\
    \ = maxWellsNeeded / maxBuckets\n        val maxBucketsNeededPerWell = maxBucketsNeeded\
    \ / maxWells\n        val maxWellsNeededPerWell = maxWellsNeeded / maxBuckets\n\
    \        val maxBucketsNeededPerWell = maxBucketsNeeded \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqwz24l6i.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsNeededPerWell\e\
    [0m = maxBucketsNeeded / maxWells\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsNeededPerWell is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqwz24l6i.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsNeededPerWell\e\
    [0m = maxWellsNeeded / maxBuckets\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWellsNeededPerWell is already defined as \e[33mvalue\e\
    [0m \e[35mmaxWellsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqwz24l6i.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsNeededPerWell\e\
    [0m = maxBucketsNeeded / maxWells\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsNeededPerWell is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqwz24l6i.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsNeededPerWell\e\
    [0m = maxWellsNeeded / maxBuckets\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWellsNeededPerWell is already defined as \e[33mvalue\e\
    [0m \e[35mmaxWellsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming E"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val bucketsCap = buckets.map(_.capacity).sum\n        val bucketsMax\
    \ = buckets.map(_.max).max\n        val bucketsMin = buckets.map(_.min).min\n\
    \        val bucketsSum = buckets.map(_.sum).sum\n        val bucketsSumOfSquares\
    \ = buckets.map(_.sumOfSquares).sum\n        val bucketsSumOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquares).sum\n        val bucketsSumOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquares).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquares).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n    \
    \    val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquare\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo_sw8eql.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo_sw8eql.scala:29:39\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCap\e[0m = buckets.map(_.capacity).sum\n\e[31m\e[31m   |\e[0m     \
    \                                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                 value capacity is not a member of Set[Long]\n\e[31m\e[31m--\
    \ Error: /tmp/tmpo_sw8eql.scala:29:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCap\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mFloatIsFractional\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mShortIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo_sw8eql.scala:33:48 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquares\e[0m\
    \ = buckets.map(_.sumOfSquares).sum\n\e[31m\e[31m   |\e[0m                   \
    \                           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \            value sumOfSquares is not a member of Set[Long]\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpo_sw8eql.scala:33:65 -----------------------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquares\e[0m = buckets.map(_.sumOfSquares).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mFloatIsFractional\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e\
    [33mobject\e[0m \e[35mShortIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m match type Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m\
    \ in \e[33mtrait\e"
  stdout: ''
  timestamp: 1659978824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketIndex = buckets.indexOf(maxBucket)\n\
    \        val bucketsCount = buckets.map(_.size).sum\n        val maxBucketSize\
    \ = buckets(maxBucketIndex).size\n        val maxBucketCapacity = maxBucketSize\
    \ * capacity\n        val maxBucketCapacityIndex = buckets.indexOf(maxBucketCapacity)\n\
    \        val bucketsCountWithMaxBucket = buckets.map(_.size).sum\n        val\
    \ maxBucketCapacityWithMaxBucket = buckets(maxBucketCapacityIndex).size\n    \
    \    val maxBucketCapacityWithMaxBucketIndex = buckets.indexOf(maxBucketCapacityWithMaxBucket)\n\
    \        val bucketsCountWithMaxBucketAndMaxBucketCapacity = buckets.map(_.size).sum\n\
    \        val maxBucketCapacityWithMaxBucketAndMaxBucketCapacityIndex = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacity)\n\
    \        val bucketsCountWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacity\
    \ = buckets.map(_.size).sum\n        val maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityIndex\
    \ = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacity)\n\
    \        val bucketsCountWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityIndex\
    \ = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacity)\n\
    \        val maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityIndex\
    \ = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacity)\n\
    \        val bucketsCountWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityIndex\
    \ = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacity)\n\
    \        val maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityIndex\
    \ = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacity)\n\
    \        val bucketsCountWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityIndex\
    \ = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacity\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2b76ztpl.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2b76ztpl.scala:37:86\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxBucketCapacityWithMaxBucketAndMaxBucketCapacityIndex\e[0m = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacity)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           Not found: maxBucketCapacityWithMaxBucketAndMaxBucketCapacity\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2b76ztpl.scala:39:106\
    \ -----------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityIndex\e\
    [0m = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacity)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacity\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2b76ztpl.scala:40:121\
    \ -----------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCountWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacityIndex\e\
    [0m = buckets.indexOf(maxBucketCapacityWithMaxBucketAndMaxBucketCapacityAndMaxBucketCapacityAndMaxBucketCapacity)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).toSet\n        val bucketsCount\
    \ = grid.map(_.toList).map(_.size).sum\n        val bucketsCap = buckets.map(_.size).sum\n\
    \        val bucketsSum = buckets.map(_.size).reduce((a, b) => a + b)\n      \
    \  val bucketsSumCap = bucketsSum + capacity\n        val bucketsSumCap2 = bucketsSumCap\
    \ * bucketsCap\n        val bucketsSumCap3 = bucketsSumCap2 * bucketsCap\n   \
    \     val bucketsSumCap4 = bucketsSumCap3 * bucketsCap\n        val bucketsSumCap5\
    \ = bucketsSumCap4 * bucketsCap\n        val bucketsSumCap6 = bucketsSumCap5 *\
    \ bucketsCap\n        val bucketsSumCap7 = bucketsSumCap6 * bucketsCap\n     \
    \   val bucketsSumCap8 = bucketsSumCap7 * bucketsCap\n        val bucketsSumCap9\
    \ = bucketsSumCap8 * bucketsCap\n        val bucketsSumCap10 = bucketsSumCap9\
    \ * bucketsCap\n        val bucketsSumCap11 = bucketsSumCap10 * bucketsCap\n \
    \       val bucketsSumCap12 = bucketsSumCap11 * bucketsCap\n        val bucketsSumCap13\
    \ = bucketsSumCap12 * bucketsCap\n        val bucketsSumCap14 = bucketsSumCap13\
    \ * bucketsCap\n        val bucketsSumCap15 = bucketsSumCap14 * bucketsCap\n \
    \       val bucketsSumCap16 = bucketsSumCap15 * bucketsCap\n        val bucketsSumCap17\
    \ = bucketsSumCap16 * bucketsCap\n        val bucketsSumCap18 = bucketsSumCap17\
    \ * bucketsCap\n        val bucketsSumCap19 = bucketsSumCap18 * bucketsCap\n \
    \       val bucketsSumCap20 = bucketsSumCap19 * bucketsCap\n        val bucketsSumCap21\
    \ = bucketsSumCap20 * bucketsCap\n        val bucketsSumCap22 = bucketsSumCap21\
    \ * bucketsCap\n        val bucketsSumCap23 = bucketsSumCap22 * bucketsCap\n \
    \       val bucketsSumCap24 = bucketsSumCap23 * bucketsCap\n        val bucketsSumCap25\
    \ = bucketsSumCap24 * bucketsCap\n        val bucketsSumCap26 = bucketsSumCap25\
    \ * bucketsCap\n        val bucketsSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphu1iurtg.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmphu1iurtg.scala:57:5 ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBuckets\
    \ = buckets.map(_.size).max\n        val maxBucketsSize = maxBuckets.toLong\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val maxBucketsCapacity\
    \ = maxBucketsSize * capacity\n        val maxBucketsCapacityInt = maxBucketsCapacity.toInt\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacityInt\
    \ = bucketsCapacity.toInt\n        val maxBucketsCapacityInt = maxBucketsCapacityInt.toInt\n\
    \        val bucketsCapacityInt = bucketsCapacityInt.toInt\n        val maxBucketsCapacity\
    \ = maxBucketsCapacity.toLong\n        val maxBucketsCapacityInt = maxBucketsCapacity.toInt\n\
    \        val maxBucketsCapacity = maxBucketsCapacity.toLong\n        val maxBucketsCapacityInt\
    \ = maxBucketsCapacityInt.toInt\n        val maxBucketsCapacity = maxBucketsCapacity.toLong\n\
    \        val maxBucketsCapacityInt = maxBucketsCapacityInt.toInt\n        val\
    \ maxBucketsCapacity = maxBucketsCapacity.toLong\n        val maxBucketsCapacityInt\
    \ = maxBucketsCapacityInt.toInt\n        val maxBucketsCapacity = maxBucketsCapacity.toLong\n\
    \        val maxBucketsCapacityInt = maxBucketsCapacityInt.toInt\n        val\
    \ maxBucketsCapacity = maxBucketsCapacity.toLong\n        val maxBucketsCapacityInt\
    \ = maxBucketsCapacityInt.toInt\n        val maxBucketsCapacity = maxBucketsCapacity.toLong\n\
    \        val maxBucketsCapacityInt = maxBucketsCapacityInt.toInt\n        val\
    \ maxBucketsCapacity = maxBucketsCapacity.toLong\n        val maxBucketsCapacityInt\
    \ = maxBucketsCapacityInt.toInt\n        val maxBucketsCapacity = maxBucketsCapacity.toLong\n\
    \        val maxBucketsCapacityInt = maxBucketsCapacityInt.toInt\n        val\
    \ maxBucketsCapacity = maxBucketsCapacity.toLong\n        val maxBucketsCapacityInt\
    \ = maxBucketsCapacityInt.toInt\n        val maxBucketsCapacity = maxBucketsCapacity.toLong\n\
    \        val maxBucketsCapacityInt = maxBucketsCapacityInt.toInt\n        val\
    \ maxBucketsCapacity = max\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzp26v2u7.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacityInt\e\
    [0m = maxBucketsCapacityInt.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacityInt is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketsCapacityInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzp26v2u7.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityInt\e[0m\
    \ = bucketsCapacityInt.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsCapacityInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzp26v2u7.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity\e[0m\
    \ = maxBucketsCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacity is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzp26v2u7.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacityInt\e\
    [0m = maxBucketsCapacity.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacityInt is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketsCapacityInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzp26v2u7.scala:38:12 ---------------------"
  stdout: ''
  timestamp: 1659978823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[List[Long]]\n  \
    \      val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacities\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotal = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsTotalCapacities = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacities = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacities = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCapacities = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCapacityCapacities = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCapacities =\
    \ mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCapacityCapacities\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsTotalCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacities\
    \ = mutable.ArrayBuffer.empty[Long]\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw4v_h1k6.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpw4v_h1k6.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpw4v_h1k6.scala:28:32 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacities\e[0m =\
    \ mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m          \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpw4v_h1k6.scala:29:27 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsTotal\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpw4v_h1k6.scala:30:32 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsTotalCount\e[0m =\
    \ mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m          \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659978820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzn0y1no4.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzn0y1no4.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzn0y1no4.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzn0y1no4.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzn0y1no4.scala:33:12 ---------------------------\e\
    [0m\e["
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCounts = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_ = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCounts_1 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_2\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_3 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_4 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_5 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_6\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_7 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_8 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_9 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_10\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_11 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_12 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_13 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_14\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_15 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_16 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_17 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_18\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_19 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_20 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_21 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_22\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_23 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_24 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_25 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_26\
    \ = mutable.HashMap[\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp56s21l2d.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp56s21l2d.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp56s21l2d.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts_1\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        grid.foreach(row\
    \ => {\n            row.foreach(bucket => {\n                buckets += bucket\
    \ -> 0\n            })\n        })\n        val maxBucket = buckets.maxBy(_._2)\n\
    \        val maxBucketCount = buckets.count(_._2 == maxBucket._2)\n        val\
    \ maxBucketCapacity = maxBucket._2\n        val maxBucketCount = maxBucketCount\
    \ + 1\n        val maxBucketCapacity = maxBucketCapacity + capacity\n        val\
    \ maxBucketCapacity = maxBucketCapacity - capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9ld119sm.scala:68:31 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9ld119sm.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCount\e[0m = maxBucketCount + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxBucketCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxBucketCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9ld119sm.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacity\e[0m = maxBucketCapacity + capacity\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9ld119sm.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m = maxBucketCapacity\
    \ - capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9ld119sm.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity / capacity\n\e[31m\e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1659978822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).map(_.toSet)\n        val\
    \ maxBucket = buckets.map(_.size).max\n        val maxBucketIndex = buckets.map(_.size).zipWithIndex.maxBy(_._1)._2\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = maxBucketSize * capacity\n        val maxBucketCapacityIndex = buckets.zipWithIndex.maxBy(_._1)._2\n\
    \        val maxBucketCapacitySize = buckets(maxBucketCapacityIndex).size\n  \
    \      val maxBucketCapacityCapacity = maxBucketCapacitySize * capacity\n    \
    \    val maxBucketCapacityCapacityIndex = buckets.zipWithIndex.maxBy(_._1)._2\n\
    \        val maxBucketCapacityCapacitySize = buckets(maxBucketCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacity = maxBucketCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityIndex = buckets.zipWithIndex.maxBy(_._1)._2\n\
    \        val maxBucketCapacityCapacityCapacitySize = buckets(maxBucketCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityIndex = buckets.zipWithIndex.maxBy(_._1)._2\n\
    \        val maxBucketCapacityCapacityCapacityCapacitySize = buckets(maxBucketCapacityCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.zipWithIndex.maxBy(_._1)._2\n        val maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityIndex).size\n   \
    \     val maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.zipWithIndex.maxBy(_._1)._2\n        val maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.zipWithIndex.maxBy(_._1)._2\n        val maxBucketCapacityCapacityCapacityCapacityCapacityCapacitySize\
    \ = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacity\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_paii0hu.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_paii0hu.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacity\e[0m = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityCapacityCapacityCapacityCapacity is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityCapacityCapacityCapacityCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_paii0hu.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex\e\
    [0m = buckets.zipWithIndex.maxBy(_._1)._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_paii0hu.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacitySize\e\
    [0m = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityCapacityIndex).size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityCapacityCapacityCapacityCapacitySize is already\
    \ d"
  stdout: ''
  timestamp: 1659978824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, List[Long]]()\n    \
    \    val maxBucket = mutable.HashMap[Long, Long]()\n        val maxBucketCount\
    \ = mutable.HashMap[Long, Long]()\n        val bucketCount = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketCounts = mutable.HashMap[Long, Long]()\n     \
    \   val maxBucketCounts_ = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_1\
    \ = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_2 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketCounts_3 = mutable.HashMap[Long, Long]()\n   \
    \     val maxBucketCounts_4 = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_5\
    \ = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_6 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketCounts_7 = mutable.HashMap[Long, Long]()\n   \
    \     val maxBucketCounts_8 = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_9\
    \ = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_10 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketCounts_11 = mutable.HashMap[Long, Long]()\n  \
    \      val maxBucketCounts_12 = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_13\
    \ = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_14 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketCounts_15 = mutable.HashMap[Long, Long]()\n  \
    \      val maxBucketCounts_16 = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_17\
    \ = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_18 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketCounts_19 = mutable.HashMap[Long, Long]()\n  \
    \      val maxBucketCounts_20 = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_21\
    \ = mutable.HashMap[Long, Long]()\n        val maxBucketCounts_22 = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketCounts_23 = mutable.HashMap[Long, Long]()\n  \
    \      val maxBucketCounts_24 = mutable.HashMap[Long, Long]()\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfi5_5cq2.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfi5_5cq2.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxBucket\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfi5_5cq2.scala:28:29 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mmaxBucketCount\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfi5_5cq2.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfi5_5cq2.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxBucketCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n"
  stdout: ''
  timestamp: 1659978822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- grid) {\n            val bucket = row(0)\n            buckets += bucket\n\
    \        }\n        val maxBucket = buckets.max\n        val numBuckets = buckets.length\n\
    \        val numWells = grid.length\n        val numBucketsNeeded = numBuckets\
    \ - maxBucket\n        val numWellsNeeded = numWells - numBucketsNeeded\n    \
    \    val numBucketsNeededToEmpty = numBucketsNeeded - capacity\n        val numWellsNeededToEmpty\
    \ = numWellsNeeded - numBucketsNeededToEmpty\n        val numBucketsNeededToEmptyToEmpty\
    \ = numBucketsNeededToEmpty - numWellsNeededToEmpty\n        val numWellsNeededToEmptyToEmpty\
    \ = numWellsNeededToEmpty - numBucketsNeededToEmptyToEmpty\n        val numBucketsNeededToEmptyToEmptyToEmpty\
    \ = numBucketsNeededToEmptyToEmpty - numWellsNeededToEmptyToEmpty\n        val\
    \ numWellsNeededToEmptyToEmptyToEmpty = numWellsNeededToEmptyToEmpty - numBucketsNeededToEmptyToEmptyToEmpty\n\
    \        val numBucketsNeededToEmptyToEmptyToEmptyToEmpty = numBucketsNeededToEmptyToEmptyToEmpty\
    \ - numWellsNeededToEmptyToEmptyToEmpty\n        val numWellsNeededToEmptyToEmptyToEmptyToEmpty\
    \ = numWellsNeededToEmptyToEmptyToEmpty - numBucketsNeededToEmptyToEmptyToEmptyToEmpty\n\
    \        val numBucketsNeededToEmptyToEmptyToEmptyToEmptyToEmpty = numBucketsNeededToEmptyToEmptyToEmptyToEmpty\
    \ - numWellsNeededToEmptyToEmptyToEmptyToEmpty\n        val numWellsNeededToEmptyToEmptyToEmptyToEmptyToEmpty\
    \ = numWellsNeededToEmptyToEmptyToEmptyToEmpty - numBucketsNeededToEmptyToEmptyToEmptyToEmptyToEmpty\n\
    \        val numBucketsNeededToEmptyToEmptyToEmptyToEmptyToEmptyToEmpty = numBucketsNeededToEmptyToEmptyToEmptyToEmptyToEmpty\
    \ - numWellsNeededToEmptyToEmptyToEmptyToEmptyToEmpty\n        val numWellsNeededToEmptyToEmptyToEmptyToEmptyToEmptyToEmpty\
    \ = numWellsNeeded\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuoo756cv.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpuoo756cv.scala:48:5 ---------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(_.toLong))\n        val maxBucket\
    \ = buckets.maxBy(_.length)\n        val maxBucketCapacity = maxBucket.length\n\
    \        val maxBucketCapacityPerWell = maxBucketCapacity / grid.length\n    \
    \    val maxBucketCapacityPerWellWithMaxBucketCapacity = maxBucketCapacityPerWell\
    \ / maxBucketCapacity\n        val maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\
    \ = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\n\
    \        val maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\
    \ = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\n\
    \        val maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\
    \ = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\n\
    \        val maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\
    \ = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\n\
    \        val maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\
    \ = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\n\
    \        val maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\
    \ = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\n\
    \        val maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWith\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoqz77weg.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoqz77weg.scala:31:135\
    \ --------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\e\
    [0m = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoqz77weg.scala:32:156\
    \ --------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\e\
    [0m = maxBucketCapacityPerWellWithMaxBucketCapacity + maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35m\n\e[31m   |\e[0m  maxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacity\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpoqz77weg.scala:35:231 --------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWellWithMaxBucketCapacityAndMaxBucketCapacityPerWell\e\
    [0m "
  stdout: ''
  timestamp: 1659978830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacitySumCountMax = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n     \
    \   val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n   \
    \     val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n \
    \       val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpholmx81e.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.Array"
  stdout: ''
  timestamp: 1659978832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val maxBucketCapacity = maxBucketSize / capacity\n        val bucketsSize\
    \ = buckets.map(_.size)\n        val bucketsCapacity = bucketsSize / capacity\n\
    \        val bucketsCapacitySum = bucketsCapacity.sum\n        val bucketsSum\
    \ = bucketsCapacity.sum\n        val bucketsSumOfBuckets = bucketsSum * capacity\n\
    \        val bucketsSumOfBucketsMinusBucketsCapacity = bucketsSumOfBuckets - bucketsCapacitySum\n\
    \        val bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacity = bucketsSumOfBucketsMinusBucketsCapacity\
    \ - bucketsCapacitySumOfBuckets\n        val bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\
    \ = bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacity - bucketsCapacitySumOfBucketsMinusBucketsCapacity\n\
    \        val bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\
    \ = bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\
    \ - bucketsCapacitySumOfBucketsMinusBucketsCapacityMinusBucketsCapacity\n    \
    \    val bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\
    \ = bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\
    \ - bucketsCapacitySumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\n\
    \        val bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\
    \ = bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\
    \ - bucketsCapacitySumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacity\n\
    \        val bucketsSumOfBucketsMinusBucketsCapacityMinusBucketsCapacityMinusBucketsCapacityMinus\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxi0yt9rj.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxi0yt9rj.scala:31:42\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCapacity\e[0m = bucketsSize / capacity\n\e[31m\e[31m   |\e[0m     \
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue / is not a\
    \ member of List[Int], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxi0yt9rj.scala:42:5 ---------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wellsCapacity =\
    \ mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wellsCapacity =\
    \ mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wellsCapacity =\
    \ mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wellsCapacity =\
    \ mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wellsCapacity =\
    \ mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wellsCapacity =\
    \ mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wellsCapacity =\
    \ mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val wellsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCapacity = mutable.HashMap[Long, Long]()\n        val wells\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp12hu65_d.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp12hu65_d.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCount\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp12hu65_d.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mwellsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCount is already defined as \e[33mvalue\e[0m \e[35mwellsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp12hu65_d.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp12hu65_d.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mwellsCapacity\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCapacity is already defined as \e[33mvalue\e[0m \e[35mwellsCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsSum = buckets.map(_.size).sum\n\
    \        val bucketsSumOfSquares = buckets.map(_.size).map(x => x * x).sum\n \
    \       val bucketsSumOfSquaresOfSquares = buckets.map(_.size).map(x => x * x).map(x\
    \ => x * x).sum\n        val bucketsSumOfSquaresOfSquaresOfSquares = buckets.map(_.size).map(x\
    \ => x * x).map(x => x * x).map(x => x * x).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.size).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.size).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.size).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).map(x => x * x).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.size).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).map(x => x * x).map(x => x * x).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.size).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).map(x => x * x).map(x => x * x).map(x => x * x).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.size).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6wjn9b48.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6wjn9b48.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\e\
    [0m = buckets.map(_.size).map(\e[36mx\e[0m => x * x).map(\e[36mx\e[0m => x * x).map(\e\
    [36mx\e[0m => x * x).map(\e[36mx\e[0m => x * x).map(x \n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp6wjn9b48.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val wellsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaobjclfl.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpaobjclfl.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mwellsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCount is already defined as \e[33mvalue\e[0m \e[35mwellsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaobjclfl.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mwellsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCount is already defined as \e[33mvalue\e[0m \e[35mwellsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaobjclfl.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mwellsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCount is already defined as \e[33mvalue\e[0m \e[35mwellsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaobjclfl.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mwellsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCount is already defined as \e[33mvalue\e[0m \e[35mwellsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ d"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = mutable.ArrayBuffer(capacity)\n        val bucketsCount =\
    \ mutable.ArrayBuffer(capacity)\n        val bucketsCount2 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount3 = mutable.ArrayBuffer(capacity)\n        val bucketsCount4\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount5 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount6 = mutable.ArrayBuffer(capacity)\n        val bucketsCount7\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount8 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount9 = mutable.ArrayBuffer(capacity)\n        val bucketsCount10\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount11 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount12 = mutable.ArrayBuffer(capacity)\n        val bucketsCount13\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount14 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount15 = mutable.ArrayBuffer(capacity)\n        val bucketsCount16\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount17 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount18 = mutable.ArrayBuffer(capacity)\n        val bucketsCount19\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount20 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount21 = mutable.ArrayBuffer(capacity)\n        val bucketsCount22\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount23 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount24 = mutable.ArrayBuffer(capacity)\n        val bucketsCount25\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount26 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount27 = mutable.ArrayBuffer(capacity)\n        val bucketsCount28\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount29 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount30 = mutable.ArrayBuffer(capacity)\n        val bucketsCount31\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount32 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount33 = mutable.ArrayBuffer(capacity)\n        val bucketsCount34\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount35 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount36 = mutable.ArrayBuffer(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkn00edcv.scala:64:49 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount36\e[0m = mutable.ArrayBuffer(\n\
    \e[31m\e[31m   |\e[0m                                                 ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkn00edcv.scala:28:22\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkn00edcv.scala:29:27\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m \
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpkn00edcv.scala:30:28 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCount2\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkn00edcv.scala:31:28 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkn00edcv.sca"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity =\
    \ mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapacitySumCount2 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount3 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount4\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount5 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount6 = mutable.ArrayBuffer.empty[Int]\n     \
    \   val bucketsCapacitySumCount7 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount8 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount9\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount10 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount11 = mutable.ArrayBuffer.empty[Int]\n    \
    \    val bucketsCapacitySumCount12 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount13 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount14\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount15 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount16 = mutable.ArrayBuffer.empty[Int]\n    \
    \    val bucketsCapacitySumCount17 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount18 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount19\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount20 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount21 = mutable.ArrayBuffer.empty[Int]\n    \
    \    val bucketsCapacitySumCount22 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCount23 = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount24\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCount25 = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount26 = mutable.ArrayBuffer.empty[Int]\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0sykugzn.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySum\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m         \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0sykugzn.scala:30:38 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacitySumCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain"
  stdout: ''
  timestamp: 1659793700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount2 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount3 = mutable.ArrayBuffer(capacity)\n        val bucketsCount4\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount5 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount6 = mutable.ArrayBuffer(capacity)\n        val bucketsCount7\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount8 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount9 = mutable.ArrayBuffer(capacity)\n        val bucketsCount10\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount11 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount12 = mutable.ArrayBuffer(capacity)\n        val bucketsCount13\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount14 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount15 = mutable.ArrayBuffer(capacity)\n        val bucketsCount16\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount17 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount18 = mutable.ArrayBuffer(capacity)\n        val bucketsCount19\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount20 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount21 = mutable.ArrayBuffer(capacity)\n        val bucketsCount22\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount23 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount24 = mutable.ArrayBuffer(capacity)\n        val bucketsCount25\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount26 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount27 = mutable.ArrayBuffer(capacity)\n        val bucketsCount28\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount29 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount30 = mutable.ArrayBuffer(capacity)\n        val bucketsCount31\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount32 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount33 = mutable.ArrayBuffer(capacity)\n        val bucketsCount34\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount35 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount36 = mutable.ArrayBuffer(capacity)\n        val bucketsCount37\
    \ = mutable.Array\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmplqyjzu1h.scala:27:27 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount2\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:30:28 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount4\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:31:28 ------------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).map(_.toSet)\n        val\
    \ maxBucket = buckets.map(_.size).max\n        val maxBucketSize = maxBucket *\
    \ capacity\n        val maxBucketCapacity = maxBucket * capacity\n        val\
    \ maxBucketCapacity2 = maxBucketCapacity * maxBucketCapacity\n        val maxBucketCapacity3\
    \ = maxBucketCapacity2 * maxBucketCapacity\n        val maxBucketCapacity4 = maxBucketCapacity3\
    \ * maxBucketCapacity\n        val maxBucketCapacity5 = maxBucketCapacity4 * maxBucketCapacity\n\
    \        val maxBucketCapacity6 = maxBucketCapacity5 * maxBucketCapacity\n   \
    \     val maxBucketCapacity7 = maxBucketCapacity6 * maxBucketCapacity\n      \
    \  val maxBucketCapacity8 = maxBucketCapacity7 * maxBucketCapacity\n        val\
    \ maxBucketCapacity9 = maxBucketCapacity8 * maxBucketCapacity\n        val maxBucketCapacity10\
    \ = maxBucketCapacity9 * maxBucketCapacity\n        val maxBucketCapacity11 =\
    \ maxBucketCapacity10 * maxBucketCapacity\n        val maxBucketCapacity12 = maxBucketCapacity11\
    \ * maxBucketCapacity\n        val maxBucketCapacity13 = maxBucketCapacity12 *\
    \ maxBucketCapacity\n        val maxBucketCapacity14 = maxBucketCapacity13 * maxBucketCapacity\n\
    \        val maxBucketCapacity15 = maxBucketCapacity14 * maxBucketCapacity\n \
    \       val maxBucketCapacity16 = maxBucketCapacity15 * maxBucketCapacity\n  \
    \      val maxBucketCapacity17 = maxBucketCapacity16 * maxBucketCapacity\n   \
    \     val maxBucketCapacity18 = maxBucketCapacity17 * maxBucketCapacity\n    \
    \    val maxBucketCapacity19 = maxBucketCapacity18 * maxBucketCapacity\n     \
    \   val maxBucketCapacity20 = maxBucketCapacity19 * maxBucketCapacity\n      \
    \  val maxBucketCapacity21 = maxBucketCapacity20 * maxBucketCapacity\n       \
    \ val maxBucketCapacity22 = maxBucketCapacity21 * maxBucketCapacity\n        val\
    \ maxBucketCapacity23 = maxBucketCapacity22 * maxBucketCapacity\n        val maxBucketCapacity24\
    \ = maxBucketCapacity23 * maxBucketCapacity\n        val maxBucketCapacity25 =\
    \ maxBucketCapacity24 * maxBucketCapacity\n        val maxBucketCapacity26 = maxBucketCapacity25\
    \ * maxBucketCapacity\n        val maxBucketCapacity27 = maxBucketCapacity26 *\
    \ maxBucketCapacity\n        val maxBucketCapacity28 = maxBucketCapacity27 * maxBucketCapacity\n\
    \        val maxBucketCapacity29 = maxBucketCapacity28 * maxBucketCapacity\n \
    \       val maxBucketCapacity30 = maxBucketCapacity29 * maxBucketCapacity\n  \
    \      val maxBucketCapacity31 = maxBucketCapacity30 * max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmprdiigkur.scala:59:54 -----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity31\e[0m\
    \ = maxBucketCapacity30 * max\n\e[31m\e[31m   |\e[0m                         \
    \         ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((Int, Int) => Int)\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmprdiigkur.scala:60:5 ---------------------\e[0m\e[0m\n\
    \e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            wells.append(row)\n        }\n        val maxWells = wells.max\n\
    \        val maxBuckets = buckets.max\n        val maxWellsIndex = wells.indexWhere(_\
    \ == maxWells)\n        val maxBucketsIndex = buckets.indexWhere(_ == maxBuckets)\n\
    \        val maxBucketsIndex2 = buckets.indexWhere(_ == maxBuckets + 1)\n    \
    \    val maxBucketsIndex3 = buckets.indexWhere(_ == maxBuckets + 2)\n        val\
    \ maxBucketsIndex4 = buckets.indexWhere(_ == maxBuckets + 3)\n        val maxBucketsIndex5\
    \ = buckets.indexWhere(_ == maxBuckets + 4)\n        val maxBucketsIndex6 = buckets.indexWhere(_\
    \ == maxBuckets + 5)\n        val maxBucketsIndex7 = buckets.indexWhere(_ == maxBuckets\
    \ + 6)\n        val maxBucketsIndex8 = buckets.indexWhere(_ == maxBuckets + 7)\n\
    \        val maxBucketsIndex9 = buckets.indexWhere(_ == maxBuckets + 8)\n    \
    \    val maxBucketsIndex10 = buckets.indexWhere(_ == maxBuckets + 9)\n       \
    \ val maxBucketsIndex11 = buckets.indexWhere(_ == maxBuckets + 10)\n        val\
    \ maxBucketsIndex12 = buckets.indexWhere(_ == maxBuckets + 11)\n        val maxBucketsIndex13\
    \ = buckets.indexWhere(_ == maxBuckets + 12)\n        val maxBucketsIndex14 =\
    \ buckets.indexWhere(_ == maxBuckets + 13)\n        val maxBucketsIndex15 = buckets.indexWhere(_\
    \ == maxBuckets + 14)\n        val maxBucketsIndex16 = buckets.indexWhere(_ ==\
    \ maxBuckets + 15)\n        val maxBucketsIndex17 = buckets.indexWhere(_ == maxBuckets\
    \ + 16)\n        val maxBucketsIndex18 = buckets.indexWhere(_ == maxBuckets +\
    \ 17)\n        val maxBucketsIndex19 = buckets.indexWhere(_ == maxBuckets + 18)\n\
    \        val maxBucketsIndex20 = buckets.indexWhere(_ == maxBuckets + 19)\n  \
    \      val maxBucketsIndex21 = buckets.indexWhere(_ == maxBuckets + 20)\n    \
    \    val maxBucketsIndex22 = buckets.indexWhere(_ == maxBuckets + 21)\n      \
    \  val maxBucketsIndex23 = buckets.indexWhere(_ == maxBuckets + 22)\n        val\
    \ maxBucketsIndex24 = buckets.indexWhere(_ == max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpued774nr.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpued774nr.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpued774nr.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mwells\e[0m = mutable.ArrayBuffer.empty[\e[35mList\e[0m[\e[35mLong\e[0m]]\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpued774nr.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[Long]\n        for (row <- 0 until grid.length)\
    \ {\n            val bucket = buckets.last\n            buckets += grid[row].last\n\
    \            wells += grid[row].init\n        }\n        val numWells = wells.length\n\
    \        val numBuckets = buckets.length\n        val numBucketsBefore = numBuckets\n\
    \        val numBucketsAfter = numBuckets\n        val numBucketsAfterAfter =\
    \ numBuckets\n        val numBucketsBeforeBefore = numBuckets\n        val numBucketsBeforeAfter\
    \ = numBuckets\n        val numBucketsAfterAfterAfter = numBuckets\n        val\
    \ numBucketsBeforeBeforeBefore = numBuckets\n        val numBucketsBeforeBeforeAfter\
    \ = numBuckets\n        val numBucketsBeforeAfterAfterAfter = numBuckets\n   \
    \     val numBucketsBeforeBeforeBeforeBefore = numBuckets\n        val numBucketsBeforeBeforeBeforeAfter\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeAfterAfter = numBuckets\n\
    \        val numBucketsBeforeBeforeBeforeBeforeBefore = numBuckets\n        val\
    \ numBucketsBeforeBeforeBeforeBeforeAfterAfter = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBefore\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeAfterAfter\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBefore\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeAfterAfter\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBefore\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeAfterAfter\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBefore\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeAfterAfter\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBefore\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeAfterAfter\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBefore\
    \ = numBuckets\n        val numBucketsBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeBeforeAfterAfter\
    \ = numBuckets\n        val numBucketsBeforeBefore\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkq3jjic_.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkq3jjic_.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkq3jjic_.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mwells\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkq3jjic_.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- 0 until grid.length) {\n            val bucket = mutable.ArrayBuffer.empty[Long]\n\
    \            for (i <- 0 until grid[row].length) {\n                bucket +=\
    \ if (grid[row](i) == 1) capacity else 0\n            }\n            buckets +=\
    \ bucket\n        }\n        buckets.foldLeft(0l) { (acc, cur) => if (cur > acc)\
    \ cur else acc }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2oiv6pno.scala:30:26 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                bucket += \e[33mif\e[0m (grid[row](i)\
    \ == \e[31m1\e[0m) capacity \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m\
    \                          ^^\e[0m\n\e[31m   |\e[0m                          expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2oiv6pno.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp2oiv6pno.scala:28:25 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mbucket\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2oiv6pno.scala:29:35 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m until grid[\e\
    [35mrow\e[0m].length) {\n\e[31m\e[31m   |\e[0m                               \
    \    ^^^\e[0m\n\e[31m   |\e[0m                                   Not found: type\
    \ row\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).flatten\n        val maxBucket\
    \ = buckets.max\n        val maxBucketIndex = buckets.indexOf(maxBucket)\n   \
    \     val bucketsCount = buckets.length\n        val bucketsIndex = buckets.zipWithIndex.filter(x\
    \ => x._1 == maxBucketIndex).map(_._2)\n        val bucketsCount = bucketsCount.length\n\
    \        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x => x._1 < bucketsCount).map(_._2)\n\
    \        val bucketsCount = bucketsCount.length\n        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x\
    \ => x._1 < bucketsCount).map(_._2)\n        val bucketsCount = bucketsCount.length\n\
    \        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x => x._1 < bucketsCount).map(_._2)\n\
    \        val bucketsCount = bucketsCount.length\n        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x\
    \ => x._1 < bucketsCount).map(_._2)\n        val bucketsCount = bucketsCount.length\n\
    \        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x => x._1 < bucketsCount).map(_._2)\n\
    \        val bucketsCount = bucketsCount.length\n        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x\
    \ => x._1 < bucketsCount).map(_._2)\n        val bucketsCount = bucketsCount.length\n\
    \        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x => x._1 < bucketsCount).map(_._2)\n\
    \        val bucketsCount = bucketsCount.length\n        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x\
    \ => x._1 < bucketsCount).map(_._2)\n        val bucketsCount = bucketsCount.length\n\
    \        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x => x._1 < bucketsCount).map(_._2)\n\
    \        val bucketsCount = bucketsCount.length\n        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x\
    \ => x._1 < bucketsCount).map(_._2)\n        val bucketsCount = bucketsCount.length\n\
    \        val bucketsIndex = bucketsIndex.zipWithIndex.filter(x => x._1 < bucketsCount).map(_._2)\n\
    \        val bucketsCount = bucketsCount.length\n        val bucketsIndex = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdzelchv_.scala:54:26 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mbucketsIndex\e[0m = \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpdzelchv_.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = bucketsCount.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdzelchv_.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsIndex\e[0m = bucketsIndex.zipWithIndex.filter(\e\
    [36mx\e[0m => x._1 < bucketsCount).map(_._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsIndex is already defined as \e[33mvalue\e[0m \e[35mbucketsIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdzelchv_.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = bucketsCount.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdzelchv_.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsIndex\e[0m = bucketsIndex.zipWithIndex.filter(\e\
    [36mx\e[0m => x._1 < bucke"
  stdout: ''
  timestamp: 1659978835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).flatten\n        val maxBucket\
    \ = buckets.max\n        val bucketsCount = buckets.count\n        val bucketsSum\
    \ = buckets.sum\n        val bucketsSumOfSquare = buckets.map(x => x * x).sum\n\
    \        val bucketsSumOfSquareOfBuckets = buckets.map(x => x * x).map(x => x\
    \ * x).sum\n        val bucketsSumOfSquareOfBucketsOfBuckets = buckets.map(x =>\
    \ x * x).map(x => x * x).map(x => x * x).sum\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(x => x * x).map(x => x * x).map(x => x * x).map(x => x * x).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBuckets = buckets.map(x\
    \ => x * x).map(x => x * x).map(x => x * x).map(x => x * x).map(x => x * x).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets =\
    \ buckets.map(x => x * x).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).sum\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(x => x * x).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).map(x => x * x).sum\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(x => x * x).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).map(x => x * x).map(x => x * x).sum\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(x => x * x).map(x => x * x).map(x => x * x).map(x => x * x).map(x\
    \ => x * x).map(x => x * x).map(x => x * x).map(x => x * x).sum\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(x => x * x).map(x => \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3c9124gt.scala:39:146 --------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\e\
    [0m = buckets.map(\e[36mx\e[0m => x * x).map(\e[36mx\e[0m => \n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3c9124gt.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).flatten\n        val maxBucket\
    \ = buckets.max\n        val bucketsNeeded = maxBucket - capacity\n        val\
    \ bucketsNeededPerWell = bucketsNeeded / grid.length\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n        val bucketsNeededPerWell\
    \ = bucketsNeededPerWell.toInt\n        val bucketsNeededPerWell = bucketsNeededPerWell.toLong\n\
    \        val bucketsNeededPerWell = bucketsNeededPerWell.toInt\n        val bucketsNe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7xbqrzfw.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7xbqrzfw.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsNeededPerWell\e[0m = bucketsNeededPerWell.toLong\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7xbqrzfw.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsNeededPerWell\e[0m\
    \ = bucketsNeededPerWell.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7xbqrzfw.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsNeededPerWell\e[0m\
    \ = bucketsNeededPerWell.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsNeededPerWell\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7xbqrzfw.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsNeededPerWell\e[0m\
    \ = bucketsNeededPerWell.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsNeededPerWell is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsNeededPer"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, List[Long]]()\n        grid.foreach(row => {\n\
    \            val bucket = row(0).toLong\n            val well = row(1).toLong\n\
    \            buckets += bucket -> bucket\n            wells += well -> List(bucket)\n\
    \        })\n        val maxBucket = buckets.maxBy(_._1).get\n        val maxWell\
    \ = wells.maxBy(_._1).get\n        val bucketsNeeded = capacity - maxBucket\n\
    \        val wellsNeeded = maxWell - maxBucket\n        bucketsNeeded + wellsNeeded\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaztyrxzy.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaztyrxzy.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        grid.foreach(row => {\n            row.foreach(well => {\n          \
    \      if (well != 0l) {\n                    buckets += well\n              \
    \      wells += row :: well\n                }\n            })\n        })\n \
    \       val bucketsCount = buckets.length\n        val wellsCount = wells.length\n\
    \        val bucketsCapacity = buckets.last\n        val wellsCapacity = wells.last.last\n\
    \        val bucketsCapacityDiff = bucketsCapacity - capacity\n        val wellsCapacityDiff\
    \ = wellsCapacity - capacity\n        val bucketsCapacityDiffCount = bucketsCapacityDiff\
    \ / wellsCapacity\n        val wellsCapacityDiffCount = wellsCapacityDiff / bucketsCapacity\n\
    \        val bucketsCapacityDiffCount = bucketsCapacityDiffCount.toLong\n    \
    \    val wellsCapacityDiffCount = wellsCapacityDiffCount.toLong\n        val bucketsCapacityDiffCount2\
    \ = bucketsCapacityDiffCount * wellsCapacityDiffCount\n        val wellsCapacityDiffCount2\
    \ = wellsCapacityDiffCount * bucketsCapacityDiffCount\n        val bucketsCapacityDiffCount3\
    \ = bucketsCapacityDiffCount2 * wellsCapacityDiffCount2\n        val wellsCapacityDiffCount3\
    \ = wellsCapacityDiffCount2 * bucketsCapacityDiffCount2\n        val bucketsCapacityDiffCount4\
    \ = bucketsCapacityDiffCount3 * wellsCapacityDiffCount3\n        val wellsCapacityDiffCount4\
    \ = wellsCapacityDiffCount3 * bucketsCapacityDiffCount3\n        val bucketsCapacityDiffCount5\
    \ = bucketsCapacityDiffCount4 * wellsCapacityDiffCount4\n        val wellsCapacityDiffCount5\
    \ = wellsCapacityDiffCount4 * bucketsCapacityDiffCount4\n        val bucketsCapacityDiffCount6\
    \ = bucketsCapacityDiffCount5 * wellsCapacityDiffCount5\n        val wellsCapacityDiffCount6\
    \ = wellsCapacityDiffCount5 * bucketsCapacityDiffCount5\n        val bucketsCapacityDiffCount7\
    \ = bucketsCapacityDiffCount6 * wellsCapacityDiffCount6\n        val wellsCapacityDiffCount7\
    \ = wellsCapacityDiffCount6 * bucketsCapacityDiffCount6\n        val bucketsCapacityDiffCount8\
    \ = bucketsCapacityDiffCount7 * wellsCapacityDiffCount7\n        val wellsCapacityDiffCount8\
    \ = wellsCapacityDiffCount7 * bucketsCapacityDiffCount7\n        val bucketsCapacityDiffCount9\
    \ = bucket\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9jlirphu.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityDiffCount\e\
    [0m = bucketsCapacityDiffCount.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityDiffCount is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacityDiffCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9jlirphu.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mwellsCapacityDiffCount\e\
    [0m = wellsCapacityDiffCount.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCapacityDiffCount is already defined as \e[33mvalue\e\
    [0m \e[35mwellsCapacityDiffCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9jlirphu.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9jlirphu.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp9jlirphu.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^"
  stdout: ''
  timestamp: 1659978836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBuckets\
    \ = buckets.map(_.size).max\n        val maxBucketsCap = maxBuckets * capacity\n\
    \        val maxBucketsCap2 = maxBucketsCap * maxBucketsCap\n        val bucketsCap\
    \ = buckets.map(_.size).sum\n        val bucketsCap2 = bucketsCap * bucketsCap\n\
    \        val bucketsCap3 = bucketsCap2 * bucketsCap2\n        val bucketsCap4\
    \ = bucketsCap3 * bucketsCap3\n        val bucketsCap5 = bucketsCap4 * bucketsCap4\n\
    \        val bucketsCap6 = bucketsCap5 * bucketsCap5\n        val bucketsCap7\
    \ = bucketsCap6 * bucketsCap6\n        val bucketsCap8 = bucketsCap7 * bucketsCap7\n\
    \        val bucketsCap9 = bucketsCap8 * bucketsCap8\n        val bucketsCap10\
    \ = bucketsCap9 * bucketsCap9\n        val bucketsCap11 = bucketsCap10 * bucketsCap10\n\
    \        val bucketsCap12 = bucketsCap11 * bucketsCap11\n        val bucketsCap13\
    \ = bucketsCap12 * bucketsCap12\n        val bucketsCap14 = bucketsCap13 * bucketsCap13\n\
    \        val bucketsCap15 = bucketsCap14 * bucketsCap14\n        val bucketsCap16\
    \ = bucketsCap15 * bucketsCap15\n        val bucketsCap17 = bucketsCap16 * bucketsCap16\n\
    \        val bucketsCap18 = bucketsCap17 * bucketsCap17\n        val bucketsCap19\
    \ = bucketsCap18 * bucketsCap18\n        val bucketsCap20 = bucketsCap19 * bucketsCap19\n\
    \        val bucketsCap21 = bucketsCap20 * bucketsCap20\n        val bucketsCap22\
    \ = bucketsCap21 * bucketsCap21\n        val bucketsCap23 = bucketsCap22 * bucketsCap22\n\
    \        val bucketsCap24 = bucketsCap23 * bucketsCap23\n        val bucketsCap25\
    \ = bucketsCap24 * bucketsCap24\n        val bucketsCap26 = bucketsCap25 * bucketsCap25\n\
    \        val bucketsCap27 = bucketsCap26 * bucketsCap26\n        val bucketsCap28\
    \ = bucketsCap27 * bucketsCap27\n        val bucketsCap\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptoiwnm4t.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptoiwnm4t.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCounts = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvipz0kyz.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCounts_ is already defined as \e[33mvalue\e[0m \e[35mbucketsCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvipz0kyz.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCounts_ is already defined as \e[33mvalue\e[0m \e[35mbucketsCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvipz0kyz.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCounts_ is already defined as \e[33mvalue\e[0m \e[35mbucketsCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvipz0kyz.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCounts_ is already defined as \e[33mvalue\e[0m \e[35mbucketsCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvipz0kyz.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbu"
  stdout: ''
  timestamp: 1659978837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount2 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount3 = mutable.ArrayBuffer(capacity)\n        val bucketsCount4\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount5 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount6 = mutable.ArrayBuffer(capacity)\n        val bucketsCount7\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount8 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount9 = mutable.ArrayBuffer(capacity)\n        val bucketsCount10\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount11 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount12 = mutable.ArrayBuffer(capacity)\n        val bucketsCount13\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount14 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount15 = mutable.ArrayBuffer(capacity)\n        val bucketsCount16\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount17 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount18 = mutable.ArrayBuffer(capacity)\n        val bucketsCount19\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount20 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount21 = mutable.ArrayBuffer(capacity)\n        val bucketsCount22\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount23 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount24 = mutable.ArrayBuffer(capacity)\n        val bucketsCount25\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount26 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount27 = mutable.ArrayBuffer(capacity)\n        val bucketsCount28\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount29 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount30 = mutable.ArrayBuffer(capacity)\n        val bucketsCount31\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount32 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount33 = mutable.ArrayBuffer(capacity)\n        val bucketsCount34\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount35 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount36 = mutable.ArrayBuffer(capacity)\n        val bucketsCount37\
    \ = mutable.Array\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmplqyjzu1h.scala:27:27 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount2\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:30:28 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount4\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:31:28 ------------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            wells.append(row)\n        }\n        val maxWells = wells.map(_.length).max\n\
    \        val maxBuckets = capacity / maxWells\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        for (row <- wells) {\n            val bucket = row.foldLeft(0l) { (acc,\
    \ x) => acc + x }\n            bucketsCount.append(bucket)\n        }\n      \
    \  val bucketsCount = bucketsCount.max\n        val bucketsCountMin = bucketsCount\
    \ / maxBuckets\n        val bucketsCountMax = bucketsCount * maxBuckets\n    \
    \    val bucketsCountSum = bucketsCount.sum\n        val bucketsCountSumMin =\
    \ bucketsCountSum / maxBuckets\n        val bucketsCountSumMax = bucketsCountSum\
    \ * maxBuckets\n        val bucketsCountSumMinMax = bucketsCountSumMin * maxBuckets\n\
    \        val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n    \
    \    val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n        val\
    \ bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n        val bucketsCountSumMinMax\
    \ = bucketsCountSumMinMax * maxBuckets\n        val bucketsCountSumMinMax = bucketsCountSumMinMax\
    \ * maxBuckets\n        val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n\
    \        val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n    \
    \    val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n        val\
    \ bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n        val bucketsCountSumMinMax\
    \ = bucketsCountSumMinMax * maxBuckets\n        val bucketsCountSumMinMax = bucketsCountSumMinMax\
    \ * maxBuckets\n        val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n\
    \        val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n    \
    \    val bucketsCountSumMinMax = bucketsCountSumMinMax * maxBuckets\n        val\
    \ bucketsCountSumMinMax = bucket\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc_lvzg0b.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = bucketsCount.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc_lvzg0b.scala:45:12 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mbucketsCountSumMinMax\e[0m = bucketsCountSumMinMax\
    \ * maxBuckets\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCountSumMinMax is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCountSumMinMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc_lvzg0b.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mbucketsCountSumMinMax\e\
    [0m = bucketsCountSumMinMax * maxBuckets\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCountSumMinMax is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCountSumMinMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc_lvzg0b.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mbucketsCountSumMinMax\e\
    [0m = bucketsCountSumMinMax * maxBuckets\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCountSumMinMax is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCountSumMinMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc_lvzg0b.scala:48:"
  stdout: ''
  timestamp: 1659978837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        grid.foreach(row\
    \ => {\n            row.foreach(bucket => {\n                buckets += (bucket\
    \ -> bucket)\n            })\n        })\n        val maxBucket = buckets.maxBy(_._2)._1\n\
    \        val maxBucketIndex = buckets.keys.indexOf(maxBucket)\n        val maxBucketSize\
    \ = buckets(maxBucket)\n        val maxBucketCapacity = maxBucketSize * capacity\n\
    \        val maxBucketIndex = maxBucketIndex + 1\n        val maxBucketSize =\
    \ maxBucketSize - 1\n        val maxBucketCapacity = maxBucketCapacity - 1\n \
    \       val maxBucket = buckets(maxBucketIndex)\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = maxBucketSize / capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = maxBucketSize / capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = maxBucketSize / capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = maxBucketSize / capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = maxBucketSize / capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = maxBucketSize / capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = maxBucketSize / capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketSize = maxBucketSize /\
    \ capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n   \
    \     val maxBucketSize = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp6f5jt3o.scala:71:27 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSize\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp6f5jt3o.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = maxBucketIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp6f5jt3o.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSize\e[0m = maxBucketSize -\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSize is already defined as \e[33mvalue\e[0m \e[35mmaxBucketSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp6f5jt3o.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m = maxBucketCapacity\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpp6f5jt3o.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxBucket\e[0m = buckets(maxBucketIndex)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mma"
  stdout: ''
  timestamp: 1659978838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsMap = buckets.map(_.toMap)\n\
    \        val bucketsMapWithCapacity = bucketsMap.map{case (k, v) => k -> (v.toSet\
    \ - capacity)}\n        val bucketsMapWithCapacityWithMax = bucketsMapWithCapacity.map{case\
    \ (k, v) => k -> (v.toSet - maxBucket)}\n        val bucketsMapWithCapacityWithMaxWithMax\
    \ = bucketsMapWithCapacityWithMax.map{case (k, v) => k -> (v.toSet - maxBucket)}\n\
    \        bucketsMapWithCapacityWithMaxWithMax.maxBy(_._2)._1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp080luc8x.scala:28:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap\e[0m = buckets.map(_.toMap)\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp080luc8x.scala:29:75\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsMapWithCapacity\e[0m = bucketsMap.map{\e[33mcase\e[0m (k, v) => k ->\
    \ (v.toSet - capacity)}\n\e[31m\e[31m   |\e[0m                               \
    \                                          ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                 value toSet is not a member of Any\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp080luc8x.scala:30:94 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsMapWithCapacityWithMax\e\
    [0m = bucketsMapWithCapacity.map{\e[33mcase\e[0m (k, v) => k -> (v.toSet - maxBucket)}\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toSet\
    \ is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e\
    [0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.list asScalaBuffer\n\e[31m  \
    \ |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |"
  stdout: ''
  timestamp: 1659978844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCap = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapCountMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapCountMaxIndex = mutable.ArrayBuffer.empty\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwkka3hm.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapCountMaxIndex\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mbucketsCapCountMaxIndex is already defined as \e[33mvalue\e[0m \e[35mbucketsCapCountMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprwkka3hm.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwkka3hm.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapCountMaxIndex\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mbucketsCapCountMaxIndex is already defined as \e[33mvalue\e[0m \e[35mbucketsCapCountMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprwkka3hm.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be de"
  stdout: ''
  timestamp: 1659978844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Int]()\n        val bucketsCount2 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount3 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount4 = mutable.HashMap[Long, Int]()\n        val bucketsCount5 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount6 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount7 = mutable.HashMap[Long, Int]()\n        val bucketsCount8 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount9 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount10 = mutable.HashMap[Long, Int]()\n        val bucketsCount11 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount12 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount13 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount14 = mutable.HashMap[Long, Int]()\n        val bucketsCount15 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount16 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount17 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount18 = mutable.HashMap[Long, Int]()\n        val bucketsCount19 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount20 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount21 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount22 = mutable.HashMap[Long, Int]()\n        val bucketsCount23 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount24 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount25 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount26 = mutable.HashMap[Long, Int]()\n        val bucketsCount27 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount28 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount29 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount30 = mutable.HashMap[Long, Int]()\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount2\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:30:28\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount4\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ ["
  stdout: ''
  timestamp: 1659978845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val bucketsCap = buckets.map(_.capacity).sum\n        val bucketsRemain\
    \ = bucketsCap - capacity\n        val bucketsRemainCap = bucketsRemain - capacity\n\
    \        val bucketsRemainCap2 = bucketsRemainCap * bucketsRemainCap\n       \
    \ val bucketsRemainCap3 = bucketsRemainCap2 * bucketsRemainCap\n        val bucketsRemainCap4\
    \ = bucketsRemainCap3 * bucketsRemainCap\n        val bucketsRemainCap5 = bucketsRemainCap4\
    \ * bucketsRemainCap\n        val bucketsRemainCap6 = bucketsRemainCap5 * bucketsRemainCap\n\
    \        val bucketsRemainCap7 = bucketsRemainCap6 * bucketsRemainCap\n      \
    \  val bucketsRemainCap8 = bucketsRemainCap7 * bucketsRemainCap\n        val bucketsRemainCap9\
    \ = bucketsRemainCap8 * bucketsRemainCap\n        val bucketsRemainCap10 = bucketsRemainCap9\
    \ * bucketsRemainCap\n        val bucketsRemainCap11 = bucketsRemainCap10 * bucketsRemainCap\n\
    \        val bucketsRemainCap12 = bucketsRemainCap11 * bucketsRemainCap\n    \
    \    val bucketsRemainCap13 = bucketsRemainCap12 * bucketsRemainCap\n        val\
    \ bucketsRemainCap14 = bucketsRemainCap13 * bucketsRemainCap\n        val bucketsRemainCap15\
    \ = bucketsRemainCap14 * bucketsRemainCap\n        val bucketsRemainCap16 = bucketsRemainCap15\
    \ * bucketsRemainCap\n        val bucketsRemainCap17 = bucketsRemainCap16 * bucketsRemainCap\n\
    \        val bucketsRemainCap18 = bucketsRemainCap17 * bucketsRemainCap\n    \
    \    val bucketsRemainCap19 = bucketsRemainCap18 * bucketsRemainCap\n        val\
    \ bucketsRemainCap20 = bucketsRemainCap19 * bucketsRemainCap\n        val bucketsRemainCap21\
    \ = bucketsRemainCap20 * bucketsRemainCap\n        val bucketsRemainCap22 = bucketsRemainCap21\
    \ * bucketsRemainCap\n        val bucketsRemainCap23 = bucketsRemainCap22 * bucketsRemainCap\n\
    \        val bucketsRemainCap24 = bucketsRemainCap23 * bucketsRemainCap\n    \
    \    val bucketsRemainCap25 = bucketsRemainCap24 * bucket\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1_mb196o.scala:29:39 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCap\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                             value capacity is not a member of Set[Long]\n\
    \e[31m\e[31m-- Error: /tmp/tmp1_mb196o.scala:29:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCap\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByteIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mShortIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1_mb196o.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ maxBuckets = mutable.HashMap[Long, Int]()\n        val maxBucketsSize = mutable.HashMap[Long,\
    \ Int]()\n        val maxBucketsSizes = mutable.HashMap[Long, Int]()\n       \
    \ val maxBucketsSizesSum = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSums\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSum = mutable.HashMap[Long,\
    \ Int]()\n        val maxBucketsSizesSumsSums = mutable.HashMap[Long, Int]()\n\
    \        val maxBucketsSizesSumsSumsSum = mutable.HashMap[Long, Int]()\n     \
    \   val maxBucketsSizesSumsSumsSums = mutable.HashMap[Long, Int]()\n        val\
    \ maxBucketsSizesSumsSumsSumsSum = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSums\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSum\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSums\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSumsSum\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSumsSums\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSumsSum\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSumsSums\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSumsSumsSum\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSumsSumsSums\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSumsSumsSumsSumsSumsSum\
    \ = mutable.HashMap[Long, Int]()\n        val maxBucketsSizesSumsSums\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzfoji43u.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzfoji43u.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketsSizesSumsSumsSumsSumsSumsSum\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsSizesSumsSumsSumsSumsSumsSum is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxBucketsSizesSumsSumsSumsSumsSumsSum\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzfoji43u.scala:43:12 ---------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsSizesSumsSumsSumsSumsSumsSums\e\
    [0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsSizesSumsSumsSumsSumsSumsSums is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxBucketsSizesSumsSumsSumsSumsSumsSums\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzfoji43u.scala:46:12 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsSizesSumsSumsSumsSumsSumsSumsSum\e\
    [0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsSizesSumsSumsSumsSumsSumsSumsSum is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxBucketsSizesSumsSumsSumsSumsSumsSumsSum\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzfoji43u.scala:26:22 ----"
  stdout: ''
  timestamp: 1659978846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzn0y1no4.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzn0y1no4.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzn0y1no4.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzn0y1no4.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzn0y1no4.scala:33:12 ---------------------------\e\
    [0m\e["
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(_.toLong))\n        val bucketsMap\
    \ = buckets.toMap\n        val bucketsCount = buckets.map(_.length)\n        val\
    \ bucketsSum = buckets.map(_.sum)\n        val bucketsSumMap = bucketsSum.toMap\n\
    \        val bucketsSumCount = bucketsSum.map(_.length)\n        val bucketsSumMapCount\
    \ = bucketsSumMap.toMap\n        val bucketsSumMapCountMap = bucketsSumMapCount.toMap\n\
    \        val bucketsSumMapCountMapCount = bucketsSumMapCountMap.toMap\n      \
    \  val bucketsSumMapCountMapCountMap = bucketsSumMapCountMapCount.toMap\n    \
    \    val bucketsSumMapCountMapCountMapCount = bucketsSumMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMap = bucketsSumMapCountMapCountMapCount.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCount = bucketsSumMapCountMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMap = bucketsSumMapCountMapCountMapCountMapCount.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMapCount = bucketsSumMapCountMapCountMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMapCountMap = bucketsSumMapCountMapCountMapCountMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMapCountMapCount = bucketsSumMapCountMapCountMapCountMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMap = bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCount\
    \ = bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMap.toMap\n    \
    \    val bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCount =\
    \ bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap\
    \ = bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap.toMap\n\
    \        val bucketsSumMapCountMapCountMapCountMapCountMap\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy0npcd91.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy0npcd91.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCount\e[0m\
    \ = bucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCountMap.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mbucketsSumMapCountMapCountMapCountMapCountMapCountMapCountMapCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmpy0npcd91.scala:27:38\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbucketsMap\e[0m = buckets.toMap\n\e[31m\e[31m   |\e[0m\
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \                  Cannot prove that List[Long] <:< (K, V)\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m                                 where:    K is a type variable\n\
    \e[31m   |\e[0m                                           V is a type variable\n\
    \e[31m   |\e[0m                                 .\n\e[31m\e[31m-- Error: /tmp/tmpy0npcd91.scala:30:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbucketsSumMap\e[0m = bucketsSum.toMap\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                Cannot prove that Long <:< (K, V)\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                                       where:    K is a type\
    \ variable\n\e[31m   |\e[0m                                                 V\
    \ is a type variable\n\e[31m   |\e[0m                         "
  stdout: ''
  timestamp: 1659978850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n        val\
    \ bucketsSize = buckets.map(_.size).sum\n        val bucketsSum = buckets.map(_.sum).sum\n\
    \        val bucketsSumOfSquare = buckets.map(_.sum).map(x => x * x).sum\n   \
    \     val bucketsSumOfSquareOfMaxBucket = buckets.map(_.sum).map(x => x * x).map(x\
    \ => x * x).maxBy(x => x)\n        val bucketsSumOfSquareOfMaxBucketSize = buckets.map(_.sum).map(x\
    \ => x * x).map(x => x * x).maxBy(x => x).size\n        val bucketsSumOfSquareOfMaxBucketSize\
    \ = buckets.map(_.sum).map(x => x * x).map(x => x * x).maxBy(x => x).size\n  \
    \      val bucketsSumOfSquareOfMaxBucketSizeAndMaxBucketSize = buckets.map(_.sum).map(x\
    \ => x * x).map(x => x * x).maxBy(x => x).size + maxBucketSize\n        val bucketsSumOfSquareOfMaxBucketSizeAndMaxBucketSizeAndMaxBucketSize\
    \ = buckets.map(_.sum).map(x => x * x).map(x => x * x).maxBy(x => x).size + maxBucketSize\
    \ + maxBucketSize\n        val bucketsSumOfSquareOfMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucketSize\
    \ = buckets.map(_.sum).map(x => x * x).map(x => x * x).maxBy(x => x).size + maxBucketSize\
    \ + maxBucketSize + maxBucketSize + maxBucketSize\n        val bucketsSumOfSquareOfMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucketSize\
    \ = buckets.map(_.sum).map(x => x * x).map(x => x * x).maxBy(x => x).size + maxBucketSize\
    \ + maxBucketSize + maxBucketSize + maxBucketSize + maxBucketSize + maxBucketSize\n\
    \        val bucketsSumOfSquareOfMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucketSize\
    \ = buckets.map(_.sum).map(x => x * x).map(x => x * x).maxBy(x => x).size + maxBucketSize\
    \ + maxBucketSize + maxBucketSize + maxBucketSize + maxBucketSize + maxBucketSize\
    \ + maxBucketSize\n        val bucketsSumOfSquareOfMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucketSizeAndMaxBucket\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcqb5689d.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcqb5689d.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumOfSquareOfMaxBucketSize\e[0m = buckets.map(_.sum).map(\e[36mx\e\
    [0m => x * x).map(\e[36mx\e[0m => x * x).maxBy(\e[36mx\e[0m => x).size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumOfSquareOfMaxBucketSize is already defined as \e\
    [33mvalue\e[0m \e[35mbucketsSumOfSquareOfMaxBucketSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcqb5689d.scala:33:113\
    \ -----------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsSumOfSquareOfMaxBucketSize\e[0m = buckets.map(_.sum).map(\e[36mx\e\
    [0m => x * x).map(\e[36mx\e[0m => x * x).maxBy(\e[36mx\e[0m => x).size\n\e[31m\e\
    [31m   |\e[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value size is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcqb5689d.scala:35:129\
    \ -----------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsSumOfSquareOfMaxBucketSizeAndMaxBucketSize\e[0m = buckets.map(_.sum).map(\e\
    [36mx\e[0m => x * x).map(\e[36mx\e[0m => x * x).maxBy(\e[36mx\e[0m => x).size\
    \ + maxBucketSize\n\e[31m\e[31m   |\e[0m                                     \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value size is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcqb5689d.scala:36:145\
    \ -----------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsSu"
  stdout: ''
  timestamp: 1659978850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer(grid.length)\n        val fills = mutable.ArrayBuffer(grid.length)\n\
    \        val result = mutable.ArrayBuffer(grid.length)\n        val maxFills =\
    \ mutable.ArrayBuffer(grid.length)\n        val maxFill = 0\n        val maxFillIndex\
    \ = 0\n        val maxFillRow = 0\n        val maxFillCol = 0\n        val maxFillRowIndex\
    \ = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n    \
    \    val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex\
    \ = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n    \
    \    val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex\
    \ = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n    \
    \    val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex\
    \ = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n    \
    \    val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex\
    \ = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n    \
    \    val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex\
    \ = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n    \
    \    val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex\
    \ = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n    \
    \    val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex\
    \ = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n    \
    \    val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex\
    \ = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n    \
    \    val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex\
    \ = 0\n        val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n    \
    \    val maxFillRowIndex = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex\
    \ = 0\n        val maxFillColIndex = 0\n        val maxFillRowIndex = 0\n    \
    \    val maxFillColIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppjd74d6g.scala:89:4 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppjd74d6g.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxFillRowIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxFillRowIndex is already defined as \e[33mvalue\e[0m \e\
    [35mmaxFillRowIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppjd74d6g.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxFillColIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmaxFillColIndex is already defined as \e[33mvalue\e[0m \e[35mmaxFillColIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppjd74d6g.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxFillRowIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxFillRowIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxFillRowIndex\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppjd74d6g.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxFillColIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxFillColIndex is already defined as \e[33mvalue\e[0m \e\
    [35mmaxFillColIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppjd74d6g.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e"
  stdout: ''
  timestamp: 1659978848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        grid.foreach(row => wells.append(row))\n\
    \        wells.foreach(well => {\n            val bucket = well.foldLeft(0l)(_\
    \ + _)\n            buckets += bucket\n        })\n        buckets.maxBy(_ - capacity)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpesmfv79b.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpesmfv79b.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[Long]\n        val visited = mutable.HashSet.empty[Long]\n\
    \        val visitedCount = mutable.HashMap.empty[Long, Long]\n        val maxCount\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxCountIndex = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCount = mutable.HashMap.empty[Long, Long]\n        val\
    \ maxCountIndex = mutable.HashMap.empty[Long, Long]\n        val maxCount = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCountIndex = mutable.HashMap.empty[Long, Long]\n     \
    \   val maxCount = mutable.HashMap.empty[Long, Long]\n        val maxCountIndex\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxCount = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCountIndex = mutable.HashMap.empty[Long, Long]\n     \
    \   val maxCount = mutable.HashMap.empty[Long, Long]\n        val maxCountIndex\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxCount = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCountIndex = mutable.HashMap.empty[Long, Long]\n     \
    \   val maxCount = mutable.HashMap.empty[Long, Long]\n        val maxCountIndex\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxCount = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCountIndex = mutable.HashMap.empty[Long, Long]\n     \
    \   val maxCount = mutable.HashMap.empty[Long, Long]\n        val maxCountIndex\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxCount = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCountIndex = mutable.HashMap.empty[Long, Long]\n     \
    \   val maxCount = mutable.HashMap.empty[Long, Long]\n        val maxCountIndex\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxCount = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCountIndex = mutable.HashMap.empty[Long, Long]\n     \
    \   val maxCount = mutable.HashMap.empty[Long, Long]\n        val maxCountIndex\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxCount = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxCountIndex = mutable.Hash\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpidsxhmxw.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpidsxhmxw.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxCountIndex\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCountIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpidsxhmxw.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpidsxhmxw.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxCountIndex\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCountIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpidsxhmxw.scala:36:12 ---------------------------\e["
  stdout: ''
  timestamp: 1659978849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size)\n        val bucketsSize = maxBucket.size\n        val\
    \ bucketsCap = maxBucket.capacity\n        val bucketsRemain = bucketsCap - capacity\n\
    \        val bucketsUsed = bucketsSize - bucketsRemain\n        val bucketsLeft\
    \ = bucketsCap - bucketsUsed\n        val bucketsUsed = bucketsSize - bucketsRemain\n\
    \        val bucketsLeft = bucketsCap - bucketsUsed\n        val bucketsUsed =\
    \ bucketsSize - bucketsRemain\n        val bucketsLeft = bucketsCap - bucketsUsed\n\
    \        val bucketsUsed = bucketsSize - bucketsRemain\n        val bucketsLeft\
    \ = bucketsCap - bucketsUsed\n        val bucketsUsed = bucketsSize - bucketsRemain\n\
    \        val bucketsLeft = bucketsCap - bucketsUsed\n        val bucketsUsed =\
    \ bucketsSize - bucketsRemain\n        val bucketsLeft = bucketsCap - bucketsUsed\n\
    \        val bucketsUsed = bucketsSize - bucketsRemain\n        val bucketsLeft\
    \ = bucketsCap - bucketsUsed\n        val bucketsUsed = bucketsSize - bucketsRemain\n\
    \        val bucketsLeft = bucketsCap - bucketsUsed\n        val bucketsUsed =\
    \ bucketsSize - bucketsRemain\n        val bucketsLeft = bucketsCap - bucketsUsed\n\
    \        val bucketsUsed = bucketsSize - bucketsRemain\n        val bucketsLeft\
    \ = bucketsCap - bucketsUsed\n        val bucketsUsed = bucketsSize - bucketsRemain\n\
    \        val bucketsLeft = bucketsCap - bucketsUsed\n        val bucketsUsed =\
    \ bucketsSize - bucketsRemain\n        val bucketsLeft = bucketsCap - bucketsUsed\n\
    \        val bucketsUsed = bucketsSize - bucketsRemain\n        val bucketsLeft\
    \ = bucketsCap - bucketsUsed\n        val bucketsUsed = bucketsSize - bucketsRemain\n\
    \        val bucketsLeft = bucketsCap - bucketsUsed\n        val bucketsUsed =\
    \ bucketsSize - bucketsRemain\n        val bucketsLeft = bucketsCap - bucketsUsed\n\
    \        val bucketsUsed = bucketsSize - bucketsRemain\n        val bucketsLeft\
    \ = bucketsCap - bucketsUsed\n        val bucketsUsed = bucketsSize \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_ad_1ytv.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsUsed\e[0m = bucketsSize\
    \ - bucketsRemain\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsUsed is already defined as \e[33mvalue\e[0m \e[35mbucketsUsed\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_ad_1ytv.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsCap - bucketsUsed\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_ad_1ytv.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsUsed\e[0m = bucketsSize - bucketsRemain\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsUsed is already defined as \e[33mvalue\e[0m \e[35mbucketsUsed\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_ad_1ytv.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsCap - bucketsUsed\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_ad_1ytv.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mbucketsUsed\e[0m = bucketsSize - bucketsRemain\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^"
  stdout: ''
  timestamp: 1659978850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        grid.foreach(row\
    \ => {\n            row.foreach(bucket => {\n                buckets += bucket\
    \ -> bucket\n            })\n        })\n        val maxBucket = buckets.maxBy(_._2)._1\n\
    \        val bucketsNeeded = capacity - maxBucket\n        val bucketsNeededPerWell\
    \ = bucketsNeeded / grid.length\n        grid.map(row => {\n            val wellsNeeded\
    \ = bucketsNeededPerWell * row.length\n            val wellsNeededPerBucket =\
    \ wellsNeeded / bucketsNeeded\n            row.map(bucket => {\n             \
    \   bucket.map(bucket => {\n                    bucketsNeeded -= 1\n         \
    \           bucketsNeededPerWell -= 1\n                    wellsNeeded -= 1\n\
    \                    wellsNeededPerBucket -= 1\n                })\n         \
    \   })\n        }).flatten.foldLeft(0l) { (acc, row) => acc + maxFill(row, capacity)\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkzlpn7cz.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkzlpn7cz.scala:39:23 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                bucket.map(\e[36mbucket\e[0m => {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value map is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659978850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n  \
    \      val bucketsCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacity =\
    \ mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpit6p7in_.scala:52:11 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpit6p7in_.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpit6p7in_.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpit6p7in_.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityC"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).flatten\n        val bucketsSet\
    \ = buckets.toSet\n        val bucketsCount = buckets.size\n        val bucketsSetSize\
    \ = bucketsSet.size\n        val bucketsSetIterator = bucketsSet.iterator\n  \
    \      val bucketsSetIteratorSize = bucketsSetIterator.size\n        val bucketsSetIteratorIterator\
    \ = bucketsSetIterator.iterator\n        val bucketsSetIteratorIteratorSize =\
    \ bucketsSetIteratorIterator.size\n        val bucketsSetIteratorIteratorIterator\
    \ = bucketsSetIteratorIterator.iterator\n        val bucketsSetIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIterator.size\n        val bucketsSetIteratorIteratorIteratorIterator\
    \ = bucketsSetIteratorIteratorIterator.iterator\n        val bucketsSetIteratorIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIteratorIterator.size\n        val bucketsSetIteratorIteratorIteratorIteratorIterator\
    \ = bucketsSetIteratorIteratorIteratorIterator.iterator\n        val bucketsSetIteratorIteratorIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIteratorIteratorIterator.size\n        val bucketsSetIteratorIteratorIteratorIteratorIteratorIterator\
    \ = bucketsSetIteratorIteratorIteratorIteratorIterator.iterator\n        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIterator.size\n        val\
    \ bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIterator = bucketsSetIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = bucketsSetIterator\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprrlijsy7.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mbucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\e\
    [0m = bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmprrlijsy7.scala:51:5 ---------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCounts = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_ = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCounts_1 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_2\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_3 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_4 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_5 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_6\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_7 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_8 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_9 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_10\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_11 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_12 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_13 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_14\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_15 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_16 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_17 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_18\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_19 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_20 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_21 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_22\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_23 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_24 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_25 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_26\
    \ = mutable.HashMap[\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp56s21l2d.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp56s21l2d.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp56s21l2d.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts_1\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- 0 until grid.length) {\n            for (col <- 0 until grid[0].length)\
    \ {\n                buckets += grid((row).toInt,(col).toInt)\n            }\n\
    \        }\n        val maxBucket = buckets.max\n        val maxBucketIndex =\
    \ buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketIndex\
    \ = buckets.indexWhere(_ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex)\n\
    \        val maxBucketCapacity = maxBucketSize \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphl0iioej.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = buckets.indexWhere(_\
    \ == maxBucket)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphl0iioej.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSize\e[0m = buckets(maxBucketIndex)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxBucketSize is already defined as \e[33mvalue\e[0m \e[35mmaxBucketSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphl0iioej.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m = maxBucketSize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphl0iioej.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = buckets.indexWhere(_\
    \ == maxBucket)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphl0iioej.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        grid.foreach(row => wells.append(row))\n\
    \        wells.foreach(well => {\n            val bucket = well.foldLeft(0l)(_\
    \ + _)\n            buckets += bucket\n        })\n        val maxBucket = buckets.max\n\
    \        val maxBucketIndex = buckets.indexWhere(_ == maxBucket)\n        val\
    \ maxBucketWells = wells.filter(_(maxBucketIndex) == 1)\n        val maxBucketWellCount\
    \ = maxBucketWells.length\n        val maxBucketWellsCount = wells.length\n  \
    \      val maxBucketCapacity = capacity - maxBucket\n        val maxBucketCapacityCount\
    \ = maxBucketWellCount + maxBucketWellsCount\n        if (maxBucketCapacity <=\
    \ 0) {\n            return 0\n        }\n        if (maxBucketCapacityCount <=\
    \ 0) {\n            return 0\n        }\n        if (maxBucketWellCount <= 0)\
    \ {\n            return 0\n        }\n        if (maxBucketWellsCount <= 0) {\n\
    \            return 0\n        }\n        if (maxBucketCapacityCount <= maxBucketWellCount)\
    \ {\n            return 0\n        }\n        if (maxBucketCapacityCount <= maxBucketWellsCount)\
    \ {\n            return 0\n        }\n        if (maxBucketCapacityCount <= maxBucketWellCount\
    \ * maxBucketWellsCount) {\n            return 0\n        }\n        if (maxBucketCapacityCount\
    \ <= maxBucketWellCount * maxBucketWellsCount * maxBucketWellsCount) {\n     \
    \       return 0\n        }\n        if (maxBucketCapacityCount <= maxBucketWellCount\
    \ * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount) {\n     \
    \       return 0\n        }\n        if (maxBucketCapacityCount <= maxBucketWellCount\
    \ * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount\
    \ * maxBucketWellsCount) {\n            return 0\n        }\n        if (maxBucketCapacityCount\
    \ <= maxBucketWellCount * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount\
    \ * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount\
    \ * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount\
    \ * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount\
    \ * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount * maxBucketWellsCount\
    \ * maxBucketWellsCount * maxBucketWellsCount * maxBucketWell\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5klw7cfn.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5klw7cfn.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5klw7cfn.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mwells\e[0m = mutable.ArrayBuffer.empty[\e[35mList\e[0m[\e[35mLong\e[0m]]\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val bucketsMap\
    \ = buckets.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n \
    \       val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap)\n\
    \        val bucketsMap = bucketsMap.map(_.toMap)\n        val bucketsMap = bucketsMap.map(_.toMap\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx4fpnbz9.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4fpnbz9.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsMap\e[0m = bucketsMap.map(_.toMap)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbucketsMap is\
    \ already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4fpnbz9.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsMap\e[0m = bucketsMap.map(_.toMap)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbucketsMap is\
    \ already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4fpnbz9.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsMap\e[0m = bucketsMap.map(_.toMap)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbucketsMap is\
    \ already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4fpnbz9.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsMap\e[0m = bucketsMap.map(_.toMap)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbucketsMap is\
    \ already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx4fpnbz9.scala:32:1"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacitySumCountMax = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n    \
    \    val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n \
    \       val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsch8pztq.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsch8pztq.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsch8pztq.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsch8pztq.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsch8pztq.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        val bucketCapacity =\
    \ mutable.ArrayBuffer.empty[Long]\n        val maxBucketCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n       \
    \ val maxBucketCapacityIndex = mutable.ArrayBuffer.empty[Int]\n        val maxBucketCapacityIndex\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprlny6f2k.scala:60:36 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m\
    \   |\e[0m                                    expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprlny6f2k.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprlny6f2k.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprlny6f2k.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprlny6f2k.scala:34:12 -----------------"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = mutable.ArrayBuffer(capacity)\n        var count = 0\n  \
    \      for (i <- 0 until m) {\n            for (j <- 0 until n) {\n          \
    \      if (grid[i][j] == 1l) {\n                    buckets(count) = buckets(count)\
    \ + 1\n                }\n            }\n        }\n        val maxCount = buckets.max\n\
    \        if (maxCount < buckets.min) {\n            return 0\n        }\n    \
    \    val maxCount = buckets.max\n        val maxCount = buckets.min\n        val\
    \ maxCount = buckets.max\n        val maxCount = buckets.min\n        val maxCount\
    \ = buckets.max\n        val maxCount = buckets.min\n        val maxCount = buckets.max\n\
    \        val maxCount = buckets.min\n        val maxCount = buckets.max\n    \
    \    val maxCount = buckets.min\n        val maxCount = buckets.max\n        val\
    \ maxCount = buckets.min\n        val maxCount = buckets.max\n        val maxCount\
    \ = buckets.min\n        val maxCount = buckets.max\n        val maxCount = buckets.min\n\
    \        val maxCount = buckets.max\n        val maxCount = buckets.min\n    \
    \    val maxCount = buckets.max\n        val maxCount = buckets.min\n        val\
    \ maxCount = buckets.max\n        val maxCount = buckets.min\n        val maxCount\
    \ = buckets.max\n        val maxCount = buckets.min\n        val maxCount = buckets.max\n\
    \        val maxCount = buckets.min\n        val maxCount = buckets.max\n    \
    \    val maxCount = buckets.min\n        val maxCount = buckets.max\n        val\
    \ maxCount = buckets.min\n        val maxCount = buckets.max\n        val maxCount\
    \ = buckets.min\n        val maxCount = buckets.max\n        val maxCount = buckets.min\n\
    \        val maxCount = buckets.max\n        val maxCount = buckets.min\n    \
    \    val maxCount = buckets.max\n        val maxCount = buckets.min\n        val\
    \ maxCount = buckets.max\n        val maxCount = buckets.min\n        val maxCount\
    \ = buckets.max\n        val maxCount = buckets.min\n        val maxCount = buckets.max\n\
    \        val maxCount = buckets.min\n        val maxCount = buckets.max\n    \
    \    val maxCount = buckets.min\n        val maxCount = buckets.max\n        val\
    \ maxCount = buckets.min\n        val maxCount = buckets.max\n        val maxCount\
    \ = buckets.min\n        val maxCount = buckets.max\n        val maxCount = buckets.min\n\
    \        val maxCount = buckets.max\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuumkpap2.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = buckets.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuumkpap2.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxCount\e[0m = buckets.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuumkpap2.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = buckets.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuumkpap2.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxCount\e[0m = buckets.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuumkpap2.scala:45:12 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = buckets.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in th"
  stdout: ''
  timestamp: 1659978852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, List[Long]]()\n    \
    \    val bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCounts\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_ = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_1 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_2 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_3\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_4 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_5 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_6 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_7\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_8 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_9 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_10 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_11\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_12 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_13 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_14 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_15\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_16 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_17 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_18 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_19\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_20 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_21 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_22 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_23\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_24 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_25 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_26 = mutable.Hash\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpebb6hw1p.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpebb6hw1p.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpebb6hw1p.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpebb6hw1p.scala:29:29\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts_\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpebb6hw1p.scala:30:30 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_1\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling w"
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = mutable.ArrayBuffer(capacity)\n        val fill = mutable.ArrayBuffer(capacity)\n\
    \        val fillCount = mutable.ArrayBuffer(capacity)\n        val fillCounts\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_ = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_1 = mutable.ArrayBuffer(capacity)\n        val fillCounts_2\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_3 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_4 = mutable.ArrayBuffer(capacity)\n        val fillCounts_5\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_6 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_7 = mutable.ArrayBuffer(capacity)\n        val fillCounts_8\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_9 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_10 = mutable.ArrayBuffer(capacity)\n        val fillCounts_11\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_12 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_13 = mutable.ArrayBuffer(capacity)\n        val fillCounts_14\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_15 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_16 = mutable.ArrayBuffer(capacity)\n        val fillCounts_17\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_18 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_19 = mutable.ArrayBuffer(capacity)\n        val fillCounts_20\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_21 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_22 = mutable.ArrayBuffer(capacity)\n        val fillCounts_23\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_24 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_25 = mutable.ArrayBuffer(capacity)\n        val fillCounts_26\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_27 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_28 = mutable.ArrayBuffer(capacity)\n        val fillCounts_29\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_30 = mutable.ArrayBuffer(capacity)\n\
    \        val fillCounts_31 = mutable.ArrayBuffer(capacity)\n        val fillCounts_32\
    \ = mutable.ArrayBuffer(capacity)\n        val fillCounts_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8mqwenfb.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8mqwenfb.scala:28:22\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8mqwenfb.scala:29:19\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mfill\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m         \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8mqwenfb.scala:30:24\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mfillCount\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m    \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8mqwenfb.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mfillCounts\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m   \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8mqwenfb.scala:32:26\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mfillCounts_\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m  \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation "
  stdout: ''
  timestamp: 1659978851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacities\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitiesCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitiesSum = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsSum = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsSumCountSum = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsSumCountSumCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSum\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCountSumCount\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp58v6v3ec.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp58v6v3ec.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp58v6v3ec.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp58v6v3ec.scala:28:32 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacities\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp58v6v3ec.scala:29:37 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitiesCount\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m       \
    \                              ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp58v6v3ec.scala:30:35 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitiesSum\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659978852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l).toList).flatten\n        val bucketsCount = buckets.map(_.size).sum\n\
    \        val bucketsSum = buckets.map(_.sum).sum\n        val bucketsSumOfSquares\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquaresOfSquares\
    \ = bucketsSumOfSquares * bucketsSumOfSquares\n        val bucketsSumOfSquaresOfSquaresOfSquares\
    \ = bucketsSumOfSquaresOfSquares * bucketsSumOfSquaresOfSquares\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsSumOfSquaresOfSquaresOfSquares * bucketsSumOfSquaresOfSquaresOfSquares\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = bucketsSumOfSquaresOfSquaresOfSquaresOfSquares\
    \ * bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOf\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps98uveac.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\e\
    [0m = bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ is already defined as \e[33mvalue\e[0m \e[35mbucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmps98uveac.scala:27:41 ------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = buckets.map(_.size).sum\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                      value size is not a member of\
    \ Long\n\e[31m\e[31m-- Error: /tmp/tmps98uveac.scala:27:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = buckets.map(_.size).sum\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mLongIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps98uveac.scala:28:39 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsSum\e[0m = buckets.map(_.sum).sum\n\
    \e[31m\e[31m"
  stdout: ''
  timestamp: 1659978854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).map(_._2).getOrElse(0l)\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val maxBucketSize = maxBucket * capacity\n        val bucketsSum = buckets.map(_.size).sum\n\
    \        val maxBucketSum = maxBucket * capacity\n        val bucketsSumSize =\
    \ bucketsSum * capacity\n        val maxBucketSumSize = maxBucketSum * capacity\n\
    \        val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val maxBucketSumSize = maxBucketSumSize * capacity\n     \
    \   val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val maxBucketSumSize = maxBucketSumSize * capacity\n     \
    \   val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val maxBucketSumSize = maxBucketSumSize * capacity\n     \
    \   val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val maxBucketSumSize = maxBucketSumSize * capacity\n     \
    \   val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val maxBucketSumSize = maxBucketSumSize * capacity\n     \
    \   val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val maxBucketSumSize = maxBucketSumSize * capacity\n     \
    \   val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val maxBucketSumSize = maxBucketSumSize * capacity\n     \
    \   val bucketsSumSize = bucketsSumSize * capacity\n        val maxBucketSumSize\
    \ = maxBucketSumSize * capacity\n        val bucketsSumSize = bucketsSumSize *\
    \ capacity\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpoahm3qow.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpoahm3qow.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumSize\e[0m = bucketsSumSize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumSize is already defined as \e[33mvalue\e[0m \e[35mbucketsSumSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoahm3qow.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSumSize\e[0m = maxBucketSumSize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSumSize is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketSumSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpoahm3qow.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumSize\e[0m = bucketsSumSize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumSize is already defined as \e[33mvalue\e[0m \e[35mbucketsSumSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoahm3qow.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSumSize\e[0m = maxBucketSumSize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSumSize is already defined as \e[33mvalu"
  stdout: ''
  timestamp: 1659978861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ wells = mutable.ArrayBuffer.empty[Int]\n        val visited = mutable.ArrayBuffer.empty[Int]\n\
    \        val visitedCount = mutable.ArrayBuffer.empty[Int]\n        val maxCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n        val maxCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCount = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n        val maxCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCount = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n        val maxCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCount = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n        val maxCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCount = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n        val maxCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCount = mutable.ArrayBuffer.empty[Int]\n        val maxCountIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val maxCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val maxCountIndex = mutable.ArrayBuffer.empty[Int]\n        val maxCount\
    \ = mutable.ArrayBuffer.empty[Int]\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbva2r67q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxCountIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCountIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbva2r67q.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbva2r67q.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxCountIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCountIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbva2r67q.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbva2r67q.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxCountIndex\e"
  stdout: ''
  timestamp: 1659978859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).toList\n        val maxBuckets\
    \ = buckets.map(_.length).max\n        val maxBucketsIndex = buckets.map(_.length).zipWithIndex.maxBy(_._1)._2\n\
    \        val bucketsIndex = buckets.zipWithIndex.filter(_._2 == maxBucketsIndex).map(_._1).toList\n\
    \        val bucketsCapacities = bucketsIndex.map(_.length).zipWithIndex.maxBy(_._1)._2\n\
    \        val bucketsCapacitiesIndex = bucketsIndex.map(_.length).zipWithIndex.maxBy(_._1)._2\n\
    \        val bucketsCapacities = bucketsCapacities.map(_.toLong).toList\n    \
    \    val bucketsCapacitiesIndex = bucketsCapacities.zipWithIndex.filter(_._2 ==\
    \ bucketsCapacitiesIndex).map(_._1).toList\n        val bucketsCapacitiesCapacities\
    \ = bucketsCapacitiesIndex.map(_.length).zipWithIndex.maxBy(_._1)._2\n       \
    \ val bucketsCapacitiesCapacitiesIndex = bucketsCapacitiesIndex.map(_.length).zipWithIndex.maxBy(_._1)._2\n\
    \        val bucketsCapacitiesCapacities = bucketsCapacitiesCapacities.map(_.toLong).toList\n\
    \        val bucketsCapacitiesCapacitiesIndex = bucketsCapacitiesCapacities.zipWithIndex.filter(_._2\
    \ == bucketsCapacitiesCapacitiesIndex).map(_._1).toList\n        val bucketsCapacitiesCapacitiesCapacities\
    \ = bucketsCapacitiesCapacitiesIndex.map(_.length).zipWithIndex.maxBy(_._1)._2\n\
    \        val bucketsCapacitiesCapacitiesCapacitiesIndex = bucketsCapacitiesCapacitiesIndex.map(_.length).zipWithIndex.maxBy(_._1)._2\n\
    \        val bucketsCapacitiesCapacitiesCapacities = bucketsCapacitiesCapacitiesCapacities.map(_.toLong).toList\n\
    \        val bucketsCapacitiesCapacitiesCapacitiesIndex = bucketsCapacitiesCapacitiesCapacities.zipWithIndex.filter(_._2\
    \ == bucketsCapacitiesCapacities\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1f0mvvny.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1f0mvvny.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacities\e[0m = bucketsCapacities.map(_.toLong).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacities is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacities\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1f0mvvny.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitiesIndex\e\
    [0m = bucketsCapacities.zipWithIndex.filter(_._2 == bucketsCapacitiesIndex).map(_._1).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitiesIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitiesIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1f0mvvny.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitiesCapacities\e\
    [0m = bucketsCapacitiesCapacities.map(_.toLong).toList\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitiesCapacities is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitiesCapacities\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1f0mvvny.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitiesCapac"
  stdout: ''
  timestamp: 1659978862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer(grid.length)\n        val bucketsCount = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCount = mutable.ArrayBuffer(grid.length)\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCapacity = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCapacitySum = mutable.ArrayBuffer(grid.length)\n        val\
    \ wellsCapacitySum = mutable.ArrayBuffer(grid.length)\n        val bucketsCapacitySumCount\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCapacitySumCount = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCapacitySumCount2 = mutable.ArrayBuffer(grid.length)\n   \
    \     val wellsCapacitySumCount2 = mutable.ArrayBuffer(grid.length)\n        val\
    \ bucketsCapacitySumCount3 = mutable.ArrayBuffer(grid.length)\n        val wellsCapacitySumCount3\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCapacitySumCount4 = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCapacitySumCount4 = mutable.ArrayBuffer(grid.length)\n     \
    \   val bucketsCapacitySumCount5 = mutable.ArrayBuffer(grid.length)\n        val\
    \ wellsCapacitySumCount5 = mutable.ArrayBuffer(grid.length)\n        val bucketsCapacitySumCount6\
    \ = mutable.ArrayBuffer(grid.length)\n        val wellsCapacitySumCount6 = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCapacitySumCount7 = mutable.ArrayBuffer(grid.length)\n   \
    \     val wellsCapacitySumCount7 = mutable.ArrayBuffer(grid.length)\n        val\
    \ bucketsCapacitySumCount8 = mutable.ArrayBuffer(grid.length)\n        val wellsCapacitySumCount8\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCapacitySumCount9 = mutable.ArrayBuffer(grid.length)\n\
    \        val wellsCapacitySumCount9 = mutable.ArrayBuffer(grid.length)\n     \
    \   val bucketsCapacitySumCount10 = mutable.ArrayBuffer(grid.length)\n       \
    \ val wellsCapacitySumCount10 = mutable.ArrayBuffer(grid.length)\n        val\
    \ bucketsCapacitySumCount11 = mutable.ArrayBuffer(grid.length)\n        val wellsCapacitySumCount11\
    \ = mutable.ArrayBuffer(grid.length)\n        val bucketsCapacitySumCount12 =\
    \ mutable.ArrayBuffer(grid.length)\n        val wellsCapacitySumCount12 = mutable.ArrayBuffer(grid.length)\n\
    \        val bucketsCapacitySumCount13 = mutable.ArrayBuffer(grid.length)\n  \
    \      val wellsCapacitySumCount13 = mutable.ArrayBuffer(grid.length)\n      \
    \  val bucketsCapacitySumCount14 = mutable.ArrayBuffer(grid.length)\n        val\
    \ wellsCapacitySum\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_y4sstnq.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_y4sstnq.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_y4sstnq.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mwells\e[0m = mutable.ArrayBuffer(grid.length)\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_y4sstnq.scala:28:27\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.ArrayBuffer(grid.length)\n\e[31m\e[31m   |\e[0m\
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_y4sstnq.scala:29:25 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mwellsCount\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp_y4sstnq.scala:30:30 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659978860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val maxBucketCapacity = maxBucketSize / capacity\n        val maxBucketCapacityWithEmpty\
    \ = maxBucketCapacity + capacity\n        val maxBucketCapacityWithoutEmpty =\
    \ maxBucketCapacityWithEmpty - capacity\n        val maxBucketCapacityWithoutEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmpty - capacity\n        val maxBucketCapacityWithoutEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmpty - capacity\n        val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmpty - capacity\n        val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmpty - capacity\n       \
    \ val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty =\
    \ maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmpty - capacity\n \
    \       val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty - capacity\n\
    \        val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n        val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n        val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n        val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n        val maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n        val maxBucketCapacityWithoutEmpty\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdxk87erf.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdxk87erf.scala:38:100\
    \ --------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\e\
    [0m = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n\e[31m\e[31m   |\e[0m                                          \
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpdxk87erf.scala:39:108 --------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\e\
    [0m = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n\e[31m\e[31m   |\e[0m                                          \
    \                                                                  ^\e[0m\n\e\
    [31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpdxk87erf.scala:41:124 --------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\e\
    [0m = maxBucketCapacityWithoutEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmptyAndEmpty\
    \ - capacity\n\e[31m\e[31m   |\e[0m      "
  stdout: ''
  timestamp: 1659978859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Int]()\n        val bucketsCount2 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount3 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount4 = mutable.HashMap[Long, Int]()\n        val bucketsCount5 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount6 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount7 = mutable.HashMap[Long, Int]()\n        val bucketsCount8 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount9 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount10 = mutable.HashMap[Long, Int]()\n        val bucketsCount11 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount12 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount13 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount14 = mutable.HashMap[Long, Int]()\n        val bucketsCount15 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount16 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount17 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount18 = mutable.HashMap[Long, Int]()\n        val bucketsCount19 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount20 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount21 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount22 = mutable.HashMap[Long, Int]()\n        val bucketsCount23 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount24 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount25 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount26 = mutable.HashMap[Long, Int]()\n        val bucketsCount27 =\
    \ mutable.HashMap[Long, Int]()\n        val bucketsCount28 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCount29 = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount30 = mutable.HashMap[Long, Int]()\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount2\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrqi6q_1.scala:30:28\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount4\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ ["
  stdout: ''
  timestamp: 1659978845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[Long]\n        for (row <- grid) {\n     \
    \       wells += row(0)\n            buckets += row(1)\n        }\n        val\
    \ maxBuckets = buckets.max\n        val maxWells = wells.max\n        val maxBucketsNeeded\
    \ = maxBuckets - capacity\n        val maxWellsNeeded = maxWells - capacity\n\
    \        val bucketsNeeded = maxBucketsNeeded / maxBuckets\n        val wellsNeeded\
    \ = maxWellsNeeded / maxWells\n        bucketsNeeded * wellsNeeded\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr_b7zdhx.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpr_b7zdhx.scala:27:20 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.map(_.max).max\n        val bucketsCount\
    \ = buckets.map(_.size).sum\n        val maxBucketCount = buckets.map(_.size).max\n\
    \        val maxBucketCapacity = maxBucketCount / bucketsCount\n        val maxBucketCapacity2\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity3\
    \ = maxBucketCapacity2.toLong * maxBucketCapacity2\n        val maxBucketCapacity4\
    \ = maxBucketCapacity3.toLong * maxBucketCapacity3\n        val maxBucketCapacity5\
    \ = maxBucketCapacity4.toLong * maxBucketCapacity4\n        val maxBucketCapacity6\
    \ = maxBucketCapacity5.toLong * maxBucketCapacity5\n        val maxBucketCapacity7\
    \ = maxBucketCapacity6.toLong * maxBucketCapacity6\n        val maxBucketCapacity8\
    \ = maxBucketCapacity7.toLong * maxBucketCapacity7\n        val maxBucketCapacity9\
    \ = maxBucketCapacity8.toLong * maxBucketCapacity8\n        val maxBucketCapacity10\
    \ = maxBucketCapacity9.toLong * maxBucketCapacity9\n        val maxBucketCapacity\
    \ = maxBucketCapacity10.toLong * maxBucketCapacity10\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong * maxBucketCapacity\n        val maxBucket\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7gw2p0d4.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7gw2p0d4.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacity\e[0m = maxBucketCapacity10.toLong * maxBucketCapacity10\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7gw2p0d4.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong * maxBucketCapacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7gw2p0d4.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong * maxBucketCapacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7gw2p0d4.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong * maxBucketCapacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsCount = buckets.map(_.size).sum\n\
    \        val bucketsSum = buckets.map(_.size).sum\n        val bucketsSum2 = buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum\n        val bucketsSum3 = buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum\n        val bucketsSum4\
    \ = buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum\n        val bucketsSum5 = buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum\n        val bucketsSum6\
    \ = buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum\n        val bucketsSum7\
    \ = buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum\n        val bucketsSum8 = buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum\n        val bucketsSum9\
    \ = buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphv1lyxbg.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmphv1lyxbg.scala:37:180 ----------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsSum9\e[0m = buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.size).sum\
    \ * buckets.map(_.size).sum * buckets.map(_.size).sum * buckets.map(_.\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments (List[Nothing])\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmphv1lyxbg.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount2 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount3 = mutable.HashMap[Long, Long]()\n       \
    \ val bucketsCount4 = mutable.HashMap[Long, Long]()\n        val bucketsCount5\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount6 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount7 = mutable.HashMap[Long, Long]()\n       \
    \ val bucketsCount8 = mutable.HashMap[Long, Long]()\n        val bucketsCount9\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount10 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount11 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount12 = mutable.HashMap[Long, Long]()\n        val bucketsCount13\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount14 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount15 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount16 = mutable.HashMap[Long, Long]()\n        val bucketsCount17\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount18 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount19 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount20 = mutable.HashMap[Long, Long]()\n        val bucketsCount21\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount22 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount23 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount24 = mutable.HashMap[Long, Long]()\n        val bucketsCount25\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount26 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount27 = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCount28 = mutable.HashMap[Long, Long]()\n        val bucketsCount29\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCount30 = mutable.HashMap[Long,\
    \ Long]()\n        \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount2\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcix3vd9j.scala:30:28\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount4\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).map(_.toSet)\n        val\
    \ maxBucket = buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacityInt\
    \ = maxBucketCapacity.toInt\n        val maxBucketCapacityLong = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacityInt = maxBucketCapacity.toInt\n        val maxBucketCapacityLong\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacityInt = maxBucketCapacity.toInt\n\
    \        val maxBucketCapacityLong = maxBucketCapacity.toLong\n        val maxBucketCapacityInt\
    \ = maxBucketCapacity.toInt\n        val maxBucketCapacityLong = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacityInt = maxBucketCapacity.toInt\n        val maxBucketCapacityLong\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacityInt = maxBucketCapacity.toInt\n\
    \        val maxBucketCapacityLong = maxBucketCapacity.toLong\n        val maxBucketCapacityInt\
    \ = maxBucketCapacity.toInt\n        val maxBucketCapacityLong = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacityInt = maxBucketCapacity.toInt\n        val maxBucketCapacityLong\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacityInt = maxBucketCapacity.toInt\n\
    \        val maxBucketCapacityLong = maxBucketCapacity.toLong\n        val maxBucketCapacityInt\
    \ = maxBucketCapacity.toInt\n        val maxBucketCapacityLong = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacityInt = maxBucketCapacity.toInt\n        val maxBucketCapacityLong\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacityInt = maxBucketCapacity.toInt\n\
    \        val maxBucketCapacityLong = maxBucketCapacity.toLong\n        val maxBucketCapacityInt\
    \ = maxBucketCapacity.toInt\n        val maxBucketCapacityLong = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacityInt = maxBucketCapacity.toInt\n        val maxBucketCapacityLong\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacityInt = maxBucketCapacity.toInt\n\
    \        val maxBucketCapacityLong = maxBucketCapacity.toLong\n        val maxBucketCapacityInt\
    \ = maxBucketCapac\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw5_uh_9h.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityInt\e[0m\
    \ = maxBucketCapacity.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketCapacityInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw5_uh_9h.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityLong\e\
    [0m = maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityLong is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw5_uh_9h.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityInt\e[0m\
    \ = maxBucketCapacity.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketCapacityInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw5_uh_9h.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityLong\e\
    [0m = maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityLong is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw5_uh_9h.scala:36:12 -----------------"
  stdout: ''
  timestamp: 1659978862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        grid.foreach(row\
    \ => row.foreach(bucket => buckets += (bucket -> 0)))\n        val maxBucket =\
    \ buckets.maxBy(_._1)._1\n        val maxBucketCount = buckets.filter(_._1 ==\
    \ maxBucket).length\n        val maxBucketCapacity = buckets.filter(_._1 == maxBucket).map(_._2).sum\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * capacity\n        val maxBucketCapacity\
    \ = maxBucketCapacity / capacity\n        val maxBucketCapacity = maxBucketCapacity\
    \ * capacity\n        val maxBucketCapacity = maxBucketCapacity / capacity\n \
    \       val maxBucketCapacity = maxBucketCapacity * \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_4mwco7k.scala:63:51 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity * \n\e[31m\e[31m   |\e[0m                                \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_4mwco7k.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_4mwco7k.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity / capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_4mwco7k.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_4mwco7k.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacit"
  stdout: ''
  timestamp: 1659978863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsSum = buckets.map(_.size).sum\n\
    \        val bucketsSumWithMaxBucketSize = bucketsSum + maxBucketSize\n      \
    \  val bucketsSumWithMaxBucketSizeWithMaxBucket = bucketsSumWithMaxBucketSize\
    \ + maxBucketSize\n        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSize\
    \ = bucketsSumWithMaxBucketSizeWithMaxBucket + maxBucketSize\n        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucket\
    \ = bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSize + maxBucketSize\n\
    \        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSize\
    \ = bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucket + maxBucketSize\n\
    \        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucket\
    \ = bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSize\
    \ + maxBucketSize\n        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSize\
    \ = bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucket\
    \ + maxBucketSize\n        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucket\
    \ = bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSize\
    \ + maxBucketSize\n        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucket\
    \ = bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucket\
    \ + maxBucketSize\n        val bucketsSumWithMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucketSizeWithMaxBucketAndMaxBucket\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvkv6vfdt.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvkv6vfdt.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer(grid.length)\n        for (row <- 0 until grid.length)\
    \ {\n            val bucket = buckets.last\n            buckets += bucket\n  \
    \          wells += row\n        }\n        val maxWells = wells.last\n      \
    \  val maxBuckets = buckets.last\n        val maxBucket = buckets.last\n     \
    \   val maxWell = wells.last\n        val maxWells = wells.last\n        val maxBuckets\
    \ = buckets.last\n        val maxBucket = buckets.last\n        val maxWell =\
    \ wells.last\n        val maxWells = wells.last\n        val maxBuckets = buckets.last\n\
    \        val maxBucket = buckets.last\n        val maxWell = wells.last\n    \
    \    val maxWells = wells.last\n        val maxBuckets = buckets.last\n      \
    \  val maxBucket = buckets.last\n        val maxWell = wells.last\n        val\
    \ maxWells = wells.last\n        val maxBuckets = buckets.last\n        val maxBucket\
    \ = buckets.last\n        val maxWell = wells.last\n        val maxWells = wells.last\n\
    \        val maxBuckets = buckets.last\n        val maxBucket = buckets.last\n\
    \        val maxWell = wells.last\n        val maxWells = wells.last\n       \
    \ val maxBuckets = buckets.last\n        val maxBucket = buckets.last\n      \
    \  val maxWell = wells.last\n        val maxWells = wells.last\n        val maxBuckets\
    \ = buckets.last\n        val maxBucket = buckets.last\n        val maxWell =\
    \ wells.last\n        val maxWells = wells.last\n        val maxBuckets = buckets.last\n\
    \        val maxBucket = buckets.last\n        val maxWell = wells.last\n    \
    \    val maxWells = wells.last\n        val maxBuckets = buckets.last\n      \
    \  val maxBucket = buckets.last\n        val maxWell = wells.last\n        val\
    \ maxWells = wells.last\n        val maxBuckets = buckets.last\n        val maxBucket\
    \ = buckets.last\n        val maxWell = wells.last\n        val maxWells = wells.last\n\
    \        val maxBuckets = buckets.last\n        val maxBucket = buckets.last\n\
    \        val maxWell = wells.last\n        val maxWells = wells.last\n       \
    \ val maxBuckets = buckets.last\n        val maxBucket = buckets.last\n      \
    \  val max\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprd951d82.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprd951d82.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWells\e[0m = wells.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWells is already defined as \e[33mvalue\e[0m \e[35mmaxWells\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprd951d82.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxBuckets\e[0m = buckets.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxBuckets\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxBuckets\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprd951d82.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucket\e[0m = buckets.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucket is already defined as \e[33mvalue\e[0m \e[35mmaxBucket\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprd951d82.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxWell\e[0m = wells.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxWell is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxWell\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprd951d82.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWells\e[0m = wells.last\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659978865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity =\
    \ mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Int]\n      \
    \  val bucketsCapacitySumCountMax = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCapacitySumCountMin = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySumCountMinIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacitySum\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgd71apxh.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgd71apxh.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMinIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMinIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMinIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgd71apxh.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMinIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMinIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMinIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgd71apxh.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMinIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMinIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMinIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgd71apxh.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMinIndex\e[0m = mutable.Array"
  stdout: ''
  timestamp: 1659978864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val bucketsCount\
    \ = buckets.map(_.size)\n        val bucketsSum = bucketsCount.sum\n        val\
    \ bucketsSumInv = bucketsSum.inv\n        val bucketsSumInv2 = bucketsSumInv.pow(2)\n\
    \        val bucketsSumInv3 = bucketsSumInv2.pow(3)\n        val bucketsSumInv4\
    \ = bucketsSumInv3.pow(4)\n        val bucketsSumInv5 = bucketsSumInv4.pow(5)\n\
    \        val bucketsSumInv6 = bucketsSumInv5.pow(6)\n        val bucketsSumInv7\
    \ = bucketsSumInv6.pow(7)\n        val bucketsSumInv8 = bucketsSumInv7.pow(8)\n\
    \        val bucketsSumInv9 = bucketsSumInv8.pow(9)\n        val bucketsSumInv10\
    \ = bucketsSumInv9.pow(10)\n        val bucketsSumInv11 = bucketsSumInv10.pow(11)\n\
    \        val bucketsSumInv12 = bucketsSumInv11.pow(12)\n        val bucketsSumInv13\
    \ = bucketsSumInv12.pow(13)\n        val bucketsSumInv14 = bucketsSumInv13.pow(14)\n\
    \        val bucketsSumInv15 = bucketsSumInv14.pow(15)\n        val bucketsSumInv16\
    \ = bucketsSumInv15.pow(16)\n        val bucketsSumInv17 = bucketsSumInv16.pow(17)\n\
    \        val bucketsSumInv18 = bucketsSumInv17.pow(18)\n        val bucketsSumInv19\
    \ = bucketsSumInv18.pow(19)\n        val bucketsSumInv20 = bucketsSumInv19.pow(20)\n\
    \        val bucketsSumInv21 = bucketsSumInv20.pow(21)\n        val bucketsSumInv22\
    \ = bucketsSumInv21.pow(22)\n        val bucketsSumInv23 = bucketsSumInv22.pow(23)\n\
    \        val bucketsSumInv24 = bucketsSumInv23.pow(24)\n        val bucketsSumInv25\
    \ = bucketsSumInv24.pow(25)\n        val bucketsSumInv26 = bucketsSumInv25.pow(26)\n\
    \        val bucketsSumInv27 = bucketsSumInv26.pow(27)\n        val bucketsSumInv28\
    \ = bucketsSumInv27.pow(28)\n        val bucketsSumInv29 = bucketsSumInv28.pow(29)\n\
    \        val bucketsSumInv30 = bucketsSumInv29.pow(30)\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiqfx2glr.scala:29:39 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumInv\e[0m = bucketsSum.inv\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                            value inv is not a member of Int\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpiqfx2glr.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).flatten\n        val bucketsMap\
    \ = buckets.groupBy(x => x).mapValues(_.size)\n        val bucketsMap = bucketsMap.filter(_._2\
    \ > 1).map(_._1)\n        val bucketsMap = bucketsMap.map(_._2).sum\n        val\
    \ bucketsMap = bucketsMap.map(x => x - capacity)\n        bucketsMap.foldLeft(0l)\
    \ { (acc, x) => acc + x }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6tii1amn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap\e[0m = bucketsMap.filter(_._2\
    \ > \e[31m1\e[0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMap is already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6tii1amn.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap\e[0m = bucketsMap.map(_._2).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbucketsMap is already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6tii1amn.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap\e[0m = bucketsMap.map(\e\
    [36mx\e[0m => x - capacity)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMap is already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmp6tii1amn.scala:31:50 -----------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        bucketsMap.foldLeft(\e[31m0l\e[0m) { (\e[36macc\e[0m, \e\
    [36mx\e[0m) => acc + x }\n\e[31m\e[31m   |\e[0m                              \
    \                ^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0m (x: String):"
  stdout: ''
  timestamp: 1659978863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val bucketsCount\
    \ = buckets.map(_.size)\n        val bucketsSum = bucketsCount.sum\n        val\
    \ bucketsSumInv = bucketsSum.inv\n        val bucketsSumInv2 = bucketsSumInv.pow(2)\n\
    \        val bucketsSumInv3 = bucketsSumInv2.pow(3)\n        val bucketsSumInv4\
    \ = bucketsSumInv3.pow(4)\n        val bucketsSumInv5 = bucketsSumInv4.pow(5)\n\
    \        val bucketsSumInv6 = bucketsSumInv5.pow(6)\n        val bucketsSumInv7\
    \ = bucketsSumInv6.pow(7)\n        val bucketsSumInv8 = bucketsSumInv7.pow(8)\n\
    \        val bucketsSumInv9 = bucketsSumInv8.pow(9)\n        val bucketsSumInv10\
    \ = bucketsSumInv9.pow(10)\n        val bucketsSumInv11 = bucketsSumInv10.pow(11)\n\
    \        val bucketsSumInv12 = bucketsSumInv11.pow(12)\n        val bucketsSumInv13\
    \ = bucketsSumInv12.pow(13)\n        val bucketsSumInv14 = bucketsSumInv13.pow(14)\n\
    \        val bucketsSumInv15 = bucketsSumInv14.pow(15)\n        val bucketsSumInv16\
    \ = bucketsSumInv15.pow(16)\n        val bucketsSumInv17 = bucketsSumInv16.pow(17)\n\
    \        val bucketsSumInv18 = bucketsSumInv17.pow(18)\n        val bucketsSumInv19\
    \ = bucketsSumInv18.pow(19)\n        val bucketsSumInv20 = bucketsSumInv19.pow(20)\n\
    \        val bucketsSumInv21 = bucketsSumInv20.pow(21)\n        val bucketsSumInv22\
    \ = bucketsSumInv21.pow(22)\n        val bucketsSumInv23 = bucketsSumInv22.pow(23)\n\
    \        val bucketsSumInv24 = bucketsSumInv23.pow(24)\n        val bucketsSumInv25\
    \ = bucketsSumInv24.pow(25)\n        val bucketsSumInv26 = bucketsSumInv25.pow(26)\n\
    \        val bucketsSumInv27 = bucketsSumInv26.pow(27)\n        val bucketsSumInv28\
    \ = bucketsSumInv27.pow(28)\n        val bucketsSumInv29 = bucketsSumInv28.pow(29)\n\
    \        val bucketsSumInv30 = bucketsSumInv29.pow(30)\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiqfx2glr.scala:29:39 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumInv\e[0m = bucketsSum.inv\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                            value inv is not a member of Int\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpiqfx2glr.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCountMap = mutable.HashMap.empty[Long, Long]\n   \
    \     val bucketsCapacityCountMap2 = mutable.HashMap.empty[Long, Long]\n     \
    \   val bucketsCapacityCountMap3 = mutable.HashMap.empty[Long, Long]\n       \
    \ val bucketsCapacityCountMap4 = mutable.HashMap.empty[Long, Long]\n        val\
    \ bucketsCapacityCountMap5 = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap6\
    \ = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap7 =\
    \ mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap8 = mutable.HashMap.empty[Long,\
    \ Long]\n        val bucketsCapacityCountMap9 = mutable.HashMap.empty[Long, Long]\n\
    \        val bucketsCapacityCountMap10 = mutable.HashMap.empty[Long, Long]\n \
    \       val bucketsCapacityCountMap11 = mutable.HashMap.empty[Long, Long]\n  \
    \      val bucketsCapacityCountMap12 = mutable.HashMap.empty[Long, Long]\n   \
    \     val bucketsCapacityCountMap13 = mutable.HashMap.empty[Long, Long]\n    \
    \    val bucketsCapacityCountMap14 = mutable.HashMap.empty[Long, Long]\n     \
    \   val bucketsCapacityCountMap15 = mutable.HashMap.empty[Long, Long]\n      \
    \  val bucketsCapacityCountMap16 = mutable.HashMap.empty[Long, Long]\n       \
    \ val bucketsCapacityCountMap17 = mutable.HashMap.empty[Long, Long]\n        val\
    \ bucketsCapacityCountMap18 = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap19\
    \ = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap20 =\
    \ mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap21 = mutable.HashMap.empty[Long,\
    \ Long]\n        val bucketsCapacityCountMap22 = mutable.HashMap.empty[Long, Long]\n\
    \        val bucketsCapacityCountMap23 = mutable.HashMap.empty[Long, Long]\n \
    \       val bucketsCapacityCountMap24\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpznmwszyd.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpznmwszyd.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpznmwszyd.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpznmwszyd.scala:28:30 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpznmwszyd.scala:29:35 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCount\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        \
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpznmwszyd.scala:30:38 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacityCountMap\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m "
  stdout: ''
  timestamp: 1659978864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        for\
    \ (row <- grid) {\n            val bucket = row(0).toLong\n            buckets\
    \ += bucket -> bucket\n        }\n        val result = mutable.HashMap[Long, Long]()\n\
    \        for (bucket <- buckets.keys) {\n            val bucketCap = buckets(bucket)\n\
    \            val bucketSum = bucketCap + capacity\n            if (bucketSum >\
    \ capacity) {\n                val bucketSum = bucketCap - capacity\n        \
    \        val bucketSum = bucketCap + capacity\n                val bucketSum =\
    \ bucketCap - capacity\n                val bucketSum = bucketCap + capacity\n\
    \                val bucketSum = bucketCap - capacity\n                val bucketSum\
    \ = bucketCap + capacity\n                val bucketSum = bucketCap - capacity\n\
    \                val bucketSum = bucketCap + capacity\n                val bucketSum\
    \ = bucketCap - capacity\n                val bucketSum = bucketCap + capacity\n\
    \                val bucketSum = bucketCap - capacity\n                val bucketSum\
    \ = bucketCap + capacity\n                val bucketSum = bucketCap - capacity\n\
    \                val bucketSum = bucketCap + capacity\n                val bucketSum\
    \ = bucketCap - capacity\n                val bucketSum = bucketCap + capacity\n\
    \                val bucketSum = bucketCap - capacity\n                val bucketSum\
    \ = bucketCap + capacity\n                val bucketSum = bucketCap - capacity\n\
    \                val bucketSum = bucketCap + capacity\n                val bucketSum\
    \ = bucketCap - capacity\n                val bucketSum = bucketCap + capacity\n\
    \                val bucketSum = bucketCap - capacity\n                val bucketSum\
    \ = bucketCap + capacity\n                val bucketSum = bucketCap - capacity\n\
    \                val bucketSum = bucketCap + capacity\n                val bucketSum\
    \ = bucketCap - capacity\n                val bucketSum = bucketCap + capacity\n\
    \                val bucketSum = bucketCap - capacity\n                val bucketSum\
    \ = bucketCap + capacity\n                val bucketSum = bucketCap - capacity\n\
    \                val bucketSum = bucketCap + capacity\n                val bucketSum\
    \ = bucketCap - capacity\n                val bucketSum = bucketCap + capacity\n\
    \                val bucketSum = bucketCap - capacity\n                val bucketSum\
    \ = bucketCap + capacity\n                val bucketSum = bucketCap - capacity\n\
    \                val bucketSum = bucketCap + capacity\n                val bucketSum\
    \ = bucketCap - capacity\n                val bucketSum = bucketCap + capacity\n\
    \                val bucketSum = bucketCap - capacity\n                val bucketSum\
    \ = bucketCap + capacity\n                val bucketSum = bucket\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcyz1saeo.scala:89:0 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcyz1saeo.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpcyz1saeo.scala:31:21 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.HashMap[\e[35mLong\e[0m,\
    \ \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpcyz1saeo.scala:80:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m80 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659978858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsMap = mutable.HashMap[Long, Long]()\n        val bucketsMap2 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap3 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap4 = mutable.HashMap[Long, Long]()\n        val bucketsMap5 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap6 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap7 = mutable.HashMap[Long, Long]()\n        val bucketsMap8 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap9 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap10 = mutable.HashMap[Long, Long]()\n        val bucketsMap11 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap12 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap13 = mutable.HashMap[Long, Long]()\n        val bucketsMap14 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap15 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap16 = mutable.HashMap[Long, Long]()\n        val bucketsMap17 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap18 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap19 = mutable.HashMap[Long, Long]()\n        val bucketsMap20 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap21 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap22 = mutable.HashMap[Long, Long]()\n        val bucketsMap23 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap24 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap25 = mutable.HashMap[Long, Long]()\n        val bucketsMap26 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap27 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap28 = mutable.HashMap[Long, Long]()\n        val bucketsMap29 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap30 = mutable.HashMap[Long, Long]()\n        val\
    \ buckets\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpalbjaxsw.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalbjaxsw.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalbjaxsw.scala:27:25\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsMap\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpalbjaxsw.scala:28:26 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap2\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalbjaxsw.scala:29:26\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsMap3\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpalbjaxsw.scala:30:26 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap4\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \     ^^^^^^^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1659978864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsCount = buckets.map(_.size)\n\
    \        val maxBucketCount = bucketsCount.max\n        val bucketsSum = bucketsCount.sum\n\
    \        val maxBucketSum = bucketsSum.max\n        val bucketsSumOfBuckets =\
    \ bucketsSum.map(_.toDouble)\n        val maxBucketSumOfBuckets = bucketsSumOfBuckets.max\n\
    \        val bucketsSumOfBucketsCount = bucketsSumOfBuckets.map(_.toLong)\n  \
    \      val maxBucketSumOfBucketsCount = bucketsSumOfBucketsCount.max\n       \
    \ val bucketsSumOfBucketsSum = bucketsSumOfBucketsCount.map(_.toDouble)\n    \
    \    val maxBucketSumOfBucketsSum = bucketsSumOfBucketsSum.max\n        val bucketsSumOfBucketsSumOfBuckets\
    \ = bucketsSumOfBucketsSum.map(_.toLong)\n        val maxBucketSumOfBucketsSumOfBuckets\
    \ = bucketsSumOfBucketsSumOfBuckets.max\n        val bucketsSumOfBucketsSumOfBucketsCount\
    \ = bucketsSumOfBucketsSumOfBuckets.map(_.toLong)\n        val maxBucketSumOfBucketsSumOfBucketsCount\
    \ = bucketsSumOfBucketsSumOfBucketsCount.max\n        val bucketsSumOfBucketsSumOfBucketsSum\
    \ = bucketsSumOfBucketsSumOfBucketsCount.map(_.toDouble)\n        val maxBucketSumOfBucketsSumOfBucketsSum\
    \ = bucketsSumOfBucketsSumOfBucketsSum.max\n        val bucketsSumOfBucketsSumOfBucketsSumOfBuckets\
    \ = bucketsSumOfBucketsSumOfBucketsSum.map(_.toLong)\n        val maxBucketSumOfBucketsSumOfBucketsSumOfBuckets\
    \ = bucketsSumOfBucketsSumOfBucketsSumOfBuckets.max\n        val bucketsSumOfBucketsSumOfBucketsSumOfBucketsCount\
    \ = bucketsSumOfBucketsSumOfBucketsSumOfBuckets.map(_.toLong)\n        val maxBucketSumOfBucketsSumOfBucketsSumOfBucketsCount\
    \ = bucketsSumOfBucketsSumOfBucketsSumOfBucketsCount.max\n        val bucketsSumOfBucketsSumOfBucketsSumOfBucketsSum\
    \ = bucket\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv5he8pqg.scala:32:45 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfBuckets\e[0m\
    \ = bucketsSum.map(_.toDouble)\n\e[31m\e[31m   |\e[0m                        \
    \          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \    value map is not a member of Int\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpv5he8pqg.scala:48:61 ------------------------\e[0m\e[0m\n\e[31m48 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsSumOfBucketsSumOfBucketsSumOfBucketsSum\e\
    [0m = bucket\n\e[31m\e[31m   |\e[0m                                          \
    \                   ^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                          Not found: bucket\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpv5he8pqg.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).map(_.toSet)\n        val\
    \ maxBucket = buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacityRatio = bucketsCapacity\
    \ / capacity\n        val bucketsSizeRatio = bucketsSize / maxBucketSize\n   \
    \     val bucketsCapacityRatio2 = bucketsCapacityRatio / bucketsSizeRatio\n  \
    \      val bucketsCapacityRatio3 = bucketsCapacityRatio * bucketsCapacityRatio\n\
    \        val bucketsCapacityRatio4 = bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio\n        val bucketsCapacityRatio5 = bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\n     \
    \   val bucketsCapacityRatio6 = bucketsCapacityRatio * bucketsCapacityRatio *\
    \ bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\n       \
    \ val bucketsCapacityRatio7 = bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\n     \
    \   val bucketsCapacityRatio8 = bucketsCapacityRatio * bucketsCapacityRatio *\
    \ bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio\n        val bucketsCapacityRatio9 = bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\n\
    \        val bucketsCapacityRatio10 = bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio\n        val bucketsCapacityRatio11 = bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\n\
    \        val bucketsCapacityRatio12 = bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio * bucketsCapacityRatio\
    \ * bucket\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpko3vc94s.scala:30:44 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             value capacity is not a member of\
    \ Set[Long]\n\e[31m\e[31m-- Error: /tmp/tmpko3vc94s.scala:30:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mDoubleIsFractional\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type\
    \ Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpko3vc94s.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).map(_.toSet)\n        val\
    \ bucketsCount = buckets.map(_.size).sum\n        val bucketsCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSum = buckets.map(_.sum).sum\n        val bucketsSumCap =\
    \ buckets.map(_.sum).sum\n        val bucketsSumCapCap = buckets.map(_.sum).sum\n\
    \        val bucketsSumCapCapCap = buckets.map(_.sum).sum\n        val bucketsSumCapCapCapCap\
    \ = buckets.map(_.sum).sum\n        val bucketsSumCapCapCapCapCap = buckets.map(_.sum).sum\n\
    \        val bucketsSumCapCapCapCapCapCap = buckets.map(_.sum).sum\n        val\
    \ bucketsSumCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n        val bucketsSumCapCapCapCapCapCapCap\
    \ = buckets.map(_.sum).sum\n        val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n      \
    \  val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n        val bucketsSumCapCapCapCapCapCapCapCap\
    \ = buckets.map(_.sum).sum\n        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n   \
    \     val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n      \
    \  val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n        val\
    \ bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n        val\
    \ bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.sum).sum\n        val\
    \ bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf8joc6eb.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf8joc6eb.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.sum).sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf8joc6eb.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.sum).sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf8joc6eb.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.sum).sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf8joc6eb.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.sum).sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount2 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount3 = mutable.ArrayBuffer(capacity)\n        val bucketsCount4\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount5 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount6 = mutable.ArrayBuffer(capacity)\n        val bucketsCount7\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount8 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount9 = mutable.ArrayBuffer(capacity)\n        val bucketsCount10\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount11 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount12 = mutable.ArrayBuffer(capacity)\n        val bucketsCount13\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount14 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount15 = mutable.ArrayBuffer(capacity)\n        val bucketsCount16\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount17 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount18 = mutable.ArrayBuffer(capacity)\n        val bucketsCount19\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount20 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount21 = mutable.ArrayBuffer(capacity)\n        val bucketsCount22\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount23 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount24 = mutable.ArrayBuffer(capacity)\n        val bucketsCount25\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount26 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount27 = mutable.ArrayBuffer(capacity)\n        val bucketsCount28\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount29 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount30 = mutable.ArrayBuffer(capacity)\n        val bucketsCount31\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount32 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount33 = mutable.ArrayBuffer(capacity)\n        val bucketsCount34\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount35 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount36 = mutable.ArrayBuffer(capacity)\n        val bucketsCount37\
    \ = mutable.Array\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmplqyjzu1h.scala:27:27 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount2\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:30:28 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount4\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqyjzu1h.scala:31:28 ------------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCounts = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_jy_d40l.scala:58:35 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCounts\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_jy_d40l.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacityCounts\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCounts is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacityCounts\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_jy_d40l.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCounts\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mbucketsCapacityCounts is already defined as \e[33mvalue\e[0m \e[35mbucketsCapacityCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_jy_d40l.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCounts is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacityCounts\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_jy_d40l.scala:34:12 --------------------------"
  stdout: ''
  timestamp: 1659978867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.map(_.max).max\n        val maxBucketIndex\
    \ = buckets.map(_.indexWhere(_ == maxBucket)).max\n        val maxBucketSize =\
    \ buckets(maxBucketIndex).size\n        val maxBucketCapacity = buckets(maxBucketIndex).capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val maxBucketIndex = buckets.map(_.indexWhere(_\
    \ == maxBucket)).max\n        val maxBucketSize = buckets(maxBucketIndex).size\n\
    \        val maxBucketCapacity = buckets(maxBucketIndex).capacity\n        val\
    \ bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val maxBucketIndex = buckets.map(_.indexWhere(_ == maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val maxBucketIndex\
    \ = buckets.map(_.indexWhere(_ == maxBucket)).max\n        val maxBucketSize =\
    \ buckets(maxBucketIndex).size\n        val maxBucketCapacity = buckets(maxBucketIndex).capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val maxBucketIndex = buckets.map(_.indexWhere(_\
    \ == maxBucket)).max\n        val maxBucketSize = buckets(maxBucketIndex).size\n\
    \        val maxBucketCapacity = buckets(maxBucketIndex).capacity\n        val\
    \ bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val maxBucketIndex = buckets.map(_.indexWhere(_ == maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val maxBucketIndex\
    \ = buckets.map(_.indexWhere(_ == maxBucket)).max\n        val maxBucketSize =\
    \ buckets(maxBucketIndex).size\n        val maxBucketCapacity = buckets(maxBucketIndex).capacity\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpygqa8boh.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = buckets.map(_.indexWhere(_\
    \ == maxBucket)).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpygqa8boh.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSize\e[0m = buckets(maxBucketIndex).size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSize is already defined as \e[33mvalue\e[0m \e[35mmaxBucketSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpygqa8boh.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m = buckets(maxBucketIndex).capacity\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpygqa8boh.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsSize\e[0m = buckets.map(_.size).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbucketsSize is already defined as \e[33mvalue\e[0m \e[35mbucketsSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpygqa8boh.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        "
  stdout: ''
  timestamp: 1659978871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = mutable.ArrayBuffer(capacity)\n        val bucketsCount =\
    \ mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCount\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.Array\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp9ehptbk.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp9ehptbk.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp9ehptbk.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp9ehptbk.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp9ehptbk.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBu"
  stdout: ''
  timestamp: 1659978871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val maxBucketSize = maxBucket * capacity\n        val maxBucketCapacity\
    \ = maxBucketSize / capacity\n        val maxBucketCapacity2 = maxBucketCapacity\
    \ * maxBucketCapacity\n        val maxBucketCapacity3 = maxBucketCapacity2 * maxBucketCapacity\n\
    \        val maxBucketCapacity4 = maxBucketCapacity3 * maxBucketCapacity\n   \
    \     val maxBucketCapacity5 = maxBucketCapacity4 * maxBucketCapacity\n      \
    \  val maxBucketCapacity6 = maxBucketCapacity5 * maxBucketCapacity\n        val\
    \ maxBucketCapacity7 = maxBucketCapacity6 * maxBucketCapacity\n        val maxBucketCapacity8\
    \ = maxBucketCapacity7 * maxBucketCapacity\n        val maxBucketCapacity9 = maxBucketCapacity8\
    \ * maxBucketCapacity\n        val maxBucketCapacity10 = maxBucketCapacity9 *\
    \ maxBucketCapacity\n        val maxBucketCapacity11 = maxBucketCapacity10 * maxBucketCapacity\n\
    \        val maxBucketCapacity12 = maxBucketCapacity11 * maxBucketCapacity\n \
    \       val maxBucketCapacity13 = maxBucketCapacity12 * maxBucketCapacity\n  \
    \      val maxBucketCapacity14 = maxBucketCapacity13 * maxBucketCapacity\n   \
    \     val maxBucketCapacity15 = maxBucketCapacity14 * maxBucketCapacity\n    \
    \    val maxBucketCapacity16 = maxBucketCapacity15 * maxBucketCapacity\n     \
    \   val maxBucketCapacity17 = maxBucketCapacity16 * maxBucketCapacity\n      \
    \  val maxBucketCapacity18 = maxBucketCapacity17 * maxBucketCapacity\n       \
    \ val maxBucketCapacity19 = maxBucketCapacity18 * maxBucketCapacity\n        val\
    \ maxBucketCapacity20 = maxBucketCapacity19 * maxBucketCapacity\n        val maxBucketCapacity21\
    \ = maxBucketCapacity20 * maxBucketCapacity\n        val maxBucketCapacity22 =\
    \ maxBucketCapacity21 * maxBucketCapacity\n        val maxBucketCapacity23 = maxBucketCapacity22\
    \ * maxBucketCapacity\n        val maxBucketCapacity24 = maxBucketCapacity23 *\
    \ maxBucketCapacity\n        val maxBucketCapacity25 = maxBucketCapacity24 * maxBucketCapacity\n\
    \        val maxBucketCapacity26 = maxBucketCapacity25 * maxBucketCapacity\n \
    \       val maxBucketCapacity27 = maxBucketCapacity26 * maxBucketCapacity\n  \
    \      val maxBucketCapacity28 = maxBucketCapacity27 * maxBucketCapacity\n   \
    \     val maxBucketCapacity29 = maxBucketCapacity28 * maxBucketCapacity\n    \
    \    val maxBucketCapacity30 = maxBucketCapacity29 * maxBucketCapacity\n     \
    \   val maxBucket\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptk7mfivx.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptk7mfivx.scala:61:5 ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- 0 until grid.length) {\n            val bucket = mutable.ArrayBuffer.empty[Long]\n\
    \            for (i <- 0 until grid[row].length) {\n                if (grid[row](i)\
    \ == 1) {\n                    bucket += i\n                }\n            }\n\
    \            buckets += bucket.sum\n        }\n        val maxBucket = buckets.max\n\
    \        val maxBucketIndex = buckets.indexOf(maxBucket)\n        val bucketsLeft\
    \ = maxBucket - capacity\n        val bucketsRight = capacity - maxBucket\n  \
    \      val bucketsLeft = bucketsLeft.toLong\n        val bucketsRight = bucketsRight.toLong\n\
    \        val bucketsLeft = bucketsLeft * bucketsRight\n        val bucketsRight\
    \ = bucketsRight * bucketsLeft\n        bucketsLeft + maxBucketIndex + bucketsRight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpej6is352.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpej6is352.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpej6is352.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft * bucketsRight\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpej6is352.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight * bucketsLeft\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpej6is352.scala:26:22 ------------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^"
  stdout: ''
  timestamp: 1659978870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ wells = mutable.HashMap[Long, List[Long]]()\n        val bucketCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Int]()\n        val\
    \ wellsCount = mutable.HashMap[Long, Int]()\n        val maxBucketCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCount = mutable.HashMap[Long, Int]()\n      \
    \  val maxWellsCount = mutable.HashMap[Long, Int]()\n        val maxWellCapacity\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCapacity = mutable.HashMap[Long, Long]()\n  \
    \      val maxWellsCapacity = mutable.HashMap[Long, Long]()\n        val maxBucketsCapacity\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCapacity = mutable.HashMap[Long, Long]()\n  \
    \      val maxWellsCapacity = mutable.HashMap[Long, Long]()\n        val maxBucketsCapacity\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCapacity = mutable.HashMap[Long, Long]()\n  \
    \      val maxWellsCapacity = mutable.HashMap[Long, Long]()\n        val maxBucketsCapacity\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCapacity = mutable.HashMap[Long, Long]()\n  \
    \      val maxWellsCapacity = mutable.HashMap[Long, Long]()\n        val maxBucketsCapacity\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCapacity = mutable.HashMap[Long, Long]()\n  \
    \      val maxWellsCapacity = mutable.HashMap[Long, Long]()\n        val maxBucketsCapacity\
    \ = mutable.HashMap[Long, Long]()\n        val maxWellsCapacity = mutable.HashMap[Long,\
    \ Long]()\n        val maxBucketsCapacity = mutable.HashMap[Long, Long]()\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkrkxfea_.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsCapacity\e[0m =\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxWellsCapacity is already defined as \e[33mvalue\e[0m \e[35mmaxWellsCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkrkxfea_.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacity is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkrkxfea_.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsCapacity\e[0m =\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxWellsCapacity is already defined as \e[33mvalue\e[0m \e[35mmaxWellsCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkrkxfea_.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacity is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] "
  stdout: ''
  timestamp: 1659978873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            wells.append(row)\n        }\n        val maxBucket = buckets.max\n\
    \        val maxWells = wells.filter(_(0) == maxBucket).length\n        if (maxBucket.equals(capacity))\
    \ {\n            return maxWells\n        }\n        val bucketsLeft = maxBucket\
    \ - capacity\n        val bucketsRight = capacity - maxBucket\n        val bucketsLeft\
    \ = bucketsLeft.toLong\n        val bucketsRight = bucketsRight.toLong\n     \
    \   val bucketsLeft = bucketsLeft % bucketsRight\n        val bucketsRight = bucketsRight\
    \ % bucketsLeft\n        val bucketsLeft = bucketsLeft / bucketsRight\n      \
    \  val bucketsRight = bucketsRight / bucketsLeft\n        val bucketsLeft = bucketsLeft.toLong\n\
    \        val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft\
    \ % bucketsRight\n        val bucketsRight = bucketsRight % bucketsLeft\n    \
    \    val bucketsLeft = bucketsLeft / bucketsRight\n        val bucketsRight =\
    \ bucketsRight / bucketsLeft\n        val bucketsLeft = bucketsLeft.toLong\n \
    \       val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft\
    \ % bucketsRight\n        val bucketsRight = bucketsRight % bucketsLeft\n    \
    \    val bucketsLeft = bucketsLeft / bucketsRight\n        val bucketsRight =\
    \ bucketsRight / bucketsLeft\n        val bucketsLeft = bucketsLeft.toLong\n \
    \       val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft\
    \ % bucketsRight\n        val bucketsRight = bucketsRight % bucketsLeft\n    \
    \    val bucketsLeft = bucketsLeft / bucketsRight\n        val bucketsRight =\
    \ bucketsRight / bucketsLeft\n        val bucketsLeft = bucketsLeft.toLong\n \
    \       val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft\
    \ % bucketsRight\n        val bucketsRight = bucketsRight % bucketsLeft\n    \
    \    val bucketsLeft = bucketsLeft / bucketsRight\n        val bucketsRight =\
    \ bucketsRight / bucketsLeft\n        val bucketsLeft = bucketsLeft.toLong\n \
    \       val bucketsRight = bucketsRight.toLong\n        val bucketsLeft = bucketsLeft\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpttk8mnv7.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpttk8mnv7.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpttk8mnv7.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft % bucketsRight\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpttk8mnv7.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight % bucketsLeft\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpttk8mnv7.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft / bucketsRight\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(_.toLong))\n        val maxBucket\
    \ = buckets.maxBy(_.length)\n        val maxBucketCapacity = maxBucket.map(_.length)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacity.indexOf(maxBucketCapacity.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \        val maxBucketCapacityIndex = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm3qhbzum.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm3qhbzum.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm3qhbzum.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm3qhbzum.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = maxBucketCapacityIndex.min(maxBucketCapacityIndex.max)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex"
  stdout: ''
  timestamp: 1659978878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacities\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumOfSquares = mutable.ArrayBuffer.empty[Long]\n \
    \       val bucketsCapacitySumOfSquaresOfSquares = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquares = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquares = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares =\
    \ mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = mutable.ArrayBuffer.empty\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn28ar995.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpn28ar995.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\e\
    [0m = mutable.ArrayBuffer.empty\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpn28ar995.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e"
  stdout: ''
  timestamp: 1659978875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- grid) {\n            val bucket = row.toSet.foldLeft(0l) { (sum, item)\
    \ => sum + item }\n            buckets += bucket\n        }\n        val maxBucket\
    \ = buckets.max\n        val maxBucketIndex = buckets.indexWhere(_ == maxBucket)\n\
    \        val bucketsCopy = buckets.toList\n        val bucketsCopyIndex = bucketsCopy.indexWhere(_\
    \ == maxBucket)\n        val bucketsCopyCount = bucketsCopy.length - bucketsCopyIndex\n\
    \        val bucketsCopyCopy = bucketsCopy.slice(bucketsCopyIndex + 1, bucketsCopyCount)\n\
    \        val bucketsCopyCopyIndex = bucketsCopyCopy.indexWhere(_ == maxBucket)\n\
    \        val bucketsCopyCopyCount = bucketsCopyCopy.length - bucketsCopyCopyIndex\n\
    \        val bucketsCopyCopyCopy = bucketsCopyCopy.slice(bucketsCopyCopyIndex\
    \ + 1, bucketsCopyCopyCount)\n        val bucketsCopyCopyCopyIndex = bucketsCopyCopyCopy.indexWhere(_\
    \ == maxBucket)\n        val bucketsCopyCopyCopyCount = bucketsCopyCopyCopy.length\
    \ - bucketsCopyCopyCopyIndex\n        val bucketsCopyCopyCopyCopy = bucketsCopyCopyCopy.slice(bucketsCopyCopyCopyIndex\
    \ + 1, bucketsCopyCopyCopyCount)\n        val bucketsCopyCopyCopyCopyIndex = bucketsCopyCopyCopyCopy.indexWhere(_\
    \ == maxBucket)\n        val bucketsCopyCopyCopyCopyCount = bucketsCopyCopyCopyCopy.length\
    \ - bucketsCopyCopyCopyCopyIndex\n        val bucketsCopyCopyCopyCopyCopy = bucketsCopyCopyCopyCopyCopy.slice(bucketsCopyCopyCopyCopyCopyIndex\
    \ + 1, bucketsCopyCopyCopyCopyCopyCount)\n        val bucketsCopyCopyCopyCopyCopyIndex\
    \ = bucketsCopyCopyCopyCopyCopyCopy.indexWhere(_ == maxBucket)\n        val bucketsCopyCopyCopyCopyCopyCount\
    \ = bucketsCopyCopyCopyCopyCopyCopy.length - bucketsCopyCopyCopyCopyCopyCopyIndex\n\
    \        val bucketsCopyCopyCopyCopyCopyCopy = bucketsCopyCopyCopyCopyCopyCopy.slice(bucketsCopyCopyCopyCopyCopyCopyIndex\
    \ + 1, bucketsCopyCopyCopyCopyCopyCopyCount)\n        val bucketsCopyCopyCopyCopyCopyCopyIndex\
    \ = bucketsCopyCopyCopyCopyCopyCopyCopy.indexWhere(_ == maxBucket)\n        val\
    \ bucketsCopyCopyCopyCopyCopyCopyCopyCount = bucketsCopyCopyCopyCopyCopyCopy\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_4tw14t.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpd_4tw14t.scala:45:42 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mbucketsCopyCopyCopyCopyCopy\e\
    [0m = bucketsCopyCopyCopyCopyCopy.slice(bucketsCopyCopyCopyCopyCopyIndex + \e\
    [31m1\e[0m, bucketsCopyCopyCopyCopyCopyCount)\n\e[31m\e[31m   |\e[0m         \
    \                                 ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35mbucketsCopyCopyCopyCopyCopy\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd_4tw14t.scala:48:46 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mbucketsCopyCopyCopyCopyCopyCopy\e\
    [0m = bucketsCopyCopyCopyCopyCopyCopy.slice(bucketsCopyCopyCopyCopyCopyCopyIndex\
    \ + \e[31m1\e[0m, bucketsCopyCopyCopyCopyCopyCopyCount)\n\e[31m\e[31m   |\e[0m\
    \                                              ^\e[0m\n\e[31m   |\e[0m       \
    \       Recursive \e[33mvalue\e[0m \e[35mbucketsCopyCopyCopyCopyCopyCopy\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_4tw14t.scala:49:51\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCopyCopyCopyCopyCopyCopyIndex\e[0m = bucketsCopyCopyCopyCopyCopyCopyCopy.indexWhere(_\
    \ == maxBucket)\n\e[31m\e[31m   |\e[0m                                       \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                   Not found: bucketsCopyCopyCopyCopyCopyCopyCopy\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type"
  stdout: ''
  timestamp: 1659978876
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        val result = mutable.HashMap[Long,\
    \ Long]()\n        grid.foreach(row => {\n            row.foreach(well => {\n\
    \                wells += (well -> 1l)\n            })\n        })\n        grid.foreach(row\
    \ => {\n            row.foreach(well => {\n                buckets += (well ->\
    \ 0l)\n            })\n        })\n        buckets.foreach(bucket => {\n     \
    \       bucket.foreach(bucket => {\n                bucket.foreach(bucket => {\n\
    \                    bucket.foreach(bucket => {\n                        bucket.foreach(bucket\
    \ => {\n                            bucket.foreach(bucket => {\n             \
    \                   bucket.foreach(bucket => {\n                             \
    \       bucket.foreach(bucket => {\n                                        bucket.foreach(bucket\
    \ => {\n                                            bucket.foreach(bucket => {\n\
    \                                                bucket.foreach(bucket => {\n\
    \                                                    bucket.foreach(bucket =>\
    \ {\n                                                        bucket.foreach(bucket\
    \ => {\n                                                            bucket.foreach(bucket\
    \ => {\n                                                                bucket.foreach(bucket\
    \ => {\n                                                                    bucket.foreach(bucket\
    \ => {\n                                                                     \
    \   bucket.foreach(bucket => {\n                                             \
    \                               bucket.foreach(bucket => {\n                 \
    \                                                               bucket.foreach(bucket\
    \ => {\n                                                                     \
    \               bucket.foreach(bucket => {\n                                 \
    \                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                       bucket.foreach(bucket => {\n                         \
    \                                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                               bucket.foreach(bucket => {\n                 \
    \                                                                            \
    \           bucket.foreach(bucket => {\n                                     \
    \                                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                           bucket.foreach(bucket => {\n     \
    \                                                                            \
    \                                   bucket.foreach(bucket => {\n             \
    \                                                                            \
    \                               bucket.foreach(bucket => {\n                 \
    \                                                                            \
    \                               bucket.foreach(bucket => {\n                 \
    \                                                                            \
    \                                   bucket.foreach(bucket => {\n             \
    \                                                                            \
    \                                           bucket.foreach(bucket => {\n     \
    \                                                                            \
    \                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                           bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                            \
    \   bucket.foreach(bucket => {\n                                             \
    \                                                                            \
    \                               bucket.foreach(bucket => {\n                 \
    \                                                                            \
    \                                                               bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                            \
    \               bucket.foreach(bucket => {\n                                 \
    \                                                                            \
    \                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                            \
    \                       bucket.foreach(bucket => {\n                         \
    \                                                                            \
    \                                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                            \
    \                               bucket.foreach(bucket => {\n                 \
    \                                                                            \
    \                                                                            \
    \           bucket.foreach(bucket => {\n                                     \
    \                                                                            \
    \                                                                       bucket.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                            \
    \                                           bucket.foreach(bucket => {\n     \
    \                                                                            \
    \                                                                            \
    \                                   \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyzv3zj95.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpyzv3zj95.scala:96:0 ----------------------------\e[0m\e[0m\n\e[31m96\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyzv3zj95.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyzv3zj95.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpyzv3zj95.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659978871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacitySumCountMax = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n     \
    \   val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n   \
    \     val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n \
    \       val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySumCountMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacitySum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpholmx81e.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxIndex is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsCapacitySumCountMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpholmx81e.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxIndex\e[0m = mutable.Array"
  stdout: ''
  timestamp: 1659978832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 0) capacity else\
    \ 1).toList)\n        val maxBucket = buckets.map(_.max).max\n        val bucketsMap\
    \ = buckets.map(x => x.map(y => if (y == 0) capacity else y).toMap)\n        val\
    \ maxBucketMap = bucketsMap.map(_.max).max\n        val maxBucketMap2 = bucketsMap.map(x\
    \ => x.map(y => if (y == 0) capacity else y)).max\n        val maxBucketMap3 =\
    \ bucketsMap.map(x => x.map(y => if (y == 0) capacity else y)).max\n        val\
    \ maxBucketMap4 = bucketsMap.map(x => x.map(y => if (y == 0) capacity else y)).max\n\
    \        val maxBucketMap5 = bucketsMap.map(x => x.map(y => if (y == 0) capacity\
    \ else y)).max\n        val maxBucketMap6 = bucketsMap.map(x => x.map(y => if\
    \ (y == 0) capacity else y)).max\n        val maxBucketMap7 = bucketsMap.map(x\
    \ => x.map(y => if (y == 0) capacity else y)).max\n        val maxBucketMap8 =\
    \ bucketsMap.map(x => x.map(y => if (y == 0) capacity else y)).max\n        val\
    \ maxBucketMap9 = bucketsMap.map(x => x.map(y => if (y == 0) capacity else y)).max\n\
    \        val maxBucketMap10 = bucketsMap.map(x => x.map(y => if (y == 0) capacity\
    \ else y)).max\n        val maxBucketMap11 = bucketsMap.map(x => x.map(y => if\
    \ (y == 0) capacity else y)).max\n        val maxBucketMap12 = bucketsMap.map(x\
    \ => x.map(y => if (y == 0) capacity else y)).max\n        val maxBucketMap13\
    \ = bucketsMap.map(x => x.map(y => if (y == 0) capacity else y)).max\n       \
    \ val maxBucketMap14 = bucketsMap.map(x => x.map(y => if (y == 0) capacity else\
    \ y)).max\n        val maxBucketMap15 = bucketsMap.map(x => x.map(y => if (y ==\
    \ 0) capacity else y)).max\n        val maxBucketMap16 = bucketsMap.map(x => x.map(y\
    \ => if (y == 0) capacity else y)).max\n        val maxBucketMap17 = bucketsMap.map(x\
    \ => x.map(y => if (y == 0) capacity else y)).max\n        val maxBucketMap18\
    \ = bucketsMap.map(x => x.map(y => if (y == 0) capacity else y)).max\n       \
    \ val maxBucketMap19 = bucketsMap.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr75jtzvg.scala:47:44 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketMap19\e[0m = bucketsMap.map(\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpr75jtzvg.scala:28:87\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mbucketsMap\e[0m = buckets.map(\e[36mx\e[0m => x.map(\e\
    [36my\e[0m => \e[33mif\e[0m (y == \e[31m0\e[0m) capacity \e[33melse\e[0m y).toMap)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                 Cannot prove that Long <:< (K, V)\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m                                       where:    K is a type variable\n\
    \e[31m   |\e[0m                                                 V is a type variable\n\
    \e[31m   |\e[0m                                       .\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpr75jtzvg.scala:29:47 -----------------------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketMap\e[0m = bucketsMap.map(_.max).max\n\
    \e[31m\e[31m   |\e[0m                                               ^\e[0m\n\e\
    [31m   |\e[0mambiguous given instances of type Ordering[B] found for parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m.\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.Tuple2[\e\
    [35mT1\e[0m, \e[35mT2\e[0m](\n\e[31m   |\e[0m      /* ambiguous: both \e[33mobject\e\
    [0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type\
    \ Ordering[T1] */\n\e[31m   |\e[0m        summon[Ordering[T1]]\n\e[31m   |\e[0m\
    \    , \n\e[31m   |\e[0m      /* ambiguous: both \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigDecim"
  stdout: ''
  timestamp: 1659978886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.map(_.max).max\n        val maxBucketIndex\
    \ = buckets.map(_.indexOf(maxBucket)).max\n        val bucketsCount = buckets.map(_.length).sum\n\
    \        val bucketsIndexes = buckets.map(_.indexOf(maxBucket))\n        val bucketsMax\
    \ = buckets.map(_.max).max\n        val bucketsMaxIndex = buckets.map(_.indexOf(bucketsMax)).max\n\
    \        val bucketsMaxCount = buckets.map(_.length).sum\n        val bucketsMaxIndexes\
    \ = buckets.map(_.indexOf(bucketsMax))\n        val bucketsMin = buckets.map(_.min).min\n\
    \        val bucketsMinIndex = buckets.map(_.indexOf(bucketsMin)).min\n      \
    \  val bucketsMinCount = buckets.map(_.length).sum\n        val bucketsMinIndexes\
    \ = buckets.map(_.indexOf(bucketsMin))\n        val bucketsSum = buckets.map(_.sum).sum\n\
    \        val bucketsSumIndex = buckets.map(_.indexOf(bucketsSum)).sum\n      \
    \  val bucketsSumCount = buckets.map(_.length).sum\n        val bucketsSumIndexes\
    \ = buckets.map(_.indexOf(bucketsSum))\n        val bucketsProduct = buckets.map(_.product).sum\n\
    \        val bucketsProductIndex = buckets.map(_.indexOf(bucketsProduct)).sum\n\
    \        val bucketsProductCount = buckets.map(_.length).sum\n        val bucketsProductIndexes\
    \ = buckets.map(_.indexOf(bucketsProduct))\n        val bucketsProductMax = buckets.map(_.max).max\n\
    \        val bucketsProductMaxIndex = buckets.map(_.indexOf(bucketsProductMax)).max\n\
    \        val bucketsProductMaxCount = buckets.map(_.length).sum\n        val bucketsProductMaxIndexes\
    \ = buckets.map(_.indexOf(bucketsProductMax))\n        val bucketsProductMin =\
    \ buckets.map(_.min).min\n        val bucketsProductMinIndex = buckets.map(_.indexOf(bucketsProductMin)).min\n\
    \        val bucketsProductMinCount = buckets.map(_.length).sum\n        val bucketsProductMinIndexes\
    \ = buckets.map(_.indexOf(bucketsProductMin))\n        val bucketsProductSum =\
    \ buckets.map(_.sum).sum\n        val bucketsProductSumIndex = buckets.map(_.indexOf(bucketsProductSum)).sum\n\
    \        val bucketsProductSumCount = buckets.map(_.length).sum\n\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpen36jez7.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- 0 until grid.length) {\n            val bucket = mutable.ArrayBuffer.empty[Long]\n\
    \            for (i <- 0 until grid[row].length) {\n                if (grid[row](i)\
    \ == 1) {\n                    bucket += i\n                }\n            }\n\
    \            buckets += bucket.sum\n        }\n        val maxBucket = buckets.max\n\
    \        val numBuckets = buckets.length\n        val numWells = grid.length\n\
    \        val numWellsLeft = numBuckets - numWells\n        val numBucketsLeft\
    \ = numBuckets - maxBucket\n        val numWellsLeft = numBucketsLeft - numWells\n\
    \        val numBucketsLeft = numBucketsLeft - maxBucket\n        val numWellsLeft\
    \ = numBucketsLeft - numWells\n        val numBucketsLeft = numBucketsLeft - maxBucket\n\
    \        val numWellsLeft = numBucketsLeft - numWells\n        val numBucketsLeft\
    \ = numBucketsLeft - maxBucket\n        val numWellsLeft = numBucketsLeft - numWells\n\
    \        val numBucketsLeft = numBucketsLeft - maxBucket\n        val numWellsLeft\
    \ = numBucketsLeft - numWells\n        val numBucketsLeft = numBucketsLeft - maxBucket\n\
    \        val numWellsLeft = numBucketsLeft - numWells\n        val numBucketsLeft\
    \ = numBucketsLeft - maxBucket\n        val numWellsLeft = numBucketsLeft - numWells\n\
    \        val numBucketsLeft = numBucketsLeft - maxBucket\n        val numWellsLeft\
    \ = numBucketsLeft - numWells\n        val numBucketsLeft = numBucketsLeft - maxBucket\n\
    \        val numWellsLeft = numBucketsLeft - numWells\n        val numBucketsLeft\
    \ = numBucketsLeft - maxBucket\n        val numWellsLeft = numBucketsLeft - numWells\n\
    \        val numBucketsLeft = numBucketsLeft - maxBucket\n        val numWellsLeft\
    \ = numBucketsLeft - numWells\n        val numBucketsLeft = numBucketsLeft - maxBucket\n\
    \        val numWellsLeft = numBucketsLeft - numWells\n        val numBucketsLeft\
    \ = numBucketsLeft - maxBucket\n        val numWellsLeft = numBucketsLeft - numWells\n\
    \        val numBucketsLeft = numBucketsLeft - maxBucket\n        val numWellsLeft\
    \ = numBucketsLeft - numWells\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpffnt41_6.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mnumWellsLeft\e[0m = numBucketsLeft\
    \ - numWells\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumWellsLeft is already defined as \e[33mvalue\e[0m \e[35mnumWellsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpffnt41_6.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mnumBucketsLeft\e[0m = numBucketsLeft\
    \ - maxBucket\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumBucketsLeft is already defined as \e[33mvalue\e[0m \e[35mnumBucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpffnt41_6.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mnumWellsLeft\e[0m = numBucketsLeft -\
    \ numWells\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumWellsLeft is already defined as \e[33mvalue\e[0m \e[35mnumWellsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpffnt41_6.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mnumBucketsLeft\e[0m = numBucketsLeft\
    \ - maxBucket\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumBucketsLeft is already defined as \e[33mvalue\e[0m \e[35mnumBucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpffnt41_6.scala:45:12 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mnumWellsLeft\e[0m = numBucketsLeft -\
    \ numWells\n\e"
  stdout: ''
  timestamp: 1659978880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).toList\n        val maxBucket\
    \ = buckets.maxBy(_.size).map(_.size).getOrElse(0)\n        val maxBucketSize\
    \ = maxBucket * capacity\n        val maxBucketCapacity = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).getOrElse(0)\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).getOrElse(0)\n        val bucketsCapacityDiff = bucketsCapacity\
    \ - maxBucketCapacity\n        val bucketsSizeDiff = bucketsSize - maxBucketSize\n\
    \        val bucketsDiff = bucketsCapacityDiff - bucketsSizeDiff\n        val\
    \ bucketsDiffDiff = bucketsDiff - bucketsCapacityDiff\n        val bucketsDiffDiffDiff\
    \ = bucketsDiffDiff - bucketsSizeDiff\n        val bucketsDiffDiffDiffDiff = bucketsDiffDiffDiff\
    \ - bucketsCapacityDiff\n        val bucketsDiffDiffDiffDiffDiff = bucketsDiffDiffDiffDiff\
    \ - bucketsCapacityDiff\n        bucketsDiffDiffDiffDiffDiff\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwjvgkynt.scala:27:52 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxBucket\e[0m = buckets.maxBy(_.size).map(_.size).getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m                                      value\
    \ size is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwjvgkynt.scala:30:46\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsSize\e[0m = buckets.map(_.size).getOrElse(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value getOrElse is not a member of List[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwjvgkynt.scala:31:44 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value capacity is not a member\
    \ of Set[Long]\n3 errors found\n"
  stdout: ''
  timestamp: 1659978880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).getOrElse(buckets.maxBy(_.size).last)\n        val maxBucketSize\
    \ = maxBucket.size\n        val maxBucketCapacity = maxBucketCapacity.size\n \
    \       val bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsCapacity = bucket\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplsduonem.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplsduonem.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplsduonem.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplsduonem.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplsduonem.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbu"
  stdout: ''
  timestamp: 1659978880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- 0 until grid.length) {\n            for (col <- 0 until grid[0].length)\
    \ {\n                if (grid[row][col] == 1l) {\n                    buckets\
    \ += capacity\n                }\n            }\n        }\n        buckets.max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7b0rzxgf.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmp7b0rzxgf.scala:28:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m (col <- \e[31m0\e[0m until\
    \ grid[\e[31m0\e[0m].length) {\n\e[31m\e[31m   |\e[0m                        \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mtrait\e[0m \e[35mLinearSeqOps\e[0m does not take type parameters\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7b0rzxgf.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (grid[\e[35mrow\e[0m][\e\
    [35mcol\e[0m] == \e[31m1l\e[0m) {\n\e[31m\e[31m   |\e[0m                     \
    \         ^^^\e[0m\n\e[31m   |\e[0m                              Not found: type\
    \ col\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7b0rzxgf.scala:29:25\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e\
    [0m (grid[\e[35mrow\e[0m][\e[35mcol\e[0m] == \e[31m1l\e[0m) {\n\e[31m\e[31m  \
    \ |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m                   \
    \      Not found: type row\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketIndex = buckets.indexWhere(_.size\
    \ == maxBucket)\n        val maxBucketSize = buckets(maxBucketIndex).size\n  \
    \      val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketCapacityIndex\
    \ = buckets.indexWhere(_.size == maxBucketCapacity)\n        val maxBucketCapacitySize\
    \ = buckets(maxBucketCapacityIndex).size\n        val maxBucketCapacityCapacity\
    \ = maxBucketCapacitySize * capacity\n        val maxBucketCapacityCapacityIndex\
    \ = buckets.indexWhere(_.size == maxBucketCapacityCapacity)\n        val maxBucketCapacityCapacitySize\
    \ = buckets(maxBucketCapacityCapacityIndex).size\n        val maxBucketCapacityCapacityCapacity\
    \ = maxBucketCapacityCapacitySize * capacity\n        val maxBucketCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(_.size == maxBucketCapacityCapacityCapacity)\n        val\
    \ maxBucketCapacityCapacityCapacitySize = buckets(maxBucketCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityIndex = buckets.indexWhere(_.size\
    \ == maxBucketCapacityCapacityCapacityCapacity)\n        val maxBucketCapacityCapacityCapacityCapacitySize\
    \ = buckets(maxBucketCapacityCapacityCapacityCapacityIndex).size\n        val\
    \ maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(_.size == maxBucketCapacityCapacityCapacityCapacityCapacity)\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacitySize = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(_.size == maxBucketCapacityCapacityCapacityCapacityCapacityCapacity)\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacitySize = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(_.size == maxBucketCapacityCapacityCapacityCapacityCapacityCapacity)\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacitySize = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityCapacityIndex).size\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacity\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp113qkcf3.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp113qkcf3.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacity\e[0m = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityCapacityCapacityCapacityCapacity is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityCapacityCapacityCapacityCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp113qkcf3.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex\e\
    [0m = buckets.indexWhere(_.size == maxBucketCapacityCapacityCapacityCapacityCapacityCapacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp113qkcf3.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacitySize\e\
    [0m = buckets(maxBucketCapacityCapacityCapacityCapacityCapacityCapacityIndex).size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.map(_.max).max\n        val maxBucketIndex\
    \ = buckets.map(_.indexOf(maxBucket)).max\n        val maxBucketSize = buckets(maxBucketIndex).size\n\
    \        val maxBucketCapacity = buckets(maxBucketIndex).capacity\n        val\
    \ maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n        val maxBucketSize\
    \ = buckets(maxBucketIndex).size\n        val maxBucketCapacity = buckets(maxBucketIndex).capacity\n\
    \        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n        val\
    \ maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \        val maxBucketSize = buckets(maxBucketIndex).size\n        val maxBucketCapacity\
    \ = buckets(maxBucketIndex).capacity\n        val maxBucketIndex = buckets.map(_.indexOf(maxBucket)).max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmb1kuqgm.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = buckets.map(_.indexOf(maxBucket)).max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmb1kuqgm.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSize\e[0m = buckets(maxBucketIndex).size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSize is already defined as \e[33mvalue\e[0m \e[35mmaxBucketSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmb1kuqgm.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m = buckets(maxBucketIndex).capacity\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmb1kuqgm.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = buckets.map(_.indexOf(maxBucket)).max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmb1kuqgm.scala:35:12 ---------------------------\e[0m\e["
  stdout: ''
  timestamp: 1659978882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ wells = mutable.HashMap[Long, List[Long]]()\n        val result = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacity = capacity\n        val maxBuckets = math.max(grid.map(_.length).max,\n\
    \                                   grid.map(_.head.length).max)\n        grid.foreach\
    \ { row =>\n            row.foreach { well =>\n                wells(well) match\
    \ {\n                    case Some(bucket) =>\n                        buckets(bucket)\
    \ += 1\n                    case None =>\n                        buckets(maxBuckets)\
    \ += 1\n                }\n            }\n        }\n        buckets.foreach {\
    \ bucket =>\n            val bucketCapacity = bucket.toLong\n            if (bucketCapacity\
    \ > maxCapacity) {\n                maxCapacity = bucketCapacity\n           \
    \     maxBuckets = bucket\n            }\n        }\n        buckets.foreach {\
    \ bucket =>\n            val bucketCapacity = bucket.toLong\n            if (bucketCapacity\
    \ < maxCapacity) {\n                bucketCapacity -= 1\n                buckets(bucketCapacity)\
    \ -= 1\n            }\n        }\n        buckets.foreach { bucket =>\n      \
    \      val bucketCapacity = bucket.toLong\n            if (bucketCapacity < maxCapacity)\
    \ {\n                bucketCapacity += 1\n                buckets(bucketCapacity)\
    \ += 1\n            }\n        }\n        buckets.foreach { bucket =>\n      \
    \      val bucketCapacity = bucket.toLong\n            if (bucketCapacity < maxCapacity)\
    \ {\n                bucketCapacity -= 1\n                buckets(bucketCapacity)\
    \ -= 1\n            }\n        }\n        buckets.foreach { bucket =>\n      \
    \      val bucketCapacity = bucket.toLong\n            if (bucketCapacity < maxCapacity)\
    \ {\n                bucketCapacity += 1\n                buckets(bucketCapacity)\
    \ += 1\n            }\n        }\n        buckets.foreach { bucket =>\n      \
    \      val bucketCapacity = bucket.toLong\n            if (bucketCapacity < maxCapacity)\
    \ {\n                bucketCapacity -= 1\n                buckets(bucketCapacity)\
    \ -= 1\n            }\n        }\n        buckets.foreach { bucket =>\n      \
    \      val bucketCapacity = bucket.toLong\n            if (bucketCapacity < maxCapacity)\
    \ {\n                bucketCapacity += 1\n                buckets(bucketCapacity)\
    \ += 1\n            }\n        }\n        buckets.foreach { bucket =>\n      \
    \      val bucketCapacity = bucket.toLong\n            if (bucketCapacity < maxCapacity)\
    \ {\n                bucketCapacity -= 1\n                buckets(bucketCapacity)\
    \ -= 1\n            }\n        }\n        buckets.foreach { bucket =>\n      \
    \      val bucketCapacity = bucket.toLong\n            if (bucketCapacity < max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5elc9r5e.scala:101:4 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5elc9r5e.scala:111:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m111 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5elc9r5e.scala:26:22 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5elc9r5e.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5elc9r5e.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp5elc9r5e.scala:31:51 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                                   grid.map(_.head.length).max)\n\e[31m\e[31m\
    \   |\e[0m                                            ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    value length is not a member of\
    \ Long\n\e[31m\e[31m-- Error: /tmp/tmp5elc9r5e.scala:31:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                                "
  stdout: ''
  timestamp: 1659978882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        for\
    \ (row <- 0 until grid.length) {\n            val bucket = mutable.ArrayBuffer.empty[Long]\n\
    \            for (i <- 0 until grid[row].length) {\n                if (grid[row](i)\
    \ == 1) {\n                    bucket += i\n                }\n            }\n\
    \            buckets += bucket.sum\n        }\n        val maxBucket = buckets.max\n\
    \        val maxBucketIndex = buckets.indexWhere(_ == maxBucket)\n        val\
    \ maxBucketSize = buckets(maxBucketIndex)\n        val maxBucketCapacity = maxBucketSize\
    \ * capacity\n        val maxBucketIndex = maxBucketIndex + 1\n        val maxBucketSize\
    \ = maxBucketSize - 1\n        val maxBucketCapacity = maxBucketCapacity - 1\n\
    \        if (maxBucketSize == 0) {\n            return 0\n        }\n        if\
    \ (maxBucketCapacity == 0) {\n            return 1\n        }\n        val maxBucketIndex\
    \ = maxBucketIndex + 1\n        val maxBucketSize = maxBucketSize - 1\n      \
    \  val maxBucketCapacity = maxBucketCapacity - 1\n        if (maxBucketSize ==\
    \ 0) {\n            return 0\n        }\n        if (maxBucketCapacity == 0) {\n\
    \            return 1\n        }\n        val maxBucketIndex = maxBucketIndex\
    \ + 1\n        val maxBucketSize = maxBucketSize - 1\n        val maxBucketCapacity\
    \ = maxBucketCapacity - 1\n        if (maxBucketSize == 0) {\n            return\
    \ 0\n        }\n        if (maxBucketCapacity == 0) {\n            return 1\n\
    \        }\n        val maxBucketIndex = maxBucketIndex + 1\n        val maxBucketSize\
    \ = maxBucketSize - 1\n        val maxBucketCapacity = maxBucketCapacity - 1\n\
    \        if (maxBucketSize == 0) {\n            return 0\n        }\n        if\
    \ (maxBucketCapacity == 0) {\n            return 1\n        }\n        val maxBucketIndex\
    \ = maxBucketIndex + 1\n        val maxBucketSize = maxBucketSize - 1\n      \
    \  val maxBucketCapacity = maxBucketCapacity - 1\n        if (maxBucketSize ==\
    \ 0) {\n            return 0\n        }\n        if (maxBucketCapacity == 0) {\n\
    \            return 1\n        }\n        val maxBucketIndex = maxBucketIndex\
    \ + 1\n        val maxBucketSize = maxBucketSize - 1\n        val maxBucketCapacity\
    \ = maxBucketCapacity - 1\n        if (maxBucketSize == 0) {\n            return\
    \ 0\n        }\n        if (maxBucketCapacity == 0) {\n            return 1\n\
    \        }\n        val maxBucketIndex = maxBucketIndex + 1\n        val maxBucketSize\
    \ = maxBucketSize - 1\n        val maxBucketCapacity = maxBucketCapacity - 1\n\
    \        if (maxBucketSize == 0) {\n            return 0\n        }\n        if\
    \ (maxBucketCapacity == 0) {\n            return 1\n        }\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpuhaqp9nw.scala:103:11 --------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhaqp9nw.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = maxBucketIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuhaqp9nw.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSize\e[0m = maxBucketSize -\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSize is already defined as \e[33mvalue\e[0m \e[35mmaxBucketSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuhaqp9nw.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m = maxBucketCapacity\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuhaqp9nw.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketIndex\e[0m = maxBucketIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketIndex is already defined as \e[33mvalue\e[0m \e[35mmaxBucketIndex"
  stdout: ''
  timestamp: 1659978880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).flatten\n        val maxBucket\
    \ = buckets.max\n        val bucketsCount = buckets.count\n        val bucketsSum\
    \ = buckets.sum\n        val bucketsSumOfSquare = buckets.map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBuckets = buckets.map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBuckets = buckets.map(_.toDouble).map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBuckets = buckets.map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBuckets = buckets.map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets =\
    \ buckets.map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).map(_.toDouble).sum\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = buckets.map(_.to\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpffzebsp2.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpffzebsp2.scala:39:128\
    \ -----------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\e\
    [0m = buckets.map(_.to\n\e[31m\e[31m   |\e[0m                                \
    \                                                                            \
    \                  ^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mto\e[0m in \e[33mtrait\e[0m \e[35mIntegralProxy\e\
    [0m with types\n\e[31m   |\e[0m (end: Long, step: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0m (end: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0mboth match expected type B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpffzebsp2.scala:40:5 ---------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        grid.foreach(row => {\n     \
    \       row.foreach(well => {\n                wells += (well -> 1l)\n       \
    \         buckets += (well -> 0l)\n            })\n        })\n        val maxBuckets\
    \ = buckets.maxBy(_._2)._1\n        val maxWells = wells.maxBy(_._2)._1\n    \
    \    val maxCapacity = capacity - maxBuckets\n        val maxWellsCount = wells.maxBy(_._1)._1\n\
    \        val maxBucketsCount = buckets.maxBy(_._1)._1\n        val maxCapacityCount\
    \ = capacity - maxBucketsCount\n        val maxBucketsCount2 = maxBucketsCount.toLong\n\
    \        val maxWellsCount2 = maxWellsCount.toLong\n        val maxCapacityCount2\
    \ = maxCapacityCount.toLong\n        val maxBucketsCount3 = maxBucketsCount2.toLong\n\
    \        val maxWellsCount3 = maxWellsCount2.toLong\n        val maxCapacityCount3\
    \ = maxCapacityCount2.toLong\n        val maxBucketsCount4 = maxBucketsCount3.toLong\n\
    \        val maxWellsCount4 = maxWellsCount3.toLong\n        val maxCapacityCount4\
    \ = maxCapacityCount3.toLong\n        val maxBucketsCount5 = maxBucketsCount4.toLong\n\
    \        val maxWellsCount5 = maxWellsCount4.toLong\n        val maxCapacityCount5\
    \ = maxCapacityCount4.toLong\n        val maxBucketsCount6 = maxBucketsCount5.toLong\n\
    \        val maxWellsCount6 = maxWellsCount5.toLong\n        val maxCapacityCount6\
    \ = maxCapacityCount5.toLong\n        val maxBucketsCount7 = maxBucketsCount6.toLong\n\
    \        val maxWellsCount7 = maxWellsCount6.toLong\n        val maxCapacityCount7\
    \ = maxCapacityCount6.toLong\n        val maxBucketsCount8 = maxBucketsCount7.toLong\n\
    \        val maxWellsCount8 = maxWellsCount7.toLong\n        val maxCapacityCount8\
    \ = maxCapacityCount7.toLong\n        val maxBucketsCount9 = maxBucketsCount8.toLong\n\
    \        val maxWellsCount9 = maxWellsCount8.toLong\n        val maxCapacityCount9\
    \ = maxCapacityCount8.toLong\n        val maxBucketsCount10 = maxBucketsCount9.toLong\n\
    \        val maxWellsCount10 = max\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5yi8m063.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5yi8m063.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yi8m063.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, Long]()\n        grid.foreach(row => {\n     \
    \       row.foreach(well => {\n                if (well != 0l) {\n           \
    \         buckets += (well -> buckets(well) + 1)\n                    wells +=\
    \ (well -> wells(well) + 1)\n                }\n            })\n        })\n \
    \       val maxBucket = buckets.maxBy(_._2)\n        val maxWell = wells.maxBy(_._2)\n\
    \        buckets.filter(_._2 == maxBucket).map(x => x._1).sum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1dw__tob.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1dw__tob.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Int]()\n        val bucketsCounts = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCounts_ = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCounts_1 = mutable.HashMap[Long, Int]()\n        val bucketsCounts_2\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCounts_3 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCounts_4 = mutable.HashMap[Long, Int]()\n       \
    \ val bucketsCounts_5 = mutable.HashMap[Long, Int]()\n        val bucketsCounts_6\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCounts_7 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCounts_8 = mutable.HashMap[Long, Int]()\n       \
    \ val bucketsCounts_9 = mutable.HashMap[Long, Int]()\n        val bucketsCounts_10\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCounts_11 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCounts_12 = mutable.HashMap[Long, Int]()\n      \
    \  val bucketsCounts_13 = mutable.HashMap[Long, Int]()\n        val bucketsCounts_14\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCounts_15 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCounts_16 = mutable.HashMap[Long, Int]()\n      \
    \  val bucketsCounts_17 = mutable.HashMap[Long, Int]()\n        val bucketsCounts_18\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCounts_19 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCounts_20 = mutable.HashMap[Long, Int]()\n      \
    \  val bucketsCounts_21 = mutable.HashMap[Long, Int]()\n        val bucketsCounts_22\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCounts_23 = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCounts_24 = mutable.HashMap[Long, Int]()\n      \
    \  val bucketsCounts_25 = mutable.HashMap[Long, Int]()\n        val bucketsCounts_26\
    \ = mutable.HashMap[\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7j97txrg.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp7j97txrg.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7j97txrg.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7j97txrg.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7j97txrg.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7j97txrg.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts_1\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\
    \e[31m\e[31m   |"
  stdout: ''
  timestamp: 1659978885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).toList\n        val bucketsSet\
    \ = buckets.flatten\n        val bucketsSetSet = bucketsSet.map(_.toSet)\n   \
    \     val bucketsSetSetSet = bucketsSetSet.map(_.toSet)\n        val bucketsSetSetSetSet\
    \ = bucketsSetSetSet.map(_.toSet)\n        val bucketsSetSetSetSetSet = bucketsSetSetSetSet.map(_.toSet)\n\
    \        val bucketsSetSetSetSetSet = bucketsSetSetSetSetSet.map(_.toSet)\n  \
    \      val bucketsSetSetSetSetSetSet = bucketsSetSetSetSetSet.toSet\n        val\
    \ bucketsSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSet.toSet\n        val\
    \ bucketsSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSet.toSet\n     \
    \   val bucketsSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val bucketsSetSetSetSetSetSetSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSetSetSetSetSetSetSetSet.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqg0ni_s7.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsSetSetSetSetSet\e\
    [0m = bucketsSetSetSetSetSet.map(_.toSet)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqg0ni_s7.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mbucketsSetSetSetSetSetSetSetSetSet\e\
    [0m = bucketsSetSetSetSetSetSetSetSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSetSetSetSetSetSetSetSetSet is already defined as \e\
    [33mvalue\e[0m \e[35mbucketsSetSetSetSetSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqg0ni_s7.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSetSetSetSetSetSetSetSetSetSetSet\e[0m = bucketsSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSetSetSetSetSetSetSetSetSetSetSet is already defined\
    \ as \e[33mvalue\e[0m \e[35mbucketsSetSetSetSetSetSetSetSetSetSetSet\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqg0ni_s7.scala:42:12 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsSetSetSetSetSetSetSetSetSetSetSetSet\e\
    [0m = bucketsSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 0) capacity else\
    \ 1))\n        val maxBucket = buckets.map(_.max).max\n        val maxBucketIndex\
    \ = buckets.map(_.max).zipWithIndex.maxBy(_._1)._2\n        val bucketsCount =\
    \ buckets.map(_.size).sum\n        val bucketsCapacity = buckets.map(_.capacity).sum\n\
    \        val bucketsMax = buckets.map(_.max).sum\n        val bucketsMin = buckets.map(_.min).sum\n\
    \        val bucketsSum = buckets.map(_.sum).sum\n        val bucketsSumOfSquares\
    \ = buckets.map(_.sumOfSquares).sum\n        val bucketsSumOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquares).sum\n        val bucketsSumOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquares).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquares).sum\n        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n    \
    \    val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = buckets.map(_.sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares).sum\n\
    \        val bucketsSumOfSqu\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjel4nhw0.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjel4nhw0.scala:30:44\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\e[31m\e[31m   |\e[0m\
    \                                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                          value capacity is not a member of List[Long]\n\e[31m\e\
    [31m-- Error: /tmp/tmpjel4nhw0.scala:30:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mFloatIsFractional\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mCharIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type\
    \ Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjel4nhw0.scala:34:48\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsSumOfSquares\e[0m = buckets.map(_.sumOfSquares).sum\n\e[31m\e[31m \
    \  |\e[0m                                              ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        value sumOfSquares is not a member of List[Long]\n\
    \e[31m\e[31m-- Error: /tmp/tmpjel4nhw0.scala:34:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquares\e[0m\
    \ = buckets.map(_.sumOfSquares).sum\n\e[31m\e[31m   |\e[0m                   \
    \                                              ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e\
    [0m \e[35msum\e"
  stdout: ''
  timestamp: 1659978889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val maxBucketCapacity\
    \ = maxBucketSize / bucketsSize\n        val maxBucketCapacity2 = maxBucketCapacity\
    \ * maxBucketCapacity\n        val maxBucketCapacity3 = maxBucketCapacity2 * maxBucketCapacity\n\
    \        val maxBucketCapacity4 = maxBucketCapacity3 * maxBucketCapacity\n   \
    \     val maxBucketCapacity5 = maxBucketCapacity4 * maxBucketCapacity\n      \
    \  val maxBucketCapacity6 = maxBucketCapacity5 * maxBucketCapacity\n        val\
    \ maxBucketCapacity7 = maxBucketCapacity6 * maxBucketCapacity\n        val maxBucketCapacity8\
    \ = maxBucketCapacity7 * maxBucketCapacity\n        val maxBucketCapacity9 = maxBucketCapacity8\
    \ * maxBucketCapacity\n        val maxBucketCapacity10 = maxBucketCapacity9 *\
    \ maxBucketCapacity\n        val maxBucketCapacity11 = maxBucketCapacity10 * maxBucketCapacity\n\
    \        val maxBucketCapacity12 = maxBucketCapacity11 * maxBucketCapacity\n \
    \       val maxBucketCapacity13 = maxBucketCapacity12 * maxBucketCapacity\n  \
    \      val maxBucketCapacity14 = maxBucketCapacity13 * maxBucketCapacity\n   \
    \     val maxBucketCapacity15 = maxBucketCapacity14 * maxBucketCapacity\n    \
    \    val maxBucketCapacity16 = maxBucketCapacity15 * maxBucketCapacity\n     \
    \   val maxBucketCapacity17 = maxBucketCapacity16 * maxBucketCapacity\n      \
    \  val maxBucketCapacity18 = maxBucketCapacity17 * maxBucketCapacity\n       \
    \ val maxBucketCapacity19 = maxBucketCapacity18 * maxBucketCapacity\n        val\
    \ maxBucketCapacity20 = maxBucketCapacity19 * maxBucketCapacity\n        val maxBucketCapacity21\
    \ = maxBucketCapacity20 * maxBucketCapacity\n        val maxBucketCapacity22 =\
    \ maxBucketCapacity21 * maxBucketCapacity\n        val maxBucketCapacity23 = maxBucketCapacity22\
    \ * maxBucketCapacity\n        val maxBucketCapacity24 = maxBucketCapacity23 *\
    \ maxBucketCapacity\n        val maxBucketCapacity25 = maxBucketCapacity24 * maxBucketCapacity\n\
    \        val maxBucketCapacity26 = maxBucketCapacity25 * maxBucketCapacity\n \
    \       val maxBucketCapacity27 = maxBucketCapacity26 * maxBucketCapacity\n  \
    \      val maxBucketCapacity28 = maxBucketCapacity27 * maxBucketCapacity\n   \
    \     val maxBucketCapacity29 = maxBucketCapacity28 * maxBucketCapacity\n    \
    \    val maxBucketCapacity30 = maxBucketCapacity29 * maxBucketCapacity\n     \
    \   val \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpb3sf3ifd.scala:60:11 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb3sf3ifd.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            val bucket = row(0)\n            val well = row.drop(1)\n       \
    \     buckets += bucket\n            wells += well\n        }\n        val maxBucket\
    \ = buckets.max\n        val maxWell = wells.max\n        val maxBucketIndex =\
    \ buckets.indexWhere(_ == maxBucket)\n        val maxWellIndex = wells.indexWhere(_\
    \ == maxWell)\n        val bucketsLeft = maxBucket - maxBucketIndex\n        val\
    \ wellsLeft = maxWell - maxWellIndex\n        val bucketsLeft = bucketsLeft /\
    \ capacity\n        val wellsLeft = wellsLeft / capacity\n        bucketsLeft\
    \ * capacity + wellsLeft\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpubceb5xf.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft\
    \ / capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpubceb5xf.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mwellsLeft\e[0m = wellsLeft / capacity\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mwellsLeft is already defined as \e[33mvalue\e[0m \e[35mwellsLeft\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpubceb5xf.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpubceb5xf.scala:27:20 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            val bucket = row(0).toLong\n            buckets += bucket\n     \
    \       wells += row\n        }\n        val maxBucket = buckets.max\n       \
    \ val maxWells = wells.filter(_(0).toLong == maxBucket).map(_(1))\n        val\
    \ numWells = maxWells.size\n        if (numWells == 0) {\n            return 0\n\
    \        }\n        val numBuckets = buckets.size\n        val numBucketsRequired\
    \ = math.min(numBuckets, capacity)\n        val numBucketsLeft = numBuckets -\
    \ numBucketsRequired\n        val numBucketsRequired = math.min(numBucketsRequired,\
    \ capacity)\n        val numBucketsLeft = numBucketsLeft - numBucketsRequired\n\
    \        if (numBucketsLeft == 0) {\n            return numWells\n        }\n\
    \        val numBucketsLeft = numBucketsLeft / numBucketsRequired\n        val\
    \ numBucketsLeft = numBucketsLeft * numBucketsRequired\n        val numBucketsLeft\
    \ = numBucketsLeft + numBucketsRequired\n        val numBucketsLeft = numBucketsLeft\
    \ / numBucketsRequired\n        val numBucketsLeft = numBucketsLeft * numBucketsRequired\n\
    \        val numBucketsLeft = numBucketsLeft + numBucketsRequired\n        val\
    \ numBucketsLeft = numBucketsLeft / numBucketsRequired\n        val numBucketsLeft\
    \ = numBucketsLeft * numBucketsRequired\n        val numBucketsLeft = numBucketsLeft\
    \ + numBucketsRequired\n        val numBucketsLeft = numBucketsLeft / numBucketsRequired\n\
    \        val numBucketsLeft = numBucketsLeft * numBucketsRequired\n        val\
    \ numBucketsLeft = numBucketsLeft + numBucketsRequired\n        val numBucketsLeft\
    \ = numBucketsLeft / numBucketsRequired\n        val numBucketsLeft = numBucketsLeft\
    \ * numBucketsRequired\n        val numBucketsLeft = numBucketsLeft + numBucketsRequired\n\
    \        val numBucketsLeft = numBucketsLeft / numBucketsRequired\n        val\
    \ numBucketsLeft = numBucketsLeft * numBucketsRequired\n        val numBucketsLeft\
    \ = numBucketsLeft + numBucketsRequired\n        val numBucketsLeft = numBucketsLeft\
    \ / numBucketsRequired\n        val numBucketsLeft = numBucketsLeft * numBucketsRequired\n\
    \        val num\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppav12nnb.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppav12nnb.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnumBucketsRequired\e[0m = math.min(numBucketsRequired, capacity)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumBucketsRequired is already defined as \e[33mvalue\e[0m\
    \ \e[35mnumBucketsRequired\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppav12nnb.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mnumBucketsLeft\e[0m = numBucketsLeft\
    \ - numBucketsRequired\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumBucketsLeft is already defined as \e[33mvalue\e[0m \e[35mnumBucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppav12nnb.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mnumBucketsLeft\e[0m = numBucketsLeft\
    \ / numBucketsRequired\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumBucketsLeft is already defined as \e[33mvalue\e[0m \e[35mnumBucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppav12nnb.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36mnumBucketsLeft\e[0m = numBucketsLeft\
    \ * numBucketsRequired\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumBucketsLeft is already defined as \e[33mvalue\e[0m \e[35mnumBucketsLeft\e\
    ["
  stdout: ''
  timestamp: 1659978887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n        val\
    \ maxBucketCapacity = maxBucketCapacity.toLong\n        val bucketsSize = buckets.map(_.size)\n\
    \        val bucketsCapacity = buckets.map(_.capacity)\n        val bucketsCapacitySum\
    \ = bucketsCapacity.sum\n        val bucketsCapacitySumOfSquares = bucketsCapacitySum\
    \ * bucketsCapacitySum\n        val bucketsCapacitySumOfSquaresOfSquares = bucketsCapacitySumOfSquares\
    \ * bucketsCapacitySumOfSquares\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquares\
    \ = bucketsCapacitySumOfSquaresOfSquares * bucketsCapacitySumOfSquaresOfSquares\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquares = bucketsCapacitySumOfSquaresOfSquaresOfSquares\
    \ * bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquares\n        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquares * bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ = bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \        val bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOf\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvw2tqw8o.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvw2tqw8o.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\e\
    [0m = bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares * bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacitySumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpvw2tqw8o.scala:29:32 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m                            \
    \    ^\e[0m\n\e[31m   |\e[0m                            Recursive \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacity\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpvw2tqw8o.scala:31:44 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity)\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             value capacity is not a member of\
    \ Set[Long]\n\e[31m\e[31m-- Error: /tmp/tmpvw"
  stdout: ''
  timestamp: 1659978889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCountMap = mutable.HashMap.empty[Long, Long]\n   \
    \     val bucketsCapacityCountMap2 = mutable.HashMap.empty[Long, Long]\n     \
    \   val bucketsCapacityCountMap3 = mutable.HashMap.empty[Long, Long]\n       \
    \ val bucketsCapacityCountMap4 = mutable.HashMap.empty[Long, Long]\n        val\
    \ bucketsCapacityCountMap5 = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap6\
    \ = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap7 =\
    \ mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap8 = mutable.HashMap.empty[Long,\
    \ Long]\n        val bucketsCapacityCountMap9 = mutable.HashMap.empty[Long, Long]\n\
    \        val bucketsCapacityCountMap10 = mutable.HashMap.empty[Long, Long]\n \
    \       val bucketsCapacityCountMap11 = mutable.HashMap.empty[Long, Long]\n  \
    \      val bucketsCapacityCountMap12 = mutable.HashMap.empty[Long, Long]\n   \
    \     val bucketsCapacityCountMap13 = mutable.HashMap.empty[Long, Long]\n    \
    \    val bucketsCapacityCountMap14 = mutable.HashMap.empty[Long, Long]\n     \
    \   val bucketsCapacityCountMap15 = mutable.HashMap.empty[Long, Long]\n      \
    \  val bucketsCapacityCountMap16 = mutable.HashMap.empty[Long, Long]\n       \
    \ val bucketsCapacityCountMap17 = mutable.HashMap.empty[Long, Long]\n        val\
    \ bucketsCapacityCountMap18 = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap19\
    \ = mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap20 =\
    \ mutable.HashMap.empty[Long, Long]\n        val bucketsCapacityCountMap21 = mutable.HashMap.empty[Long,\
    \ Long]\n        val bucketsCapacityCountMap22 = mutable.HashMap.empty[Long, Long]\n\
    \        val bucketsCapacityCountMap23 = mutable.HashMap.empty[Long, Long]\n \
    \       val bucketsCapacityCountMap24\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpznmwszyd.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpznmwszyd.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpznmwszyd.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpznmwszyd.scala:28:30 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpznmwszyd.scala:29:35 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCount\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        \
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpznmwszyd.scala:30:38 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacityCountMap\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m "
  stdout: ''
  timestamp: 1659978864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ wells = mutable.HashMap[Long, List[Long]]()\n        val empty = mutable.HashMap[Long,\
    \ Long]()\n        val result = mutable.HashMap[Long, Long]()\n        val maxCapacity\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mutable.HashMap[Long, Long]()\n    \
    \    val maxCapacityIndex = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mutable.HashMap[Long, Long]()\n    \
    \    val maxCapacityIndex = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mutable.HashMap[Long, Long]()\n    \
    \    val maxCapacityIndex = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mutable.HashMap[Long, Long]()\n    \
    \    val maxCapacityIndex = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mutable.HashMap[Long, Long]()\n    \
    \    val maxCapacityIndex = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mutable.HashMap[Long, Long]()\n    \
    \    val maxCapacityIndex = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mutable.HashMap[Long, Long]()\n    \
    \    val maxCapacityIndex = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex\
    \ = mutable.HashMap[Long, Long]()\n        val maxCapacityIndex = mutable.HashMap[Long,\
    \ Long]()\n        val maxCapacityIndex = mut\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp13y2gdp5.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxCapacityIndex\e[0m =\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxCapacityIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCapacityIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp13y2gdp5.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxCapacityIndex\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCapacityIndex is already defined as \e[33mvalue\e[0m \e\
    [35mmaxCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp13y2gdp5.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxCapacityIndex\e[0m =\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxCapacityIndex is already defined as \e[33mvalue\e[0m \e[35mmaxCapacityIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp13y2gdp5.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxCapacityIndex\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCapacityIndex is already defined as \e[33mvalue\e[0m \e\
    [35mmaxCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /t"
  stdout: ''
  timestamp: 1659978890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet).flatten\n        val bucketsMap\
    \ = buckets.groupBy(_._1).mapValues(_.size)\n        val bucketsMap = bucketsMap.filter(_._2\
    \ > 1).map(_._1).distinct\n        val bucketsMap = bucketsMap.map(x => (x, bucketsMap.get(x)))\n\
    \        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n        val bucketsMap\
    \ = bucketsMap.take(bucketsMap.length)\n        val bucketsMap = bucketsMap.map(x\
    \ => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val bucketsMap = bucketsMap.sortBy(_._1).reverse\n\
    \        val bucketsMap = bucketsMap.take(bucketsMap.length)\n        val bucketsMap\
    \ = bucketsMap.map(x => (x, bucketsMap.get(x)))\n        val buckets\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj4p1x4_u.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj4p1x4_u.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsMap\e[0m = bucketsMap.filter(_._2 > \e[31m1\e[0m).map(_._1).distinct\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMap is already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj4p1x4_u.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap\e[0m = bucketsMap.map(\e\
    [36mx\e[0m => (x, bucketsMap.get(x)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMap is already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj4p1x4_u.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap\e[0m = bucketsMap.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMap is already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj4p1x4_u.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap\e[0m = bucketsMap.take(bucketsMap.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMap is already defined as \e[33mvalue\e[0m \e[35mbucketsMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that "
  stdout: ''
  timestamp: 1659978893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val bucketsCount = buckets.map(_.length)\n        val bucketsSum\
    \ = bucketsCount.sum\n        val bucketsSumOfSquare = bucketsSum * bucketsSum\n\
    \        val bucketsSumOfSquareOfBuckets = bucketsSumOfSquare * bucketsCount\n\
    \        val bucketsSumOfSquareOfBucketsOfBuckets = bucketsSumOfSquareOfBuckets\
    \ * bucketsCount\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBuckets =\
    \ bucketsSumOfSquareOfBucketsOfBuckets * bucketsCount\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = bucketsSumOfSquareOfBucketsOfBucketsOfBuckets * bucketsCount\n        val\
    \ bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets = bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBuckets\
    \ * bucketsCount\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets * bucketsCount\n\
    \        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets *\
    \ bucketsCount\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ * bucketsCount\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ * bucketsCount\n        val bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\
    \ = bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucket\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8l1a7izq.scala:30:61 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquareOfBuckets\e\
    [0m = bucketsSumOfSquare * bucketsCount\n\e[31m\e[31m   |\e[0m               \
    \                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m  \
    \ |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m\
    \  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short):\
    \ Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((bucketsCount\
    \ : List[Int]))\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8l1a7izq.scala:39:123\
    \ -----------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBuckets\e\
    [0m = bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucket\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: bucketsSumOfSquareOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucketsOfBucket\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8l1a7izq.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacitySumCount2 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount3 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount4\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount5 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount6 = mutable.ArrayBuffer.empty[Long]\n    \
    \    val bucketsCapacitySumCount7 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount8 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount9\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount10 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount11 = mutable.ArrayBuffer.empty[Long]\n   \
    \     val bucketsCapacitySumCount12 = mutable.ArrayBuffer.empty[Long]\n      \
    \  val bucketsCapacitySumCount13 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount14 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount15\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount16 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount17 = mutable.ArrayBuffer.empty[Long]\n   \
    \     val bucketsCapacitySumCount18 = mutable.ArrayBuffer.empty[Long]\n      \
    \  val bucketsCapacitySumCount19 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount20 = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount21\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySumCount22 = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount23 = mutable.ArrayBuffer.empty[Long]\n   \
    \     val bucketsCapacitySumCount24 = mutable.ArrayBuffer.empty[Long]\n      \
    \  val bucketsCapacitySumCount25 = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCount26 = mutable.ArrayBuffer.empty[Long]\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f0mg_za.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySum\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8f0mg_za.scala:30:38 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCapacitySumCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-ex"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsMap = buckets.map(_.toMap)\n\
    \        val maxBucketMap = bucketsMap.maxBy(_._2.size)._2\n        val maxBucketMapSize\
    \ = maxBucketMap.size\n        val maxBucketMapValues = maxBucketMap.values.toSet\n\
    \        val maxBucketMapValueSize = maxBucketMapValues.size\n        val maxBucketMapValueValues\
    \ = maxBucketMapValues.toSet\n        val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n\
    \        val maxBucketMapValueValueValues = maxBucketMapValueValues.toSet\n  \
    \      val maxBucketMapValueValueValueSize = maxBucketMapValueValueValues.size\n\
    \        val maxBucketMapValueValueValueValues = maxBucketMapValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValues.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucketMapValueValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValueSize.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucketMapValueValueValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValueSize.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucketMapValueValueValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValueSize.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucketMapValueValueValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValueSize.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucketMapValueValueValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValueSize.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucketMapValueValueValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValueSize.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucketMapValueValueValueValueValues.toSet\n\
    \        val maxBucketMapValueValueValueValueSize = maxBucketMapValueValueValueValueSize.size\n\
    \        val maxBucketMapValueValueValueValueValues = maxBucket\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt04nt2wn.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketMapValueValueValueValueSize\e\
    [0m = maxBucketMapValueValueValueValueSize.size\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketMapValueValueValueValueSize is already defined as\
    \ \e[33mvalue\e[0m \e[35mmaxBucketMapValueValueValueValueSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt04nt2wn.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketMapValueValueValueValueValues\e[0m = maxBucketMapValueValueValueValueValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketMapValueValueValueValueValues is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxBucketMapValueValueValueValueValues\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpt04nt2wn.scala:42:12 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxBucketMapValueValueValueValueSize\e[0m\
    \ = maxBucketMapValueValueValueValueSize.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketMapValueValueValueValueSize is already defined as\
    \ \e[33mvalue\e[0m \e[35mmaxBucketMapValueValueValueValueSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt04nt2wn.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketMapValueValueValueValueValues\e[0m = maxBucketMapValueValueValueValueValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l).toList)\n        val maxBucket = buckets.map(_.max).max\n        val\
    \ maxBucketIndex = buckets.zipWithIndex.filter(x => x._2 == maxBucket).map(x =>\
    \ x._1).head\n        val bucketsLeft = maxBucketIndex + 1\n        val bucketsRight\
    \ = bucketsLeft + 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucketsLeft - 1\n        val bucketsRight\
    \ = bucketsRight - 1\n        val bucketsLeft = bucket\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm4fe4573.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm4fe4573.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm4fe4573.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsLeft is already defined as \e[33mvalue\e[0m \e[35mbucketsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm4fe4573.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsRight\e[0m = bucketsRight - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsRight is already defined as \e[33mvalue\e[0m \e[35mbucketsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm4fe4573.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsLeft\e[0m = bucketsLeft - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m  "
  stdout: ''
  timestamp: 1659978896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => 0l))\n        val maxBuckets\
    \ = buckets.map(_.length)\n        val maxBucketsIndex = maxBuckets.zipWithIndex.maxBy(_._1)._2\n\
    \        val maxBucketsValue = maxBuckets(maxBucketsIndex)\n        val maxBucketsIndex2\
    \ = maxBuckets.zipWithIndex.maxBy(_._2)._2\n        val maxBucketsValue2 = maxBuckets(maxBucketsIndex2)\n\
    \        val bucketsCount = maxBucketsIndex2\n        val bucketsValue2 = maxBucketsValue2\n\
    \        val bucketsValue1 = maxBucketsValue\n        val bucketsValue0 = maxBucketsIndex\n\
    \        val bucketsIndex1 = maxBucketsIndex2\n        val bucketsIndex0 = maxBucketsIndex\n\
    \        val bucketsIndex2 = maxBucketsIndex\n        val bucketsIndex3 = maxBucketsIndex\n\
    \        val bucketsIndex4 = maxBucketsIndex\n        val bucketsIndex5 = maxBucketsIndex\n\
    \        val bucketsIndex6 = maxBucketsIndex\n        val bucketsIndex7 = maxBucketsIndex\n\
    \        val bucketsIndex8 = maxBucketsIndex\n        val bucketsIndex9 = maxBucketsIndex\n\
    \        val bucketsIndex10 = maxBucketsIndex\n        val bucketsIndex11 = maxBucketsIndex\n\
    \        val bucketsIndex12 = maxBucketsIndex\n        val bucketsIndex13 = maxBucketsIndex\n\
    \        val bucketsIndex14 = maxBucketsIndex\n        val bucketsIndex15 = maxBucketsIndex\n\
    \        val bucketsIndex16 = maxBucketsIndex\n        val bucketsIndex17 = maxBucketsIndex\n\
    \        val bucketsIndex18 = maxBucketsIndex\n        val bucketsIndex19 = maxBucketsIndex\n\
    \        val bucketsIndex20 = maxBucketsIndex\n        val bucketsIndex21 = maxBucketsIndex\n\
    \        val bucketsIndex22 = maxBucketsIndex\n        val bucketsIndex23 = maxBucketsIndex\n\
    \        val bucketsIndex24 = maxBucketsIndex\n        val bucketsIndex25 = maxBucketsIndex\n\
    \        val bucketsIndex26 = maxBucketsIndex\n        val bucketsIndex27 = maxBucketsIndex\n\
    \        val bucketsIndex28 = maxBucketsIndex\n        val bucketsIndex29 = maxBucketsIndex\n\
    \        val bucketsIndex30 = maxBucketsIndex\n        val bucketsIndex31 = maxBucketsIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpab27oo1b.scala:68:5\
    \ ---------------------\e[0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ wells = mutable.HashMap[Long, Int]()\n        grid.foreach(row => {\n      \
    \      row.foreach(well => {\n                wells += (well -> 1)\n         \
    \   })\n        })\n        grid.foreach(row => {\n            row.foreach(well\
    \ => {\n                buckets += (well -> 0)\n            })\n        })\n \
    \       val maxBuckets = buckets.maxBy(_._2)._2\n        val maxWells = wells.maxBy(_._2)._2\n\
    \        val maxCapacity = capacity - maxBuckets\n        val result = maxBuckets\
    \ - maxWells\n        if (result > maxCapacity) result else maxCapacity\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoxp102oy.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpoxp102oy.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val maxBucketCapacity\
    \ = maxBucketSize / bucketsSize\n        val maxBucketCapacity2 = maxBucketCapacity\
    \ * maxBucketCapacity\n        val maxBucketCapacity3 = maxBucketCapacity2 * maxBucketCapacity\n\
    \        val maxBucketCapacity4 = maxBucketCapacity3 * maxBucketCapacity\n   \
    \     val maxBucketCapacity5 = maxBucketCapacity4 * maxBucketCapacity\n      \
    \  val maxBucketCapacity6 = maxBucketCapacity5 * maxBucketCapacity\n        val\
    \ maxBucketCapacity7 = maxBucketCapacity6 * maxBucketCapacity\n        val maxBucketCapacity8\
    \ = maxBucketCapacity7 * maxBucketCapacity\n        val maxBucketCapacity9 = maxBucketCapacity8\
    \ * maxBucketCapacity\n        val maxBucketCapacity10 = maxBucketCapacity9 *\
    \ maxBucketCapacity\n        val maxBucketCapacity11 = maxBucketCapacity10 * maxBucketCapacity\n\
    \        val maxBucketCapacity12 = maxBucketCapacity11 * maxBucketCapacity\n \
    \       val maxBucketCapacity13 = maxBucketCapacity12 * maxBucketCapacity\n  \
    \      val maxBucketCapacity14 = maxBucketCapacity13 * maxBucketCapacity\n   \
    \     val maxBucketCapacity15 = maxBucketCapacity14 * maxBucketCapacity\n    \
    \    val maxBucketCapacity16 = maxBucketCapacity15 * maxBucketCapacity\n     \
    \   val maxBucketCapacity17 = maxBucketCapacity16 * maxBucketCapacity\n      \
    \  val maxBucketCapacity18 = maxBucketCapacity17 * maxBucketCapacity\n       \
    \ val maxBucketCapacity19 = maxBucketCapacity18 * maxBucketCapacity\n        val\
    \ maxBucketCapacity20 = maxBucketCapacity19 * maxBucketCapacity\n        val maxBucketCapacity21\
    \ = maxBucketCapacity20 * maxBucketCapacity\n        val maxBucketCapacity22 =\
    \ maxBucketCapacity21 * maxBucketCapacity\n        val maxBucketCapacity23 = maxBucketCapacity22\
    \ * maxBucketCapacity\n        val maxBucketCapacity24 = maxBucketCapacity23 *\
    \ maxBucketCapacity\n        val maxBucketCapacity25 = maxBucketCapacity24 * maxBucketCapacity\n\
    \        val maxBucketCapacity26 = maxBucketCapacity25 * maxBucketCapacity\n \
    \       val maxBucketCapacity27 = maxBucketCapacity26 * maxBucketCapacity\n  \
    \      val maxBucketCapacity28 = maxBucketCapacity27 * maxBucketCapacity\n   \
    \     val maxBucketCapacity29 = maxBucketCapacity28 * maxBucketCapacity\n    \
    \    val maxBucketCapacity30 = maxBucketCapacity29 * maxBucketCapacity\n     \
    \   val \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpb3sf3ifd.scala:60:11 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb3sf3ifd.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsCount = mutable.ArrayBuffer(capacity)\n        val bucketsCounts = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_1\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_2 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_3 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_4\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_5 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_6 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_7\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_8 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_9 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_10\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_11 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_12 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_13\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_14 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_15 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_16\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_17 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_18 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_19\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_20 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_21 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_22\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_23 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_24 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_25\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_26 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_27 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_28\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_29 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCounts_30 = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_31\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCounts_32 = mut\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpcmzyvraa.scala:27:27 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:30:30 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_1\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcmzyvraa.scala:31:30 ------------------------"
  stdout: ''
  timestamp: 1659793684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).map(_.size).getOrElse(0)\n        val maxBucketSize =\
    \ maxBucket * capacity\n        val bucketsSize = buckets.map(_.size).sum\n  \
    \      val bucketsSizeDiff = bucketsSize - maxBucketSize\n        val bucketsSizeDiffDiff\
    \ = bucketsSizeDiff / maxBucketSize\n        val bucketsSizeDiffDiff = bucketsSizeDiff\
    \ / maxBucket\n        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n\
    \        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n     \
    \   val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n        val\
    \ bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n        val bucketsSizeDiffDiffDiff\
    \ = bucketsSizeDiffDiff / maxBucket\n        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff\
    \ / maxBucket\n        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n\
    \        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n     \
    \   val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n        val\
    \ bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n        val bucketsSizeDiffDiffDiff\
    \ = bucketsSizeDiffDiff / maxBucket\n        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff\
    \ / maxBucket\n        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n\
    \        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n     \
    \   val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n        val\
    \ bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n        val bucketsSizeDiffDiffDiff\
    \ = bucketsSizeDiffDiff / maxBucket\n        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff\
    \ / maxBucket\n        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n\
    \        val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n     \
    \   val bucketsSizeDiffDiffDiff = bucketsSizeDiffDiff / maxBucket\n        val\
    \ bucketsSizeDiffDiffDiff\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg712og1m.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg712og1m.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSizeDiffDiff\e[0m = bucketsSizeDiff / maxBucket\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbucketsSizeDiffDiff is already defined as \e[33mvalue\e[0m \e[35mbucketsSizeDiffDiff\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg712og1m.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsSizeDiffDiffDiff\e[0m = bucketsSizeDiffDiff\
    \ / maxBucket\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSizeDiffDiffDiff is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSizeDiffDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg712og1m.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsSizeDiffDiffDiff\e\
    [0m = bucketsSizeDiffDiff / maxBucket\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSizeDiffDiffDiff is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSizeDiffDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg712og1m.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsSizeDiffDiffDiff\e\
    [0m = bucketsSizeDiffDiff / maxBucket\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSizeDiffDiffDiff i"
  stdout: ''
  timestamp: 1659978895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.maxBy(_.sum)\n        val maxBucketIndex\
    \ = buckets.indexWhere(x => x.sum == maxBucket)\n        val maxBucketSize = maxBucket.sum\n\
    \        val maxBucketCapacity = maxBucketSize * capacity\n        val maxBucketCapacityIndex\
    \ = buckets.indexWhere(x => x.sum == maxBucketCapacity)\n        val maxBucketCapacitySize\
    \ = maxBucketCapacity.sum\n        val maxBucketCapacityCapacity = maxBucketCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityIndex = buckets.indexWhere(x\
    \ => x.sum == maxBucketCapacityCapacity)\n        val maxBucketCapacityCapacitySize\
    \ = maxBucketCapacityCapacity.sum\n        val maxBucketCapacityCapacityCapacity\
    \ = maxBucketCapacityCapacitySize * capacity\n        val maxBucketCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(x => x.sum == maxBucketCapacityCapacityCapacity)\n    \
    \    val maxBucketCapacityCapacityCapacitySize = maxBucketCapacityCapacityCapacity.sum\n\
    \        val maxBucketCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityIndex = buckets.indexWhere(x\
    \ => x.sum == maxBucketCapacityCapacityCapacityCapacity)\n        val maxBucketCapacityCapacityCapacityCapacitySize\
    \ = maxBucketCapacityCapacityCapacityCapacityCapacity.sum\n        val maxBucketCapacityCapacityCapacityCapacityCapacity\
    \ = maxBucketCapacityCapacityCapacityCapacitySize * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(x => x.sum == maxBucketCapacityCapacityCapacityCapacityCapacity)\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacitySize = maxBucketCapacityCapacityCapacityCapacityCapacityCapacity.sum\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(x => x.sum == maxBucketCapacityCapacityCapacityCapacityCapacityCapacity)\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacitySize = maxBucketCapacityCapacityCapacityCapacityCapacityCapacity.sum\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacity = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n        val maxBucketCapacityCapacityCapacityCapacityCapacityIndex\
    \ = buckets.indexWhere(x => x.sum == maxBucketCapacityCapacityCapacityCapacityCapacityCapacity)\n\
    \        val maxBucketCapacityCapacityCapacityCapacityCapacitySize = maxBucketCapacityCapacityCapacityCapacityCapacityCapacityCapacity.sum\n\
    \        val maxBucketCapacityCapacityCapacityCapacity\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp93dtvq21.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp93dtvq21.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacity\e[0m = maxBucketCapacityCapacityCapacityCapacityCapacitySize\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityCapacityCapacityCapacityCapacity is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityCapacityCapacityCapacityCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93dtvq21.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex\e\
    [0m = buckets.indexWhere(\e[36mx\e[0m => x.sum == maxBucketCapacityCapacityCapacityCapacityCapacityCapacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityCapacityCapacityCapacityCapacityIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93dtvq21.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCapacityCapacityCapacityCapacitySize\e\
    [0m = maxBucketCapacityCapacityCapacityCapacityCapacityCapacity.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsCapacity\
    \ = buckets.map(_.capacity).sum\n        val bucketsRemain = bucketsSize - maxBucketSize\n\
    \        val bucketsRem = bucketsCapacity - bucketsRemain\n        val bucketsRem\
    \ = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n        val\
    \ bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val bucketsRem = bucketsRem.toLong\n        val bucketsRem = bucketsRem.toInt\n\
    \        val buckets\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9_hcrclg.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9_hcrclg.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsRem\e[0m = bucketsRem.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsRem is already defined as \e[33mvalue\e[0m \e[35mbucketsRem\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9_hcrclg.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsRem\e[0m = bucketsRem.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mbucketsRem is already defined as \e[33mvalue\e[0m \e[35mbucketsRem\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9_hcrclg.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsRem\e[0m = bucketsRem.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbucketsRem\
    \ is already defined as \e[33mvalue\e[0m \e[35mbucketsRem\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9_hcrclg.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsRem\e[0m = bucketsRem.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsRem is already defined as \e[33mvalue\e[0m \e[35mbucketsRem\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9_hcrclg.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m "
  stdout: ''
  timestamp: 1659978895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBuckets\
    \ = buckets.map(_.size).max\n        val maxBucketsSize = maxBuckets.toLong\n\
    \        val maxBucketsCapacity = maxBucketsSize * capacity\n        val maxBucketsCapacity2\
    \ = maxBucketsCapacity * maxBucketsCapacity\n        val maxBucketsCapacity3 =\
    \ maxBucketsCapacity2 * maxBucketsCapacity\n        val maxBucketsCapacity4 =\
    \ maxBucketsCapacity3 * maxBucketsCapacity\n        val maxBucketsCapacity5 =\
    \ maxBucketsCapacity4 * maxBucketsCapacity\n        val maxBucketsCapacity6 =\
    \ maxBucketsCapacity5 * maxBucketsCapacity\n        val maxBucketsCapacity7 =\
    \ maxBucketsCapacity6 * maxBucketsCapacity\n        val maxBucketsCapacity8 =\
    \ maxBucketsCapacity7 * maxBucketsCapacity\n        val maxBucketsCapacity9 =\
    \ maxBucketsCapacity8 * maxBucketsCapacity\n        val maxBucketsCapacity10 =\
    \ maxBucketsCapacity9 * maxBucketsCapacity\n        val maxBucketsCapacity = maxBucketsCapacity10\
    \ / capacity\n        val maxBucketsCapacity2 = maxBucketsCapacity * maxBucketsCapacity\n\
    \        val maxBucketsCapacity3 = maxBucketsCapacity2 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity4 = maxBucketsCapacity3 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity5 = maxBucketsCapacity4 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity6 = maxBucketsCapacity5 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity7 = maxBucketsCapacity6 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity8 = maxBucketsCapacity7 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity9 = maxBucketsCapacity8 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity10 = maxBucketsCapacity9 * maxBucketsCapacity\n\
    \        val maxBucketsCapacity = maxBucketsCapacity10 / capacity\n        val\
    \ maxBucketsCapacity2 = maxBucketsCapacity * maxBucketsCapacity\n        val maxBucketsCapacity3\
    \ = maxBucketsCapacity2 * maxBucketsCapacity\n        val maxBucketsCapacity4\
    \ = maxBucketsCapacity3 * maxBucketsCapacity\n        val maxBucketsCapacity5\
    \ = maxBucketsCapacity4 * maxBucketsCapacity\n        val maxBucketsCapacity6\
    \ = maxBucketsCapacity5 * maxBucketsCapacity\n        val maxBucketsCapacity7\
    \ = maxBucketsCapacity6 * maxBucketsCapacity\n        val maxBucketsCapacity8\
    \ = maxBucketsCapacity7 * maxBucketsCapacity\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8qbse9qv.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity\e[0m\
    \ = maxBucketsCapacity10 / capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacity is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8qbse9qv.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity2\e[0m\
    \ = maxBucketsCapacity * maxBucketsCapacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacity2 is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCapacity2\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8qbse9qv.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity3\e[0m\
    \ = maxBucketsCapacity2 * maxBucketsCapacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacity3 is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCapacity3\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8qbse9qv.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCapacity4\e[0m\
    \ = maxBucketsCapacity3 * maxBucketsCapacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCapacity4 is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxBucketsCapacity4\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definiti"
  stdout: ''
  timestamp: 1659978894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n        val\
    \ maxBucketCapacity = maxBucketCapacity.toLong\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val bucketsCapacity = buckets.map(_.capacity).sum\n        val bucketsCapacityDiff\
    \ = bucketsCapacity - maxBucketCapacity\n        val bucketsSizeDiff = bucketsSize\
    \ - maxBucketSize\n        val bucketsDiff = bucketsCapacityDiff - bucketsSizeDiff\n\
    \        val bucketsDiffToMaxBucket = bucketsDiff - maxBucketCapacity\n      \
    \  val bucketsDiffToMaxBucketToMaxBucket = bucketsDiffToMaxBucket - maxBucketSize\n\
    \        val bucketsDiffToMaxBucketToMaxBucketToMaxBucket = bucketsDiffToMaxBucketToMaxBucket\
    \ - maxBucketCapacity\n        val bucketsDiffToMaxBucketToMaxBucketToMaxBucketToMaxBucket\
    \ = bucketsDiffToMaxBucketToMaxBucketToMaxBucket - maxBucketSize\n        val\
    \ bucketsDiffToMaxBucketToMaxBucketToMaxBucketToMaxBucketToMaxBucket = bucketsDiffToMaxBucketToMaxBucketToMaxBucketToMaxBucket\
    \ - maxBucketCapacity\n        bucketsDiffToMaxBucketToMaxBucketToMaxBucketToMaxBucketToMaxBucket\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphwu8e8w3.scala:29:32 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m                            \
    \    ^\e[0m\n\e[31m   |\e[0m                            Recursive \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacity\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmphwu8e8w3.scala:31:44 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             value capacity is not a member of\
    \ Set[Long]\n\e[31m\e[31m-- Error: /tmp/tmphwu8e8w3.scala:31:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = buckets.map(_.capacity).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mShortIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match\
    \ type Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659978897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer(grid.length)\n        val fill = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCount = mutable.ArrayBuffer(grid.length)\n        val fillCounts\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_ = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_1 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_2\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_3 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_4 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_5\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_6 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_7 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_8\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_9 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_10 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_11\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_12 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_13 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_14\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_15 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_16 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_17\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_18 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_19 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_20\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_21 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_22 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_23\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_24 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_25 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_26\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_27 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_28 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_29\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_30 = mutable.ArrayBuffer(grid.length)\n\
    \        val fillCounts_31 = mutable.ArrayBuffer(grid.length)\n        val fillCounts_32\
    \ = mutable.ArrayBuffer(grid.length)\n        val fillCounts_33 = \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4ajwm5gb.scala:64:27 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \e[36mfillCounts_33\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4ajwm5gb.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4ajwm5gb.scala:27:20 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4ajwm5gb.scala:28:19 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mfill\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4ajwm5gb.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mfillCount\e[0m = mutable.ArrayBuffer(grid.length)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4ajwm5gb.scala:30:25 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mfillCounts\e[0m = mutable."
  stdout: ''
  timestamp: 1659978897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsMap = buckets.map(_.toMap)\n\
    \        val maxBucketMap = bucketsMap.maxBy(_._2.size)._2\n        val maxBucketMapSize\
    \ = maxBucketMap.size\n        val maxBucketMapKeys = maxBucketMap.keys\n    \
    \    val maxBucketMapValues = maxBucketMap.values\n        val maxBucketMapValueSize\
    \ = maxBucketMapValues.size\n        val maxBucketMapValueKeys = maxBucketMapValues.map(_.size)\n\
    \        val maxBucketMapValueValues = maxBucketMapValues.map(_.toList)\n    \
    \    val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n        val\
    \ maxBucketMapValueValueKeys = maxBucketMapValueValues.map(_.size)\n        val\
    \ maxBucketMapValueValueValues = maxBucketMapValueValues.map(_.toList)\n     \
    \   val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n        val\
    \ maxBucketMapValueValueKeys = maxBucketMapValueValues.map(_.size)\n        val\
    \ maxBucketMapValueValueValues = maxBucketMapValueValues.map(_.toList)\n     \
    \   val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n        val\
    \ maxBucketMapValueValueKeys = maxBucketMapValueValues.map(_.size)\n        val\
    \ maxBucketMapValueValueValues = maxBucketMapValueValues.map(_.toList)\n     \
    \   val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n        val\
    \ maxBucketMapValueValueKeys = maxBucketMapValueValues.map(_.size)\n        val\
    \ maxBucketMapValueValueValues = maxBucketMapValueValues.map(_.toList)\n     \
    \   val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n        val\
    \ maxBucketMapValueValueKeys = maxBucketMapValueValues.map(_.size)\n        val\
    \ maxBucketMapValueValueValues = maxBucketMapValueValues.map(_.toList)\n     \
    \   val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n        val\
    \ maxBucketMapValueValueKeys = maxBucketMapValueValues.map(_.size)\n        val\
    \ maxBucketMapValueValueValues = maxBucketMapValueValues.map(_.toList)\n     \
    \   val maxBucketMapValueValueSize = maxBucketMapValueValues.size\n        val\
    \ maxBucketMapValueValueKeys = maxBucketMapValueValues.map(_.size)\n        val\
    \ maxBucketMapValueValueValues = maxBucketMapValueValues.map(\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_cvnh7a0.scala:56:71 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketMapValueValueValues\e\
    [0m = maxBucketMapValueValues.map(\n\e[31m\e[31m   |\e[0m                    \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                     expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_cvnh7a0.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketMapValueValueSize\e[0m = maxBucketMapValueValues.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketMapValueValueSize is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketMapValueValueSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_cvnh7a0.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketMapValueValueKeys\e\
    [0m = maxBucketMapValueValues.map(_.size)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketMapValueValueKeys is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketMapValueValueKeys\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_cvnh7a0.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketMapValueValueValues\e\
    [0m = maxBucketMapValueValues.map(_.toList)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketMapValueValueValues is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketMapValueValueValues\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined i"
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            wells.append(row)\n        }\n        val maxBucket = wells.map(_.length).max\n\
    \        val maxWell = wells.map(_.head).max\n        val maxBucketCapacity =\
    \ maxBucket * capacity\n        val maxWellCapacity = maxWell * capacity\n   \
    \     val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val wellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCapacity = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount\
    \ = wells.map(_.length).sum\n        val wellsCount = wells.map(_.head).sum\n\
    \        val bucketsCapacity = wells.map(_.length * capacity).sum\n        val\
    \ wellsCapacity = wells.map(_.head).sum * capacity\n        val bucketsCapacity\
    \ = wells.map(_.length * capacity).sum\n        val wellsCapacity = wells.map(_.head).sum\
    \ * capacity\n        val bucketsCapacity = wells.map(_.length * capacity).sum\n\
    \        val wellsCapacity = wells.map(_.head).sum * capacity\n        val bucketsCapacity\
    \ = wells.map(_.length * capacity).sum\n        val wellsCapacity = wells.map(_.head).sum\
    \ * capacity\n        val bucketsCapacity = wells.map(_.length * capacity).sum\n\
    \        val wellsCapacity = wells.map(_.head).sum * capacity\n        val bucketsCapacity\
    \ = wells.map(_.length * capacity).sum\n        val wellsCapacity = wells.map(_.head).sum\
    \ * capacity\n        val bucketsCapacity = wells.map(_.length * capacity).sum\n\
    \        val wellsCapacity = wells.map(_.head).sum * capacity\n        val bucketsCapacity\
    \ = wells.map(_.length * capacity).sum\n        val wellsCapacity = wells.map(_.head).sum\
    \ * capacity\n        val bucketsCapacity = wells.map(_.length * capacity).sum\n\
    \        val wellsCapacity = wells.map(_.head).sum * capacity\n        val bucketsCapacity\
    \ = wells.map(_.length * capacity).sum\n        val wellsCapacity = wells.map(_.head).sum\
    \ * capacity\n        val bucketsCapacity = wells.map(_.length * capacity).sum\n\
    \        val well\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg26adsmt.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg26adsmt.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCount\e[0m = wells.map(_.length).sum\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbucketsCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg26adsmt.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mwellsCount\e[0m = wells.map(_.head).sum\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mwellsCount is already\
    \ defined as \e[33mvalue\e[0m \e[35mwellsCount\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg26adsmt.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacity\e[0m = wells.map(_.length * capacity).sum\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e[35mbucketsCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg26adsmt.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mwellsCapacity\e[0m = wells.map(_.head).sum\
    \ * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwellsCapacity is already defined as \e[33mvalue\e[0m \e[35mwellsCapacity\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplev"
  stdout: ''
  timestamp: 1659978897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n        val\
    \ bucketsSize = buckets.map(_.size).sum\n        val maxBucketCapacity = maxBucketSize\
    \ * capacity\n        val maxBucketCapacityWithEmpty = maxBucketCapacity - maxBucketCapacity\n\
    \        val emptyBuckets = buckets.filter(_.size == 0)\n        val emptyBucketsSize\
    \ = emptyBuckets.map(_.size).sum\n        val emptyBucketsCapacity = emptyBuckets.map(_.capacity).sum\n\
    \        val emptyBucketsCapacityWithEmpty = emptyBucketsCapacity - emptyBucketsCapacity\n\
    \        val emptyBucketsCapacityWithEmptyAndEmptyBucketsSize = emptyBucketsCapacityWithEmpty\
    \ + emptyBucketsSize\n        val emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacity\
    \ = emptyBucketsCapacityWithEmptyAndEmptyBucketsSize * capacity\n        val emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmpty\
    \ = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmpty - emptyBucketsCapacityWithEmpty\n\
    \        val emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ * capacity\n        val emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacity\
    \ = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacity\
    \ - emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmpty\n        val\
    \ emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ * capacity\n        val emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ * capacity\n        val emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBuckets\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzst2f26w.scala:34:54 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36memptyBucketsCapacity\e[0m\
    \ = emptyBuckets.map(_.capacity).sum\n\e[31m\e[31m   |\e[0m                  \
    \                                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                   value capacity is not a member of Set[Long]\n\e[31m\e[31m--\
    \ Error: /tmp/tmpzst2f26w.scala:34:67 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36memptyBucketsCapacity\e[0m\
    \ = emptyBuckets.map(_.capacity).sum\n\e[31m\e[31m   |\e[0m                  \
    \                                                 ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mLongIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzst2f26w.scala:38:76 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36memptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmpty\e\
    [0m = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmpty - emptyBucketsCapacityWithEmpty\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35memptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmpty\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzst2f26w.scala:39:95\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36memptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\e\
    [0m = emptyBucketsCapacityWithEmptyAndEmptyBucketsCapacityWithEmptyAndEmptyBucketsSize\
    \ * capacity\n\e[31m\e[31m   |\e[0m                                          \
    \                                                     ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mv"
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        grid.foreach(row\
    \ => {\n            val bucket = buckets.last\n            buckets += row(0)\n\
    \            bucketsCount += row(0)\n            wells += row\n            wellsCount\
    \ += row.length\n        })\n        val bucketsSum = buckets.sum\n        val\
    \ wellsSum = wells.sum\n        val bucketsDiff = bucketsSum - bucketsCount.last\n\
    \        val wellsDiff = wellsSum - wellsCount.last\n        val bucketsDiffCount\
    \ = bucketsCount - bucketsSum\n        val wellsDiffCount = wellsCount - wellsSum\n\
    \        val bucketsDiffSum = bucketsDiff.sum\n        val wellsDiffSum = wellsDiff.sum\n\
    \        val bucketsDiffCount = bucketsDiffCount.sum\n        val wellsDiffCount\
    \ = wellsDiffCount.sum\n        val bucketsDiffSum = bucketsDiffSum.last\n   \
    \     val wellsDiffSum = wellsDiffSum.last\n        val bucketsDiffCount = bucketsDiffCount.last\n\
    \        val wellsDiffCount = wellsDiffCount.last\n        val bucketsDiffSum\
    \ = bucketsDiffSum.last\n        val wellsDiffSum = wellsDiffSum.last\n      \
    \  val bucketsDiffCount = bucketsDiffCount.last\n        val wellsDiffCount =\
    \ wellsDiffCount.last\n        val bucketsDiffSum = bucketsDiffSum.last\n    \
    \    val wellsDiffSum = wellsDiffSum.last\n        val bucketsDiffCount = bucketsDiffCount.last\n\
    \        val wellsDiffCount = wellsDiffCount.last\n        val bucketsDiffSum\
    \ = bucketsDiffSum.last\n        val wellsDiffSum = wellsDiffSum.last\n      \
    \  val bucketsDiffCount = bucketsDiffCount.last\n        val wellsDiffCount =\
    \ wellsDiffCount.last\n        val bucketsDiffSum = bucketsDiffSum.last\n    \
    \    val wellsDiffSum = wellsDiffSum.last\n        val bucketsDiffCount = bucketsDiffCount.last\n\
    \        val wellsDiffCount = wellsDiffCount.last\n        val bucketsDiffSum\
    \ = bucketsDiffSum.last\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk75thsyn.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mbucketsDiffCount\e[0m =\
    \ bucketsDiffCount.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsDiffCount is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsDiffCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk75thsyn.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mwellsDiffCount\e[0m = wellsDiffCount.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mwellsDiffCount is already defined as \e[33mvalue\e[0m \e[35mwellsDiffCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk75thsyn.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mbucketsDiffSum\e[0m = bucketsDiffSum.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbucketsDiffSum is already defined as \e[33mvalue\e[0m \e[35mbucketsDiffSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk75thsyn.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36mwellsDiffSum\e[0m = wellsDiffSum.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mwellsDiffSum is already defined as \e[33mvalue\e[0m \e[35mwellsDiffSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk75thsyn.scala:49:12 ---------------------------\e[0m\e[0m\n\e\
    [31m49 |\e[0m        \e[33mval\e[0m \e[36mbucketsDiffCount\e[0m = bucketsDiffCount.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val maxCapacity = math.max(m, n)\n        val buckets = mutable.ArrayBuffer(capacity)\n\
    \        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n        \
    \        buckets += grid(i)(j)\n            }\n        }\n        val res = buckets.foldLeft(0l)((acc,\
    \ b) => math.max(acc, b) + 1)\n        if (res > maxCapacity) {\n            res\n\
    \        } else {\n            maxCapacity\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0qncwbbv.scala:29:22 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Int]()\n        val bucketsCapacity = mutable.HashMap[Long,\
    \ Int]()\n        val bucketsCapacityCount = mutable.HashMap[Long, Int]()\n  \
    \      val bucketsCapacityCapacity = mutable.HashMap[Long, Int]()\n        val\
    \ bucketsCapacityCapacityCount = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.HashMap[Long, Int]()\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.HashMap[Long, Int]()\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpin7obw5u.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\e\
    [0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpin7obw5u.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\e\
    [0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpin7obw5u.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpin7obw5u.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e["
  stdout: ''
  timestamp: 1659978902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.maxBy(_.length)\n        val maxBucketSize\
    \ = maxBucket.length\n        val maxBucketCapacity = maxBucket.map(_.length).max\n\
    \        val maxBucketCapacitySize = maxBucketCapacity\n        val maxBucketCapacityCapacity\
    \ = maxBucketCapacitySize * maxBucketCapacitySize\n        val maxBucketCapacityCapacity2\
    \ = maxBucketCapacityCapacity * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity3\
    \ = maxBucketCapacityCapacity2 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity4\
    \ = maxBucketCapacityCapacity3 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity5\
    \ = maxBucketCapacityCapacity4 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity6\
    \ = maxBucketCapacityCapacity5 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity7\
    \ = maxBucketCapacityCapacity6 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity8\
    \ = maxBucketCapacityCapacity7 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity9\
    \ = maxBucketCapacityCapacity8 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity10\
    \ = maxBucketCapacityCapacity9 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity11\
    \ = maxBucketCapacityCapacity10 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity12\
    \ = maxBucketCapacityCapacity11 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity13\
    \ = maxBucketCapacityCapacity12 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity14\
    \ = maxBucketCapacityCapacity13 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity15\
    \ = maxBucketCapacityCapacity14 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity16\
    \ = maxBucketCapacityCapacity15 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity17\
    \ = maxBucketCapacityCapacity16 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity18\
    \ = maxBucketCapacityCapacity17 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity19\
    \ = maxBucketCapacityCapacity18 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity20\
    \ = maxBucketCapacityCapacity19 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity21\
    \ = maxBucketCapacityCapacity20 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity22\
    \ = maxBucketCapacityCapacity21 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity23\
    \ = maxBucketCapacityCapacity22 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity24\
    \ = maxBucketCapacityCapacity23 * maxBucketCapacityCapacity\n        val maxBucketCapacityCapacity\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9m_grmd0.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9m_grmd0.scala:29:48\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxBucketCapacity\e[0m = maxBucket.map(_.length).max\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    value length is not a member of Long\n\e\
    [31m\e[31m-- Error: /tmp/tmp9m_grmd0.scala:29:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucket.map(_.length).max\n\e[31m\e[31m   |\e[0m                         \
    \                                  ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35mmax\e[0m\
    \ in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9m_grmd0.scala:56:5 ---------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = mutable.ArrayBuffer(capacity)\n        val bucketsCount =\
    \ mutable.ArrayBuffer(capacity)\n        val bucketsCount = mutable.ArrayBuffer(capacity)\n\
    \        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n        \
    \        if (grid(i)(j) == 1) {\n                    buckets(buckets.length) =\
    \ grid(i)(j)\n                    bucketsCount(bucketsCount.length) = grid(i)(j)\n\
    \                    bucketsCount(bucketsCount.length) = bucketsCount(bucketsCount.length)\
    \ - 1\n                }\n            }\n        }\n        val maxBuckets = buckets.max\n\
    \        val maxBucketsCount = bucketsCount.max\n        if (maxBucketsCount >\
    \ capacity) {\n            maxBucketsCount\n        } else {\n            maxBucketsCount\
    \ + 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6cgkbbr8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp6cgkbbr8.scala:28:22 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp6cgkbbr8.scala:29:27 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        grid.foreach(row\
    \ => {\n            row.foreach(bucket => {\n                buckets += bucket\
    \ -> 0\n            })\n        })\n        val maxBucket = buckets.maxBy(_._2)._1\n\
    \        val maxBucketIndex = buckets.keys.indexOf(maxBucket)\n        val bucketsCount\
    \ = buckets.values.sum\n        val maxBucketCount = buckets.values.count(_ ==\
    \ maxBucket)\n        val maxBucketCapacity = maxBucketCount * capacity\n    \
    \    val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n  \
    \      val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        val maxBucketCapacityIndex = bucketsCount.indexOf(maxBucketCapacity)\n\
    \        val maxBucketCapacityCount = bucketsCount.count(_ == maxBucketCapacity)\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ua9ky1k.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = bucketsCount.indexOf(maxBucketCapacity)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ua9ky1k.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCount\e\
    [0m = bucketsCount.count(_ == maxBucketCapacity)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxBucketCapacityCount is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacityCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2ua9ky1k.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityIndex\e\
    [0m = bucketsCount.indexOf(maxBucketCapacity)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityIndex is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketCapacityIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ua9ky1k.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityCount\e\
    [0m = bucketsCount.count(_ == maxBucketCapacity)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxBucketCapacityCount is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacityCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that o"
  stdout: ''
  timestamp: 1659978903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        grid.foreach(row => {\n\
    \            val well = mutable.ArrayBuffer.empty[Long]\n            row.foreach(col\
    \ => {\n                well.append(col)\n            })\n            wells.append(well)\n\
    \        })\n        wells.foreach(well => {\n            well.foreach(col =>\
    \ {\n                buckets.append(col.toInt)\n            })\n        })\n \
    \       buckets.foreach(bucket => {\n            bucket = bucket.toInt\n     \
    \       buckets.foreach(bucket => {\n                bucket = bucket.toInt\n \
    \               if (bucket < capacity) {\n                    buckets.foreach(bucket\
    \ => {\n                        bucket = bucket.toInt\n                      \
    \  if (bucket < capacity) {\n                            buckets.foreach(bucket\
    \ => {\n                                bucket = bucket.toInt\n              \
    \                  if (bucket < capacity) {\n                                \
    \    buckets.foreach(bucket => {\n                                        bucket\
    \ = bucket.toInt\n                                        if (bucket < capacity)\
    \ {\n                                            buckets.foreach(bucket => {\n\
    \                                                bucket = bucket.toInt\n     \
    \                                           if (bucket < capacity) {\n       \
    \                                             buckets.foreach(bucket => {\n  \
    \                                                      bucket = bucket.toInt\n\
    \                                                        if (bucket < capacity)\
    \ {\n                                                            buckets.foreach(bucket\
    \ => {\n                                                                bucket\
    \ = bucket.toInt\n                                                           \
    \     if (bucket < capacity) {\n                                             \
    \                       buckets.foreach(bucket => {\n                        \
    \                                                bucket = bucket.toInt\n     \
    \                                                                   if (bucket\
    \ < capacity) {\n                                                            \
    \                buckets.foreach(bucket => {\n                               \
    \                                                 bucket = bucket.toInt\n    \
    \                                                                            if\
    \ (bucket < capacity) {\n                                                    \
    \                                buckets.foreach(bucket => {\n               \
    \                                                                         bucket\
    \ = bucket.toInt\n                                                           \
    \                             if (bucket < capacity) {\n                     \
    \                                                                       buckets.foreach(bucket\
    \ => {\n                                                                     \
    \                           bucket = bucket.toInt\n                          \
    \                                                                      if (bucket\
    \ < capacity) {\n                                                            \
    \                                        buckets.foreach(bucket => {\n       \
    \                                                                            \
    \                     bucket = bucket.toInt\n                                \
    \                                                                        if (bucket\
    \ < capacity) {\n                                                            \
    \                                                buckets.foreach(bucket => {\n\
    \                                                                            \
    \                                    bucket = bucket.toInt\n                 \
    \                                                                            \
    \                   if (bucket < capacity) {\n                               \
    \                                                                            \
    \         buckets.foreach(bucket => {\n                                      \
    \                                                                            \
    \      bucket = bucket.toInt\n                                               \
    \                                                                         if (bucket\
    \ < capacity) {\n                                                            \
    \                                                                buckets.foreach(bucket\
    \ => {\n                                                                     \
    \                                                           bucket = bucket.toInt\n\
    \                                                                            \
    \                                                    if (bucket < capacity) {\n\
    \                                                                            \
    \                                                        buckets.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                   bucket = bucket.toInt\n\
    \                                                                            \
    \                                                            if (bucket < capacity)\
    \ {\n                                                                        \
    \                                                                    buckets.foreach(bucket\
    \ => {\n                                                                     \
    \                                                                           bucket\
    \ = bucket.toInt\n                                                           \
    \                                                                            \
    \         if (bucket \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc2qtpmk9.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc2qtpmk9.scala:94:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m94 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpc2qtpmk9.scala:103:0 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc2qtpmk9.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc2qtpmk9.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mwells\e[0m = mutable.ArrayBuffer.empty[\e[35mList\e[0m[\e[35mLong\e[0m]]\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpc2qtpmk9.scala:29:23 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m            \e[33mval\e[0m \e[36mwell\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1659978899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsCount = buckets.map(_.size).sum\n\
    \        val bucketsSum = buckets.map(_.sum).sum\n        val bucketsSumOfSquare\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquareOfMaxBucket\
    \ = buckets.map(_.map(x => x * x).sum).sum\n        val bucketsSumOfSquare\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiq84grcp.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiq84grcp.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumOfSquareOfMaxBucket\e[0m = buckets.map(_.map(\e[36mx\e[0m =>\
    \ x * x).sum).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumOfSquareOfMaxBucket is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumOfSquareOfMaxBucket\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiq84grcp.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquareOfMaxBucket\e\
    [0m = buckets.map(_.map(\e[36mx\e[0m => x * x).sum).sum\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumOfSquareOfMaxBucket is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumOfSquareOfMaxBucket\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiq84grcp.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquareOfMaxBucket\e\
    [0m = buckets.map(_.map(\e[36mx\e[0m => x * x).sum).sum\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumOfSquareOfMaxBucket is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumOfSquareOfMaxBucket\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiq84grcp.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumOfSquareOfMaxBuck"
  stdout: ''
  timestamp: 1659978905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Int]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity =\
    \ mutable.ArrayBuffer.empty[Int]\n        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount = mutable.ArrayBuffer.empty[Int]\n\
    \        val bucketsCapacity = mutable.ArrayBuffer.empty[Int]\n        val bucketsCount\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptjf0qr7t.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptjf0qr7t.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptjf0qr7t.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptjf0qr7t.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptjf0qr7t.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659978905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).getOrElse(0l)\n        val maxBucketSize = maxBucket /\
    \ capacity\n        val maxBucketCapacity = maxBucket % capacity\n        val\
    \ bucketsSize = buckets.map(_.size)\n        val bucketsCapacity = buckets.map(_.capacity)\n\
    \        val bucketsMaxSize = buckets.map(_.maxBy(_.size).getOrElse(0l))\n   \
    \     val bucketsMaxCapacity = buckets.map(_.maxBy(_.capacity).getOrElse(0l))\n\
    \        val bucketsMaxSize = bucketsMaxSize.map(_.toSet)\n        val bucketsMaxCapacity\
    \ = bucketsMaxCapacity.map(_.toSet)\n        val bucketsMaxSize = bucketsMaxSize.map(_.size)\n\
    \        val bucketsMaxCapacity = bucketsMaxCapacity.map(_.size)\n        val\
    \ bucketsMaxSize = bucketsMaxSize.map(_.size)\n        val bucketsMaxCapacity\
    \ = bucketsMaxCapacity.map(_.size)\n        val bucketsMaxSize = bucketsMaxSize.map(_.size)\n\
    \        val bucketsMaxCapacity = bucketsMaxCapacity.map(_.size)\n        val\
    \ bucketsMaxSize = bucketsMaxSize.map(_.size)\n        val bucketsMaxCapacity\
    \ = bucketsMaxCapacity.map(_.size)\n        val bucketsMaxSize = bucketsMaxSize.map(_.size)\n\
    \        val bucketsMaxCapacity = bucketsMaxCapacity.map(_.size)\n        val\
    \ bucketsMaxSize = bucketsMaxSize.map(_.size)\n        val bucketsMaxCapacity\
    \ = bucketsMaxCapacity.map(_.size)\n        val bucketsMaxSize = bucketsMaxSize.map(_.size)\n\
    \        val bucketsMaxCapacity = bucketsMaxCapacity.map(_.size)\n        val\
    \ bucketsMaxSize = bucketsMaxSize.map(_.size)\n        val bucketsMaxCapacity\
    \ = bucketsMaxCapacity.map(_.size)\n        val bucketsMaxSize = bucketsMaxSize.map(_.size)\n\
    \        val bucketsMaxCapacity = bucketsMaxCapacity.map(_.size)\n        val\
    \ bucketsMaxSize = bucketsMaxSize.map(_.size)\n        val bucketsMaxCapacity\
    \ = bucketsMaxCapacity.map(_.size)\n        val bucketsMaxSize = bucketsMaxSize.map(_.size)\n\
    \        val bucketsMaxCapacity = bucketsMaxCapacity.map(_.size)\n        val\
    \ bucketsMaxSize = bucketsMaxSize.map(_.size)\n        val buckets\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpym93w8p7.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpym93w8p7.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsMaxSize\e[0m = bucketsMaxSize.map(_.toSet)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbucketsMaxSize is already defined as \e[33mvalue\e[0m \e[35mbucketsMaxSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpym93w8p7.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsMaxCapacity\e[0m = bucketsMaxCapacity.map(_.toSet)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMaxCapacity is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsMaxCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpym93w8p7.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsMaxSize\e[0m = bucketsMaxSize.map(_.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMaxSize is already defined as \e[33mvalue\e[0m \e[35mbucketsMaxSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpym93w8p7.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mbucketsMaxCapacity\e[0m = bucketsMaxCapacity.map(_.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMaxCapacity is already defined as \e[33mvalue\e[0m\
    \ \e[35mbucketsMaxCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that ov"
  stdout: ''
  timestamp: 1659978907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).map(_.size).max\n        val bucketsMap = buckets.map(_.toMap)\n\
    \        val bucketsMapWithCapacity = bucketsMap.mapValues(_.withCapacity(capacity))\n\
    \        val bucketsMapWithCapacityWithMax = bucketsMapWithCapacity.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMax = bucketsMapWithCapacityWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMax = bucketsMapWithCapacityWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMax = bucketsMapWithCapacityWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMax = bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\
    \ = bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\
    \ = bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\
    \ = bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\
    \ = bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\
    \ = bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \        val bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0xmn070_.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0xmn070_.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\e\
    [0m = bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.mapValues(_.withMax(maxBucket))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsMapWithCapacityWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMaxWithMax\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0xmn070_.scala:27:52 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxBucket\e[0m = buckets.maxBy(_.size).map(_.size).max\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value size is not a\
    \ member of Long\n\e[31m\e[31m-- Error: /tmp/tmp0xmn070_.scala:27:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxBucket\e[0m = buckets.maxBy(_.size).map(_.size).max\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m\
    \ \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e\
    [35mIterableOnceOps\e[0m\n\e[31m\e[31m-- Er"
  stdout: ''
  timestamp: 1659978909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.map(_.size).max\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSet = buckets.map(_.toSet)\n        val bucketsSetSize = bucketsSet.map(_.size).max\n\
    \        val maxBucketSet = bucketsSet.map(_.size).max\n        val maxBucketSetSize\
    \ = maxBucketSet * capacity\n        val bucketsSetSet = bucketsSet.map(_.toSet)\n\
    \        val bucketsSetSetSize = bucketsSetSet.map(_.size).max\n        val maxBucketSetSet\
    \ = bucketsSetSet.map(_.size).max\n        val maxBucketSetSetSize = maxBucketSetSet\
    \ * capacity\n        val bucketsSetSetSet = bucketsSetSet.map(_.toSet)\n    \
    \    val bucketsSetSetSetSize = bucketsSetSetSet.map(_.size).max\n        val\
    \ maxBucketSetSetSetSize = maxBucketSetSetSet * capacity\n        val bucketsSetSetSetSet\
    \ = bucketsSetSetSet.map(_.toSet)\n        val bucketsSetSetSetSetSize = bucketsSetSetSetSet.map(_.size).max\n\
    \        val maxBucketSetSetSetSetSize = maxBucketSetSetSetSet * capacity\n  \
    \      val bucketsSetSetSetSetSet = bucketsSetSetSetSet.map(_.toSet)\n       \
    \ val bucketsSetSetSetSetSetSize = bucketsSetSetSetSetSet.map(_.size).max\n  \
    \      val maxBucketSetSetSetSetSetSize = maxBucketSetSetSetSetSet * capacity\n\
    \        val bucketsSetSetSetSetSetSet = bucketsSetSetSetSetSetSet.map(_.toSet)\n\
    \        val bucketsSetSetSetSetSetSetSize = bucketsSetSetSetSetSetSet.map(_.size).max\n\
    \        val maxBucketSetSetSetSetSetSetSize = maxBucketSetSetSetSetSetSet * capacity\n\
    \        val bucketsSetSetSetSetSetSet = bucketsSetSetSetSetSetSet.map(_.toSet)\n\
    \        val bucketsSetSetSetSetSetSetSize = bucketsSetSetSetSetSetSet.map(_.size).max\n\
    \        val maxBucketSetSetSetSetSetSetSize = maxBucketSetSetSetSetSetSet * capacity\n\
    \        val bucketsSetSetSetSetSetSetSet = bucketsSetSetSetSetSetSetSet.map(_.toSet)\n\
    \        val bucketsSetSetSetSetSet\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptl4a2db_.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptl4a2db_.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSetSetSetSetSetSet\e[0m = bucketsSetSetSetSetSetSet.map(_.toSet)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSetSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSetSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptl4a2db_.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbucketsSetSetSetSetSetSetSize\e\
    [0m = bucketsSetSetSetSetSetSet.map(_.size).max\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSetSetSetSetSetSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSetSetSetSetSetSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptl4a2db_.scala:51:12 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketSetSetSetSetSetSetSize\e\
    [0m = maxBucketSetSetSetSetSetSet * capacity\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketSetSetSetSetSetSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mmaxBucketSetSetSetSetSetSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptl4a2db_.scala:39:37\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxBucketSetSetSetSize\e[0m = maxBucketSetSetSet * capaci"
  stdout: ''
  timestamp: 1659978908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 0) capacity else\
    \ 1).toList)\n        val maxBucket = buckets.map(_.max).max\n        val maxBucketIndex\
    \ = buckets.map(_.indexOf(maxBucket)).max\n        buckets(maxBucketIndex).map(x\
    \ => if (x == 0) capacity else 1).toList.sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4awz57_l.scala:32)\n\tat Problem.main(tmp4awz57_l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val bucketsCap = buckets.map(_.capacity).sum\n        val bucketsSum\
    \ = buckets.map(_.capacity).sum\n        val bucketsSumCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCap = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCap\
    \ = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCap = buckets.map(_.capacity).sum\n       \
    \ val bucketsSumCapCapCapCapCapCap = buckets.map(_.capacity).sum\n        val\
    \ bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCapCapCapCap\
    \ = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCapCapCapCap =\
    \ buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n \
    \       val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n  \
    \      val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n   \
    \     val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n \
    \       val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = bucket\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppg7tc8vi.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumCapCapCapCapCapCapCap\e\
    [0m = buckets.map(_.capacity).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppg7tc8vi.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.capacity).sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppg7tc8vi.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.capacity).sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppg7tc8vi.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.capacity).sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e["
  stdout: ''
  timestamp: 1659978911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toList).map(_.toSet).map(_.toList)\n\
    \        val maxBucket = buckets.maxBy(_.size)\n        val maxBucketSize = maxBucket.size\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCapacity.toLong\n        val maxBucketCapacity\
    \ = maxBucketCapacity.toLong\n        val maxBucketCapacity = maxBucketCapacity.toLong\n\
    \        val maxBucketCapacity = maxBucketCap\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmperx8vbj5.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmperx8vbj5.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmperx8vbj5.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmperx8vbj5.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucketCapacity.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacity is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketCapacity\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmperx8vbj5.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1659978908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val fill = bucketsSize\
    \ - maxBucketSize\n        fill\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppyrkc_b2.scala:34)\n\tat Problem.main(tmppyrkc_b2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid) {\n\
    \            wells.append(row)\n        }\n        wells.foreach(row => {\n  \
    \          val bucket = buckets.last\n            buckets += bucket\n        \
    \    val well = row.filter(_ != 0l)\n            val newBucket = bucket - well.length\n\
    \            if (newBucket <= capacity) {\n                buckets += newBucket\n\
    \                wells += well\n            }\n        })\n        wells.foldLeft(0l)\
    \ { (acc, well) => acc - well.length }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpycd64mj9.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpycd64mj9.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBuckets\
    \ = buckets.map(_.size).max\n        val maxBucketsCount = buckets.map(_.size).count\n\
    \        val bucketsCount = buckets.count\n        val bucketsSum = buckets.map(_.size).sum\n\
    \        val bucketsSumCount = buckets.map(_.size).count\n        val bucketsSumMax\
    \ = buckets.map(_.size).max\n        val bucketsSumMaxCount = buckets.map(_.size).count\n\
    \        val bucketsSumMin = buckets.map(_.size).min\n        val bucketsSumMinCount\
    \ = buckets.map(_.size).count\n        val bucketsSumSum = buckets.map(_.size).sum\n\
    \        val bucketsSumSumCount = buckets.map(_.size).count\n        val bucketsSumSumMax\
    \ = buckets.map(_.size).max\n        val bucketsSumSumMaxCount = buckets.map(_.size).count\n\
    \        val bucketsSumSumMin = buckets.map(_.size).min\n        val bucketsSumSumMinCount\
    \ = buckets.map(_.size).count\n        val bucketsSumSumSum = buckets.map(_.size).sum\n\
    \        val bucketsSumSumSumCount = buckets.map(_.size).count\n        val bucketsSumSumSumMax\
    \ = buckets.map(_.size).max\n        val bucketsSumSumSumMaxCount = buckets.map(_.size).count\n\
    \        val bucketsSumSumSumMin = buckets.map(_.size).min\n        val bucketsSumSumSumMinCount\
    \ = buckets.map(_.size).count\n        val bucketsSumSumSumSum = buckets.map(_.size).sum\n\
    \        val bucketsSumSumSumSumCount = buckets.map(_.size).count\n        val\
    \ bucketsSumSumSumSumMax = buckets.map(_.size).max\n        val bucketsSumSumSumSumMaxCount\
    \ = buckets.map(_.size).count\n        val bucketsSumSumSumSumMin = buckets.map(_.size).min\n\
    \        val bucketsSumSumSumSumMinCount = buckets.map(_.size).count\n       \
    \ val bucketsSumSumSumSumSum = buckets.map(_.size).sum\n        val bucketsSumSumSumSumSumCount\
    \ = buckets.map(_.size).count\n        val bucketsSumSumSumSumMax = buckets.map(_.size).max\n\
    \        val bucketsSumSumSumSumMaxCount = buckets.map(_.size).count\n       \
    \ val bucketsSum\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyon6w9s_.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyon6w9s_.scala:56:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumSumSumSumMax\e[0m = buckets.map(_.size).max\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbucketsSumSumSumSumMax is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsSumSumSumSumMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyon6w9s_.scala:57:12 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mbucketsSumSumSumSumMaxCount\e\
    [0m = buckets.map(_.size).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumSumSumSumMaxCount is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumSumSumSumMaxCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyon6w9s_.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[List[Long]]\n  \
    \      val bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacitySum = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacitySumCountMax = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacitySumCountMin = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCountMaxMin = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCapacitySumCountMaxMinMin = mutable.ArrayBuffer.empty[Long]\n       \
    \ val bucketsCapacitySumCountMaxMinMinMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacitySumCountMaxMinMinMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpve1d8a33.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpve1d8a33.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCapacitySumCountMaxMinMinMaxMax\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxMinMinMaxMax is already defined\
    \ as \e[33mvalue\e[0m \e[35mbucketsCapacitySumCountMaxMinMinMaxMax\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpve1d8a33.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySumCountMaxMinMinMaxMax\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxMinMinMaxMax is already defined\
    \ as \e[33mvalue\e[0m \e[35mbucketsCapacitySumCountMaxMinMinMaxMax\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpve1d8a33.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacitySumCountMaxMinMinMaxMax\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacitySumCountMaxMinMinMaxMax is already defined\
    \ as \e[33mvalue\e[0m \e[35mbucketsCapacitySumCountMaxMinMinMaxMax\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpve1d8a33.scala:40:12 ---------------------------\e[0m\e[0m\n"
  stdout: ''
  timestamp: 1659978909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBuckets\
    \ = buckets.map(_.size).max\n        val maxBucketsIndex = buckets.map(_.size).zipWithIndex.maxBy(_._1)._2\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsCap = buckets.map(_.capacity).sum\n\
    \        val bucketsIndex = buckets.zipWithIndex.maxBy(_._1)._2\n        val bucketsCapIndex\
    \ = buckets.zipWithIndex.maxBy(_._1)._2\n        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex = bucketsCapIndex.map(_._1)\n\
    \        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n        val bucketsCapIndex\
    \ = bucketsCapIndex.map(_._1)\n        val bucketsCapIndex = bucketsCapIndex.map(_._2)\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl6_r_h90.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapIndex\e[0m = bucketsCapIndex.map(_._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapIndex is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl6_r_h90.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapIndex\e[0m = bucketsCapIndex.map(_._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapIndex is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl6_r_h90.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapIndex\e[0m = bucketsCapIndex.map(_._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapIndex is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl6_r_h90.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapIndex\e[0m = bucketsCapIndex.map(_._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapIndex is already defined as \e[33mvalue\e[0m \e\
    [35mbucketsCapIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl6_r_h90.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapIndex\e[0"
  stdout: ''
  timestamp: 1659978912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val maxBucketSize = maxBucket * capacity\n\
    \        val bucketsSize = buckets.map(_.size).sum\n        val bucketsSizeDiff\
    \ = bucketsSize - maxBucketSize\n        val bucketsSizeDiffRatio = bucketsSizeDiff\
    \ / maxBucketSize\n        val bucketsSizeDiffRatioAbs = math.abs(bucketsSizeDiffRatio)\n\
    \        val bucketsSizeDiffRatioAbsMin = math.min(bucketsSizeDiffRatioAbs, 1)\n\
    \        val bucketsSizeDiffRatioAbsMax = math.max(bucketsSizeDiffRatioAbs, 1)\n\
    \        val bucketsSizeDiffRatioAbsMinMax = math.min(math.max(bucketsSizeDiffRatioAbsMin,\
    \ bucketsSizeDiffRatioAbsMax), 1)\n        val bucketsSizeDiffRatioAbsMinMaxMin\
    \ = math.min(math.max(bucketsSizeDiffRatioAbsMinMax, bucketsSizeDiffRatioAbsMin),\
    \ 1)\n        val bucketsSizeDiffRatioAbsMinMaxMinMin = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMin,\
    \ bucketsSizeDiffRatioAbsMin), 1)\n        val bucketsSizeDiffRatioAbsMinMaxMinMinMin\
    \ = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMin, bucketsSizeDiffRatioAbsMin),\
    \ 1)\n        val bucketsSizeDiffRatioAbsMinMaxMinMinMin = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMin,\
    \ bucketsSizeDiffRatioAbsMin), 1)\n        val bucketsSizeDiffRatioAbsMinMaxMinMinMin\
    \ = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMin, bucketsSizeDiffRatioAbsMin),\
    \ 1)\n        val bucketsSizeDiffRatioAbsMinMaxMinMinMinMin = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMinMin,\
    \ bucketsSizeDiffRatioAbsMin), 1)\n        val bucketsSizeDiffRatioAbsMinMaxMinMinMinMin\
    \ = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMinMin, bucketsSizeDiffRatioAbsMin),\
    \ 1)\n        val bucketsSizeDiffRatioAbsMinMaxMinMinMinMin = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMinMin,\
    \ bucketsSizeDiffRatioAbsMin), 1)\n        val bucketsSize\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxn0fet0n.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxn0fet0n.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSizeDiffRatioAbsMinMaxMinMinMin\e[0m = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMin,\
    \ bucketsSizeDiffRatioAbsMin), \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSizeDiffRatioAbsMinMaxMinMinMin is already defined\
    \ as \e[33mvalue\e[0m \e[35mbucketsSizeDiffRatioAbsMinMaxMinMinMin\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxn0fet0n.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsSizeDiffRatioAbsMinMaxMinMinMin\e\
    [0m = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMin, bucketsSizeDiffRatioAbsMin),\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSizeDiffRatioAbsMinMaxMinMinMin is already defined\
    \ as \e[33mvalue\e[0m \e[35mbucketsSizeDiffRatioAbsMinMaxMinMinMin\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxn0fet0n.scala:42:12 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36mbucketsSizeDiffRatioAbsMinMaxMinMinMinMin\e\
    [0m = math.min(math.max(bucketsSizeDiffRatioAbsMinMaxMinMinMin, bucketsSizeDiffRatioAbsMin),\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659978911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.map(x => if (x == 1l.toLong) capacity\
    \ else 0l))\n        val maxBucket = buckets.maxBy(_.length)\n        val maxBucketSize\
    \ = maxBucket.length\n        val maxBucketCapacity = maxBucket.map(_.length).sum\n\
    \        val maxBucketCapacityDiff = maxBucketCapacity - capacity\n        val\
    \ maxBucketCapacityDiffDiffRatio = maxBucketCapacityDiff / capacity\n        val\
    \ maxBucketCapacityDiffRatioAbs = maxBucketCapacityDiffRatio.abs\n        val\
    \ maxBucketCapacityDiffRatioAbsDiff = maxBucketCapacityDiffRatioAbs.abs\n    \
    \    val maxBucketCapacityDiffRatioAbsDiffRatio = maxBucketCapacityDiffRatioAbsDiff\
    \ / maxBucketCapacityDiffRatioAbs\n        val maxBucketCapacityDiffRatioAbsDiffRatioRatioAbs\
    \ = maxBucketCapacityDiffRatioAbsDiffRatio.abs\n        val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiff\
    \ = maxBucketCapacityDiffRatioAbsDiffRatioAbs.abs\n        val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatio\
    \ = maxBucketCapacityDiffRatioAbsDiffRatioAbsDiff / maxBucketCapacityDiffRatioAbsDiffRatioAbs\n\
    \        val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbs = maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatio.abs\n\
    \        val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiff = maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatio.abs\n\
    \        val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatio =\
    \ maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatio.abs\n       \
    \ val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatio = maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatioAbs.abs\n\
    \        val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatioAbs\
    \ = maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatioAbsDiff.abs\n\
    \        val maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatioAbsDiff\
    \ = maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatioAbs.abs\n\
    \        val maxBucketCapacityDiffRatioAbsDiffRatio\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2_j6i3nt.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2_j6i3nt.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatio\e[0m =\
    \ maxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatioAbs.abs\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatio\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxBucketCapacityDiffRatioAbsDiffRatioAbsDiffRatioAbsDiffRatio\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp2_j6i3nt.scala:29:48 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m = maxBucket.map(_.length).sum\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value length is not a\
    \ member of Long\n\e[31m\e[31m-- Error: /tmp/tmp2_j6i3nt.scala:29:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacity\e[0m =\
    \ maxBucket.map(_.length).sum\n\e[31m\e[31m   |\e[0m                         \
    \                                  ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m and \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e[0m \e\
    [35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e[0m \e\
    [35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp2_j6i3nt.scala:32:44 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketCapacityDiffRatioA"
  stdout: ''
  timestamp: 1659978911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCount = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCount = mutable.HashMap[Long, Long]()\n        val\
    \ bucket\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphdnvsyhm.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphdnvsyhm.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsCount\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphdnvsyhm.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphdnvsyhm.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphdnvsyhm.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCount is already defined as \e[33mvalue\e[0m \e[35mbucketsCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659978911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[Long]\n        val bucketsCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellsCount = mutable.ArrayBuffer.empty[Long]\n        val maxBuckets\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxWells = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCount = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n        val maxWellsCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val maxBucketsCounts = mutable.ArrayBuffer.empty[Long]\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpltd9h1bk.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCounts\e[0m =\
    \ mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCounts is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketsCounts\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpltd9h1bk.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWellsCounts is already defined as \e[33mvalue\e[0m \e[35mmaxWellsCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpltd9h1bk.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxBucketsCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxBucketsCounts is already defined as \e[33mvalue\e[0m \e\
    [35mmaxBucketsCounts\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpltd9h1bk.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxWellsCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWellsCounts is already defined as \e[33mvalue\e[0m \e[35mmaxWellsCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpltd9h1bk.scala:40:12 ---------"
  stdout: ''
  timestamp: 1659978912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer(capacity)\n        val\
    \ bucketsMap = mutable.HashMap[Long, Long]()\n        val bucketsMap2 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap3 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap4 = mutable.HashMap[Long, Long]()\n        val bucketsMap5 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap6 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap7 = mutable.HashMap[Long, Long]()\n        val bucketsMap8 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap9 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap10 = mutable.HashMap[Long, Long]()\n        val bucketsMap11 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap12 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap13 = mutable.HashMap[Long, Long]()\n        val bucketsMap14 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap15 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap16 = mutable.HashMap[Long, Long]()\n        val bucketsMap17 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap18 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap19 = mutable.HashMap[Long, Long]()\n        val bucketsMap20 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap21 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap22 = mutable.HashMap[Long, Long]()\n        val bucketsMap23 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap24 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap25 = mutable.HashMap[Long, Long]()\n        val bucketsMap26 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap27 = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsMap28 = mutable.HashMap[Long, Long]()\n        val bucketsMap29 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsMap30 = mutable.HashMap[Long, Long]()\n        val\
    \ buckets\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpalbjaxsw.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalbjaxsw.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalbjaxsw.scala:27:25\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsMap\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpalbjaxsw.scala:28:26 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap2\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalbjaxsw.scala:29:26\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsMap3\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpalbjaxsw.scala:30:26 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mbucketsMap4\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \     ^^^^^^^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1659978864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val m = grid.length\n        val n = grid(0).length\n  \
    \      val buckets = mutable.ArrayBuffer(capacity)\n        val bucketsCount =\
    \ mutable.ArrayBuffer(capacity)\n        val bucketsCount2 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount3 = mutable.ArrayBuffer(capacity)\n        val bucketsCount4\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount5 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount6 = mutable.ArrayBuffer(capacity)\n        val bucketsCount7\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount8 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount9 = mutable.ArrayBuffer(capacity)\n        val bucketsCount10\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount11 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount12 = mutable.ArrayBuffer(capacity)\n        val bucketsCount13\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount14 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount15 = mutable.ArrayBuffer(capacity)\n        val bucketsCount16\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount17 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount18 = mutable.ArrayBuffer(capacity)\n        val bucketsCount19\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount20 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount21 = mutable.ArrayBuffer(capacity)\n        val bucketsCount22\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount23 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount24 = mutable.ArrayBuffer(capacity)\n        val bucketsCount25\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount26 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount27 = mutable.ArrayBuffer(capacity)\n        val bucketsCount28\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount29 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount30 = mutable.ArrayBuffer(capacity)\n        val bucketsCount31\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount32 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount33 = mutable.ArrayBuffer(capacity)\n        val bucketsCount34\
    \ = mutable.ArrayBuffer(capacity)\n        val bucketsCount35 = mutable.ArrayBuffer(capacity)\n\
    \        val bucketsCount36 = mutable.ArrayBuffer(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkn00edcv.scala:64:49 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount36\e[0m = mutable.ArrayBuffer(\n\
    \e[31m\e[31m   |\e[0m                                                 ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkn00edcv.scala:28:22\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbuckets\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkn00edcv.scala:29:27\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCount\e[0m = mutable.ArrayBuffer(capacity)\n\e[31m\e[31m   |\e[0m \
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpkn00edcv.scala:30:28 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mbucketsCount2\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkn00edcv.scala:31:28 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount3\e[0m = mutable.ArrayBuffer(capacity)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkn00edcv.sca"
  stdout: ''
  timestamp: 1659978834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ bucketsCount = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n     \
    \   val bucketsCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n  \
    \      val bucketsCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacity =\
    \ mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ = mutable.ArrayBuffer.empty[Long]\n        val bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpit6p7in_.scala:52:11 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpit6p7in_.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacity\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpit6p7in_.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  bucketsCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCapacityCount\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpit6p7in_.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mbucketsCapacityCapacityCapacityC"
  stdout: ''
  timestamp: 1659794073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.ArrayBuffer.empty[Long]\n        val\
    \ wells = mutable.ArrayBuffer.empty[Long]\n        val bucketCapacity = mutable.ArrayBuffer.empty[Long]\n\
    \        val wellCapacity = mutable.ArrayBuffer.empty[Long]\n        grid.foreach(row\
    \ => {\n            row.foreach(well => {\n                wells += well\n   \
    \             buckets += 0\n                bucketCapacity += capacity\n     \
    \       })\n        })\n        val maxWells = wells.toList.max\n        val maxBuckets\
    \ = buckets.toList.max\n        val maxBucketCapacity = bucketCapacity.toList.max\n\
    \        val maxWellCapacity = wellCapacity.toList.max\n        val maxWellsCapacity\
    \ = maxWells * maxBucketCapacity\n        val maxBucketsCapacity = maxBuckets\
    \ * maxWellCapacity\n        val maxWellsCapacity2 = maxWells * maxWellCapacity\n\
    \        val maxBucketsCapacity2 = maxBuckets * maxBucketCapacity\n        val\
    \ maxBucketsCapacity3 = maxBuckets * maxBucketCapacity * maxWellCapacity\n   \
    \     val maxWellsCapacity3 = maxWells * maxWellCapacity * maxBucketCapacity\n\
    \        val maxWellsCapacity4 = maxWells * maxWellCapacity * maxBucketCapacity\
    \ * maxWellCapacity\n        val maxBucketsCapacity4 = maxBuckets * maxBucketCapacity\
    \ * maxWellCapacity * maxWellCapacity\n        val maxBucketsCapacity5 = maxBuckets\
    \ * maxBucketCapacity * maxWellCapacity * maxWellCapacity * maxBucketCapacity\n\
    \        val maxWellsCapacity5 = maxWells * maxWellCapacity * maxBucketCapacity\
    \ * maxWellCapacity * maxWellCapacity\n        val maxWellsCapacity6 = maxWells\
    \ * maxWellCapacity * maxBucketCapacity * maxWellCapacity * maxWellCapacity *\
    \ maxBucketCapacity\n        val maxBucketsCapacity6 = maxBuckets * maxBucketCapacity\
    \ * maxWellCapacity * maxWellCapacity * maxWellCapacity * maxWellCapacity\n  \
    \      val maxWellsCapacity7 = maxWells * maxWellCapacity * maxBucketCapacity\
    \ * maxWellCapacity * maxWellCapacity * maxWellCapacity * maxBucketCapacity\n\
    \        val maxBucketsCapacity7 = maxBuckets * maxBucketCapacity * maxWellCapacity\
    \ * maxWellCapacity * maxWellCapacity * maxWellCapacity * maxWellCapacity\n  \
    \      val maxWellsCapacity8 = maxWells * maxWellCapacity * maxBucketCapacity\
    \ * maxWellCapacity * maxWell\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxate3s5z.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxate3s5z.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mwells\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpxate3s5z.scala:28:29 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbucketCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpxate3s5z.scala:29:27 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mwellCapacity\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxate3s5z.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = mutable.HashMap[Long, Long]()\n        val\
    \ bucketsCount = mutable.HashMap[Long, Long]()\n        val bucketsCounts = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_ = mutable.HashMap[Long, Long]()\n      \
    \  val bucketsCounts_1 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_2\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_3 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_4 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_5 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_6\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_7 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_8 = mutable.HashMap[Long, Long]()\n     \
    \   val bucketsCounts_9 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_10\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_11 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_12 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_13 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_14\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_15 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_16 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_17 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_18\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_19 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_20 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_21 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_22\
    \ = mutable.HashMap[Long, Long]()\n        val bucketsCounts_23 = mutable.HashMap[Long,\
    \ Long]()\n        val bucketsCounts_24 = mutable.HashMap[Long, Long]()\n    \
    \    val bucketsCounts_25 = mutable.HashMap[Long, Long]()\n        val bucketsCounts_26\
    \ = mutable.HashMap[\n    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\
    \ == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp56s21l2d.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp56s21l2d.scala:26:22 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mbuckets\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbucketsCount\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp56s21l2d.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mbucketsCounts_\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56s21l2d.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mbucketsCounts_1\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31"
  stdout: ''
  timestamp: 1659978821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n    // and each 1 in a row represents a single unit of water.\n    //\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n    // and all buckets have the same capacity.\n    // Your task is to\
    \ use the buckets to empty the wells.\n    // Output the number of times you need\
    \ to lower the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n\
    \    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
    \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
    \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n\
    \    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    //\
    \ * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long)\
    \ : Long = {\n        val buckets = grid.map(_.toSet)\n        val maxBucket =\
    \ buckets.maxBy(_.size).size\n        val bucketsSize = buckets.map(_.size).sum\n\
    \        val bucketsCap = buckets.map(_.capacity).sum\n        val bucketsSum\
    \ = buckets.map(_.capacity).sum\n        val bucketsSumCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCap = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCap\
    \ = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCap = buckets.map(_.capacity).sum\n       \
    \ val bucketsSumCapCapCapCapCapCap = buckets.map(_.capacity).sum\n        val\
    \ bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCapCapCapCap\
    \ = buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCapCapCapCap =\
    \ buckets.map(_.capacity).sum\n        val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n \
    \       val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCapCapCapCapCapCapCapCapCap = buckets.map(_.capacity).sum\n\
    \        val bucketsSumCapCap\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong,\
    \ 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\
    \ == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
    \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4hif6ipa.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4hif6ipa.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.capacity).sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4hif6ipa.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.capacity).sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4hif6ipa.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.capacity).sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbucketsSumCapCapCapCapCapCapCap is already defined as \e[33mvalue\e\
    [0m \e[35mbucketsSumCapCapCapCapCapCapCap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4hif6ipa.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbucketsSumCapCapCapCapCapCapCap\e[0m = buckets.map(_.capacity).sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^"
  stdout: ''
  timestamp: 1659978913
