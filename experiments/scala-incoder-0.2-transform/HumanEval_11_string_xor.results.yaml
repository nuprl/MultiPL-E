language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for (i <- 0 until aList.length)\n            carry += aList(i)\
    \ xor bList(i)\n        carry += carry\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ifhtnal.scala:14:18 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            carry += aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp3ifhtnal.scala:14:30 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m            carry += aList(i) xor bList(i)\n\e[31m\e[31m   |\e[0m    \
    \                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     value\
    \ xor is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ifhtnal.scala:17:14\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        carry += aList(aList.length)\
    \ xor bList(aList.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        value += is not a member of Int - did you mean Int.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3ifhtnal.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        carry += aList(aList.length) xor bList(aList.length)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 value xor is not a member of Char\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp3ifhtnal.scala:19:14 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        carry += aList(aList.length) xor bList(aList.length)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3ifhtnal.scala:19:37 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        carry += aList(aList.length) xor bList(aList.length)\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \            value xor is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp3ifhtnal.scala:21:14 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        carry += aList(aList.length) xor bList(aList.length)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Fou"
  stdout: ''
  timestamp: 1659793177
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(_ + 48).toString\n        xorBitsString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbue24bg3.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbue24bg3.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n    \
    \    for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n     \
    \   xorList.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp13eal9s2.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.substring(0,xorBitsString.length-1)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuy2nu7rm.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithLeadingZeros = \"\
    0\" + xorBitsString\n        val xorBitsStringWithTrailingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        xorBitsStringWithTrailingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo65oanwt.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      val len = aList.size + bList.size\n        var i = 0\n        while (i\
    \ < len) {\n            val aChar = aList(i)\n            val bChar = bList(i)\n\
    \            if (aChar == '0' && bChar == '0') {\n                result.append(\"\
    0\")\n            } else if (aChar == '0' && aChar == '1') {\n               \
    \ result.append(\"1\")\n            } else if (bChar == '0' && bChar == '1') {\n\
    \                result.append(\"1\")\n            } else {\n                result.append(\"\
    0\")\n            }\n            i += 1\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpteu1cc8b.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val aLen = aList.length\n        val bLen = bList.length\n\
    \        val result = new StringBuilder(aLen)\n        var i = 0\n        while\
    \ (i < aLen) {\n            result.append(aList(i) ^ bList(i))\n            i\
    \ += 1\n        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<- 0 until xorBitsStringLength) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcyomo_0p.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until a.length) {\n            val\
    \ aBit = aBits(i)\n            val bBit = bBits(i)\n            val xor = aBit\
    \ ^ bBit ^ carry\n            carry = xor >> 1\n            result.append(xor\
    \ & 1)\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp04ijd006.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp04ijd006.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp04ijd006.scala:11:25 ------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m\
    \ mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new Array[Int](a.length)\n\
    \        var i = 0\n        while (i < a.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(result)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxyasiuc.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value xor is not a member of Int\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpqxyasiuc.scala:17:12 -----------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(result)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((result : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits.toInt\n\
    \            val bBit = bBits.toInt\n            val aChar = a(i).toChar\n   \
    \         val bChar = b(i).toChar\n            val aBit = aBit + aChar.toInt *\
    \ bChar.toInt\n            val aBit = aBit + carry\n            val aBit = aBit\
    \ % 2\n            val aBit = aBit == 1 ? \"1\" : \"0\"\n            val aBits\
    \ = aBit + bBits.toInt\n            val aBits = aBits % 2\n            val aBits\
    \ = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n      \
    \      val aBits = aBits % 2\n            val aBits = aBits == 1 ? \"1\" : \"\
    0\"\n            val aBits = aBits + carry\n            val aBits = aBits % 2\n\
    \            val aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits\
    \ + carry\n            val aBits = aBits % 2\n            val aBits = aBits ==\
    \ 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n            val aBits\
    \ = aBits % 2\n            val aBits = aBits == 1 ? \"1\" : \"0\"\n          \
    \  val aBits = aBits + carry\n            val aBits = aBits % 2\n            val\
    \ aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n\
    \            val aBits = aBits % 2\n            val aBits = aBits == 1 ? \"1\"\
    \ : \"0\"\n            val aBits = aBits + carry\n            val aBits = aBits\
    \ % 2\n            val aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits\
    \ = aBits + carry\n            val aBits = aBits % 2\n            val aBits =\
    \ aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n        \
    \    val aBits = aBits % 2\n            val aBits = aBits == 1 ? \"1\" : \"0\"\
    \n            val aBits = aBits + carry\n            val aBits = aBits % 2\n \
    \           val aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits\
    \ + carry\n            val aBit\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8t4xf4q_.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8t4xf4q_.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t4xf4q_.scala:19:16 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit + aChar.toInt *\
    \ bChar.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBit is already defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8t4xf4q_.scala:20:16 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit + carry\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maBit is already\
    \ defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8t4xf4q_.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit % \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0maBit is already defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8t4xf4q_.scala:22:16 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit == \e[31m1\e[0m ? \e\
    [31m\"1\"\e[0m : \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBit is already defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ var i = 0\n        while (i < aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n  \
    \          val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9l399x2i.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:30:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:32:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:33:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9l399x2i.scala:36:57\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntI"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      var carry = 0\n        for(i <- 0 until aList.length){\n            val\
    \ aChar = aList(i)\n            val bChar = bList(i)\n            val xor = aChar\
    \ xor bChar\n            val newCarry = xor & 1\n            val newChar = xor\
    \ >> 1\n            val newCharString = Integer.toBinaryString(newChar)\n    \
    \        val newCarryString = Integer.toBinaryString(newCarry)\n            val\
    \ newString = newCharString + newCarryString\n            result.add(newString)\n\
    \            carry = newCarry\n        }\n        if(carry != 0){\n          \
    \  result.add(\"1\")\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9c8zmgdn.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9c8zmgdn.scala:16:28\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m\
    \ \e[36mxor\e[0m = aChar xor bChar\n\e[31m\e[31m   |\e[0m                    \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value xor is not a member\
    \ of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val aLen = a.length\n        val bLen\
    \ = b.length\n        val result = new StringBuilder(aLen)\n        var i = 0\n\
    \        while (i < aLen && i < bLen) {\n            result.append(aArray(i) XOR\
    \ bArray(i))\n            i += 1\n        }\n        result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1yzrrrxa.scala:16:36 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            result.append(aArray(i) XOR bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array[Int]()\n\
    \        var xor = 0\n        var i = 0\n        while (i < aArray.length) {\n\
    \            xor = xor + aArray(i) ^ bArray(i)\n            xorArray = xorArray\
    \ :+ xor\n            i = i + 1\n        }\n        xorArray.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkya2ot5d.scala:16:21 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            xorArray = xorArray :+ xor\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Reassignment to val xorArray\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            xorArray += (aArray(i) xor\
    \ bArray(i))\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfeuuoii.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ xor bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl49c0ick.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ XOR bList(i)\n            i += 1\n        }\n        xorList.toList.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp37yr2y_3.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.append(xorBitsString)\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp7k83bek.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpp7k83bek.scala:15:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmpp7k83bek.scala:17:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n3 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for (i <- 0 until aList.length)\n        {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val aInt = aChar match\
    \ {\n                case '1' => 1\n                case '0' => 0\n          \
    \      case _ => throw new IllegalArgumentException(\"Invalid character \" + aChar)\n\
    \            }\n            val bInt = bChar match {\n                case '1'\
    \ => 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + bChar)\n            }\n            val aInt = aInt XOR\
    \ bInt\n            val aChar = aInt match {\n                case 0 => '0'\n\
    \                case 1 => '1'\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + aInt)\n            }\n            result.append(aChar)\n\
    \            carry = aInt XOR bInt XOR carry\n        }\n        if (carry !=\
    \ 0)\n            result.append(carry)\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmparbt6ipg.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36maInt\e[0m = aInt XOR\
    \ bInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0maInt is already defined as \e[33mvalue\e[0m \e[35maInt\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmparbt6ipg.scala:28:16 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            \e[33mval\e[0m \e[36maChar\e[0m = aInt \e[33mmatch\e[0m {\n\
    \e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0maChar is already defined\
    \ as \e[33mvalue\e[0m \e[35maChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m29 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => \e[31m'0'\e[0m\n\
    \e[31m30 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => \e[31m'1'\e[0m\n\
    \e[31m31 |\e[0m                \e[33mcase\e[0m _ => \e[33mthrow\e[0m \e[33mnew\e\
    [0m \e[35mIllegalArgumentException\e[0m(\e[31m\"Invalid character \"\e[0m + aInt)\n\
    \e[31m32 |\e[0m            }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmparbt6ipg.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            carry = aInt\
    \ XOR bInt XOR carry\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    value XOR is not a member of Int\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      for( i <- 0 until aList.size ) {\n            if( aList(i) XOR bList(i)\
    \ == 1 ) {\n                result += \"1\"\n            } else {\n          \
    \      result += \"0\"\n            }\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkogh5ll.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnkogh5ll.scala:13:25\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m(\
    \ aList(i) XOR bList(i) == \e[31m1\e[0m ) {\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value XOR is not a member\
    \ of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978611
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     var i = 0\n        while (i < a.length) {\n            result.append(aArray(i)\
    \ ^ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        var result = \"\"\n        var carry\
    \ = 0\n        var i = 0\n        var j = 0\n        while (i < a.length && j\
    \ < b.length) {\n            val aChar = aArray(i)\n            val bChar = bArray(j)\n\
    \            val aInt = aChar match {\n                case '1' => 1\n       \
    \         case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid input\")\n            }\n            val bInt = bChar match {\n      \
    \          case '1' => 1\n                case '0' => 0\n                case\
    \ _ => throw new IllegalArgumentException(\"Invalid input\")\n            }\n\
    \            val aInt2 = aInt XOR bInt\n            val aInt3 = aInt2 XOR carry\n\
    \            val aInt4 = aInt3 XOR 1\n            val aInt5 = aInt4 XOR 1\n  \
    \          val aInt6 = aInt5 XOR 1\n            val aInt7 = aInt6 XOR 1\n    \
    \        val aInt8 = aInt7 XOR 1\n            val aInt9 = aInt8 XOR 1\n      \
    \      val aInt10 = aInt9 XOR 1\n            val aInt11 = aInt10 XOR 1\n     \
    \       val aInt12 = aInt11 XOR 1\n            val aInt13 = aInt12 XOR 1\n   \
    \         val aInt14 = aInt13 XOR 1\n            val aInt15 = aInt14 XOR 1\n \
    \           val aInt16 = aInt15 XOR 1\n            val aInt17 = aInt16 XOR 1\n\
    \            val aInt18 = aInt17 XOR 1\n            val aInt19 = aInt18 XOR 1\n\
    \            val aInt20 = aInt19 XOR 1\n            val aInt21 = aInt20 XOR 1\n\
    \            val aInt22 = aInt21 XOR 1\n            val aInt23 = aInt22 XOR 1\n\
    \            val aInt24 = aInt23 XOR 1\n            val aInt25 = aInt24 XOR 1\n\
    \            val aInt26 = aInt25 XOR 1\n            val aInt27 = aInt26 XOR 1\n\
    \            val aInt28 = aInt27 XOR 1\n            val aInt29 = aInt28 XOR 1\n\
    \            val aInt30 = aInt29 XOR 1\n            val aInt31 = aInt30 XOR 1\n\
    \            val aInt32 = aInt31 XOR 1\n            val aInt33 = aInt32 XOR \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq7r3xgno.scala:59:35 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e[0m \e[36maInt33\e[0m = aInt32\
    \ XOR \n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq7r3xgno.scala:68:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpq7r3xgno.scala:28:29 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m            \e[33mval\e[0m \e[36maInt2\e[0m = aInt XOR bInt\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                    value XOR is not a member of Int\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpq7r3xgno.scala:67:1 ---------------------\e[0m\e[0m\n\
    \e[31m67 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpq7r3xgno.scala:61:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m61 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659978613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(0,xorBitsString.length-1)\n        xorBitsStringWithoutLeadingZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc043e832.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        val length = math.min(aBits,\
    \ bBits)\n        val aBitsRemaining = aBits % 8\n        val bBitsRemaining =\
    \ bBits % 8\n        val aBitsRemainingBits = 8 - aBitsRemaining\n        val\
    \ bBitsRemainingBits = 8 - bBitsRemaining\n        val aBitsRemainingBitsBits\
    \ = aBitsRemainingBits + bBitsRemainingBits\n        val aBitsRemainingBitsBitsBitsBitsBits\
    \ = aBitsRemainingBitsBits * 8 + aBitsRemainingBitsBitsBits\n        val bBitsRemainingBitsBitsBitsBitsBits\
    \ = bBitsRemainingBitsBits * 8 + bBitsRemainingBitsBitsBitsBits\n        val aBitsRemainingBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBit\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9wgb7hg8.scala:21:4 ----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9wgb7hg8.scala:18:78\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36maBitsRemainingBitsBitsBitsBitsBits\e[0m = aBitsRemainingBitsBits * \e[31m8\e\
    [0m + aBitsRemainingBitsBitsBits\n\e[31m\e[31m   |\e[0m                      \
    \                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: aBitsRemainingBitsBitsBits\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9wgb7hg8.scala:19:49\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mbBitsRemainingBitsBitsBitsBitsBits\e[0m = bBitsRemainingBitsBits * \e[31m8\e\
    [0m + bBitsRemainingBitsBitsBitsBits\n\e[31m\e[31m   |\e[0m                  \
    \                               ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                      Not found: bBitsRemainingBitsBits\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wgb7hg8.scala:21:5 ---------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659978611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     var carry = 0\n        for (i <- 0 until aArray.length) {\n            val\
    \ aChar = aArray(i)\n            val bChar = bArray(i)\n            val xor =\
    \ aChar xor bChar\n            val newCarry = xor and carry\n            carry\
    \ = newCarry xor carry\n            result.append(newCarry)\n        }\n     \
    \   result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd_r3rbbo.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new mutable.StringBuilder\n\
    \        var i = 0\n        while (i < aArray.length) {\n            result.append(aArray(i)\
    \ XOR bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppk2ron5k.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toIntArray\n    \
    \    val bArray = b.toIntArray\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until aArray.length) {\n         \
    \   val aVal = aArray(i)\n            val bVal = bArray(i)\n            val xorVal\
    \ = aVal ^ bVal + carry\n            carry = xorVal / 2\n            result.append(xorVal)\n\
    \        }\n        if (carry != 0) {\n            result.append(carry)\n    \
    \    }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp17ajqxi2.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maArray\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m   \
    \                  value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp17ajqxi2.scala:10:23 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbArray\e[0m = b.toIntArray\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                    value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp17ajqxi2.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits.toInt\n\
    \            val bBit = bBits.toInt\n            val aBitInt = aBit + carry\n\
    \            val bBitInt = bBit + carry\n            val aBitString = aBitInt.toString\n\
    \            val bBitString = bBitInt.toString\n            val aBitStringLen\
    \ = aBitString.length\n            val bBitStringLen = bBitString.length\n   \
    \         val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9lk15eir.scala:49:15 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9lk15eir.scala:58:0 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9lk15eir.scala:25:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36maBitStringLenInt\e[0m = aBitStringLen.toInt\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maBitStringLenInt\
    \ is already defined as \e[33mvalue\e[0m \e[35maBitStringLenInt\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9lk15eir.scala:26:16 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36mbBitStringLenInt\e[0m = bBitStringLen.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBitStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35mbBitStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9lk15eir.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36maBitStringLenInt\e[0m\
    \ = aBitStringLen.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35maBitStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9lk15eir.scala:28:16 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        var xor = 0\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xor = xor + aArray(i) xor bArray(i)\n            i = i + 1\n    \
    \    }\n        xor.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg73uuxq2.scala:15:34 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits & (1 <<\
    \ (a.length - i - 1))\n            val bBit = bBits & (1 << (b.length - i - 1))\n\
    \            val aBitXor = bBit ^ aBit\n            val aBitAndCarry = aBit &\
    \ carry\n            val aBitAndCarryXor = aBitAndCarry ^ aBitXor\n          \
    \  val aBitAndCarryAndCarry = aBitAndCarry & aBitAndCarryXor\n            val\
    \ aBitAndCarryAndCarryXor = aBitAndCarryAndCarry ^ aBitAndCarryXor\n         \
    \   val aBitAndCarryAndCarryAndCarry = aBitAndCarryAndCarry & aBitAndCarryAndCarryXor\n\
    \            val aBitAndCarryAndCarryAndCarryXor = aBitAndCarryAndCarryAndCarry\
    \ ^ aBitAndCarryXor\n            val aBitAndCarryAndCarryAndCarryAndCarry = aBitAndCarryAndCarryAndCarry\
    \ & aBitAndCarryAndCarryAndCarryXor\n            val aBitAndCarryAndCarryAndCarryAndCarryXor\
    \ = aBitAndCarryAndCarryAndCarryAndCarry ^ aBitAndCarryXor\n            val aBitAndCarryAndCarryAndCarryAndCarryAndCarry\
    \ = aBitAndCarryAndCarryAndCarryAndCarry & aBitAndCarryAndCarryAndCarryAndCarryXor\n\
    \            val aBitAndCarryAndCarryAndCarryAndCarryAndCarryXor = aBitAndCarryAndCarryAndCarryAndCarryAndCarry\
    \ ^ aBitAndCarryXor\n            val aBitAndCarryAndCarryAndCarryAndCarryAndCarryAndCarry\
    \ = aBitAndCarryAnd\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnqnfndy5.scala:37:0 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnqnfndy5.scala:28:71\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m\
    \ \e[36maBitAndCarryAndCarryAndCarryAndCarryAndCarryAndCarry\e[0m = aBitAndCarryAnd\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                      Not found: aBitAndCarryAnd\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpnqnfndy5.scala:36:1 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpnqnfndy5.scala:30:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m30 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new Array[Int](a.length)\n\
    \        var i = 0\n        while (i < a.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(result)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxyasiuc.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value xor is not a member of Int\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpqxyasiuc.scala:17:12 -----------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(result)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((result : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        var result = \"\"\n        var i = 0\n\
    \        var j = 0\n        while (i < a.length && j < b.length) {\n         \
    \   if (aArray(i) XOR bArray(j) == 1) {\n                result += aArray(i)\n\
    \                i += 1\n                j += 1\n            } else if (aArray(i)\
    \ XOR bArray(j) == 0) {\n                result += aArray(i)\n               \
    \ i += 1\n            } else {\n                result += bArray(j)\n        \
    \        j += 1\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp719jgyaq.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (aArray(i) XOR bArray(j) ==\
    \ \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                value XOR is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp719jgyaq.scala:19:33 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (aArray(i)\
    \ XOR bArray(j) == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                    \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value XOR is not\
    \ a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ a.zip(b).map { case (a, b) => a ^ b }\n        xor.foreach { x => result.append(x)\
    \ }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.append(xorBitsString)\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnw8vo_b0.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2jxp4fbz.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        val xorBitsIndex = 0\n        for (aBit <- 0 until aBits.length;\
    \ bBit <- 0 until bBits.length) {\n            val aBit = aBits(aBit)\n      \
    \      val bBit = bBits(bBit)\n            xorBits(xorBitsIndex) = aBit ^ bBit\n\
    \            xorBitsIndex += 1\n        }\n        xorBits.map(_.toString.toInt).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_o9qs2t.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph_o9qs2t.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph_o9qs2t.scala:17:25 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            xorBitsIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value += is not a\
    \ member of Int - did you mean xorBitsIndex.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659978613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 xor x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppk7c60bh.scala:11:52 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = aList.zip(bList).map(\e\
    [36mx\e[0m => x._1 xor x._2).mkString\n\e[31m\e[31m   |\e[0m                 \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                       value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val result = new StringBuilder\n        val xorResult\
    \ = scala.math.xor.xor(aBits, bBits)\n        val bits = xorResult match {\n \
    \           case 0 => \"\"\n            case 1 => result.append(0)\n         \
    \   case _ => result.append(1)\n        }\n        result.toString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkl7qnd9z.scala:12:35 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = scala.math.xor.xor(aBits,\
    \ bBits)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        value xor is not a member of math\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978611
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 ^ x._2)\n        val xorString =\
    \ xorArray.toString.map(_.toChar).mkString(\"\")\n        xorString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppphnp1fx.scala:18)\n\tat Problem.main(tmppphnp1fx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<-xorBitsStringLength to 0) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9yv0iiy5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val aLen = aList.size\n        val bLen = bList.size\n\
    \        val result = new StringBuilder\n        var i = 0\n        while (i <\
    \ aLen && i < bLen) {\n            if (aList(i) XOR bList(i) == 1) {\n       \
    \         result.append((aList(i) XOR bList(i)))\n                i += 1\n   \
    \         } else {\n                result.append((aList(i) XOR bList(i)))\n \
    \           }\n        }\n        if (i < aLen) {\n            while (i < aLen)\
    \ {\n                result.append((aList(i) XOR 0))\n                i += 1\n\
    \            }\n        }\n        if (i < bLen) {\n            while (i < bLen)\
    \ {\n                result.append((0 XOR bList(i)))\n                i += 1\n\
    \            }\n        }\n        return result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppbw65420.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (aList(i) XOR bList(i) == \e\
    [31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value XOR is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppbw65420.scala:17:40 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                result.append((aList(i) XOR bList(i)))\n\e\
    [31m\e[31m   |\e[0m                               ^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                               value XOR is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppbw65420.scala:20:40 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                result.append((aList(i) XOR bList(i)))\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               value XOR is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmppbw65420.scala:25:40 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                result.append((aList(i) XOR \e[31m0\e\
    [0m))\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value XOR is not a member of Char\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppbw65420.scala:31:33 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                result.append((\e[31m0\e[0m XOR bList(i)))\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                               value XOR is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1659978621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<-xorBitsStringLength to 0) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9yv0iiy5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ xor bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl49c0ick.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits XOR bBits\n        val\
    \ xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n       \
    \ xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6k_de47.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpw6k_de47.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i) xor bBits(i)\n            i += 1\n        }\n\
    \        xorBits.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcgsnfx2p.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcgsnfx2p.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toList.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2wxbdf16.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp49rlj__b.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        for(i <- 0 until xorBits.length)\n            xorBits(i) = aBits(i) !=\
    \ bBits(i) ? '1' : '0'\n        xorBits.mkString(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6f8m728g.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6f8m728g.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.reverse\n  \
    \      return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp74rjo9h2.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        var i = 0\n        while (i < a.length) {\n            result.append(aArray(i)\
    \ xor bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5fgi1fww.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toList.reverse.mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw2wu_59f.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        for(i\
    \ <- 0 until a.length){\n            val aBit = aBits & (1 << i)\n           \
    \ val bBit = bBits & (1 << i)\n            val aBitsDiff = aBit ^ bBit\n     \
    \       val aBitsDiffBits = aBitsDiff >> 1\n            val aBitsDiffBitsString\
    \ = aBitsDiffBits.toString.reverse\n            val aBitsDiffBitsStringLength\
    \ = a.length - i\n            val aBitsDiffBitsStringLengthString = a.length -\
    \ i\n            val aBitsDiffBitsStringLengthStringReversed = aBitsDiffBitsStringLengthString.reverse\n\
    \            val aBitsDiffBitsStringLengthStringReversedString = aBitsDiffBitsStringLengthStringReversed.reverse\n\
    \            val aBitsDiffBitsStringLengthStringReversedStringLength = a.length\
    \ - i - 1\n            val aBitsDiffBitsStringLengthStringReversedStringLength\
    \ = aBitsDiffBitsStringLengthStringReversedString.length\n            val aBitsDiffBitsStringLengthStringReversedStringLengthString\
    \ = aBitsDiffBitsStringLengthStringReversedStringLength.toString.reverse\n   \
    \         val aBitsDiffBitsStringLengthStringReversedStringLengthStringLength\
    \ = a.length - i - 2\n            val aBitsDiffBitsStringLengthStringReversedStringLengthStringLength\
    \ = aBitsDiffBitsStringLengthStringReversedStringLengthStringLength.toString.reverse\n\
    \            val aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthString\
    \ = aBitsDiffBitsStringLengthStringReversedStringLengthStringLength.toString.reverse\n\
    \            val aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthStringLength\
    \ = aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthStringLength.toString.reverse\n\
    \            val aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthStringLength\
    \ = aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthStringLength.toString.reverse\n\
    \            val aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthStringLength\
    \ = aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthStringLength.toString.reverse\n\
    \            val aBitsDiffBitsStringLengthStringReversedStringLengthStringLengthStringLengthString\
    \ = aBitsDiffBitsStringLengthStringReversedStringLength\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx278f2c3.scala:41:0 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx278f2c3.scala:24:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e\
    [0m \e[36maBitsDiffBitsStringLengthStringReversedStringLength\e[0m = aBitsDiffBitsStringLengthStringReversedString.length\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitsDiffBitsStringLengthStringReversedStringLength is already\
    \ defined as \e[33mvalue\e[0m \e[35maBitsDiffBitsStringLengthStringReversedStringLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx278f2c3.scala:27:16 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m            \e[33mval\e[0m \e[36maBitsDiffBitsStringLengthStringReversedStringLengthStringLength\e\
    [0m = aBitsDiffBitsStringLengthStringReversedStringLengthStringLength.toString.reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitsDiffBitsStringLengthStringReversedStringLengthStringLength\
    \ is already defined as \e[33mvalue\e[0m \e[35maBitsDiffBitsStringLengthStringReversedStringLengthStringLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpx278f2c3.scala:21:90 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            \e[33mval\e[0m \e[36maBitsDiffBitsStringLengthStringReversed\e\
    [0m = aBitsDiffBitsStringLengthString.reverse\n\e[31m\e[31m   |\e[0m         \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value rever"
  stdout: ''
  timestamp: 1659978624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      var carry = 0\n        for (i <- 0 until aList.size) {\n            val\
    \ aChar = aList(i)\n            val bChar = bList(i)\n            val xor = aChar\
    \ xor bChar\n            val newCarry = xor and carry\n            carry = newCarry\
    \ xor carry\n            result.append(newCarry)\n        }\n        carry match\
    \ {\n            case 0 => result.reverse\n            case _ => result.reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb4b0i9oy.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb4b0i9oy.scala:16:28\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m\
    \ \e[36mxor\e[0m = aChar xor bChar\n\e[31m\e[31m   |\e[0m                    \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value xor is not a member\
    \ of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        val xorResult = Array.ofDim[Int](aBits.length)\n        val xorResultIndex\
    \ = 0\n        val xorBitIndex = 0\n        for(i <- 0 until aBits.length){\n\
    \            xorBits(xorBitIndex) = aBits(i) xor bBits(i)\n            xorResultIndex\
    \ += 1\n            xorResult(xorResultIndex) = xorBits(xorBitIndex)\n       \
    \     xorBitIndex += 1\n        }\n        xorResult.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaevgy8w_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpaevgy8w_.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpaevgy8w_.scala:17:27 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            xorResultIndex += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is\
    \ not a member of Int - did you mean xorResultIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpaevgy8w_.scala:19:24 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            xorBitIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a\
    \ member of Int - did you mean xorBitIndex.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659978624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val aLen = aList.length\n        val bLen = bList.length\n\
    \        val result = new Array[String](aLen)\n        var i = 0\n        while\
    \ (i < aLen) {\n            result(i) = aList(i) xor bList(i)\n            i +=\
    \ 1\n        }\n        new String(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpngrix6o5.scala:16:33 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            result(i) = aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                  value xor is not a member of Char\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpngrix6o5.scala:19:12 -----------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(result)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((result : Array[String]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for (i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv9n87vu9.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        var xor = 0\n        for(i <- 0 until aArray.length) xor += (aArray(i)\
    \ xor bArray(i))\n        xorArray = xorArray.toArray\n        new String(xorArray.reverse.map(_.toChar).mkString)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_hh3zu5e.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_hh3zu5e.scala:13:44 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aArray.length)\
    \ xor += (aArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m                    \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp_hh3zu5e.scala:13:58 ------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aArray.length) xor += (aArray(i)\
    \ xor bArray(i))\n\e[31m\e[31m   |\e[0m                                      \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \         value xor is not a member of Int\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp_hh3zu5e.scala:14:17 -----------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        xorArray = xorArray.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val xorArray\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        var xor = 0\n        for (i <- 0 until xorArray.length)\n           \
    \ xor = xor + aArray(i) xor bArray(i)\n        xorArray.toString.toCharArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzzzg5qta.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzzzg5qta.scala:15:8 ---------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        xorArray.toString.toCharArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[Char]\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val result = xorBitsString.reverse\n     \
    \   return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwpg42bwb.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      for(i <- 0 until aList.length) result += (aList(i) XOR bList(i)).toString.toChar\n\
    \        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvoat9d7l.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar xor bChar\n        }\n        xorList.toList.reverse.mkString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3xscoexp.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            for(j <- 0 until bArray.length)\n\
    \                xorArray.append(aArray(i) xor bArray(j))\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1vli5774.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.size) {\n            val aChar = aList(i)\n         \
    \   val bChar = bList(i)\n            val aInt = aChar match {\n             \
    \   case '1' => 1\n                case '0' => 0\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character \" + aChar)\n            }\n\
    \            val bInt = bChar match {\n                case '1' => 1\n       \
    \         case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + bChar)\n            }\n            val aAndB = aInt & bInt\n\
    \            val aOrB = aInt | bInt\n            val aXorB = aAndB ^ aOrB\n  \
    \          val aAndBAndC = aAndB & aXorB\n            val aAndBOrC = aAndB | aXorB\n\
    \            val aAndBXorC = aAndB ^ aAndBOrC\n            val aAndBAndCAndD =\
    \ aAndBAndC & aAndBXorC\n            val aAndBAndCAndDAndE = aAndBAndCAndD & aAndBXorC\n\
    \            val aAndBAndCAndDAndEAndF = aAndBAndCAndDAndE & aAndBXorC\n     \
    \       val aAndBAndCAndDAndEAndFAndG = aAndBAndCAndDAndEAndF & aAndBXorC\n  \
    \          val aAndBAndCAndDAndEAndFAndGAndH = aAndBAndCAndDAndEAndFAndG & aAndBXorC\n\
    \            val aAndBAndCAndDAndEAndFAndGAndHAndI = aAndBAndCAndDAndEAndFAndGAndH\
    \ & aAndBXorC\n            val aAndBAndCAndDAndEAndFAndGAndHAndIAndJ = aAndBAndCAndDAndEAndFAndGAndHAndIAndJ\
    \ & aAndBXorC\n            val aAndBAndCAndDAndEAndFAndGAndHAndIAndJAndK = aAndBAndCAndDAndEAndFAndGAndHAndIAndJAndK\
    \ & aAndBXorC\n            val aAndBAndCAnd\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphahd0xzf.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphahd0xzf.scala:49:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m49 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmphahd0xzf.scala:48:1 ---------------------\e[0m\e[0m\n\
    \e[31m48 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmphahd0xzf.scala:42:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m42 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659978624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithLeadingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsoe_5ap4.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpsoe_5ap4.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for (i <- 0 until aList.length)\n            result += (aList(i)\
    \ xor bList(i) xor carry)\n        carry += aList.length\n        for (i <- 0\
    \ until bList.length)\n            result += (aList(i) xor bList(i) xor carry)\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe0o2qr0_.scala:14:32 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result += (aList(i) xor bList(i) xor carry)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value xor is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpe0o2qr0_.scala:17:32 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            result += (aList(i) xor bList(i) xor carry)\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                      value xor is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978633
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        val maxBits = Math.max(aBits,\
    \ bBits)\n        val aMask = 1 << maxBits\n        val bMask = 1 << maxBits -\
    \ 1\n        val aBitsRemaining = aBits & aMask\n        val bBitsRemaining =\
    \ bBits & bMask\n        val aBitsRemainingAndOne = aBitsRemaining | 1\n     \
    \   val bBitsRemainingAndOne = bBitsRemaining | 1\n        val aBitsRemainingAndTwo\
    \ = aBitsRemaining & 2\n        val bBitsRemainingAndTwo = bBitsRemaining & 2\n\
    \        val aBitsRemainingAndThree = aBitsRemaining & 3\n        val bBitsRemainingAndThree\
    \ = bBitsRemaining & 3\n        val aBitsRemainingAndFour = aBitsRemaining & 4\n\
    \        val bBitsRemainingAndFour = bBitsRemaining & 4\n        val aBitsRemainingAndFive\
    \ = aBitsRemaining & 5\n        val bBitsRemainingAndFive = bBitsRemaining & 5\n\
    \        val aBitsRemainingAndSix = aBitsRemaining & 6\n        val bBitsRemainingAndSix\
    \ = bBitsRemaining & 6\n        val aBitsRemainingAndSeven = aBitsRemaining &\
    \ 7\n        val bBitsRemainingAndSeven = bBitsRemaining & 7\n        val aBitsRemainingAndEight\
    \ = aBitsRemaining & 8\n        val bBitsRemainingAndEight = bBitsRemaining &\
    \ 8\n        val aBitsRemainingAndNine = aBitsRemaining & 9\n        val bBitsRemainingAndNine\
    \ = bBitsRemaining & 9\n        val aBitsRemainingAndTen = aBitsRemaining & 10\n\
    \        val bBitsRemainingAndTen = bBitsRemaining & 10\n        val aBitsRemainingAndEleven\
    \ = aBitsRemaining & 11\n        val bBitsRemainingAndEleven = bBitsRemaining\
    \ & 11\n        val aBitsRemainingAndTwelve = aBitsRemaining & 12\n        val\
    \ bBitsRemainingAndTwelve = bBitsRemaining & 12\n        val aBitsRemain\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwfc0_xff.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwfc0_xff.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for(i <- 0 until aList.length){\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aInt = aChar match {\n    \
    \            case '1' => 1\n                case '0' => 0\n                case\
    \ _ => throw new IllegalArgumentException(\"Invalid character: \" + aChar)\n \
    \           }\n            val bInt = bChar match {\n                case '1'\
    \ => 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character: \" + bChar)\n            }\n            val aInt = aInt XOR\
    \ bInt\n            val aChar = aInt match {\n                case 0 => 0\n  \
    \              case 1 => 1\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character: \" + aInt)\n            }\n            result.append(aChar)\n\
    \            carry = aInt XOR carry\n        }\n        if(carry != 0){\n    \
    \        result.append(carry)\n        }\n        result.toString\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfq9jgi6r.scala:26:16 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36maInt\e[0m = aInt XOR\
    \ bInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0maInt is already defined as \e[33mvalue\e[0m \e[35maInt\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfq9jgi6r.scala:27:16 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            \e[33mval\e[0m \e[36maChar\e[0m = aInt \e[33mmatch\e[0m {\n\
    \e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0maChar is already defined\
    \ as \e[33mvalue\e[0m \e[35maChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m28 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => \e[31m0\e[0m\n\e\
    [31m29 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => \e[31m1\e[0m\n\e\
    [31m30 |\e[0m                \e[33mcase\e[0m _ => \e[33mthrow\e[0m \e[33mnew\e\
    [0m \e[35mIllegalArgumentException\e[0m(\e[31m\"Invalid character: \"\e[0m + aInt)\n\
    \e[31m31 |\e[0m            }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfq9jgi6r.scala:33:25\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            carry = aInt\
    \ XOR carry\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    value XOR is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659978631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        var result = \"\"\n        var carry = 0\n\
    \        var i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n\
    \            val bBit = bBits(i)\n            val aBitAndBBit = carry + (aBit\
    \ & bBit)\n            val aBitAndBBitInt = aBitAndBBit >> 1\n            val\
    \ aBitAndBBitBit = aBitAndBBit & 1\n            val aBitAndBBitString = (aBitAndBBitInt\
    \ + (aBitAndBBitBit == 0 ? \"\" : \"\"))\n            val aBitAndBBitStringInt\
    \ = aBitAndBBitString.toInt\n            val aBitAndBBitStringBit = aBitAndBBitString.toInt\n\
    \            val aBitAndBBitStringString = aBitAndBBitString.toInt\n         \
    \   val aBitAndBBitStringStringInt = aBitAndBBitStringString.toInt\n         \
    \   val aBitAndBBitStringStringBit = aBitAndBBitStringString.toInt\n         \
    \   val aBitAndBBitStringStringString = aBitAndBBitStringString.toInt\n      \
    \      val aBitAndBBitStringStringStringInt = aBitAndBBitStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringBit = aBitAndBBitStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringString = aBitAndBBitStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringInt = aBitAndBBitStringStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringBit = aBitAndBBitStringStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringString = aBitAndBBitStringStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringStringInt = aBitAndBBitStringStringStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringStringBit = aBitAndBBitStringStringStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringStringString = aBitAndBBitStringStringStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringStringInt = aBitAndBBitStringStringStringStringStringString.toInt\n\
    \            val aBitAndBBitStringStringStringStringStringBit = aBitAndB\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb6j_1lc2.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb6j_1lc2.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36maBits\e[0m = a.toIntArray\n\e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                    value toIntArray is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb6j_1lc2.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpb6j_1lc2.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36maBitAndBBitStringStringStringStringStringInt\e\
    [0m = aBitAndBBitStringStringStringStringStringString.toInt\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitAndBBitStringStringStringStringStringInt is already defined\
    \ as \e[33mvalue\e[0m \e[35maBitAndBBitStringStringStringStringStringInt\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpb6j_1lc2.scala:37:16 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33mval\e[0m \e[36maBitAndBBitStringStringStringStringStringBit\e\
    [0m = aBitAndB\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitAndBBitStringStringStringStringStringBit is already defined\
    \ as \e[33mvalue\e[0m \e[35maBitAndBBitStringStringStringStringStringBit\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb6j_1lc2.scala:45:1 "
  stdout: ''
  timestamp: 1659978634
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until aArray.length) {\n         \
    \   val aVal = aArray(i)\n            val bVal = bArray(i)\n            val newVal\
    \ = aVal ^ bVal + carry\n            carry = newVal / 2\n            result.append(newVal\
    \ % 2)\n        }\n        if (carry > 0) result.append(carry)\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        var i = 0\n        while (i < aArray.length) {\n            xorArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        new String(xorArray)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps3dk7sk8.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        val xorArraySize = a.length * b.length\n        val xorArray2 = ArrayBuffer.empty[Int]\n\
    \        val xorArray2Size = a.length * b.length\n        val xorArray3 = ArrayBuffer.empty[Int]\n\
    \        val xorArray3Size = a.length * b.length\n        val xorArray4 = ArrayBuffer.empty[Int]\n\
    \        val xorArray4Size = a.length * b.length\n        val xorArray5 = ArrayBuffer.empty[Int]\n\
    \        val xorArray5Size = a.length * b.length\n        val xorArray6 = ArrayBuffer.empty[Int]\n\
    \        val xorArray6Size = a.length * b.length\n        val xorArray7 = ArrayBuffer.empty[Int]\n\
    \        val xorArray7Size = a.length * b.length\n        val xorArray8 = ArrayBuffer.empty[Int]\n\
    \        val xorArray8Size = a.length * b.length\n        val xorArray9 = ArrayBuffer.empty[Int]\n\
    \        val xorArray9Size = a.length * b.length\n        val xorArray10 = ArrayBuffer.empty[Int]\n\
    \        val xorArray10Size = a.length * b.length\n        val xorArray11 = ArrayBuffer.empty[Int]\n\
    \        val xorArray11Size = a.length * b.length\n        val xorArray12 = ArrayBuffer.empty[Int]\n\
    \        val xorArray12Size = a.length * b.length\n        val xorArray13 = ArrayBuffer.empty[Int]\n\
    \        val xorArray13Size = a.length * b.length\n        val xorArray14 = ArrayBuffer.empty[Int]\n\
    \        val xorArray14Size = a.length * b.length\n        val xorArray15 = ArrayBuffer.empty[Int]\n\
    \        val xorArray15Size = a.length * b.length\n        val xorArray16 = ArrayBuffer.empty[Int]\n\
    \        val xorArray16Size = a.length * b.length\n        val xorArray17 = ArrayBuffer.empty[Int]\n\
    \        val xorArray17Size = a.length * b.length\n        val xorArray18 = ArrayBuffer.empty[Int]\n\
    \        val xorArray18Size = a.length * b.length\n        val xorArray19 = ArrayBuffer.empty[Int]\n\
    \        val xorArray19Size = a.length * b.length\n        val xorArray20 = ArrayBuffer.empty[Int]\n\
    \        val xorArray20Size = a.\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoio3xt37.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpoio3xt37.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length){\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb4jnsqld.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val result = xorBitsStringWithZeros.substring(0, xorBitsStringWithZeros.length-1)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp137p0tau.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp137p0tau.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        val length = math.min(aBits,\
    \ bBits)\n        var carry = 0\n        for (i <- 0 until length) {\n       \
    \     val aBit = aBits - i\n            val bBit = bBits - i\n            val\
    \ aBitMask = aBit - 1\n            val bBitMask = bBit - 1\n            val aBitValue\
    \ = aBit == 0 ? 0 : aBitMask\n            val bBitValue = bBit == 0 ? 0 : bBitMask\n\
    \            val aBitValueInt = aBitValue + carry\n            val bBitValueInt\
    \ = bBitValue + carry\n            val aBitValueString = aBitValueInt.toString\n\
    \            val bBitValueString = bBitValueInt.toString\n            val aBitValueStringWithCarry\
    \ = aBitValueString + aBitValueString + carry\n            val bBitValueStringWithCarry\
    \ = bBitValueString + bBitValueString + carry\n            val aBitValueStringWithCarryInt\
    \ = aBitValueStringWithCarry.toInt\n            val bBitValueStringWithCarryInt\
    \ = bBitValueStringWithCarry.toInt\n            val aBitValueStringWithCarryString\
    \ = aBitValueStringWithCarryInt.toString\n            val bBitValueStringWithCarryString\
    \ = bBitValueStringWithCarryInt.toString\n            val aBitValueStringWithCarryStringWithCarry\
    \ = aBitValueStringWithCarryString + aBitValueStringWithCarryString + carry\n\
    \            val bBitValueStringWithCarryStringWithCarry = bBitValueStringWithCarryString\
    \ + bBitValueStringWithCarryString + carry\n            val aBitValueStringWithCarryStringWithCarryInt\
    \ = aBitValueStringWithCarryStringWithCarry.toInt\n            val bBitValueStringWithCarryStringWithCarryInt\
    \ = bBitValueStringWithCarryStringWithCarry.toInt\n            val aBitValueStringWithCarryStringWithCarryString\
    \ = aBitValueStringWithCarryStringWithCarryInt.toString\n            val bBitValueStringWithCarryStringWithCarryString\
    \ = bBitValueStringWithCarryStringWithCarryInt.toString\n            val aBitValueStringWithCarr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe2o2zylw.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe2o2zylw.scala:46:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpe2o2zylw.scala:19:44 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m            \e[33mval\e[0m \e[36maBitValue\e[0m = aBit == \e[31m0\e\
    [0m ? \e[31m0\e[0m : \e[35maBitMask\e[0m\n\e[31m\e[31m   |\e[0m              \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                            Not found: type aBitMask\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpe2o2zylw.scala:19:38 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36maBitValue\e[0m = aBit\
    \ == \e[31m0\e[0m ? \e[31m0\e[0m : \e[35maBitMask\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                    ^^^\e[0m\n\e[31m   |\e[0m               \
    \                     value ? is not a member of Int\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpe2o2zylw.scala:20:44 ------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m            \e[33mval\e[0m \e[36mbBitValue\e[0m = bBit == \e[31m0\e\
    [0m ? \e[31m0\e[0m : \e[35mbBitMask\e[0m\n\e[31m\e[31m   |\e[0m              \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                            Not found: type bBitMask\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpe2o2zylw.scala:20:38 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mbBitValue\e[0m = bBit\
    \ == \e[31m0\e[0m ? \e[31m0\e[0m : \e[35mbBitMask\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                    ^^^\e[0m\n\e[31m   |\e[0m               \
    \                     value ? is not a member of Int\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpe2o2zylw.scala:4"
  stdout: ''
  timestamp: 1659978635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        var xor = 0\n        var i = 0\n        while (i < xorBits.length) {\n\
    \            xor = xor + (aBits(i) xor bBits(i))\n            i += 1\n       \
    \ }\n        xor.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd1azg2ok.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpd1azg2ok.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        val aLen = a.length\n  \
    \      val bLen = b.length\n        val aLenInt = aLen.toInt\n        val bLenInt\
    \ = bLen.toInt\n        val aLenBits = aLenInt.bitLength\n        val bLenBits\
    \ = bLenInt.bitLength\n        val aLenBitsInt = (1L << aLenBits).toInt\n    \
    \    val bLenBitsInt = (1L << bLenBits).toInt\n        var aBitsInt = 0\n    \
    \    var bBitsInt = 0\n        var aBitsInt2 = 0\n        var bBitsInt2 = 0\n\
    \        var aBitsInt3 = 0\n        var bBitsInt3 = 0\n        var aBitsInt4 =\
    \ 0\n        var bBitsInt4 = 0\n        var aBitsInt5 = 0\n        var bBitsInt5\
    \ = 0\n        var aBitsInt6 = 0\n        var bBitsInt6 = 0\n        var aBitsInt7\
    \ = 0\n        var bBitsInt7 = 0\n        var aBitsInt8 = 0\n        var bBitsInt8\
    \ = 0\n        var aBitsInt9 = 0\n        var bBitsInt9 = 0\n        var aBitsInt10\
    \ = 0\n        var bBitsInt10 = 0\n        var aBitsInt11 = 0\n        var bBitsInt11\
    \ = 0\n        var aBitsInt12 = 0\n        var bBitsInt12 = 0\n        var aBitsInt13\
    \ = 0\n        var bBitsInt13 = 0\n        var aBitsInt14 = 0\n        var bBitsInt14\
    \ = 0\n        var aBitsInt15 = 0\n        var bBitsInt15 = 0\n        var aBitsInt16\
    \ = 0\n        var bBitsInt16 = 0\n        var aBitsInt17 = 0\n        var bBitsInt17\
    \ = 0\n        var aBitsInt18 = 0\n        var bBitsInt18 = 0\n        var aBitsInt19\
    \ = 0\n        var bBitsInt19 = 0\n        var aBitsInt20 = 0\n        var bBitsInt20\
    \ = 0\n        var aBitsInt21 = 0\n        var bBitsInt21 = 0\n        var aBitsInt22\
    \ = 0\n        var bBitsInt22 = 0\n        var aBitsInt23 = 0\n        var bBitsInt23\
    \ = 0\n        var aBitsInt24 = 0\n        var bBitsInt24 = 0\n        var aBitsInt25\
    \ = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbb3t0b_v.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36maLenBits\e[0m = aLenInt.bitLength\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue bitLength is not a member of Int, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.int2bigInt\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbb3t0b_v.scala:17:31\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mbLenBits\e[0m = bLenInt.bitLength\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue bitLength is not a member\
    \ of Int, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.BigInt.int2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpbb3t0b_v.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.length){\n            val aChar = aList(i)\n        \
    \    val bChar = bList(i)\n            val aInt = aChar match {\n            \
    \    case '1' => 1\n                case '0' => 0\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character in string a: \" + aChar)\n\
    \            }\n            val bInt = bChar match {\n                case '1'\
    \ => 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string b: \" + bChar)\n            }\n            val aAndB\
    \ = aInt & bInt\n            val aOrB = aInt | bInt\n            val aXorB = aAndB\
    \ ^ aOrB\n            val aAndBAndC = aAndB & aXorB\n            val aAndBOrC\
    \ = aAndB | aXorB\n            val aAndBXorC = aAndBAndC ^ aAndBOrC\n        \
    \    val aAndBAndCAndD = aAndBAndC & aAndBXorC\n            val aAndBAndCAndDAndE\
    \ = aAndBAndCAndD ^ aAndBAndCAndDAndE\n            val aAndBAndCAndDAndEAndF =\
    \ aAndBAndCAndDAndE & aAndBAndCAndDAndEAndF\n            val aAndBAndCAndDAndEAndFAndG\
    \ = aAndBAndCAndDAndEAndFAndG ^ aAndBAndCAndDAndEAndFAndG\n            val aAndBAndCAndDAndEAndFAndGAndH\
    \ = aAndBAndCAndDAndEAndFAndGAndH ^ aAndBAndCAndDAndEAndFAndGAndH\n          \
    \  val aAndBAndCAndDAndEAndFAndGAndHAndI = aAndBAndCAndDAndEAndFAndGAndHAndI ^\
    \ aAndBAndCAndDAndEAndFAndGAndHAndI\n            val aAndBAndCAndDAndEAndFAndGAndHAndIAndJ\
    \ = aAndBAndCAndDAndEAndFAndGAndHAndIAndJ ^ aAndBAndCAndDAndEAndFAndGAndHAndI\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg460f32r.scala:47:0 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg460f32r.scala:46:1\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpg460f32r.scala:40:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m40 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659978635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](a.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = aArray(i) xor bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_mvgfhpq.scala:12:66 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                        value xor is not a member of Int\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmp_mvgfhpq.scala:13:12 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorArray)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m\
    \ \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\
    \e[31m   |\e[0m (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m\
    \   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m \
    \  |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1:\
    \ Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int,\
    \ x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\
    \e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ XOR bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bygrrxx.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp32cq85hl.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n\
    \        val xorArray2 = new Array[Int](aArray.length)\n        val xorArray3\
    \ = new Array[Int](aArray.length)\n        val xorArray4 = new Array[Int](aArray.length)\n\
    \        val xorArray5 = new Array[Int](aArray.length)\n        val xorArray6\
    \ = new Array[Int](aArray.length)\n        val xorArray7 = new Array[Int](aArray.length)\n\
    \        val xorArray8 = new Array[Int](aArray.length)\n        val xorArray9\
    \ = new Array[Int](aArray.length)\n        val xorArray10 = new Array[Int](aArray.length)\n\
    \        val xorArray11 = new Array[Int](aArray.length)\n        val xorArray12\
    \ = new Array[Int](aArray.length)\n        val xorArray13 = new Array[Int](aArray.length)\n\
    \        val xorArray14 = new Array[Int](aArray.length)\n        val xorArray15\
    \ = new Array[Int](aArray.length)\n        val xorArray16 = new Array[Int](aArray.length)\n\
    \        val xorArray17 = new Array[Int](aArray.length)\n        val xorArray18\
    \ = new Array[Int](aArray.length)\n        val xorArray19 = new Array[Int](aArray.length)\n\
    \        val xorArray20 = new Array[Int](aArray.length)\n        val xorArray21\
    \ = new Array[Int](aArray.length)\n        val xorArray22 = new Array[Int](aArray.length)\n\
    \        val xorArray23 = new Array[Int](aArray.length)\n        val xorArray24\
    \ = new Array[Int](aArray.length)\n        val xorArray25 = new Array[Int](aArray.length)\n\
    \        val xorArray26 = new Array[Int](aArray.length)\n        val xorArray27\
    \ = new Array[Int](aArray.length)\n        val xorArray28 = new Array[Int](aArray.length)\n\
    \        val xorArray29 = new Array[Int](aArray.length)\n        val xorArray30\
    \ = new Array[Int](aArray.length)\n        val xorArray31 = new Array[Int](aArray.length)\n\
    \        val xorArray32 = new Array[Int](aArray.length)\n        val xorArray33\
    \ = new Array[Int](a\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw4yhkkxm.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpw4yhkkxm.scala:43:40 --------------------\e[0m\e[0m\n\e[31m43 |\e[0m\
    \        \e[33mval\e[0m \e[36mxorArray33\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mInt\e[0m](a\n\e[31m\e[31m   |\e[0m                                       \
    \ ^\e[0m\n\e[31m   |\e[0m                                        Found:    (a\
    \ : String)\n\e[31m   |\e[0m                                        Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw4yhkkxm.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.padToInt(xorBitsString.length,\
    \ \"0\")\n        val resultString = Integer.toString(result)\n        return\
    \ resultString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_vckurxx.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_vckurxx.scala:13:35 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = xorBitsString.padToInt(xorBitsString.length,\
    \ \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value padToInt is not a member of String\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorResult = mutable.Buffer.empty[String]\n   \
    \     val xorResultList = mutable.Buffer.empty[String]\n        val xorResultList2\
    \ = mutable.Buffer.empty[String]\n        val xorResultList3 = mutable.Buffer.empty[String]\n\
    \        val xorResultList4 = mutable.Buffer.empty[String]\n        val xorResultList5\
    \ = mutable.Buffer.empty[String]\n        val xorResultList6 = mutable.Buffer.empty[String]\n\
    \        val xorResultList7 = mutable.Buffer.empty[String]\n        val xorResultList8\
    \ = mutable.Buffer.empty[String]\n        val xorResultList9 = mutable.Buffer.empty[String]\n\
    \        val xorResultList10 = mutable.Buffer.empty[String]\n        val xorResultList11\
    \ = mutable.Buffer.empty[String]\n        val xorResultList12 = mutable.Buffer.empty[String]\n\
    \        val xorResultList13 = mutable.Buffer.empty[String]\n        val xorResultList14\
    \ = mutable.Buffer.empty[String]\n        val xorResultList15 = mutable.Buffer.empty[String]\n\
    \        val xorResultList16 = mutable.Buffer.empty[String]\n        val xorResultList17\
    \ = mutable.Buffer.empty[String]\n        val xorResultList18 = mutable.Buffer.empty[String]\n\
    \        val xorResultList19 = mutable.Buffer.empty[String]\n        val xorResultList20\
    \ = mutable.Buffer.empty[String]\n        val xorResultList21 = mutable.Buffer.empty[String]\n\
    \        val xorResultList22 = mutable.Buffer.empty[String]\n        val xorResultList23\
    \ = mutable.Buffer.empty[String]\n        val xorResultList24 = mutable.Buffer.empty[String]\n\
    \        val xorResultList25 = mutable.Buffer.empty[String]\n        val xorResultList26\
    \ = mutable.Buffer.empty[String]\n        val xorResultList27 = mutable.Buffer.empty[String]\n\
    \        val xorResultList28 = mutable.Buffer.empty[String]\n        val xorResultList29\
    \ = mutable.Buffer.empty[String]\n        val xorResultList30 = mutable.Buffer.empty[String]\n\
    \        val xorResultList31 = mutable.Buffer.empty[String]\n        val xorResultList32\
    \ = mutable.Buffer.empty[String]\n        val xorResultList33 = mutable.Buffer.empty[String]\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4w3ajv4k.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4w3ajv4k.scala:12:28 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResultList\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp4w3ajv4k.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResultList2\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4w3ajv4k.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResultList3\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4w3ajv4k.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResultList4\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp"
  stdout: ''
  timestamp: 1659978635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        for(i\
    \ <- 0 until aBits.length){\n            val aBit = aBits(i)\n            val\
    \ bBit = bBits(i)\n            val aBitVal = aBit + carry\n            val bBitVal\
    \ = bBit + carry\n            val aBitValStr = aBitVal.toString.reverse\n    \
    \        val bBitValStr = bBitVal.toString.reverse\n            val aBitValStrLen\
    \ = aBitValStr.length\n            val bBitValStrLen = bBitValStr.length\n   \
    \         val aBitValStrPad = if (aBitValStrLen < bBitValStrLen) aBitValStrLen\
    \ else bBitValStrLen\n            val bBitValStrPad = if (aBitValStrLen < bBitValStrLen)\
    \ bBitValStrLen else aBitValStrLen\n            val aBitValStrPadStr = aBitValStr.padRight(aBitValStrPad)\n\
    \            val bBitValStrPadStr = bBitValStr.padRight(bBitValStrPad)\n     \
    \       val aBitValStrPadVal = Integer.parseInt(aBitValStrPadStr)\n          \
    \  val bBitValStrPadVal = Integer.parseInt(bBitValStrPadStr)\n            val\
    \ aBitValStrPadValStr = aBitValStrPadVal.toString\n            val bBitValStrPadValStr\
    \ = bBitValStrPadVal.toString\n            val aBitValStrPadValStrLen = aBitValStrPadValStr.length\n\
    \            val bBitValStrPadValStrLen = bBitValStrPadValStr.length\n       \
    \     val aBitValStrPadValStrPad = if (aBitValStrPadValStrLen < bBitValStrPadValStrLen)\
    \ aBitValStrPadValStrLen else bBitValStrPadValStrLen\n            val bBitValStrPadValStrPad\
    \ = if (aBitValStrPadValStrLen < bBitValStrPadValStrLen) bBitValStrPadValStrLen\
    \ else aBitValStrPadValStrLen\n            val aBitValStrPadValStrPadStr = aBitValStrPadValStrPad.toString\n\
    \            val bBitValStrPadValStrPadStr = bBitValStrPadValStrPad.toString\n\
    \            val aBitValStrPadValStrPadVal = Integer.parseInt(aBitValStrPadValStrPadStr)\n\
    \            val \n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp37005j_b.scala:37:15 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp37005j_b.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp37005j_b.scala:13:31\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m(i\
    \ <- \e[31m0\e[0m until aBits.length){\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value length\
    \ is not a member of Int\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp37005j_b.scala:14:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e\
    [0m \e[36maBit\e[0m = aBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35maBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp37005j_b.scala:15:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36mbBit\e[0m = bBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35mbBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp37005j_b.scala:45:1\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp37005j_b.scala:39:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m39 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e"
  stdout: ''
  timestamp: 1659978636
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits XOR bBits\n        val\
    \ xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n       \
    \ xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw6k_de47.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpw6k_de47.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            xorArray.append(aArray(i)\
    \ xor bArray(i))\n        xorArray.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr_n5smv5.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978633
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var xor = 0\n        var i = 0\n        while (i < aList.length && i <\
    \ bList.length) {\n            xor = xor + (aList(i) XOR bList(i))\n         \
    \   xorList.add(xor)\n            i += 1\n        }\n        xorList.toList.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaatqsai9.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpaatqsai9.scala:15:34 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            xor = xor + (aList(i) XOR bList(i))\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    value XOR is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978636
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      for( i <- 0 until aList.size ) {\n            val aChar = aList(i)\n  \
    \          val bChar = bList(i)\n            if( aChar != bChar ) {\n        \
    \        result.add(aChar)\n            }\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7988zomv.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList +=\
    \ aChar ^ bChar\n        }\n        xorList.toList.reverse.mkString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbw3nufnm.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978640
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     var i = 0\n        while (i < aArray.length && i < bArray.length) {\n  \
    \          result.append(aArray(i) ^ bArray(i))\n            i += 1\n        }\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978644
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map { case (aChar, bChar)\
    \ => aChar ^ bChar }.mkString\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.Array[Int](aArray.length)\n\
    \        val xor = new mutable.Array[Int](aArray.length)\n        val xorResult\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult2 = new mutable.Array[Int](aArray.length)\n\
    \        val xorResult3 = new mutable.Array[Int](aArray.length)\n        val xorResult4\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult5 = new mutable.Array[Int](aArray.length)\n\
    \        val xorResult6 = new mutable.Array[Int](aArray.length)\n        val xorResult7\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult8 = new mutable.Array[Int](aArray.length)\n\
    \        val xorResult9 = new mutable.Array[Int](aArray.length)\n        val xorResult10\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult11 = new mutable.Array[Int](aArray.length)\n\
    \        val xorResult12 = new mutable.Array[Int](aArray.length)\n        val\
    \ xorResult13 = new mutable.Array[Int](aArray.length)\n        val xorResult14\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult15 = new mutable.Array[Int](aArray.length)\n\
    \        val xorResult16 = new mutable.Array[Int](aArray.length)\n        val\
    \ xorResult17 = new mutable.Array[Int](aArray.length)\n        val xorResult18\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult19 = new mutable.Array[Int](aArray.length)\n\
    \        val xorResult20 = new mutable.Array[Int](aArray.length)\n        val\
    \ xorResult21 = new mutable.Array[Int](aArray.length)\n        val xorResult22\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult23 = new mutable.Array[Int](aArray.length)\n\
    \        val xorResult24 = new mutable.Array[Int](aArray.length)\n        val\
    \ xorResult25 = new mutable.Array[Int](aArray.length)\n        val xorResult26\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResult27 = new mutable.Array[\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpecu0639p.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpecu0639p.scala:11:25 ------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.Array[\e\
    [35mInt\e[0m](aArray.length)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpecu0639p.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.Array[\e[35mInt\e[0m](aArray.length)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpecu0639p.scala:13:28\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult\e[0m = \e[33mnew\e[0m mutable.Array[\e[35mInt\e[0m](aArray.length)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpecu0639p.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = \e[33mnew\e\
    [0m mutable.Array[\e[35mInt\e[0m](aArray.length)\n\e[31m\e[31m   |\e[0m      \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpecu0639p.scala:15:29 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = \e[33mnew\e[0m mutable.Array[\e\
    [35mInt\e[0m](aArray.leng"
  stdout: ''
  timestamp: 1659978643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      var carry = 0\n        var i = 0\n        while (i < aList.length && i\
    \ < bList.length) {\n            val aChar = aList(i)\n            val bChar =\
    \ bList(i)\n            val aInt = aChar match {\n                case '1' =>\
    \ 1\n                case '0' => 0\n            }\n            val bInt = bChar\
    \ match {\n                case '1' => 1\n                case '0' => 0\n    \
    \        }\n            val aInt = aInt XOR bInt\n            val aChar = aInt\
    \ match {\n                case 0 => '0'\n                case 1 => '1'\n    \
    \        }\n            val result = result :+ aChar\n            carry = aInt\
    \ AND bInt\n            i += 1\n        }\n        if (i < aList.length) {\n \
    \           val aChar = aList(i)\n            val aInt = aChar match {\n     \
    \           case '1' => 1\n                case '0' => 0\n            }\n    \
    \        val result = result :+ aChar\n            carry = aInt AND bInt\n   \
    \     }\n        if (i < bList.length) {\n            val bChar = bList(i)\n \
    \           val bInt = bChar match {\n                case '1' => 1\n        \
    \        case '0' => 0\n            }\n            val result = result :+ bChar\n\
    \            carry = aInt AND bInt\n        }\n        if (carry != 0) {\n   \
    \         val result = result :+ carry\n        }\n        result.toString\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphcpx55dy.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphcpx55dy.scala:25:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36maInt\e[0m = aInt XOR bInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maInt is already defined as \e[33mvalue\e[0m \e[35maInt\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphcpx55dy.scala:26:16 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36maChar\e[0m = aInt \e[33mmatch\e[0m {\n\
    \e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0maChar is already defined\
    \ as \e[33mvalue\e[0m \e[35maChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m27 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => \e[31m'0'\e[0m\n\
    \e[31m28 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => \e[31m'1'\e[0m\n\
    \e[31m29 |\e[0m            }\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphcpx55dy.scala:30:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mresult\e[0m = result :+ aChar\n\e[31m\e[31m   |\e[0m               \
    \          ^\e[0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e\
    [0m \e[35mresult\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphcpx55dy.scala:31:25 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m            carry = aInt AND bInt\n\e[31m\e[31m   |\e[0m                  \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value AND is not a member\
    \ of Int\n\e[31"
  stdout: ''
  timestamp: 1659978644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new mutable.StringBuilder\n\
    \        val len = Math.min(aArray.length, bArray.length)\n        var i = 0\n\
    \        while (i < len) {\n            result.append(aArray(i) xor bArray(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvxotji55.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<-xorBitsStringLength to 0) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq321sfod.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpq321sfod.scala:18:29 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val aLen = aArray.length\n        val\
    \ bLen = bArray.length\n        val result = new Array[Char](aLen + bLen)\n  \
    \      var i = 0\n        var j = 0\n        while (i < aLen && j < bLen) {\n\
    \            result(i) = aArray(i) XOR bArray(j)\n            i += 1\n       \
    \     j += 1\n        }\n        while (i < aLen) {\n            result(i) = aArray(i)\n\
    \            i += 1\n        }\n        while (j < bLen) {\n            result(i)\
    \ = bArray(j)\n            j += 1\n        }\n        new String(result)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp98h7th43.scala:17:34 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            result(i) = aArray(i) XOR bArray(j)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        for(i <- 0 until aBits)\
    \ {\n            result += ((aBits & (1 << i)) != (bBits & (1 << i)) ? \"1\" :\
    \ \"0\")\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpexx4s_vc.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aBits & (\e[31m1\e[0m << i))\
    \ != (bBits & (\e[31m1\e[0m << i)) ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpexx4s_vc.scala:13:64 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m            result += ((aBits & (\e[31m1\e[0m << i)) != (bBits\
    \ & (\e[31m1\e[0m << i)) ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          value ? is not a\
    \ member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659978644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            for(j <- 0 until bArray.length)\n\
    \                if(aArray(i) XOR bArray(j) == 1)\n                    xorArray.append(1)\n\
    \                else\n                    xorArray.append(0)\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_d8l3pa.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0_d8l3pa.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mif\e[0m(aArray(i) XOR bArray(j)\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   value XOR is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659978645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(\n            x => x._1 ^ x._2\n        ).map(\n\
    \            x => x.toString.toChar\n        ).mkString\n        xorArray\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ntpjcwq.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[36mx\e[0m => x.toString.toChar\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \         value toChar is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmp0ntpjcwq.scala:17:9\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m      \
    \  ).mkString\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         No\
    \ ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.size) {\n            val aChar = aList(i)\n         \
    \   val bChar = bList(i)\n            val aCharInt = aChar match {\n         \
    \       case '1' => 1\n                case '0' => 0\n                case _ =>\
    \ throw new IllegalArgumentException(\"Invalid character \" + aChar)\n       \
    \     }\n            val bCharInt = bChar match {\n                case '1' =>\
    \ 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + bChar)\n            }\n            val aCharInt = aCharInt\
    \ xor bCharInt\n            val aCharChar = aCharInt match {\n               \
    \ case 1 => '1'\n                case 0 => '0'\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character \" + aChar)\n            }\n\
    \            val bCharChar = bCharInt match {\n                case 1 => '1'\n\
    \                case 0 => '0'\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + bChar)\n            }\n            val aCharCharInt = aCharChar\
    \ match {\n                case '1' => 1\n                case '0' => 0\n    \
    \            case _ => throw new IllegalArgumentException(\"Invalid character\
    \ \" + aChar)\n            }\n            val bCharCharInt = bCharChar match {\n\
    \                case '1' => 1\n                case '0' => 0\n              \
    \  case _ => throw new IllegalArgumentException(\"Invalid character \" + bChar)\n\
    \            }\n            val aCharCharChar = aCharCharInt xor bCharCharInt\n\
    \            val aCharCharCharChar = aCharCharChar match {\n                case\
    \ '1' => '1'\n                case '0' => '0'\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character \" + aChar)\n            }\n\
    \            val bCharCharChar = bCharCharInt match {\n                case '1'\
    \ => '1'\n                case '0' => '0'\n                case _ => throw new\
    \ IllegalArgumentException(\"Invalid character \" + bChar)\n            }\n  \
    \          val aCharCharCharChar = bCharCharChar match {\n                case\
    \ '1' => '1'\n                case '0' => '0'\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character \" + bChar)\n            }\n\
    \            val aCharCharCharCharChar = aCharCharCharCharInt xor bCharCharCharCharInt\n\
    \            val aCharCharCharCharCharChar = aCharCharCharCharChar match {\n \
    \               case '1' => '1'\n                case '0' => '0'\n           \
    \     case _ => throw new IllegalArgumentException(\"Invalid character \" + aChar)\n\
    \            }\n            \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4fcus8qg.scala:78:0 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4fcus8qg.scala:26:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e\
    [0m \e[36maCharInt\e[0m = aCharInt xor bCharInt\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maCharInt is already\
    \ defined as \e[33mvalue\e[0m \e[35maCharInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4fcus8qg.scala:58:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e\
    [0m \e[36maCharCharCharChar\e[0m = bCharCharChar \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0maCharCharCharChar is already defined\
    \ as \e[33mvalue\e[0m \e[35maCharCharCharChar\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m59 |\e[0m                \e[33mcase\e[0m \e[31m'1'\e\
    [0m => \e[31m'1'\e[0m\n\e[31m60 |\e[0m                \e[33mcase\e[0m \e[31m'0'\e\
    [0m => \e[31m'0'\e[0m\n\e[31m61 |\e[0m                \e[33mcase\e[0m _ => \e\
    [33mthrow\e[0m \e[33mnew\e[0m \e[35mIllegalArgumentException\e[0m(\e[31m\"Invalid\
    \ character \"\e[0m + bChar)\n\e[31m62 |\e[0m            }\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4fcus8qg.scala:47:45 ------------------------\e[0m\e\
    [0m\n\e[31m47 |\e[0m            \e[33mval\e[0m \e[36maCharCharChar\e[0m = aCharCharInt\
    \ xor bCharCharInt\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value xor is not a member\
    \ of Int\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4fcus8qg.scala:63:40\
    \ ------------------------\e[0m\e[0m\n\e[31m63 |\e[0m            \e[33mval\e[0m\
    \ \e[36maCharCharCharCharChar\e[0m = aCharCharCharCharInt xor bCharCharCharCharInt\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      "
  stdout: ''
  timestamp: 1659978647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val result = new mutable.ArrayBuffer(a.length)\n\
    \        for( i <- 0 until a.length ) {\n            result(i) = aBits(i).xor(bBits(i)).toChar\n\
    \        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmyqt5jyg.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpmyqt5jyg.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmyqt5jyg.scala:11:25 ------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m\
    \ mutable.ArrayBuffer(a.length)\n\e[31m\e[31m   |\e[0m                       \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length){\n            xorList += (aList(i) xor\
    \ bList(i)).toString\n        }\n        xorList.toList.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4t3j1lt7.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val aLen =\
    \ aList.length\n        val bLen = bList.length\n        val aIndex = 0\n    \
    \    val bIndex = 0\n        while (aIndex < aLen && bIndex < bLen) {\n      \
    \      val aChar = aList(aIndex)\n            val bChar = bList(bIndex)\n    \
    \        if (aChar != bChar) {\n                result.append(aChar)\n       \
    \     } else {\n                result.append(aChar)\n            }\n        \
    \    aIndex += 1\n            bIndex += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcjmuff2w.scala:24:19 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            aIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean aIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcjmuff2w.scala:25:19\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            bIndex += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value += is not a member of Int - did you mean bIndex.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val result = xorBitsString.reverse\n     \
    \   return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwpg42bwb.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.length && i < bList.length) {\n  \
    \          xorList += aList(i) xor bList(i)\n            i += 1\n        }\n \
    \       xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgsdemze4.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        for(i <- 0\
    \ until aList.size) {\n            result.append(aList(i) XOR bList(i))\n    \
    \    }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1bbwvki4.scala:13:35 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result.append(aList(i) XOR bList(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     val xor = a.zip(b).map(x => x._1 xor x._2)\n        xor.foreach(x => result.append(x))\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsepcj4lh.scala:12:41 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = a.zip(b).map(\e\
    [36mx\e[0m => x._1 xor x._2)\n\e[31m\e[31m   |\e[0m                          \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    value\
    \ xor is not a member of Char\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpsepcj4lh.scala:13:32\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        xor.foreach(\e[36mx\e\
    [0m => result.append(x))\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mappend\e[0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m with types\n\
    \e[31m   |\e[0m (x: Char): StringBuilder\n\e[31m   |\e[0m (x: Double): StringBuilder\n\
    \e[31m   |\e[0m (x: Float): StringBuilder\n\e[31m   |\e[0m (x: Long): StringBuilder\n\
    \e[31m   |\e[0m (x: Int): StringBuilder\n\e[31m   |\e[0m (x: Short): StringBuilder\n\
    \e[31m   |\e[0m (x: Byte): StringBuilder\n\e[31m   |\e[0m (x: Boolean): StringBuilder\n\
    \e[31m   |\e[0m (s: StringBuilder): StringBuilder\n\e[31m   |\e[0m (cs: CharSequence):\
    \ StringBuilder\n\e[31m   |\e[0m (s: String): StringBuilder\n\e[31m   |\e[0m (x:\
    \ Any): StringBuilder\n\e[31m   |\e[0mall match arguments ((x : Nothing))\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n       \
    \ xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpppgwo4te.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpppgwo4te.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978647
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(\n            x => x._1 ^ x._2\n        ).map(\n\
    \            x => x.toString\n        ).mkString(\"\")\n        xorArray\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(\n            x => x._1 ^ x._2\n        ).map(\n\
    \            x => x.toString.toChar\n        ).mkString\n        xorArray\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ntpjcwq.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[36mx\e[0m => x.toString.toChar\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \         value toChar is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmp0ntpjcwq.scala:17:9\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m      \
    \  ).mkString\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         No\
    \ ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ xor bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl49c0ick.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.size) {\n            val xor = aList(i) xor bList(i)\n\
    \            xorList += xor.asInstanceOf[String]\n        }\n        xorList.toList.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi5h_qx_r.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpi5h_qx_r.scala:13:31 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aList(i)\
    \ xor bList(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value xor is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.ListBuffer.empty[Int]\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        val xorResult = mutable.ListBuffer.empty[Int]\n        val xorResultList\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList2 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList3 = mutable.ListBuffer.empty[Int]\n        val xorResultList4\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList5 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList6 = mutable.ListBuffer.empty[Int]\n        val xorResultList7\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList8 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList9 = mutable.ListBuffer.empty[Int]\n        val xorResultList10\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList11 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList12 = mutable.ListBuffer.empty[Int]\n        val xorResultList13\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList14 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList15 = mutable.ListBuffer.empty[Int]\n        val xorResultList16\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList17 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList18 = mutable.ListBuffer.empty[Int]\n        val xorResultList19\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList20 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList21 = mutable.ListBuffer.empty[Int]\n        val xorResultList22\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList23 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList24 = mutable.ListBuffer.empty[Int]\n        val xorResultList25\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList26 = mutable.ListBuffer.empty[Int]\n\
    \        val xorResultList27 = mutable.ListBuffer.empty[Int]\n        val xorResultList28\
    \ = mutable.ListBuffer.empty[Int]\n        val xorResultList29 = mutable.ListBuffer.empty[Int\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2dfcverm.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2dfcverm.scala:12:18\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = mutable.ListBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2dfcverm.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mxorList\e[0m = mutable.ListBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2dfcverm.scala:14:24\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult\e[0m = mutable.ListBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2dfcverm.scala:15:28 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResultList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2dfcverm.scala:16:29 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResultList2\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not fo"
  stdout: ''
  timestamp: 1659978648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val result = aBits ^ bBits\n        val result = Integer.toBinaryString(result)\n\
    \        val result = result.substring(0, result.length - 1)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1vsa2wwq.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = Integer.toBinaryString(result)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1vsa2wwq.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.substring(\e[31m0\e\
    [0m, result.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp1vsa2wwq.scala:14:8 ---------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (result : Int)\n\e[31m   |\e[0m        Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     val xorResult = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray2 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray3 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray4\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray5 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray6 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray7\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray8 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray9 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray10\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray11 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray12 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray13\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray14 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray15 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray16\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray17 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray18 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray19\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray20 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray21 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray22\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray23 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray24 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray25\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray26 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray27 = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray28\
    \ = mutable.ArrayBuffer.empty[Int]\n        val xorResultArray29 = mutable.ArrayBuffer.empty[Int]\n\
    \        val xorResultArray30 = mutable.ArrayBuffer.empty[Int]\n        val xor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5ithj21d.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ithj21d.scala:12:24\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m \
    \  |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5ithj21d.scala:13:29 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResultArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ithj21d.scala:14:30 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResultArray2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ithj21d.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResultArray3\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ithj21d.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResultArray4\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                    "
  stdout: ''
  timestamp: 1659978650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        var i = 0\n        while (i < aList.length && i < bList.length)\
    \ {\n            val aChar = aList(i)\n            val bChar = bList(i)\n    \
    \        val aInt = aChar match {\n                case '1' => 1\n           \
    \     case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + aChar)\n            }\n            val bInt = bChar match\
    \ {\n                case '1' => 1\n                case '0' => 0\n          \
    \      case _ => throw new IllegalArgumentException(\"Invalid character \" + bChar)\n\
    \            }\n            val aInt = aInt XOR bInt\n            val aChar =\
    \ aInt match {\n                case 0 => '0'\n                case 1 => '1'\n\
    \                case _ => throw new IllegalArgumentException(\"Invalid character\
    \ \" + aInt)\n            }\n            result.append(aChar)\n            carry\
    \ = aInt XOR carry\n            i += 1\n        }\n        if (carry != 0) {\n\
    \            result.append(carry)\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk2q_cehr.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36maInt\e[0m = aInt XOR\
    \ bInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0maInt is already defined as \e[33mvalue\e[0m \e[35maInt\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpk2q_cehr.scala:28:16 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            \e[33mval\e[0m \e[36maChar\e[0m = aInt \e[33mmatch\e[0m {\n\
    \e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0maChar is already defined\
    \ as \e[33mvalue\e[0m \e[35maChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m29 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => \e[31m'0'\e[0m\n\
    \e[31m30 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => \e[31m'1'\e[0m\n\
    \e[31m31 |\e[0m                \e[33mcase\e[0m _ => \e[33mthrow\e[0m \e[33mnew\e\
    [0m \e[35mIllegalArgumentException\e[0m(\e[31m\"Invalid character \"\e[0m + aInt)\n\
    \e[31m32 |\e[0m            }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk2q_cehr.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            carry = aInt\
    \ XOR carry\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    value XOR is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659978652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for ((index, value) <- xorBitsString.zipWithIndex) {\n            xorBitsStringBuilder.append(if\
    \ (value == 1) \"1\" else \"0\")\n        }\n        xorBitsStringBuilder.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps5m1cr16.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.padToInt(xorBitsString.length,\
    \ \"0\")\n        return Integer.toString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwf8ijk3s.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwf8ijk3s.scala:13:35 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = xorBitsString.padToInt(xorBitsString.length,\
    \ \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value padToInt is not a member of String\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        var i = 0\n        while (i < aList.size) {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n\
    \            val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqo8vstao.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqo8vstao.scala:30:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqo8vstao.scala:31:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqo8vstao.scala:32:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqo8vstao.scala:33:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation"
  stdout: ''
  timestamp: 1659978655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.reverse\n  \
    \      return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp74rjo9h2.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n   \
    \         val bBit = bBits(i)\n            val aBitInt = aBit + carry\n      \
    \      val bBitInt = bBit + carry\n            val aBitString = aBitInt.toString(2)\n\
    \            val bBitString = bBitInt.toString(2)\n            val aBitStringLen\
    \ = aBitString.length\n            val bBitStringLen = bBitString.length\n   \
    \         val aBitStringPad = if (aBitStringLen < bBitStringLen) aBitString else\
    \ bBitString\n            val bBitStringPad = if (aBitStringLen < bBitStringLen)\
    \ bBitString else aBitString\n            val aBitStringPadLen = aBitStringPad.length\n\
    \            val bBitStringPadLen = bBitStringPad.length\n            val aBitStringPadPad\
    \ = if (aBitStringPadLen < bBitStringPadLen) aBitStringPad else bBitStringPad\n\
    \            val bBitStringPadPad = if (aBitStringPadLen < bBitStringPadLen) bBitStringPad\
    \ else aBitStringPadPad\n            val aBitStringPadPadLen = aBitStringPadPad.length\n\
    \            val bBitStringPadPadLen = bBitStringPadPad.length\n            val\
    \ aBitStringPadPadPad = if (aBitStringPadPadLen < bBitStringPadPadLen) aBitStringPadPad\
    \ else bBitStringPadPad\n            val bBitStringPadPad = if (aBitStringPadPadLen\
    \ < bBitStringPadPadLen) bBitStringPadPad else aBitStringPadPadPad\n         \
    \   val aBitStringPadPadPadLen = aBitStringPadPadPad.length\n            val bBitStringPadPadLen\
    \ = bBitStringPadPad.length\n            val aBitStringPadPadPad = if (aBitStringPadPadLen\
    \ < bBitStringPadPadLen) aBitStringPadPadPad else bBitStringPadPadPad\n      \
    \      val bBitStringPadPad = if (aBitStringPadPadLen < bBitStringPadPadLen) bBitStringPadPad\
    \ else aBitStringPadPadPad\n            val aBitStringPadPadPadLen = aBitStringPadPadPad.length\n\
    \            val bBitStringPadPadLen = bBitStringPadPad.length\n            val\
    \ aBitString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1isazroi.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1isazroi.scala:48:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m48 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1isazroi.scala:32:16 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m            \e[33mval\e[0m \e[36mbBitStringPadPad\e[0m = \e[33mif\e\
    [0m (aBitStringPadPadLen < bBitStringPadPadLen) bBitStringPadPad \e[33melse\e\
    [0m aBitStringPadPadPad\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBitStringPadPad is already defined as \e[33mvalue\e[0m \e\
    [35mbBitStringPadPad\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1isazroi.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mbBitStringPadPadLen\e\
    [0m = bBitStringPadPad.length\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBitStringPadPadLen is already defined as \e[33mvalue\e[0m\
    \ \e[35mbBitStringPadPadLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1isazroi.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36maBitStringPadPadPad\e\
    [0m = \e[33mif\e[0m (aBitStringPadPadLen < bBitStringPadPadLen) aBitStringPadPadPad\
    \ \e[33melse\e[0m bBitStringPadPadPad\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitStringPadPadPad is already defined as \e[33mvalue\e[0m\
    \ \e[35maBitStringPadPadPad\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mN"
  stdout: ''
  timestamp: 1659978654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        var xor = 0\n        for (i <- 0 until aArray.length)\n            xor\
    \ = xor + aArray(i) xor bArray(i)\n        xorArray = xorArray.toArray\n     \
    \   xorArray(xorArray.length-1) = xor\n        new String(xorArray.reverse.map(_.toChar).mkString)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd62f3ve8.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpd62f3ve8.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpd62f3ve8.scala:15:17 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        xorArray = xorArray.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val xorArray\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length){\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.reverse.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg70j9owe.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        for(i\
    \ <- 0 until a.length){\n            val aBit = aBits & (1 << (a.length - i -\
    \ 1))\n            val bBit = bBits & (1 << (b.length - i - 1))\n            val\
    \ aBitsDiff = aBit ^ bBit\n            val bBitsDiff = bBit ^ aBit\n         \
    \   val aBitsDiffStr = aBitsDiff == 0\n            val bBitsDiffStr = bBitsDiff\
    \ == 0\n            val aBitsDiffStrStr = aBitsDiffStr ? \"0\" : \"1\"\n     \
    \       val bBitsDiffStrStr = bBitsDiffStr ? \"0\" : \"1\"\n            val aBitsDiffStrStrStr\
    \ = aBitsDiffStrStr ? \"0\" : \"1\"\n            val bBitsDiffStrStrStr = bBitsDiffStrStr\
    \ ? \"0\" : \"1\"\n            val aBitsDiffStrStrStrStr = aBitsDiffStrStrStr\
    \ ? \"0\" : \"1\"\n            val bBitsDiffStrStrStrStr = bBitsDiffStrStrStr\
    \ ? \"0\" : \"1\"\n            val aBitsDiffStrStrStrStrStr = aBitsDiffStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val bBitsDiffStrStrStrStrStr = bBitsDiffStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val aBitsDiffStrStrStrStrStrStr = aBitsDiffStrStrStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val bBitsDiffStrStrStrStrStrStr = bBitsDiffStrStrStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val aBitsDiffStrStrStrStrStrStrStr = aBitsDiffStrStrStrStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val bBitsDiffStrStrStrStrStrStrStr = bBitsDiffStrStrStrStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val aBitsDiffStrStrStrStrStrStrStrStr = aBitsDiffStrStrStrStrStrStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val bBitsDiffStrStrStrStrStrStrStrStr = bBitsDiffStrStrStrStrStrStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val aBitsDiffStrStrStrStrStrStrStrStr = aBitsDiffStrStrStrStrStrStrStrStrStr\
    \ ? \"0\" : \"1\"\n            val bBits\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0fnj8770.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0fnj8770.scala:44:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m44 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0fnj8770.scala:34:16 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m            \e[33mval\e[0m \e[36maBitsDiffStrStrStrStrStrStrStrStr\e\
    [0m = aBitsDiffStrStrStrStrStrStrStrStrStr ? \e[31m\"0\"\e[0m : \e[31m\"1\"\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitsDiffStrStrStrStrStrStrStrStr is already defined as \e\
    [33mvalue\e[0m \e[35maBitsDiffStrStrStrStrStrStrStrStr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0fnj8770.scala:15:29\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbBit\e[0m = bBits & (\e[31m1\e[0m << (b.length - i - \e[31m1\e[0m))\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue &\
    \ is not a member of Null, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.set\
    \ asScala\n\e[31m   |\e[0m  import math.BigInt.javaBigInteger2bigInt\n\e[31m \
    \  |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0fnj8770.scala:22:53\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m\
    \ \e[36maBitsDiffStrStrStr\e[0m = aBitsDiffStrStr ? \e[31m\"0\"\e[0m : \e[31m\"\
    1\"\e[0m\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value ? is not a member\
    \ of String\n\e[31m\e[31m-- [E0"
  stdout: ''
  timestamp: 1659978658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<-xorBitsStringLength to 0) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8g3ap077.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < aArray.length && i < bArray.length) {\n\
    \            val xor = aArray(i) xor bArray(i)\n            if (xor != 0) {\n\
    \                result.append(xor)\n            }\n            i += 1\n     \
    \   }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptmggo_b8.scala:14:32 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aArray(i)\
    \ xor bArray(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value xor is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978656
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     var i = 0\n        while (i < a.length) {\n            result.append(aArray(i)\
    \ ^ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfs2ukig.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.ListBuffer[Int]()\n        val xorResult = mutable.ListBuffer[Int]()\n\
    \        val xorResult2 = mutable.ListBuffer[Int]()\n        val xorResult3 =\
    \ mutable.ListBuffer[Int]()\n        val xorResult4 = mutable.ListBuffer[Int]()\n\
    \        val xorResult5 = mutable.ListBuffer[Int]()\n        val xorResult6 =\
    \ mutable.ListBuffer[Int]()\n        val xorResult7 = mutable.ListBuffer[Int]()\n\
    \        val xorResult8 = mutable.ListBuffer[Int]()\n        val xorResult9 =\
    \ mutable.ListBuffer[Int]()\n        val xorResult10 = mutable.ListBuffer[Int]()\n\
    \        val xorResult11 = mutable.ListBuffer[Int]()\n        val xorResult12\
    \ = mutable.ListBuffer[Int]()\n        val xorResult13 = mutable.ListBuffer[Int]()\n\
    \        val xorResult14 = mutable.ListBuffer[Int]()\n        val xorResult15\
    \ = mutable.ListBuffer[Int]()\n        val xorResult16 = mutable.ListBuffer[Int]()\n\
    \        val xorResult17 = mutable.ListBuffer[Int]()\n        val xorResult18\
    \ = mutable.ListBuffer[Int]()\n        val xorResult19 = mutable.ListBuffer[Int]()\n\
    \        val xorResult20 = mutable.ListBuffer[Int]()\n        val xorResult21\
    \ = mutable.ListBuffer[Int]()\n        val xorResult22 = mutable.ListBuffer[Int]()\n\
    \        val xorResult23 = mutable.ListBuffer[Int]()\n        val xorResult24\
    \ = mutable.ListBuffer[Int]()\n        val xorResult25 = mutable.ListBuffer[Int]()\n\
    \        val xorResult26 = mutable.ListBuffer[Int]()\n        val xorResult27\
    \ = mutable.ListBuffer[Int]()\n        val xorResult28 = mutable.ListBuffer[Int]()\n\
    \        val xorResult29 = mutable.ListBuffer[Int]()\n        val xorResult30\
    \ = mutable.ListBuffer[Int]()\n        val xorResult31 = mutable.ListBuffer[Int]()\n\
    \        val xorResult32 = mutable.ListBuffer[Int]()\n        val xorResult33\
    \ = mutable.\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvv3qd9cy.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpvv3qd9cy.scala:12:18 ------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ListBuffer[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpvv3qd9cy.scala:13:24 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvv3qd9cy.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvv3qd9cy.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvv3qd9cy.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |"
  stdout: ''
  timestamp: 1659978657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2jxp4fbz.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length) xorList += aList(i) xor bList(i)\n    \
    \    xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpogr1r0uv.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i)).toString\n\
    \        xorList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp27aw7iga.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until aBits.length) {\n          \
    \  val aBit = aBits(i)\n            val bBit = bBits(i)\n            val aAndB\
    \ = aBit + bBit + carry\n            val aAndBBits = aAndB.toIntArray\n      \
    \      val aAndBBit = aAndBBits(0)\n            val carry = aAndBBit / 2\n   \
    \         val result = result + aAndBBits.mkString\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphskbwltj.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphskbwltj.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmphskbwltj.scala:11:25 ------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m\
    \ mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for (i <- 0 until aList.size) {\n            val aChar = aList(i)\n        \
    \    val bChar = bList(i)\n            val aCharInt = aChar.toInt\n          \
    \  val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_n3fbdj3.scala:45:0 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_n3fbdj3.scala:35:57\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntIntInt\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_n3fbdj3.scala:44:1 ---------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp_n3fbdj3.scala:38:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m38 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659978658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        val aLen = aList.length\n\
    \        val bLen = bList.length\n        var i = 0\n        var j = 0\n     \
    \   while (i < aLen && j < bLen) {\n            if (aList(i) XOR bList(j) == 1)\
    \ {\n                result += aList(i)\n                i += 1\n            \
    \    j += 1\n            } else if (aList(i) XOR bList(j) == 0) {\n          \
    \      i += 1\n            } else {\n                j += 1\n            }\n \
    \       }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8lmmxcc5.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (aList(i) XOR bList(j) == \e\
    [31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value XOR is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp8lmmxcc5.scala:21:32 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (aList(i) XOR\
    \ bList(j) == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value XOR is not a member of Char\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfs2ukig.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<-xorBitsStringLength to 0) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9yv0iiy5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val aLen =\
    \ aList.length\n        val bLen = bList.length\n        val aIndex = 0\n    \
    \    val bIndex = 0\n        while(aIndex < aLen && bIndex < bLen) {\n       \
    \     val aChar = aList(aIndex)\n            val bChar = bList(bIndex)\n     \
    \       if(aChar != bChar) {\n                result.append((aChar ^ bChar))\n\
    \            }\n            aIndex += 1\n            bIndex += 1\n        }\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsfnp49yz.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            aIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean aIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsfnp49yz.scala:23:19\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            bIndex += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value += is not a member of Int - did you mean bIndex.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toList.reverse.mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw2wu_59f.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for (i <- 0 until aList.length)\n            result += aList(i)\
    \ xor bList(i) xor carry\n        result + (if (carry > 0) \"1\" else \"0\")\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0v8aj24d.scala:14:31 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result += aList(i) xor bList(i) xor carry\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      value xor is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0v8aj24d.scala:15:15 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        result + (\e[33mif\e[0m (carry > \e[31m0\e[0m) \e\
    [31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of StringBuilder, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfxf_z9kd.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   var carry = 0\n        for(i <- 0 until aList.size) {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val xor = aChar xor\
    \ bChar xor (carry << 1)\n            carry = xor >> 1\n            xorList +=\
    \ xor.asInstanceOf[String]\n        }\n        xorList += carry.asInstanceOf[String]\n\
    \        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg4hncgh4.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpg4hncgh4.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar xor (carry << \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value xor is not a member\
    \ of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978659
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.foldLeft(\"\") { (acc, x) => acc\
    \ + (x ^ bList(0)) }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcd22lyeu.scala:15)\n\tat Problem.main(tmpcd22lyeu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n   \
    \         val bBit = bBits(i)\n            val aBitVal = aBit + carry\n      \
    \      val bBitVal = bBit + carry\n            val aBitValInt = aBitVal % 2\n\
    \            val bBitValInt = bBitVal % 2\n            val aBitValStr = aBitValInt.toString\n\
    \            val bBitValStr = bBitValInt.toString\n            val aBitValStrLen\
    \ = aBitValStr.length\n            val bBitValStrLen = bBitValStr.length\n   \
    \         val aBitValStrPad = if (aBitValStrLen > bBitValStrLen) aBitValStrLen\
    \ else bBitValStrLen\n            val bBitValStrPad = if (aBitValStrLen > bBitValStrLen)\
    \ bBitValStrLen else aBitValStrLen\n            val aBitValStrPadZero = if (aBitValStrPad\
    \ == 0) \"0\" else aBitValStrPad\n            val bBitValStrPadZero = if (bBitValStrPad\
    \ == 0) \"0\" else bBitValStrPad\n            val aBitValStrPadOne = if (aBitValStrPad\
    \ == 1) \"1\" else aBitValStrPad\n            val bBitValStrPadOne = if (bBitValStrPad\
    \ == 1) \"1\" else bBitValStrPad\n            val aBitValStrPadTwo = if (aBitValStrPad\
    \ == 2) \"10\" else aBitValStrPad\n            val bBitValStrPadTwo = if (bBitValStrPad\
    \ == 2) \"10\" else bBitValStrPad\n            val aBitValStrPadThree = if (aBitValStrPad\
    \ == 3) \"100\" else aBitValStrPad\n            val bBitValStrPadThree = if (bBitValStrPad\
    \ == 3) \"100\" else bBitValStrPad\n            val aBitValStrPadFour = if (aBitValStrPad\
    \ == 4) \"1000\" else aBitValStrPad\n            val bBitValStrPadFour = if (bBitValStrPad\
    \ == 4) \"1000\" else bBitValStrPad\n            val aBitValStrPadFive = if (aBitValStrPad\
    \ == 5) \"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpczlqfq_c.scala:37:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36maBitValStrPadFive\e\
    [0m = \e[33mif\e[0m (aBitValStrPad == \e[31m5\e[0m) \"\n\e[31m\e[31m   |\e[0m\
    \                                                            ^\e[0m\n\e[31m  \
    \ |\e[0m                                                 unclosed string literal\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpczlqfq_c.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpczlqfq_c.scala:15:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36maBit\e[0m = aBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35maBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpczlqfq_c.scala:16:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e\
    [0m \e[36mbBit\e[0m = bBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35mbBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpczlqfq_c.scala:45:1\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpczlqfq_c.scala:39:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m39 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmpczlqfq_c.scala:38:4 -----------------\e\
    [0m\e[0m\n\e[33m37 |\e[0m         "
  stdout: ''
  timestamp: 1659978662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(Array.fill(aArray.length)(0))\n\
    \        val xorArray2 = bArray.zip(Array.fill(bArray.length)(0))\n        xorArray.zip(xorArray2).map\
    \ { case (aChar, bChar) => (aChar ^ bChar) }.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4jwge0tu.scala:13:68 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        xorArray.zip(xorArray2).map { \e[33mcase\e[0m\
    \ (aChar, bChar) => (aChar ^ bChar) }.mkString\n\e[31m\e[31m   |\e[0m        \
    \                                                      ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                   value ^ is not a member of (Int, Int)\n\
    \e[31m\e[31m-- Error: /tmp/tmp4jwge0tu.scala:13:78 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        xorArray.zip(xorArray2).map { \e[33mcase\e[0m\
    \ (aChar, bChar) => (aChar ^ bChar) }.mkString\n\e[31m\e[31m   |\e[0m        \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   for(i <- 0 until aList.length){\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.reverse.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwxzfu8a7.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        var result = \"\"\n        var carry = 0\n\
    \        var i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n\
    \            val bBit = bBits(i)\n            val aBitInt = aBit + carry\n   \
    \         val bBitInt = bBit + carry\n            val aBitString = aBitInt.toString(2)\n\
    \            val bBitString = bBitInt.toString(2)\n            val aBitStringWithCarry\
    \ = aBitString + aBitString + carry\n            val bBitStringWithCarry = bBitString\
    \ + bBitString + carry\n            val aBitStringWithCarryInt = aBitStringWithCarry.toInt\n\
    \            val bBitStringWithCarryInt = bBitStringWithCarry.toInt\n        \
    \    val aBitStringWithCarryString = aBitStringWithCarryInt.toString(2)\n    \
    \        val bBitStringWithCarryString = bBitStringWithCarryInt.toString(2)\n\
    \            val aBitStringWithCarryStringWithCarry = aBitStringWithCarryString\
    \ + aBitStringWithCarryString + carry\n            val bBitStringWithCarryStringWithCarry\
    \ = bBitStringWithCarryString + bBitStringWithCarryString + carry\n          \
    \  val aBitStringWithCarryStringWithCarryInt = aBitStringWithCarryStringWithCarry.toInt\n\
    \            val bBitStringWithCarryStringWithCarryInt = bBitStringWithCarryStringWithCarry.toInt\n\
    \            val aBitStringWithCarryStringWithCarryString = aBitStringWithCarryStringWithCarryInt.toString(2)\n\
    \            val bBitStringWithCarryStringWithCarryString = bBitStringWithCarryStringWithCarryInt.toString(2)\n\
    \            val aBitStringWithCarryStringWithCarryStringWithCarry = aBitStringWithCarryStringWithCarryString\
    \ + aBitStringWithCarryStringWithCarryString + carry\n            val bBitStringWithCarryStringWithCarryStringWithCarry\
    \ = bBitStringWithCarryStringWithCarryString + bBitStringWithCarryStringWithCarry\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzb16hl7t.scala:43:0 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzb16hl7t.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36maBits\e[0m = a.toIntArray\n\e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                    value toIntArray is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzb16hl7t.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpzb16hl7t.scala:42:1 ---------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpzb16hl7t.scala:36:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m36 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659978665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfs2ukig.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val aLen = aList.length\n        val bLen = bList.length\n\
    \        val result = new StringBuilder\n        var i = 0\n        while (i <\
    \ aLen) {\n            result.append(aList(i) ^ bList(i))\n            i += 1\n\
    \        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        var i = 0\n        while (i < aList.size) {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val xor = aChar xor\
    \ bChar\n            val newCarry = xor and carry\n            carry = newCarry\n\
    \            result.append(newCarry)\n            i += 1\n        }\n        if\
    \ (carry != 0) {\n            result.append(carry)\n        }\n        return\
    \ result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeyjxiybp.scala:17:28 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toIntArray\n    \
    \    val bArray = b.toIntArray\n        val xorArray = new Array[Int](a.length)\n\
    \        var i = 0\n        while (i < xorArray.length) {\n            xorArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        val xorString\
    \ = new StringBuilder(xorArray.length)\n        xorString.append(xorArray.toString)\n\
    \        xorString.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu4ac3ad8.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maArray\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m   \
    \                  value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpu4ac3ad8.scala:10:23 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbArray\e[0m = b.toIntArray\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                    value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5jlbaow2.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n    \
    \    for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                xorList += (aList(i) xor bList(j))\n        xorList.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpukaqx54x.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList +=\
    \ aChar ^ bChar\n        }\n        xorList.toList.reverse.mkString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbw3nufnm.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        var i = 0\n        while (i < aList.size) {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n\
    \            val bCharInt = bChar.toInt\n            val aCharInt = aCharInt +\
    \ carry\n            val bCharInt = bCharInt + carry\n            val aCharChar\
    \ = aCharInt.toChar\n            val bCharChar = bCharInt.toChar\n           \
    \ val aCharCharInt = aCharChar.toInt\n            val bCharCharInt = bCharChar.toInt\n\
    \            val aCharCharInt = aCharCharInt + carry\n            val bCharCharInt\
    \ = bCharCharInt + carry\n            val aCharCharChar = aCharCharInt.toChar\n\
    \            val bCharCharChar = bCharCharInt.toChar\n            val aCharCharCharInt\
    \ = aCharCharChar.toInt\n            val bCharCharCharInt = bCharCharChar.toInt\n\
    \            val aCharCharCharInt = aCharCharCharInt + carry\n            val\
    \ bCharCharCharInt = bCharCharCharInt + carry\n            val aCharCharCharChar\
    \ = aCharCharCharInt.toChar\n            val bCharCharCharChar = bCharCharCharInt.toChar\n\
    \            val aCharCharCharCharInt = aCharCharCharChar.toInt\n            val\
    \ bCharCharCharCharInt = bCharCharCharChar.toInt\n            val aCharCharCharCharInt\
    \ = aCharCharCharCharInt + carry\n            val bCharCharCharCharInt = bCharCharCharCharInt\
    \ + carry\n            val aCharCharCharCharChar = aCharCharCharCharInt.toChar\n\
    \            val bCharCharCharCharChar = bCharCharCharCharInt.toChar\n       \
    \     val aCharCharCharCharCharInt = aCharCharCharCharChar.toInt\n           \
    \ val bCharCharCharCharCharInt = bCharCharCharCharChar.toInt\n            val\
    \ aCharCharCharCharCharInt = aCharCharCharCharCharInt + carry\n            val\
    \ bCharCharCharCharCharInt = bCharCharCharCharCharInt + carry\n            val\
    \ aCharCharCharCharChar = aCharCharCharCharCharInt.toChar\n            val bCharCharCharCharChar\
    \ = bCharChar\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv9zjvbvc.scala:55:0 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv9zjvbvc.scala:19:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e\
    [0m \e[36maCharInt\e[0m = aCharInt + carry\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maCharInt is already defined as \e[33mvalue\e[0m \e[35maCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv9zjvbvc.scala:20:16 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m            \e[33mval\e[0m \e[36mbCharInt\e[0m = bCharInt + carry\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbCharInt is already defined as \e[33mvalue\e[0m \e[35mbCharInt\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv9zjvbvc.scala:25:16 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mval\e[0m \e[36maCharCharInt\e[0m = aCharCharInt + carry\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0maCharCharInt is already defined as \e[33mvalue\e[0m \e[35maCharCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv9zjvbvc.scala:26:16 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m            \e[33mval\e[0m \e[36mbCharCharInt\e[0m = bCharCharInt\
    \ + carry\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbCharCharInt is already defined as \e[33mvalue\e[0m \e[35mbCharCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv9zjvbvc.scala:31:16 -------------------"
  stdout: ''
  timestamp: 1659978668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            for(j <- 0 until bArray.length)\n\
    \                if(aArray(i) xor bArray(j) == 0)\n                    xorArray.append(0)\n\
    \                else\n                    xorArray.append(1)\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_we3opbw.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_we3opbw.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mif\e[0m(aArray(i) xor bArray(j)\
    \ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659978666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n       \
    \ xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpppgwo4te.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpppgwo4te.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(0,xorBitsString.length-1)\n        val xorBitsStringWithoutTrailingZeros\
    \ = xorBitsString.substring(xorBitsString.length-1)\n        xorBitsStringWithoutLeadingZeros\
    \ + xorBitsStringWithoutTrailingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpydkbc26o.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        return xorBitsString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps92iwgnj.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ XOR bList(i)\n            i += 1\n        }\n        xorList.toList.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw8m79adj.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits XOR bBits\n        val\
    \ xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpadr3lqvk.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpadr3lqvk.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        var i = 0\n        while (i < xorArray.length) {\n            xorArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxr5xyxzy.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.substring(0,xorBitsString.length-1)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuy2nu7rm.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(Integer.toString).mkString(\"\")\n        xorBitsString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptjp1mln6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptjp1mln6.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toIntArray\n    \
    \    val bArray = b.toIntArray\n        var result = \"\"\n        var carry =\
    \ 0\n        for (i <- 0 until a.length) {\n            val aVal = aArray(i)\n\
    \            val bVal = bArray(i)\n            val product = aVal ^ bVal + carry\n\
    \            result += (product % 2).toChar\n            carry = product / 2\n\
    \        }\n        if (carry > 0) result += (1 - (carry % 2)).toChar\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1q5h5aur.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maArray\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m   \
    \                  value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp1q5h5aur.scala:10:23 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbArray\e[0m = b.toIntArray\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                    value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringWithZeros = Array.fill(8 - xorBitsStringLength)(0)\n\
    \        xorBitsStringWithZeros ++ xorBitsString ++ xorBitsStringWithZeros\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplp6cnmqa.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmplp6cnmqa.scala:15:8 ---------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        xorBitsStringWithZeros ++ xorBitsString ++ xorBitsStringWithZeros\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[AnyVal]\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithLeadingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsoe_5ap4.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpsoe_5ap4.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until aArray.length)\n           \
    \ result += (aArray(i) XOR bArray(i)) XOR carry\n        result + (carry XOR aArray(aArray.length\
    \ - 1)) XOR bArray(bArray.length - 1) \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp409gxz04.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        for(i <- 0 until aList.size)\
    \ {\n            result += ((aList(i) XOR bList(i)) XOR aList(i)) XOR bList(i)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1svsxkqc.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aList(i) XOR bList(i)) XOR aList(i))\
    \ XOR bList(i)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value += is not a member of String - did you mean String.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp1svsxkqc.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aList(i) XOR bList(i)) XOR aList(i))\
    \ XOR bList(i)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        value XOR is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutZeros = xorBitsString.filter(_\
    \ != '0')\n        val xorBitsStringWithoutOnes = xorBitsStringWithoutZeros.filter(_\
    \ != '1')\n        val xorBitsStringWithoutOnesAndZeros = xorBitsStringWithoutOnes.filter(_\
    \ != '0')\n        val xorBitsStringWithoutOnesAndZerosWithoutOnes = xorBitsStringWithoutOnesAndZeros.filter(_\
    \ != '1')\n        val xorBitsStringWithoutOnesAndZerosWithoutOnesAndZeros = xorBitsStringWithoutOnesAndZerosWithoutOnes.filter(_\
    \ != '0')\n        val xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnes\
    \ = xorBitsStringWithoutOnesAndZerosWithoutOnesAndZeros.filter(_ != '1')\n   \
    \     val xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZeros\
    \ = xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnes.filter(_ !=\
    \ '0')\n        val xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnes\
    \ = xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZeros.filter(_\
    \ != '1')\n        val xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZeros\
    \ = xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnes.filter(_\
    \ != '0')\n        val xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnes\
    \ = xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZeros.filter(_\
    \ != '1')\n        val xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZeros\
    \ = xorBitsStringWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnesAndZerosWithoutOnes.filter(_\
    \ != '0')\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptb7hm3nv.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmptb7hm3nv.scala:24:5 ---------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(bArray).map(x\
    \ => x._1 xor x._2)\n        val xorString = xorArray.toString.map(_.toChar).mkString\n\
    \        xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdt5cm3o9.scala:11:56 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = aArray.zip(bArray).map(\e\
    [36mx\e[0m => x._1 xor x._2)\n\e[31m\e[31m   |\e[0m                          \
    \                         ^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                   value xor is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmpdt5cm3o9.scala:11:65\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m11 |\e[0m       \
    \ \e[33mval\e[0m \e[36mxorArray\e[0m = aArray.zip(bArray).map(\e[36mx\e[0m =>\
    \ x._1 xor x._2)\n\e[31m\e[31m   |\e[0m                                      \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \                No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \                                          where:    B is a type variable\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i) xor bBits(i)\n            i += 1\n        }\n\
    \        xorBits.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcgsnfx2p.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcgsnfx2p.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for ((index, value) <- xorBitsString.zipWithIndex) {\n            if (value\
    \ == 0) {\n                xorBitsStringBuilder.append(0)\n            } else\
    \ {\n                xorBitsStringBuilder.append(1)\n            }\n        }\n\
    \        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpthzcgtrp.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpthzcgtrp.scala:22:29 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        var i = 0\n        while (i < aList.length && i < bList.length)\
    \ {\n            val aChar = aList(i)\n            val bChar = bList(i)\n    \
    \        val aCharInt = aChar match {\n                case '1' => 1\n       \
    \         case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string a: \" + aChar)\n            }\n            val bCharInt\
    \ = bChar match {\n                case '1' => 1\n                case '0' =>\
    \ 0\n                case _ => throw new IllegalArgumentException(\"Invalid character\
    \ in string b: \" + bChar)\n            }\n            val aCharInt = aCharInt\
    \ xor bCharInt\n            val aCharChar = aCharInt match {\n               \
    \ case 1 => '1'\n                case 0 => '0'\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character in string a: \" + aChar)\n\
    \            }\n            val bCharChar = bCharInt match {\n               \
    \ case 1 => '1'\n                case 0 => '0'\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character in string b: \" + bChar)\n\
    \            }\n            result.append(aCharChar)\n            carry = aCharInt\
    \ xor bCharInt\n            i += 1\n        }\n        if (i < aList.length) {\n\
    \            val aChar = aList(i)\n            val bChar = bList(i)\n        \
    \    val aCharInt = aChar match {\n                case '1' => 1\n           \
    \     case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string a: \" + aChar)\n            }\n            val bCharInt\
    \ = bChar match {\n                case '1' => 1\n                case '0' =>\
    \ 0\n                case _ => throw new IllegalArgumentException(\"Invalid character\
    \ in string b: \" + bChar)\n            }\n            val aCharInt = aCharInt\
    \ xor bCharInt\n            val aCharChar = aCharInt match {\n               \
    \ case 1 => '1'\n                case 0 => '0'\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character in string a: \" + aChar)\n\
    \            }\n            val bCharChar = bCharInt match {\n               \
    \ case 1 => '1'\n                case 0 => '0'\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character in string b: \" + bChar)\n\
    \            }\n            result.append(aCharChar)\n            carry = aCharInt\
    \ xor bCharInt\n        }\n        if (i < bList.length) {\n            val aChar\
    \ = aList(i)\n            val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmppdqzlh59.scala:71:15 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppdqzlh59.scala:80:0 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppdqzlh59.scala:27:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e\
    [0m \e[36maCharInt\e[0m = aCharInt xor bCharInt\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maCharInt is already\
    \ defined as \e[33mvalue\e[0m \e[35maCharInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppdqzlh59.scala:39:29\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            carry = aCharInt\
    \ xor bCharInt\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    value xor is not a member of Int\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmppdqzlh59.scala:55:16 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[33mval\e[0m \e[36maCharInt\e[0m = aCharInt\
    \ xor bCharInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maCharInt is already defined as \e[33mvalue\e[0m \e[35maCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmppdqzlh59.scala:67:29 ------------------------\e[0m\e[0m\n\
    \e[31m67 |\e[0m            carry = aCharInt xor bCharInt\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ xor is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppdqzlh59.scala:79:1\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m}\n\e[31m\e"
  stdout: ''
  timestamp: 1659978673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpes6ija0h.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpes6ija0h.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(1,xorBitsString.length)\n        val result = xorBitsStringWithoutLeadingZeros\
    \ + \"0\"\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfw2koaah.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithZeros.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuqtf3fwj.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpuqtf3fwj.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwtdm0wd.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwwtdm0wd.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toString.reverse\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo7gs53pk.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978673
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.foldLeft(\"\") { (result, currentChar)\
    \ =>\n            val currentIndex = aList.indexOf(currentChar)\n            val\
    \ currentIndex2 = bList.indexOf(currentChar)\n            if (currentIndex ==\
    \ -1 || currentIndex2 == -1) {\n                result + currentChar\n       \
    \     } else {\n                val xor = currentChar ^ bList(currentIndex2)\n\
    \                result + xor\n            }\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpma51xzal.scala:24)\n\tat Problem.main(tmpma51xzal.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfs2ukig.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978653
