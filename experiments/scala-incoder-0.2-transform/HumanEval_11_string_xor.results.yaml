language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for (i <- 0 until aList.length)\n            carry += aList(i)\
    \ xor bList(i)\n        carry += carry\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n        carry += aList(aList.length)\
    \ xor bList(aList.length)\n        carry /= 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ifhtnal.scala:14:18 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            carry += aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp3ifhtnal.scala:14:30 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m            carry += aList(i) xor bList(i)\n\e[31m\e[31m   |\e[0m    \
    \                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     value\
    \ xor is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ifhtnal.scala:17:14\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        carry += aList(aList.length)\
    \ xor bList(aList.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        value += is not a member of Int - did you mean Int.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3ifhtnal.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        carry += aList(aList.length) xor bList(aList.length)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 value xor is not a member of Char\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp3ifhtnal.scala:19:14 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        carry += aList(aList.length) xor bList(aList.length)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3ifhtnal.scala:19:37 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        carry += aList(aList.length) xor bList(aList.length)\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \            value xor is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp3ifhtnal.scala:21:14 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        carry += aList(aList.length) xor bList(aList.length)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Fou"
  stdout: ''
  timestamp: 1659793177
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(_ + 48).toString\n        xorBitsString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbue24bg3.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbue24bg3.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n    \
    \    for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n     \
    \   xorList.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp13eal9s2.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.substring(0,xorBitsString.length-1)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuy2nu7rm.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithLeadingZeros = \"\
    0\" + xorBitsString\n        val xorBitsStringWithTrailingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        xorBitsStringWithTrailingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo65oanwt.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      val len = aList.size + bList.size\n        var i = 0\n        while (i\
    \ < len) {\n            val aChar = aList(i)\n            val bChar = bList(i)\n\
    \            if (aChar == '0' && bChar == '0') {\n                result.append(\"\
    0\")\n            } else if (aChar == '0' && aChar == '1') {\n               \
    \ result.append(\"1\")\n            } else if (bChar == '0' && bChar == '1') {\n\
    \                result.append(\"1\")\n            } else {\n                result.append(\"\
    0\")\n            }\n            i += 1\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpteu1cc8b.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val aLen = aList.length\n        val bLen = bList.length\n\
    \        val result = new StringBuilder(aLen)\n        var i = 0\n        while\
    \ (i < aLen) {\n            result.append(aList(i) ^ bList(i))\n            i\
    \ += 1\n        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<- 0 until xorBitsStringLength) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcyomo_0p.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until a.length) {\n            val\
    \ aBit = aBits(i)\n            val bBit = bBits(i)\n            val xor = aBit\
    \ ^ bBit ^ carry\n            carry = xor >> 1\n            result.append(xor\
    \ & 1)\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp04ijd006.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp04ijd006.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp04ijd006.scala:11:25 ------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m\
    \ mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new Array[Int](a.length)\n\
    \        var i = 0\n        while (i < a.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(result)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxyasiuc.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value xor is not a member of Int\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpqxyasiuc.scala:17:12 -----------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(result)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((result : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits.toInt\n\
    \            val bBit = bBits.toInt\n            val aChar = a(i).toChar\n   \
    \         val bChar = b(i).toChar\n            val aBit = aBit + aChar.toInt *\
    \ bChar.toInt\n            val aBit = aBit + carry\n            val aBit = aBit\
    \ % 2\n            val aBit = aBit == 1 ? \"1\" : \"0\"\n            val aBits\
    \ = aBit + bBits.toInt\n            val aBits = aBits % 2\n            val aBits\
    \ = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n      \
    \      val aBits = aBits % 2\n            val aBits = aBits == 1 ? \"1\" : \"\
    0\"\n            val aBits = aBits + carry\n            val aBits = aBits % 2\n\
    \            val aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits\
    \ + carry\n            val aBits = aBits % 2\n            val aBits = aBits ==\
    \ 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n            val aBits\
    \ = aBits % 2\n            val aBits = aBits == 1 ? \"1\" : \"0\"\n          \
    \  val aBits = aBits + carry\n            val aBits = aBits % 2\n            val\
    \ aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n\
    \            val aBits = aBits % 2\n            val aBits = aBits == 1 ? \"1\"\
    \ : \"0\"\n            val aBits = aBits + carry\n            val aBits = aBits\
    \ % 2\n            val aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits\
    \ = aBits + carry\n            val aBits = aBits % 2\n            val aBits =\
    \ aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits + carry\n        \
    \    val aBits = aBits % 2\n            val aBits = aBits == 1 ? \"1\" : \"0\"\
    \n            val aBits = aBits + carry\n            val aBits = aBits % 2\n \
    \           val aBits = aBits == 1 ? \"1\" : \"0\"\n            val aBits = aBits\
    \ + carry\n            val aBit\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8t4xf4q_.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8t4xf4q_.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t4xf4q_.scala:19:16 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit + aChar.toInt *\
    \ bChar.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBit is already defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8t4xf4q_.scala:20:16 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit + carry\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maBit is already\
    \ defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8t4xf4q_.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit % \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0maBit is already defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8t4xf4q_.scala:22:16 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBit == \e[31m1\e[0m ? \e\
    [31m\"1\"\e[0m : \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBit is already defined as \e[33mvalue\e[0m \e[35maBit\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ var i = 0\n        while (i < aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n  \
    \          val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9l399x2i.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:30:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:32:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:33:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9l399x2i.scala:36:57\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntI"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      var carry = 0\n        for(i <- 0 until aList.length){\n            val\
    \ aChar = aList(i)\n            val bChar = bList(i)\n            val xor = aChar\
    \ xor bChar\n            val newCarry = xor & 1\n            val newChar = xor\
    \ >> 1\n            val newCharString = Integer.toBinaryString(newChar)\n    \
    \        val newCarryString = Integer.toBinaryString(newCarry)\n            val\
    \ newString = newCharString + newCarryString\n            result.add(newString)\n\
    \            carry = newCarry\n        }\n        if(carry != 0){\n          \
    \  result.add(\"1\")\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9c8zmgdn.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9c8zmgdn.scala:16:28\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m\
    \ \e[36mxor\e[0m = aChar xor bChar\n\e[31m\e[31m   |\e[0m                    \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value xor is not a member\
    \ of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val aLen = a.length\n        val bLen\
    \ = b.length\n        val result = new StringBuilder(aLen)\n        var i = 0\n\
    \        while (i < aLen && i < bLen) {\n            result.append(aArray(i) XOR\
    \ bArray(i))\n            i += 1\n        }\n        result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1yzrrrxa.scala:16:36 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            result.append(aArray(i) XOR bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array[Int]()\n\
    \        var xor = 0\n        var i = 0\n        while (i < aArray.length) {\n\
    \            xor = xor + aArray(i) ^ bArray(i)\n            xorArray = xorArray\
    \ :+ xor\n            i = i + 1\n        }\n        xorArray.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkya2ot5d.scala:16:21 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            xorArray = xorArray :+ xor\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Reassignment to val xorArray\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            xorArray += (aArray(i) xor\
    \ bArray(i))\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfeuuoii.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793175
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
