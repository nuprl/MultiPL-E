name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given an array arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the array, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
  \ -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))\n\
  \    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n    def prodSigns(arr\
  \ : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = arr.map(x => x * x).sum\n        signs.map(x => x\
    \ * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        product.sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)( (x, y) =>\
    \ x * y)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = product.map(x => math.abs(x))\n        magnitudes.sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  magnitudes.map(x => x * product).sum", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val product = signs.map(x => x * magnitudes.sum)\n   \
    \     magnitudes.zip(product).map(x => x._1 * x._2).sum", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  val sum = magnitudes.sum\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x == 0) 0 else 1)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = magnitudes.map(x => x * product)\n        val\
    \ productMagnitudesSum = productMagnitudes.sum\n        val productMagnitudesSumAbs\
    \ = math.abs(productMagnitudesSum)\n        if (productMagnitudesSumAbs == 0)\
    \ None else Some(productMagnitudesSumAbs)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)", "        val product = arr.foldLeft(1l)(_\
    \ * _)\n        val signs = arr.map(x => if (x < 0) -1 else 1)\n        signs.foldLeft(product)(_\
    \ * _)", "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * product)",
  "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => product * x)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x == 0) 0 else 1)\n        val product\
    \ = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitude = product.map(x => math.abs(x))\n\
    \        magnitude.sum", "        val product = arr.foldLeft(1L)(_ * _)\n    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  signs.foldLeft(product)(_ * _)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ *\
    \ _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_\
    \ + _)\n        Some(sum * product)", "        val product = arr.foldLeft(1L)\
    \ { (product, num) =>\n            product * num\n        }\n        val signs\
    \ = arr.map(num => if (num > 0) 1 else -1)\n        val magnitudes = signs.map(num\
    \ => math.abs(num))\n        val sum = magnitudes.sum\n        val productOfSigns\
    \ = signs.foldLeft(1L) { (product, sign) =>\n            product * sign\n    \
    \    }\n        val productOfMagnitudes = magnitudes.foldLeft(1L) { (product,\
    \ magnitude) =>\n            product * magnitude\n        }\n        Some(sum\
    \ * productOfMagnitudes * productOfSigns)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)\
    \ { (acc, x) => acc + x._1 * x._2 }", "        val m = arr.map(_.abs).sum\n  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        Some(signs.map(x => x * product).sum\
    \ / m)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = signs.product\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        signs.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val result = magnitudes.zip(signs).map(x => x * product)\n\
    \        if (result.isEmpty) None else Some(result.sum)", "        val product\
    \ = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)((x, y) => x * y)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l){\
    \ (sum, tuple) =>\n            val productSign = tuple._1 * tuple._2\n       \
    \     sum + productSign\n        }", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.reduce(_ * _)\n        magnitudes.map(x => x * product).getOrElse(None)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(sum * product)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val result = magnitudes.map(x\
    \ => x * product).sum\n        if (result > 0) Some(result) else None", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        magnitudes.map(x => x * product).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x == 0) 0 else 1)\n        val product\
    \ = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.sum", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = arr.map(x => x * signs.sum)\n        val sum = signs.sum\n       \
    \ val mag = arr.map(x => math.abs(x)).sum\n        val result = mag * product.sum\n\
    \        if (sum == 0) None else Some(result)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)(\
    \ (acc, x) => acc + x._1 * x._2 )", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.product\n        if (product == 0) None else Some(signs.map(x\
    \ => x * m).sum)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x\
    \ * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val productMagnitudes = product.zip(magnitudes)\n \
    \       productMagnitudes.foldLeft(0l)(_ * _)", "        val product = arr.foldLeft(1L)\
    \ { (product, value) => product * value }\n        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x =>\
    \ math.abs(x))\n        magnitudes.zip(product).map { case (mag, prod) => mag\
    \ * prod }", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = signs.product\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        val result = Some(sum\
    \ * product)\n        result", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n \
    \       val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = product.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        if\
    \ (sum > 0) Some(sum) else None", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(product)(_\
    \ + _)\n        Some(sum)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        if\
    \ (sum == product) Some(sum) else None", "        val product = arr.foldLeft(1L)\
    \ { (product, item) => product * item }\n        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product) { (product,\
    \ sign) => product * sign }", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x == 0) 0 else 1)\n        val product = signs.reduce((x, y) => x *\
    \ y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result =\
    \ magnitudes.zip(signs).map(x => x.product).zip(product).map(x => x._1 * x._2)\n\
    \        if (result.isEmpty) None else Some(result.sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val product = arr.map(x\
    \ => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0).sum\n        Some(signs * product)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        Some(signs.map(x => x * product).sum)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)\
    \ { (sum, tuple) => sum + tuple._1 * tuple._2 }", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        signs.map(x => x * product).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n        Some(product\
    \ * sum)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val\
    \ m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n        Some(arr.map(x\
    \ => x * m * s).sum)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val result = magnitudes.zip(product).map(x => x._1 * x._2).sum\n    \
    \    if (sum == 0) None else Some(result)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.map(x => x * product).sum\n        if (result > 0) Some(result)\
    \ else None", "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n\
    \        Some(m * s)", "        val m = arr.map(_.abs).sum\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        Some(arr.map(x => x * product).sum / m)", "       \
    \ val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = arr.map(x => x * x).sum\n        val magnitudes = signs.map(x => x\
    \ * product)\n        magnitudes.sum", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,y)\
    \ => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum\
    \ = magnitudes.reduce((x,y) => x + y)\n        val productSign = signs.reduce((x,y)\
    \ => x * y)\n        if (sum == product) {\n            Some(product)\n      \
    \  } else if (sum < product) {\n            None\n        } else {\n         \
    \   Some(product)\n        }", "        val m = arr.map(_.abs).sum\n        val\
    \ signs = arr.map(_.signum).sum\n        Some(m * signs)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduce((x, y) => x + y)\n        val productSign\
    \ = signs.reduce((x, y) => x * y)\n        val magnitudeSign = magnitudes.reduce((x,\
    \ y) => x + y)\n        val productSignMagnitude = productSign * magnitudeSign\n\
    \        val productSignMagnitudeOption = productSignMagnitude match {\n     \
    \       case 0 => None\n            case x => Some(productSignMagnitude)\n   \
    \     }\n        productSignMagnitudeOption", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L) { (x, y) => x *\
    \ y }\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(0L)\
    \ { (x, y) => x + y }\n        Some(sum * product)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      product.sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ == 0) 0 else 1)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_\
    \ + _)\n        Some(sum * product)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * x).sum\n\
    \        signs.map(x => x * product).sum", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ *\
    \ _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result =\
    \ magnitudes.zip(signs).map(x => x.product).zip(product).map(x => x._1 * x._2)\n\
    \        Some(result.sum)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = product.zip(magnitudes)\n        productMagnitudes.find(_._1 == productMagnitudes.max(_._2))",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n        Some(product\
    \ * sum)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes =\
    \ arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ product = arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0).sum\n        Some(product * signs)", "     \
    \   val product = arr.foldLeft(1l)((acc, x) => acc * x)\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)((acc,\
    \ x) => acc * x)", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(_.signum).sum\n\
    \        Some(signs * m * arr.product)", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.reduce((x, y) => x + y)\n        Some(product * sum)", "  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        signs.map(x => product * x).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        val result = if (sum == product) Some(sum)\
    \ else None\n        result", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitudes = product.map(math.abs)\n        magnitudes.sum", "  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x\
    \ => math.abs(x)).sum\n        Some(magnitude * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = magnitudes.map(x => x * product)\n        val\
    \ productMagnitudesSum = productMagnitudes.sum\n        val magnitudesSum = magnitudes.sum\n\
    \        val magnitudesSumProduct = magnitudesSum * product\n        val magnitudesSumProductMagnitudes\
    \ = magnitudesSumProduct * signs\n        val magnitudesSumProductMagnitudesSum\
    \ = magnitudesSumProductMagnitudes.sum\n        val magnitudesSumProductMagnitudesSumProduct\
    \ = magnitudesSumProductMagnitudesSum * signs\n        val magnitudesSumProductMagnitudesSumProductMagnitudes\
    \ = magnitudesSumProductMagnitudesSumProduct * signs\n        val magnitudesSumProductMagnitudesSumProductMagnitudesSum\
    \ = magnitudesSumProductMagnitudesSumProductMagnitudes.sum\n        val magnitudesSumProductMagnitudesSumProductMagnitudesSumProduct\
    \ = magnitudesSumProductMagnitudesSumProductMagnitudesSum * signs\n        val\
    \ magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudes = magnitudesSumProductMagnitudesSumProductMagnitudesSumProduct\
    \ * signs\n        val magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSum\
    \ = magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudes.sum\n\
    \        val magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSumProduct\
    \ = magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSum\
    \ * signs\n        val magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudes\
    \ = magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSumProduct\
    \ * signs\n        val magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSum\
    \ = magnitudesSumProductMagnitudesSumProductMagnitudesSumProductMagnitudesSumProduct",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ product = arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val magnitudesProduct = magnitudes.map(x => x * product)\n        magnitudesProduct.sum",
  "        val product = arr.foldLeft(1L) { (product, elem) =>\n            product\
    \ * elem\n        }\n        val signs = arr.map(elem => if (elem < 0) -1 else\
    \ if (elem > 0) 1 else 0)\n        val magnitudes = signs.map(elem => math.abs(elem))\n\
    \        magnitudes.zip(product).map(elem => elem._1 * elem._2).sum", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduce(_ + _)\n        Some(product * sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).getOrElse(None)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.reduce(_ * _)\n   \
    \     magnitudes.map(x => x * product).sum", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.map(x => x * product).sum\n        Some(sum)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * x).sum\n        val magnitude = signs.map(x => x * product).sum\n\
    \        magnitude.map(x => if (x < 0) -x else x).orElse(None)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(math.abs)\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n \
    \       val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x *\
    \ product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n\
    \        val result = if (magnitude == 0) None else Some(magnitude * product)\n\
    \        result", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val product = arr.map(_.toLong).product\n        val signs = arr.map(_.toLong).map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.sum", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ productMagnitudes = magnitudes.zip(signs).map(x => x._1 * x._2)\n        magnitudes.zip(productMagnitudes).map(x\
    \ => x._1 + x._2).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val result\
    \ = Some(sum * product)\n        result", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.foldLeft(0L)(_ + _)\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        magnitudes.map(x => product * x).sum", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n \
    \       val product = signs.zip(magnitudes).map(x => x._1 * x._2).sum\n      \
    \  val result = if (product == 0) None else Some(product)\n        result", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val result = magnitudes.map(x => x * product).sum\n\
    \        if (result > 0) Some(result) else None", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val result = Some(sum * product)\n        result", "        val product\
    \ = arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0).sum\n        Some(signs * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.foldLeft(product)(_ + _)\n   \
    \     Some(sum)", "        val product = arr.map(x => x * x).sum\n        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val magnitudeProduct = magnitudes.map(x\
    \ => x * product)\n        magnitudeProduct.sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.map(x => x * product).sum\n        if (result > 0) Some(result)\
    \ else None", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = product.zip(magnitudes)\n\
    \        productMagnitudes.foldLeft(0l)( (x, y) => x * y)", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(arr.map(x => x * x * m *\
    \ s).sum)", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        Some(signs.map(x => x * product).sum / m)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.foldLeft(0L)(_ + _)\n        Some(product * sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n        val\
    \ productSign = signs.reduceLeft(_ * _)\n        val productMagnitudes = magnitudes.reduceLeft(_\
    \ + _)\n        val productSum = magnitudes.reduceLeft(_ + _)\n        val productProductSign\
    \ = signs.reduceLeft(_ * _)\n        val productProductMagnitudes = magnitudes.reduceLeft(_\
    \ + _)\n        val productProductSum = magnitudes.reduceLeft(_ + _)\n       \
    \ Some(sum * productSign)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n \
    \       val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x *\
    \ product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n \
    \       if (sum == 0) None else Some(sum * product.sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        if (sum > 0) Some(sum * product.sum) else None", "        val product\
    \ = arr.foldLeft(1L) { (product, elem) => product * elem }\n        val signs\
    \ = arr.map(elem => if (elem < 0L) -1L else 1L)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ *\
    \ _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduce(_\
    \ + _)\n        Some(sum * product)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x == 0) 0 else 1)\n        val product = signs.product\n  \
    \      val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map\
    \ { case (m, s) => m * s * product }", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._1).sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n \
    \       val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x *\
    \ product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val result = magnitudes.map(x => x * product).sum\n\
    \        Some(result)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val result = magnitudes.map(x\
    \ => x * product)\n        if (result.isEmpty) None else Some(result.sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)\
    \ { (sum, tuple) => sum + tuple._1 * tuple._2 }", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(0L) { (x, y) => x + y }\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduce((x, y) => x + y)\n    \
    \    val productSign = signs.reduce((x, y) => x * y)\n        if (magnitude ==\
    \ 0) None else Some(productSign * product)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n\
    \        magnitudes.map(math.pow(_, product))", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        Some(signs.map(x => x * product).sum)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.zip(product).map { case (mag, prod) => mag\
    \ * prod }", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes =\
    \ arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val productSign\
    \ = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudeSign = magnitudes.map(x\
    \ => math.abs(x))\n        val productSignMagnitude = productSign * magnitudeSign\n\
    \        val productSignMagnitudeSum = productSignMagnitude.sum\n        val productSignMagnitudeSumAbs\
    \ = productSignMagnitudeSum.abs\n        if (productSignMagnitudeSumAbs == sum)\
    \ {\n            Some(productSignMagnitudeSum)\n        } else {\n           \
    \ None\n        }", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val product = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        val productSigns = signs.map(x => x\
    \ * product)\n        val productMagnitudes = magnitudes.map(x => x * product)\n\
    \        val productSum = productSigns.sum\n        if (productSum == 0) None\
    \ else Some(sum * productSum)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduce((x, y) => x *\
    \ y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.reduce((x, y)\
    \ => x + y)", "        val product = arr.foldLeft(1l)((acc, x) => acc * x)\n \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     signs.foldLeft(product)((acc, x) => acc * x)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x == 0) 0 else 1)\n        val product = signs.foldLeft(1l)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * x).sum\n        signs.map(x\
    \ => product * x).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduce(_ + _)\n  \
    \      Some(product * sum)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * x).sum\n      \
    \  signs.map(x => product * x).sum", "        val m = arr.map(_.abs).sum\n   \
    \     val s = arr.map(_.signum).sum\n        Some(arr.map(x => x * m * s).sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val sum = magnitudes.sum\n        val productOfSigns = product.map(x => x *\
    \ signs.sum)\n        val productOfMagnitudes = productOfSigns.map(x => math.abs(x))\n\
    \        val productOfMagnitudesSum = productOfMagnitudes.sum\n        if (productOfMagnitudesSum\
    \ == sum) {\n            Some(productOfMagnitudesSum)\n        } else {\n    \
    \        None\n        }", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x == 0) 0 else 1)\n        val product = signs.foldLeft(1L)(_ * _)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x =>\
    \ x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ == 0) 0 else 1)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = magnitudes.map(x\
    \ => x * product)\n        productMagnitudes.sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.product\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ product = arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * product)", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ m = arr.foldLeft(0l) { (sum, elem) => sum + elem * math.signum(elem) }\n   \
    \     val signs = arr.map(math.signum).sum\n        if (signs == 0) None else\
    \ Some(signs * m)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes = product.zip(magnitudes)\n\
    \        productMagnitudes.foldLeft(0l)(_ * _).map(math.abs)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduce(_ + _)\n        Some(sum * product)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.product\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ product = arr.foldLeft(1L) { (product, item) =>\n            product * item\n\
    \        }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        signs.foldLeft(product) { (product, sign) =>\n            product\
    \ * sign\n        }", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitude = arr.map(x => math.abs(x)).sum\n        val result = if (magnitude\
    \ == 0) None else Some(magnitude * product)\n        result", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * x).sum\n      \
    \  signs.map(x => x * product).sum", "        val m = arr.map(_.abs).sum\n   \
    \     val n = arr.map(_.signum).sum\n        Some(arr.map(x => x * x * m * n).sum)",
  "        val product = arr.foldLeft(1L){ (product, value) => product * value }\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2).sum", "        val product = arr.foldLeft(1L) { (product, element)\
    \ => product * element }\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product) { (product, sign) => product\
    \ * sign }", "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n\
    \        Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val sum = magnitudes.reduce(_ + _)\n        Some(product\
    \ * sum)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n        val\
    \ productSign = signs.reduceLeft(_ * _)\n        val productMagnitude = magnitudes.reduceLeft(_\
    \ * _)\n        if (sum == product) Some(product) else None", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val result = magnitudes.map(x => x * product).sum\n        if (result\
    \ > 0) Some(result) else None", "        val product = arr.foldLeft(1L) { (product,\
    \ value) =>\n            product * value\n        }\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.zip(product).map(x => x._1 * x._2).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * x).sum\n        signs.map(x => product * x).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitude\
    \ = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduce(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x == 0) 0 else 1)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        if (sum == product) Some(product) else None",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduce((x, y) => x + y)\n    \
    \    val productSign = signs.reduce((x, y) => x * y)\n        if (magnitude ==\
    \ 0) None else Some(sum * productSign)", "        val product = arr.foldLeft(1L)(_\
    \ * _)\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        signs.foldLeft(product)((x, y) => x * y)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ arr.map(x => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduce(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum"]
stop_tokens:
- "\n    }\n"
