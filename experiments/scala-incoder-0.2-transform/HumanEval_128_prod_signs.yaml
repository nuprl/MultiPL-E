name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given an array arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the array, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
  \ -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))\n\
  \    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n    def prodSigns(arr\
  \ : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = arr.map(x => x * x).sum\n        signs.map(x => x\
    \ * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        product.sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)( (x, y) =>\
    \ x * y)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = product.map(x => math.abs(x))\n        magnitudes.sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * x).sum\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  magnitudes.map(x => x * product).sum", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val product = signs.map(x => x * magnitudes.sum)\n   \
    \     magnitudes.zip(product).map(x => x._1 * x._2).sum", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n      \
    \  val sum = magnitudes.sum\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x == 0) 0 else 1)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = magnitudes.map(x => x * product)\n        val\
    \ productMagnitudesSum = productMagnitudes.sum\n        val productMagnitudesSumAbs\
    \ = math.abs(productMagnitudesSum)\n        if (productMagnitudesSumAbs == 0)\
    \ None else Some(productMagnitudesSumAbs)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)", "        val product = arr.foldLeft(1l)(_\
    \ * _)\n        val signs = arr.map(x => if (x < 0) -1 else 1)\n        signs.foldLeft(product)(_\
    \ * _)", "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * product)",
  "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => product * x)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x == 0) 0 else 1)\n        val product\
    \ = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitude = product.map(x => math.abs(x))\n\
    \        magnitude.sum", "        val product = arr.foldLeft(1L)(_ * _)\n    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  signs.foldLeft(product)(_ * _)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ *\
    \ _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_\
    \ + _)\n        Some(sum * product)", "        val product = arr.foldLeft(1L)\
    \ { (product, num) =>\n            product * num\n        }\n        val signs\
    \ = arr.map(num => if (num > 0) 1 else -1)\n        val magnitudes = signs.map(num\
    \ => math.abs(num))\n        val sum = magnitudes.sum\n        val productOfSigns\
    \ = signs.foldLeft(1L) { (product, sign) =>\n            product * sign\n    \
    \    }\n        val productOfMagnitudes = magnitudes.foldLeft(1L) { (product,\
    \ magnitude) =>\n            product * magnitude\n        }\n        Some(sum\
    \ * productOfMagnitudes * productOfSigns)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0l)\
    \ { (acc, x) => acc + x._1 * x._2 }"]
stop_tokens:
- "\n    }\n"
