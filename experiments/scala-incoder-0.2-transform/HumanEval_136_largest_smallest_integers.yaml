name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        val negative = lst.filter(x => x < 0l)\n        val positive\
    \ = lst.filter(x => x > 0l)\n        if (negative.isEmpty && positive.isEmpty)\n\
    \            (None, None)\n        else if (negative.isEmpty)\n            (Some(positive.min),\
    \ Some(positive.max))\n        else if (positive.isEmpty)\n            (Some(negative.min),\
    \ Some(negative.max))\n        else\n            (Some(negative.min), Some(negative.max))",
  "        val positive = lst.filter(x => x < 0l)\n        val negative = lst.filter(x\
    \ => x > 0l)\n        if (positive.isEmpty && negative.isEmpty) None\n       \
    \ else if (positive.isEmpty) Some(negative.minOption)\n        else if (negative.isEmpty)\
    \ Some(positive.maxOption)\n        else (Some(positive.maxOption), Some(negative.minOption))",
  "        val negative = lst.filter(_ < 0l)\n        val positive = lst.filter(_\
    \ > 0l)\n        if (negative.isEmpty && positive.isEmpty) None\n        else\
    \ if (negative.isEmpty || positive.isEmpty) Some(None) else None\n        else\
    \ {\n            val maxNegative = negative.max\n            val minPositive =\
    \ positive.min\n            if (maxNegative < minPositive) Some(None) else None\n\
    \            else Some(maxNegative) :: Some(minPositive)\n        }", "      \
    \  val negatives = lst.filter(x => x < 0l)\n        val positives = lst.filter(x\
    \ => x > 0l)\n        if (negatives.isEmpty) None\n        else if (positives.isEmpty)\
    \ None\n        else {\n            val largest = negatives.max\n            val\
    \ smallest = positives.min\n            (Some(largest), Some(smallest))\n    \
    \    }", "        val negative = lst.filter(_ < 0l)\n        val positive = lst.filter(_\
    \ >= 0l)\n        if (negative.isEmpty && positive.isEmpty)\n            (None,\
    \ None)\n        else if (negative.isEmpty)\n            (Some(positive.min),\
    \ Some(positive.max))\n        else if (positive.isEmpty)\n            (Some(negative.min),\
    \ Some(negative.max))\n        else\n            (Some(negative.min), Some(negative.max))",
  "        val negative = lst.filter(_ < 0l)\n        val positive = lst.filter(_\
    \ > 0l)\n        if (negative.isEmpty && positive.isEmpty) None\n        else\
    \ if (negative.isEmpty) Some(positive.min.toLong)\n        else if (positive.isEmpty)\
    \ Some(negative.min.toLong)\n        else (Some(negative.min.toLong), Some(positive.min.toLong))",
  "        val negative = lst.filter(x => x < 0l)\n        val positive = lst.filter(x\
    \ => x > 0l)\n        if (negative.isEmpty && positive.isEmpty)\n            (None,\
    \ None)\n        else if (negative.isEmpty)\n            (Some(positive.min),\
    \ Some(negative.max))\n        else if (positive.isEmpty)\n            (Some(negative.min),\
    \ Some(positive.max))\n        else\n            (Some(negative.min), Some(positive.max))",
  "        val negative = lst.filter(_ < 0l)\n        val positive = lst.filter(_\
    \ > 0l)\n        if (negative.isEmpty && positive.isEmpty) None else (Some(negative.max),\
    \ Some(positive.min))", "        val negative = lst.filter(x => x < 0l)\n    \
    \    val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty && positive.isEmpty)\
    \ None\n        else if (negative.isEmpty) Some(positive.minOption)\n        else\
    \ if (positive.isEmpty) Some(negative.maxOption)\n        else (Some(negative.maxOption),\
    \ Some(positive.minOption))", "        val negative = lst.filter(_ < 0l)\n   \
    \     val positive = lst.filter(_ > 0l)\n        val a = negative.maxBy(_)\n \
    \       val b = positive.minBy(_)\n        (a.toOption, b)", "        val negative\
    \ = lst.filter(x => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n\
    \        if (negative.isEmpty && positive.isEmpty) None else (Some(negative.max),\
    \ Some(positive.min))", "        val negatives = lst.filter(x => x < 0l)\n   \
    \     val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))", "        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))", "        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))", "        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)", "        val negative = lst.filter(_ < 0l)\n        val positive\
    \ = lst.filter(_ > 0l)\n        if (negative.isEmpty && positive.isEmpty)\n  \
    \          (None, None)\n        else if (negative.isEmpty)\n            (Some(positive.min),\
    \ Some(positive.max))\n        else if (positive.isEmpty)\n            (Some(negative.min),\
    \ Some(negative.max))\n        else\n            (Some(negative.min), Some(negative.max))",
  "        val negatives = lst.filter(x => x < 0l)\n        val positives = lst.filter(x\
    \ => x > 0l)\n        if (negatives.isEmpty) \n            (Some(None), Some(positives.min))\n\
    \        else if (positives.isEmpty) \n            (Some(negatives.max), Some(None))\n\
    \        else\n            (Some(negatives.max), Some(positives.min))", "    \
    \    val negatives = lst.filter(x => x < 0l)\n        val positives = lst.filter(x\
    \ => x > 0l)\n        if (negatives.isEmpty) \n            (Some(None), Some(positives.min))\n\
    \        else if (positives.isEmpty)\n            (Some(negatives.max), Some(None))\n\
    \        else\n            (Some(negatives.max), Some(positives.min))", "    \
    \    val negatives = lst.filter(x => x < 0l)\n        val positives = lst.filter(x\
    \ => x > 0l)\n        if (negatives.isEmpty) \n            (Some(None), Some(positives.min))\n\
    \        else if (positives.isEmpty) \n            (Some(negatives.max), Some(None))\n\
    \        else \n            (Some(negatives.max), Some(positives.min))", "   \
    \     val negative = lst.filter(_ < 0l)\n        val positive = lst.filter(_ >\
    \ 0l)\n        if (negative.isEmpty && positive.isEmpty) None\n        else if\
    \ (negative.isEmpty) Some(positive.minOption)\n        else if (positive.isEmpty)\
    \ Some(negative.maxOption)\n        else (negative.minOption, positive.maxOption)"]
stop_tokens:
- "\n    }\n"
