language: scala
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeroMinusOne = onesZero -\
    \ 1\n        val onesZeroMinusOneMinusOne = onesZeroMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n   \
    \     val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne -\
    \ 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:25:79 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:26:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                 ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:27:95\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8bgo_283.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_sorted = onesZeros.sortBy(x => x.toString.toInt)\n    \
    \    val onesZeros_sorted_sorted = onesZeros_sorted.sortBy(x => x.toString.toInt)\n\
    \        val onesZeros_sorted_sorted_sorted = onesZeros_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted.sortBy(x => x.toString.toInt)\n    \
    \    val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x => x.toString.toInt)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpboo6qcwd.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpboo6qcwd.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpboo6qcwd.scala:17:29 ------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).size\n        val zeros\
    \ = arr.filter(_ == 0).size\n        val onesZeros = ones + zeros\n        val\
    \ onesZerosList = onesZeros.toList\n        val onesZerosListSorted = onesZerosList.toList.sortBy(_\
    \ / onesZerosListSorted.last)\n        val onesZerosListSortedReversed = onesZerosListSorted.reverse\n\
    \        val onesZerosListSortedReversedSorted = onesZerosListSortedReversed.sortBy(_\
    \ / onesZerosListSortedReversed.last)\n        val onesZerosListSortedReversedSortedList\
    \ = onesZerosListSortedReversedSorted.toList\n        val onesZerosListSortedReversedSortedListSorted\
    \ = onesZerosListSortedReversedSortedList.sortBy(_ / onesZerosListSortedReversedSortedList.last)\n\
    \        val onesZerosListSortedReversedSortedListSortedList = onesZerosListSortedReversedSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSorted = onesZerosListSortedReversedSortedListSortedList.toList.sortBy(_\
    \ / onesZerosListSortedReversedSortedListSortedList.last)\n        val onesZerosListSortedReversedSortedListSortedListSortedList\
    \ = onesZerosListSortedReversedSortedListSortedListSortedList.toList\n       \
    \ val onesZerosListSortedReversedSortedListSortedListSortedListSorted = onesZerosListSortedReversedSortedListSortedListSortedListSorted.toList.sortBy(_\
    \ / onesZerosListSortedReversedSortedListSortedListSortedList.last)\n        val\
    \ onesZerosListSortedReversedSortedListSortedListSortedListSortedList = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSortedListSortedListSorted\
    \ = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSorted\
    \ = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSorted\
    \ = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSortedListSorted.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyi0fzhaj.scala:18:38 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZerosList\e[0m = onesZeros.toList\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyi0fzhaj.scala:26:72 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesZerosListSortedReversedSortedListSortedListSortedList\e\
    [0m = onesZerosListSortedReversedSortedListSortedListSortedList.toList\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesZerosListSortedReversedSortedListSortedListSortedList\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyi0fzhaj.scala:27:78\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZerosListSortedReversedSortedListSortedListSortedListSorted\e[0m =\
    \ onesZerosListSortedReversedSortedListSortedListSortedListSorted.toList.sortBy(_\
    \ / onesZerosListSortedReversedSortedListSortedListSortedList.last)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesZerosListSortedReversedSortedListSortedListSortedListSorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyi0fzhaj.scala:31:108\
    \ -----------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36monesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSorted\e\
    [0m = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSortedListSorted.to\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                    ^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.max\n \
    \       val maxZeros = arr.min\n        val maxOnesDecimal = maxOnes.toString.toInt\n\
    \        val maxZerosDecimal = maxZeros.toString.toInt\n        val maxDecimal\
    \ = math.max(maxOnesDecimal, maxZerosDecimal)\n        val onesDecimal = ones.toString.toInt\n\
    \        val zerosDecimal = zeros.toString.toInt\n        val decimal = math.max(onesDecimal,\
    \ zerosDecimal)\n        val decimalDecimal = decimal.toString.toInt\n       \
    \ val decimalDecimalDecimal = math.pow(10, decimalDecimal)\n        val decimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimal)\n        val decimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimal)\n        val decimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimal)\n        val decimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimal)\n        val\
    \ decimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(10,\
    \ decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n  \
    \      val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(10,\
    \ decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiswp8ud1.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiswp8ud1.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = math.pow(\e[31m10\e\
    [0m, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpiswp8ud1.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = math.pow(\e[31m10\e[0m, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpiswp8ud1.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = math.pow(\e[31m10\e[0m, decimalDecimalDecimalDecimalD"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(x => x.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2uy2i5tj.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmp2uy2i5tj.scala:29:77\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = ones.map(\e[36mx\e[0m\
    \ => x.to\n\e[31m\e[31m   |\e[0m                                             \
    \                              ^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mto\e[0m in \e[33mtrait\e\
    [0m \e[35mIntegralProxy\e[0m with types\n\e[31m   |\e[0m (end: Long, step: Long):\
    \ scala.collection.immutable.NumericRange.Inclusive[Long]\n\e[31m   |\e[0m (end:\
    \ Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\e[31m   |\e\
    [0mboth match expected type B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2uy2i5tj.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoi0n4suy.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoi0n4suy.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpoi0n4suy.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / ones\n        val\
    \ zerosDecimal = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal\
    \ / onesDecimal\n        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9jqlbckh.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9jqlbckh.scala:32:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                     ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9jqlbckh.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9jqlbckh.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZeros_sorted = arr.sortBy(_ - onesZeros)\n        val onesZeros_sorted_reversed\
    \ = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_ - onesZeros)\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4k4nci_x.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4k4nci_x.scala:29:120\
    \ --------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m\
    \  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp4k4nci_x.scala:30:127 --------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4k4nci_x.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5v6kwp7n.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp5v6kwp7n.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5v6kwp7n.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: "
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toInt).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toInt).sum\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5qs7p56w.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5qs7p56w.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5qs7p56w.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5qs7p56w.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5qs7p56w.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = arr.count(_ == 1 && _ == 0)\n   \
    \     val onesOnes = arr.count(_ == 1 && _ == 1)\n        val onesZeroOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1)\n        val onesOnesOnes = arr.count(_ == 1 && _\
    \ == 1 && _ == 1)\n        val onesZeroOnesOnes = arr.count(_ == 1 && _ == 0 &&\
    \ _ == 1 && _ == 1)\n        val onesOnesOnesOnes = arr.count(_ == 1 && _ == 1\
    \ && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnes = arr.count(_ == 1 &&\
    \ _ == 0 && _ == 1 && _ == 1 && _ == 1)\n        val onesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n    \
    \    val onesOnesOnesOnesOnesOnes = arr.count(_ == 1 && _ == 1 && _ == 1 && _\
    \ == 1 && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val\
    \ onesOnesOnesOnesOnesOnesOnes = arr.count(_ == 1 && _ == 1 && _ == 1 && _ ==\
    \ 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnesOnesOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ ==\
    \ 1 && _ == 1 && _ == 1)\n        val onesOnesOnesOnesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 &&\
    \ _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 &&\
    \ _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val onesOnesOnes\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprp5u8m53.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:17:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros\e[0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:18:33 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesOnes\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \             Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmprp5u8m53.scala:19:37 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeroOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:20:37 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesOnesOnes\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:21:41 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroOnesOnes\e[0m =\
    \ arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m && _ == \e[31m1\e[0m && _ ==\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9xmhdn3j.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp9xmhdn3j.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9xmhdn3j.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo3f708ok.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo3f708ok.scala:32:119\
    \ --------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3f708ok.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3f708ok.scala:36:83\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / 10\n        val\
    \ zerosDecimalDecimal = zerosDecimal / 10\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxoicu4q0.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxoicu4q0.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxoicu4q0.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpxoicu4q0.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphk869fg9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphk869fg9.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmphk869fg9.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvhzyp36r.scala:38:153 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpvhzyp36r.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvhzyp36r.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count(_ == 1)\n\
    \        val zerosCount = zeros.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzo0sphut.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzo0sphut.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpzo0sphut.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n        val zerosArr\
    \ = arr.filter(_ == 0)\n        val onesCount = onesArr.size\n        val zerosCount\
    \ = zerosArr.size\n        val onesArr = onesArr.sortBy(x => (onesCount - onesArr.indexOf(x)),\
    \ Ordering[Long].reverse)\n        val zerosArr = zerosArr.sortBy(x => (zerosCount\
    \ - zerosArr.indexOf(x)), Ordering[Long].reverse)\n        val onesArr = onesArr.sortBy(x\
    \ => (onesCount - onesArr.indexOf(x)), Ordering[Long].reverse)\n        val zerosArr\
    \ = zerosArr.sortBy(x => (zerosCount - zerosArr.indexOf(x)), Ordering[Long].reverse)\n\
    \        onesArr::zerosArr\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuxtk37yh.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e\
    [36mx\e[0m => (onesCount - onesArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuxtk37yh.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(\e[36mx\e\
    [0m => (zerosCount - zerosArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuxtk37yh.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e[36mx\e\
    [0m => (onesCount - onesArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuxtk37yh.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(\e[36mx\e\
    [0m => (zerosCount - zerosArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZeroDec = onesZeros / 10\n        val zeroDec = zeros / 10\n  \
    \      val onesZeroDecDec = onesZeroDec / 10\n        val zeroDecDec = zeroDec\
    \ / 10\n        val onesZeroDecDecDec = onesZeroDecDec / 10\n        val zeroDecDecDec\
    \ = zeroDecDec / 10\n        val onesZeroDecDecDecDec = onesZeroDecDecDec / 10\n\
    \        val zeroDecDecDecDec = zeroDecDecDec / 10\n        val onesZeroDecDecDecDecDec\
    \ = onesZeroDecDecDecDec / 10\n        val zeroDecDecDecDecDec = zeroDecDecDecDec\
    \ / 10\n        val onesZeroDecDecDecDecDecDec = onesZeroDecDecDecDecDec / 10\n\
    \        val zeroDecDecDecDecDecDec = zeroDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDecDecDec\
    \ = onesZeroDec\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylmr547s.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36monesZeroDecDecDecDecDecDecDecDec\e\
    [0m = onesZeroDecDecDecDecDecDecDecDecDec / \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroDecDecDecDecDecDecDecDec is already defined as \e\
    [33mvalue\e[0m \e[35monesZeroDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylmr547s.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroDecDecDecDecDecDecDecDecDec\e[0m = onesZeroDecDecDecDecDecDecDecDecDecDec\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroDecDecDecDecDecDecDecDecDec is already defined as\
    \ \e[33mvalue\e[0m \e[35monesZeroDecDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylmr547s.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzeroDecDecDecDecDecDecDecDecDecDec\e[0m = zeroDecDecDecDecDecDecDecDecDec\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzeroDecDecDecDecDecDecDecDecDecDec is already defined as \e\
    [33mvalue\e[0m \e[35mzeroDecDecDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpylmr547s.scala:30:44\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroDecDecDecDecDecDecDec\e[0m = onesZeroDecDecDecDecDecDecDec / \e\
    [31m10\e[0m\n\e[31m\e[31m   |\e[0m                                           \
    \ ^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toString.toInt).sum\n        val zerosCount = zeros.map(x => x.toString.toInt).sum\n\
    \        val onesDecimal = onesCount / ones.size\n        val zerosDecimal = zerosCount\
    \ / zeros.size\n        val onesDecimalDecimal = onesDecimal / onesCount\n   \
    \     val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDe\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0xbrnt4e.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0xbrnt4e.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0xbrnt4e.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659795367
