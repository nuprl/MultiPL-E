language: scala
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeroMinusOne = onesZero -\
    \ 1\n        val onesZeroMinusOneMinusOne = onesZeroMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n   \
    \     val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne -\
    \ 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:25:79 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:26:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                 ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:27:95\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8bgo_283.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_sorted = onesZeros.sortBy(x => x.toString.toInt)\n    \
    \    val onesZeros_sorted_sorted = onesZeros_sorted.sortBy(x => x.toString.toInt)\n\
    \        val onesZeros_sorted_sorted_sorted = onesZeros_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted.sortBy(x => x.toString.toInt)\n    \
    \    val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x => x.toString.toInt)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toString.toInt)\n        \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpboo6qcwd.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpboo6qcwd.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpboo6qcwd.scala:17:29 ------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).size\n        val zeros\
    \ = arr.filter(_ == 0).size\n        val onesZeros = ones + zeros\n        val\
    \ onesZerosList = onesZeros.toList\n        val onesZerosListSorted = onesZerosList.toList.sortBy(_\
    \ / onesZerosListSorted.last)\n        val onesZerosListSortedReversed = onesZerosListSorted.reverse\n\
    \        val onesZerosListSortedReversedSorted = onesZerosListSortedReversed.sortBy(_\
    \ / onesZerosListSortedReversed.last)\n        val onesZerosListSortedReversedSortedList\
    \ = onesZerosListSortedReversedSorted.toList\n        val onesZerosListSortedReversedSortedListSorted\
    \ = onesZerosListSortedReversedSortedList.sortBy(_ / onesZerosListSortedReversedSortedList.last)\n\
    \        val onesZerosListSortedReversedSortedListSortedList = onesZerosListSortedReversedSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSorted = onesZerosListSortedReversedSortedListSortedList.toList.sortBy(_\
    \ / onesZerosListSortedReversedSortedListSortedList.last)\n        val onesZerosListSortedReversedSortedListSortedListSortedList\
    \ = onesZerosListSortedReversedSortedListSortedListSortedList.toList\n       \
    \ val onesZerosListSortedReversedSortedListSortedListSortedListSorted = onesZerosListSortedReversedSortedListSortedListSortedListSorted.toList.sortBy(_\
    \ / onesZerosListSortedReversedSortedListSortedListSortedList.last)\n        val\
    \ onesZerosListSortedReversedSortedListSortedListSortedListSortedList = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSortedListSortedListSorted\
    \ = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSorted\
    \ = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSorted.toList\n\
    \        val onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSorted\
    \ = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSortedListSorted.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyi0fzhaj.scala:18:38 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZerosList\e[0m = onesZeros.toList\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyi0fzhaj.scala:26:72 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesZerosListSortedReversedSortedListSortedListSortedList\e\
    [0m = onesZerosListSortedReversedSortedListSortedListSortedList.toList\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesZerosListSortedReversedSortedListSortedListSortedList\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyi0fzhaj.scala:27:78\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZerosListSortedReversedSortedListSortedListSortedListSorted\e[0m =\
    \ onesZerosListSortedReversedSortedListSortedListSortedListSorted.toList.sortBy(_\
    \ / onesZerosListSortedReversedSortedListSortedListSortedList.last)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesZerosListSortedReversedSortedListSortedListSortedListSorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyi0fzhaj.scala:31:108\
    \ -----------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36monesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSorted\e\
    [0m = onesZerosListSortedReversedSortedListSortedListSortedListSortedListSortedListSortedListSortedListSorted.to\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                    ^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.max\n \
    \       val maxZeros = arr.min\n        val maxOnesDecimal = maxOnes.toString.toInt\n\
    \        val maxZerosDecimal = maxZeros.toString.toInt\n        val maxDecimal\
    \ = math.max(maxOnesDecimal, maxZerosDecimal)\n        val onesDecimal = ones.toString.toInt\n\
    \        val zerosDecimal = zeros.toString.toInt\n        val decimal = math.max(onesDecimal,\
    \ zerosDecimal)\n        val decimalDecimal = decimal.toString.toInt\n       \
    \ val decimalDecimalDecimal = math.pow(10, decimalDecimal)\n        val decimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimal)\n        val decimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimal)\n        val decimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimal)\n        val decimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimal)\n        val\
    \ decimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(10,\
    \ decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n  \
    \      val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(10,\
    \ decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = math.pow(10, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiswp8ud1.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiswp8ud1.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = math.pow(\e[31m10\e\
    [0m, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpiswp8ud1.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = math.pow(\e[31m10\e[0m, decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpiswp8ud1.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mdecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = math.pow(\e[31m10\e[0m, decimalDecimalDecimalDecimalD"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(x => x.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2uy2i5tj.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmp2uy2i5tj.scala:29:77\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = ones.map(\e[36mx\e[0m\
    \ => x.to\n\e[31m\e[31m   |\e[0m                                             \
    \                              ^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mto\e[0m in \e[33mtrait\e\
    [0m \e[35mIntegralProxy\e[0m with types\n\e[31m   |\e[0m (end: Long, step: Long):\
    \ scala.collection.immutable.NumericRange.Inclusive[Long]\n\e[31m   |\e[0m (end:\
    \ Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\e[31m   |\e\
    [0mboth match expected type B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2uy2i5tj.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoi0n4suy.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoi0n4suy.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpoi0n4suy.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / ones\n        val\
    \ zerosDecimal = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal\
    \ / onesDecimal\n        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9jqlbckh.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9jqlbckh.scala:32:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                     ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9jqlbckh.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9jqlbckh.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZeros_sorted = arr.sortBy(_ - onesZeros)\n        val onesZeros_sorted_reversed\
    \ = onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted = onesZeros_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_ - onesZeros)\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4k4nci_x.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4k4nci_x.scala:29:120\
    \ --------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_\
    \ - onesZeros)\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m\
    \  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp4k4nci_x.scala:30:127 --------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4k4nci_x.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5v6kwp7n.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp5v6kwp7n.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5v6kwp7n.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: "
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toInt).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toInt).sum\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).sum\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).sum\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).sum\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).sum\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).sum\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5qs7p56w.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5qs7p56w.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5qs7p56w.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5qs7p56w.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5qs7p56w.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = arr.count(_ == 1 && _ == 0)\n   \
    \     val onesOnes = arr.count(_ == 1 && _ == 1)\n        val onesZeroOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1)\n        val onesOnesOnes = arr.count(_ == 1 && _\
    \ == 1 && _ == 1)\n        val onesZeroOnesOnes = arr.count(_ == 1 && _ == 0 &&\
    \ _ == 1 && _ == 1)\n        val onesOnesOnesOnes = arr.count(_ == 1 && _ == 1\
    \ && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnes = arr.count(_ == 1 &&\
    \ _ == 0 && _ == 1 && _ == 1 && _ == 1)\n        val onesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n    \
    \    val onesOnesOnesOnesOnesOnes = arr.count(_ == 1 && _ == 1 && _ == 1 && _\
    \ == 1 && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val\
    \ onesOnesOnesOnesOnesOnesOnes = arr.count(_ == 1 && _ == 1 && _ == 1 && _ ==\
    \ 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnesOnesOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ ==\
    \ 1 && _ == 1 && _ == 1)\n        val onesOnesOnesOnesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 &&\
    \ _ == 1 && _ == 1)\n        val onesZeroOnesOnesOnesOnesOnesOnesOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 && _ == 1 &&\
    \ _ == 1 && _ == 1 && _ == 1 && _ == 1)\n        val onesOnesOnes\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprp5u8m53.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:17:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros\e[0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:18:33 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesOnes\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \             Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmprp5u8m53.scala:19:37 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeroOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:20:37 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesOnesOnes\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprp5u8m53.scala:21:41 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroOnesOnes\e[0m =\
    \ arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m && _ == \e[31m1\e[0m && _ ==\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9xmhdn3j.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp9xmhdn3j.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9xmhdn3j.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo3f708ok.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo3f708ok.scala:32:119\
    \ --------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3f708ok.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3f708ok.scala:36:83\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / 10\n        val\
    \ zerosDecimalDecimal = zerosDecimal / 10\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxoicu4q0.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxoicu4q0.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxoicu4q0.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpxoicu4q0.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphk869fg9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphk869fg9.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmphk869fg9.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvhzyp36r.scala:38:153 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpvhzyp36r.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvhzyp36r.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count(_ == 1)\n\
    \        val zerosCount = zeros.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzo0sphut.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzo0sphut.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpzo0sphut.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n        val zerosArr\
    \ = arr.filter(_ == 0)\n        val onesCount = onesArr.size\n        val zerosCount\
    \ = zerosArr.size\n        val onesArr = onesArr.sortBy(x => (onesCount - onesArr.indexOf(x)),\
    \ Ordering[Long].reverse)\n        val zerosArr = zerosArr.sortBy(x => (zerosCount\
    \ - zerosArr.indexOf(x)), Ordering[Long].reverse)\n        val onesArr = onesArr.sortBy(x\
    \ => (onesCount - onesArr.indexOf(x)), Ordering[Long].reverse)\n        val zerosArr\
    \ = zerosArr.sortBy(x => (zerosCount - zerosArr.indexOf(x)), Ordering[Long].reverse)\n\
    \        onesArr::zerosArr\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuxtk37yh.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e\
    [36mx\e[0m => (onesCount - onesArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuxtk37yh.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(\e[36mx\e\
    [0m => (zerosCount - zerosArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuxtk37yh.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e[36mx\e\
    [0m => (onesCount - onesArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuxtk37yh.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(\e[36mx\e\
    [0m => (zerosCount - zerosArr.indexOf(x)), Ordering[\e[35mLong\e[0m].reverse)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZeroDec = onesZeros / 10\n        val zeroDec = zeros / 10\n  \
    \      val onesZeroDecDec = onesZeroDec / 10\n        val zeroDecDec = zeroDec\
    \ / 10\n        val onesZeroDecDecDec = onesZeroDecDec / 10\n        val zeroDecDecDec\
    \ = zeroDecDec / 10\n        val onesZeroDecDecDecDec = onesZeroDecDecDec / 10\n\
    \        val zeroDecDecDecDec = zeroDecDecDec / 10\n        val onesZeroDecDecDecDecDec\
    \ = onesZeroDecDecDecDec / 10\n        val zeroDecDecDecDecDec = zeroDecDecDecDec\
    \ / 10\n        val onesZeroDecDecDecDecDecDec = onesZeroDecDecDecDecDec / 10\n\
    \        val zeroDecDecDecDecDecDec = zeroDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDecDec\
    \ = onesZeroDecDecDecDecDecDecDecDecDecDec / 10\n        val zeroDecDecDecDecDecDecDecDecDecDec\
    \ = zeroDecDecDecDecDecDecDecDecDec / 10\n        val onesZeroDecDecDecDecDecDecDecDecDecDec\
    \ = onesZeroDec\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylmr547s.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36monesZeroDecDecDecDecDecDecDecDec\e\
    [0m = onesZeroDecDecDecDecDecDecDecDecDec / \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroDecDecDecDecDecDecDecDec is already defined as \e\
    [33mvalue\e[0m \e[35monesZeroDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylmr547s.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroDecDecDecDecDecDecDecDecDec\e[0m = onesZeroDecDecDecDecDecDecDecDecDecDec\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroDecDecDecDecDecDecDecDecDec is already defined as\
    \ \e[33mvalue\e[0m \e[35monesZeroDecDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylmr547s.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzeroDecDecDecDecDecDecDecDecDecDec\e[0m = zeroDecDecDecDecDecDecDecDecDec\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzeroDecDecDecDecDecDecDecDecDecDec is already defined as \e\
    [33mvalue\e[0m \e[35mzeroDecDecDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpylmr547s.scala:30:44\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroDecDecDecDecDecDecDec\e[0m = onesZeroDecDecDecDecDecDecDec / \e\
    [31m10\e[0m\n\e[31m\e[31m   |\e[0m                                           \
    \ ^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toString.toInt).sum\n        val zerosCount = zeros.map(x => x.toString.toInt).sum\n\
    \        val onesDecimal = onesCount / ones.size\n        val zerosDecimal = zerosCount\
    \ / zeros.size\n        val onesDecimalDecimal = onesDecimal / onesCount\n   \
    \     val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDe\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0xbrnt4e.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0xbrnt4e.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0xbrnt4e.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = onesCount / 2l.toLong\n        val zerosDecimal = zerosCount\
    \ / 2l.toLong\n        val onesDecimalDecimal = onesDecimal / 2l.toLong\n    \
    \    val zerosDecimalDecimal = zerosDecimal / 2l.toLong\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 2l.toLong\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk9nl5pgo.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / \e[31m2l\e[0m.toLong\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk9nl5pgo.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / \e[31m2l\e[0m.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk9nl5pgo.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / \e[31m2l\e[0m.toLong\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: "
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.filter(_\
    \ % 2 == 0).max\n        val maxZeros = arr.filter(_ % 2 == 1).max\n        val\
    \ maxOnesDecimal = maxOnes.toString.toInt\n        val maxZerosDecimal = maxZeros.toString.toInt\n\
    \        val maxOnesDecimalDecimal = maxOnesDecimal / 10\n        val maxZerosDecimalDecimal\
    \ = maxZerosDecimal / 10\n        val maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal\
    \ / 10\n        val maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal / 10\n\
    \        val maxOnesDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimal\
    \ / 10\n        val maxZerosDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimal\
    \ / 10\n        val maxOnesDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxZerosDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n     \
    \   val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecim\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp30dadz_d.scala:29:64 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp30dadz_d.scala:30:65\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \                            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp30dadz_d.scala:33:78\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp30dadz_d.scala:34:79\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e["
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvk6_yv5x.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvk6_yv5x.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvk6_yv5x.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvk6_yv5x.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdevtvzpn.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdevtvzpn.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpdevtvzpn.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l.toLong)\n        val\
    \ zeros = arr.filter(_ == 0l.toLong)\n        val onesCount = ones.count()\n \
    \       val zerosCount = zeros.count()\n        val onesDecimal = onesCount.toDouble\
    \ / arr.size\n        val zerosDecimal = zerosCount.toDouble / arr.size\n    \
    \    val onesDecimalInt = onesDecimal.toInt\n        val zerosDecimalInt = zerosDecimal.toInt\n\
    \        val onesDecimalLong = onesDecimal.toLong\n        val zerosDecimalLong\
    \ = zerosDecimal.toLong\n        val onesDecimalFloat = onesDecimal.toFloat\n\
    \        val zerosDecimalFloat = zerosDecimal.toFloat\n        val onesDecimalDouble\
    \ = onesDecimal.toDouble\n        val zerosDecimalDouble = zerosDecimal.toDouble\n\
    \        val onesDecimalLongDouble = onesDecimal.toLongDouble\n        val zerosDecimalLongDouble\
    \ = zerosDecimal.toLongDouble\n        val onesDecimalFloatDouble = onesDecimal.toFloatDouble\n\
    \        val zerosDecimalFloatDouble = zerosDecimal.toFloatDouble\n        val\
    \ onesDecimalLongFloat = onesDecimal.toLongFloat\n        val zerosDecimalLongFloat\
    \ = zerosDecimal.toLongFloat\n        val onesDecimalLongDouble = onesDecimal.toLongDouble\n\
    \        val zerosDecimalLongDouble = zerosDecimal.toLongDouble\n        val onesDecimalFloatLong\
    \ = onesDecimal.toFloatLong\n        val zerosDecimalFloatLong = zerosDecimal.toFloatLong\n\
    \        val onesDecimalLongFloat = onesDecimal.toLongFloat\n        val zerosDecimalLongFloat\
    \ = zerosDecimal.toLongFloat\n        val onesDecimalLongDouble = onesDecimal.toLongDouble\n\
    \        val zerosDecimalLongDouble = zerosDecimal.toLongDouble\n        val onesDecimalFloatLong\
    \ = onesDecimal.toFloatLong\n        val zerosDecimalFloatLong = zerosDecimal.toFloatLong\n\
    \        val onesDecimalLongFloat = onesDecimal.toLongFloat\n        val zerosDecimalLongFloat\
    \ = zerosDecimal.toLongFloat\n        val onesDecimalLongDouble = onesDecimal.toLongDouble\n\
    \        val zerosDecimalLongDouble = zerosDecimal.toLongDouble\n        val onesDecimalFloatLong\
    \ = onesDecimal.toFloatLong\n        val zerosDecimalFloatLong = zerosDecimal.toFloatLong\n\
    \        val onesDecimalLongFloat = onesDecimal.toLongFloat\n        val zerosDecimalLongFloat\
    \ = zerosDecimal.toLongFloat\n        val onesDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0izpiomo.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0izpiomo.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalLongDouble\e[0m = onesDecimal.toLongDouble\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0monesDecimalLongDouble is already defined as \e[33mvalue\e[0m \e[35monesDecimalLongDouble\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0izpiomo.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalLongDouble\e[0m = zerosDecimal.toLongDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalLongDouble is already defined as \e[33mvalue\e\
    [0m \e[35mzerosDecimalLongDouble\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0izpiomo.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36monesDecimalLongFloat\e[0m\
    \ = onesDecimal.toLongFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalLongFloat is already defined as \e[33mvalue\e[0m\
    \ \e[35monesDecimalLongFloat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0izpiomo.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalLongFloat\e\
    [0m = zerosDecimal.toLongFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalLongFloat is already defined as \e[33mvalue\e\
    [0m \e[35mzerosDecimalLongFloat"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength - zerosArrayLength\n        val zerosArrayLength\
    \ = zerosArrayLength - onesArrayLength\n        val onesArrayLength = onesArrayLength\
    \ / 2\n        val zerosArrayLength = zerosArrayLength / 2\n        val onesArrayLength\
    \ = onesArrayLength.toInt\n        val zerosArrayLength = zerosArrayLength.toInt\n\
    \        val onesArray = onesArray.sortWith(_ < _)\n        val zerosArray = zerosArray.sortWith(_\
    \ < _)\n        val onesArray = onesArray.sortWith(_ < _)\n        val zerosArray\
    \ = zerosArray.sortWith(_ < _)\n        val onesArray = onesArray.sortWith(_ <\
    \ _)\n        val zerosArray = zerosArray.sortWith(_ < _)\n        val onesArray\
    \ = onesArray.sortWith(_ < _)\n        val zerosArray = zerosArray.sortWith(_\
    \ < _)\n        val onesArray = onesArray.sortWith(_ < _)\n        val zerosArray\
    \ = zerosArray.sortWith(_ < _)\n        val onesArray = onesArray.sortWith(_ <\
    \ _)\n        val zerosArray = zerosArray.sortWith(_ < _)\n        val onesArray\
    \ = onesArray.sortWith(_ < _)\n        val zerosArray = zerosArray.sortWith(_\
    \ < _)\n        val onesArray = onesArray.sortWith(_ < _)\n        val zerosArray\
    \ = zerosArray.sortWith(_ < _)\n        val onesArray = onesArray.sortWith(_ <\
    \ _)\n        val zerosArray = zerosArray.sortWith(_ < _)\n        val onesArray\
    \ = onesArray.sortWith(_ < _)\n        val zerosArray = zerosArray.sortWith(_\
    \ < _)\n        val onesArray = onesArray.sortWith(_ < _)\n        val zerosArray\
    \ = zerosArray.sortWith(_ < _)\n        val onesArray = onesArray.sortWith(_ <\
    \ _)\n        val zerosArray = zerosArray.sortWith(_ < _)\n        val ones\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1q0pc_8b.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1q0pc_8b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArrayLength\e[0m = onesArrayLength - zerosArrayLength\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1q0pc_8b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArrayLength\
    \ - onesArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1q0pc_8b.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1q0pc_8b.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overlo"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = ones.map(x => x.toLong).map(_.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toLong).map(_.toString.toDouble).sum\n\
    \        val onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb786wxgq.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb786wxgq.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb786wxgq.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb786wxgq.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx7s2wdco.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx7s2wdco.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7s2wdco.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7s2wdco.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toLong).sum\n\
    \        val zerosCount = zeros.map(_.toLong).sum\n        val onesDecimal = ones.map(_.toLong).map(_.toInt).sum\n\
    \        val zerosDecimal = zeros.map(_.toLong).map(_.toInt).sum\n        val\
    \ onesDecimalDecimal = ones.map(_.toLong).map(_.toLong).sum\n        val zerosDecimalDecimal\
    \ = zeros.map(_.toLong).map(_.toLong).sum\n        val onesDecimalDecimalDecimal\
    \ = ones.map(_.toLong).map(_.toLong).map(_.toLong).sum\n        val zerosDecimalDecimalDecimal\
    \ = zeros.map(_.toLong).map(_.toLong).map(_.toLong).sum\n        val onesDecimalDecimalDecimalDecimal\
    \ = ones.map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).sum\n       \
    \ val zerosDecimalDecimalDecimalDecimal = zeros.map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).map(_.toLong).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(_.toLong).map(_.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp57o5bo0r.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp57o5bo0r.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.count(_\
    \ == 1)\n        val zerosCount = zeros.count(_ == 0)\n        val onesDecimal\
    \ = onesCount.toDouble / arr.size\n        val zerosDecimal = zerosCount.toDouble\
    \ / arr.size\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n  \
    \      val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toDouble / arr.size\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal.toDouble / arr.size\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal.toDouble / arr.size\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal.toDouble / arr.size\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toDouble / arr.size\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / arr.size\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toDouble / arr.size\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toDouble / arr.size\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.size\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.size\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.size\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.size\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.size\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.size\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.size\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.size\n\
    \        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6jhkjkv1.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6jhkjkv1.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6jhkjkv1.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6jhkjkv1.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ arr.size\n\e[31m\e[31"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc0zh9ufj.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc0zh9ufj.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpc0zh9ufj.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found"
  stdout: ''
  timestamp: 1659979865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesArr2 = onesArr.filter(_ % 2 == 0).sortBy(_\
    \ % 2).reverse\n        val zerosArr2 = zerosArr.filter(_ % 2 == 1).sortBy(_ %\
    \ 2).reverse\n        val onesArr3 = onesArr2.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n\
    \        val zerosArr3 = zerosArr2.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n\
    \        val onesArr4 = onesArr3.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n  \
    \      val zerosArr4 = zerosArr3.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n  \
    \      val onesArr5 = onesArr4.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n    \
    \    val zerosArr5 = zerosArr4.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n    \
    \    val onesArr6 = onesArr5.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n      \
    \  val zerosArr6 = zerosArr5.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n      \
    \  val onesArr7 = onesArr6.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val\
    \ zerosArr7 = zerosArr6.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val\
    \ onesArr8 = onesArr7.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr8\
    \ = zerosArr7.filter(_ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr9 =\
    \ onesArr8.filter(_ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr9 = zerosArr8.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr10 = onesArr9.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr10 = zerosArr9.filter(_ %\
    \ 2 == 1).sortBy(_ % 2).reverse\n        val onesArr11 = onesArr10.filter(_ %\
    \ 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr11 = zerosArr10.filter(_\
    \ % 2 == 1).sortBy(_ % 2).reverse\n        val onesArr12 = onesArr11.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr12 = zerosArr11.filter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf5j2jer1.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = ones / onesCount\n        val\
    \ zerosDecimal = zeros / zerosCount\n        val onesDecimalDecimal = onesDecimal\
    \ / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n     \
    \   val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgbft7vw4.scala:38:167 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                           expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgbft7vw4.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgbft7vw4.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is alre"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => (x % 2) == 0).sorted\n\
    \        val zerosArray = arr.map(x => (x % 2) == 1).sorted\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength / 2\n        val zerosArrayLength =\
    \ zerosArrayLength / 2\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zerosArrayLength = zerosArrayLength + onesArrayLength\n        val\
    \ onesArray = onesArray.toList\n        val zerosArray = zerosArray.toList\n \
    \       val onesArrayLength = onesArray.length\n        val zerosArrayLength =\
    \ zerosArray.length\n        val onesArrayLength = onesArrayLength / 2\n     \
    \   val zerosArrayLength = zerosArrayLength / 2\n        val onesArrayLength =\
    \ onesArrayLength + zerosArrayLength\n        val zerosArrayLength = zerosArrayLength\
    \ + onesArrayLength\n        val onesArray = onesArray.toList\n        val zerosArray\
    \ = zerosArray.toList\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArrayLength\
    \ / 2\n        val zerosArrayLength = zerosArrayLength / 2\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val zerosArrayLength = zerosArrayLength\
    \ + onesArrayLength\n        val onesArray = onesArray.toList\n        val zerosArray\
    \ = zerosArray.toList\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArrayLength\
    \ / 2\n        val zerosArrayLength = zerosArrayLength / 2\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val zerosArrayLength = zerosArrayLength\
    \ + onesArrayLength\n        val onesArray = onesArray.toList\n        val zerosArray\
    \ = zerosArray.toList\n        val onesArrayLength = onesArray.length\n      \
    \  val zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArrayLength\
    \ / 2\n        val zerosArrayLength = zerosArrayLength / 2\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val zerosArrayLength = zerosArrayLength\
    \ + onesArrayLength\n        val onesArray = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpy0xy10rs.scala:57:23 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpy0xy10rs.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpy0xy10rs.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpy0xy10rs.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ + zerosArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpy0xy10rs.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength + onesArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvk6_yv5x.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvk6_yv5x.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvk6_yv5x.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvk6_yv5x.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => 1l).sum\n        val zerosCount = zeros.map(x => 1l).sum\n        val onesDecimal\
    \ = ones.map(x => x.toString.toDouble).sum\n        val zerosDecimal = zeros.map(x\
    \ => x.toString.toDouble).sum\n        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n \
    \       val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n    \
    \    val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n     \
    \   val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount =\
    \ zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x\
    \ => x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x =>\
    \ x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n \
    \       val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n    \
    \    val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n     \
    \   val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toDouble).count\n        val zerosDecimalCount =\
    \ zeros.map(x => x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x\
    \ => x.toString.toDouble).count\n        val zerosDecimalCount = zeros.map(x =>\
    \ x.toString.toDouble).count\n        val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toDouble).count\n \
    \       val onesDecimalCount = ones.map(x => x.toString.toDouble).count\n    \
    \    val zerosDecimalCount = zeros.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvxc2n6_c.scala:44:42 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\n\e[31m\e[31m   |\e[0m                                          ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvxc2n6_c.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvxc2n6_c.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvxc2n6_c.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => x.toString.toDouble).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvxc2n6_c.scala:26:12 ---------"
  stdout: ''
  timestamp: 1659979865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.size\n     \
    \   val zerosCount = zeros.size\n        val onesDecimal = onesCount.toDouble\
    \ / onesCount.toDouble\n        val zerosDecimal = zerosCount.toDouble / zerosCount.toDouble\n\
    \        val onesDecimalDecimal = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ / onesDecimalDecimal.toDouble\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble\
    \ / zerosDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toDouble / onesDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toDouble / onesDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa8dyb_l2.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa8dyb_l2.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa8dyb_l2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpa8dyb_l2.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = "
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = ones.map(x => x.toLong).map(x => x.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toLong).map(x => x.toString.toDouble).sum\n\
    \        val onesDecimalDecimal = onesDecimal.toString.toDouble\n        val zerosDecimalDecimal\
    \ = zerosDecimal.toString.toDouble\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm05mx2xc.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm05mx2xc.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm05mx2xc.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpm05mx2xc.scala:34:76 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString."
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x.toInt == 1)\n       \
    \ val zeros = arr.filter(x => x.toInt == 0)\n        val onesCount = ones.map(x\
    \ => x.toInt).sum\n        val zerosCount = zeros.map(x => x.toInt).sum\n    \
    \    val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / 10\n        val\
    \ zerosDecimalDecimal = zerosDecimal / 10\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb1v8ayt7.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb1v8ayt7.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb1v8ayt7.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpb1v8ayt7.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m10\e[0m\n\e\
    [3"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeros = onesZero % 2\n  \
    \      val onesZero = onesZeros / 2\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjgcwnitc.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZero\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjgcwnitc.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36monesZero\e[0m = onesZeros / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesZero is already defined as \e[33mvalue\e[0m \e[35monesZero\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjgcwnitc.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZero % \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZeros\
    \ is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjgcwnitc.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZero\e[0m = onesZeros / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZero is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZero\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjgcwnitc.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZero\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_sorted = onesZeros.sortBy(_ % 10)\n        val onesZeros_sorted_sorted\
    \ = onesZeros_sorted.sortBy(_ % 2)\n        val onesZeros_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted.sortBy(_ / 2)\n        val onesZeros_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted.sortBy(_ / 10)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted.sortBy(_ / 100)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted.sortBy(_ / 1000)\n        val\
    \ onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / 10000)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_ / 100000)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / 1000000)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / 10000000)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / 100000000)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / 1000000000)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / 10000000000)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_\
    \ / 100000000000)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmrbgc436.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmrbgc436.scala:17:29\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros\e[0m = ones + zeros\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpmrbgc436.scala:33:5 ---------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = onesCount / arr.length\n        val zerosDecimal =\
    \ zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / 10\n\
    \        val zerosDecimalDecimal = zerosDecimal / 10\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptlroan9t.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptlroan9t.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptlroan9t.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptlroan9t.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e\
    [31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpey4kra1z.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpey4kra1z.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpey4kra1z.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesD"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeroMinusOne = onesZero -\
    \ 1\n        val onesZeroMinusOneMinusOne = onesZeroMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n   \
    \     val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne -\
    \ 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:25:79 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:26:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                 ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bgo_283.scala:27:95\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8bgo_283.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e"
  stdout: ''
  timestamp: 1659795366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).length\n        val onesOnes = arr.filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).length\n        val onesZeroOnes = arr.filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnes\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n    \
    \    val onesZeroOnesOnes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnes = arr.filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n\
    \        val onesZeroOnesOnesOnes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).length\n        val onesZeroOnesOnesOnesOnes = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnesOnesOnes =\
    \ arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n       \
    \ val onesZeroOnesOnesOnesOnesOnes = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).length\n        val onesOnesOnesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2\
    \ == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).length\n        val onesZeroOnesOnesOnesOnesOnesOnes\
    \ = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzsxtu5r3.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpzsxtu5r3.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesZeros = ones.zip(zeros)\n        val onesZeroCount\
    \ = onesZeros.map(x => x._2).sum\n        val onesZeroZeros = onesZeros.map(x\
    \ => x._1)\n        val onesZeroZeroCount = onesZeroZeros.map(x => x._2).sum\n\
    \        val onesZeroZeroZeros = onesZeroZeros.map(x => x._1)\n        val onesZeroZeroZeroCount\
    \ = onesZeroZeroZeros.map(x => x._2).sum\n        val onesZeroZeroZeroZeros =\
    \ onesZeroZeroZeros.map(x => x._1)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x\
    \ => x._2).sum\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.map(x\
    \ => x._1)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x\
    \ => x._2).sum\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.map(x\
    \ => x._1)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x\
    \ => x._2).sum\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.map(x\
    \ => x._1)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x\
    \ => x._2).sum\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.map(x\
    \ => x._1)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x\
    \ => x._2).sum\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.map(x\
    \ => x._1)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.map(x\
    \ => x._2).sum\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.map(x\
    \ => x._1)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZero\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptyq_xjan.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeros.map(\e[36mx\e[0m => x._2).sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptyq_xjan.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeros.map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptyq_xjan.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeros.map(\e[36mx\e[0m => x._2).sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptyq_xjan.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeros.map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35mones"
  stdout: ''
  timestamp: 1659979880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesCount = arr.filter(_ == 1).map(_.toLong).sum\n\
    \        val zerosCount = arr.filter(_ == 0).map(_.toLong).sum\n        val onesDecimal\
    \ = onesCount / ones\n        val zerosDecimal = zerosCount / zeros\n        val\
    \ onesDecimalDecimal = onesDecimal / onesDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal =\
    \ zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy0_4phx7.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy0_4phx7.scala:32:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy0_4phx7.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy0_4phx7.scala:34:76\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        "
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu1s2zqsm.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu1s2zqsm.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpu1s2zqsm.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphk869fg9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphk869fg9.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmphk869fg9.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).size\n        val\
    \ zeros = arr.filter(_ % 2 == 1).size\n        val onesArr = arr.filter(_ % 2\
    \ == 0).sortBy(_.toString.toInt)\n        val zerosArr = arr.filter(_ % 2 == 1).sortBy(_.toString.toInt)\n\
    \        val onesArr2 = onesArr.sortBy(_.toString.toInt)\n        val zerosArr2\
    \ = zerosArr.sortBy(_.toString.toInt)\n        val onesArr3 = onesArr2.sortBy(_.toString.toInt)\n\
    \        val zerosArr3 = zerosArr2.sortBy(_.toString.toInt)\n        val onesArr4\
    \ = onesArr3.sortBy(_.toString.toInt)\n        val zerosArr4 = zerosArr3.sortBy(_.toString.toInt)\n\
    \        val onesArr5 = onesArr4.sortBy(_.toString.toInt)\n        val zerosArr5\
    \ = zerosArr4.sortBy(_.toString.toInt)\n        val onesArr6 = onesArr5.sortBy(_.toString.toInt)\n\
    \        val zerosArr6 = zerosArr5.sortBy(_.toString.toInt)\n        val onesArr7\
    \ = onesArr6.sortBy(_.toString.toInt)\n        val zerosArr7 = zerosArr6.sortBy(_.toString.toInt)\n\
    \        val onesArr8 = onesArr7.sortBy(_.toString.toInt)\n        val zerosArr8\
    \ = zerosArr7.sortBy(_.toString.toInt)\n        val onesArr9 = onesArr8.sortBy(_.toString.toInt)\n\
    \        val zerosArr9 = zerosArr8.sortBy(_.toString.toInt)\n        val onesArr10\
    \ = onesArr9.sortBy(_.toString.toInt)\n        val zerosArr10 = zerosArr9.sortBy(_.toString.toInt)\n\
    \        val onesArr11 = onesArr10.sortBy(_.toString.toInt)\n        val zerosArr11\
    \ = zerosArr10.sortBy(_.toString.toInt)\n        val onesArr12 = onesArr11.sortBy(_.toString.toInt)\n\
    \        val zerosArr12 = zerosArr11.sortBy(_.toString.toInt)\n        val onesArr13\
    \ = onesArr12.sortBy(_.toString.toInt)\n        val zerosArr13 = zerosArr12.sortBy(_.toString.toInt)\n\
    \        val onesArr14 = onesArr13.sortBy(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0l1n87gl.scala:43:41 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesArr14\e[0m = onesArr13.sortBy(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp0l1n87gl.scala:44:4\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\
    \e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp0l1n87gl.scala:44:5 ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = onesCount / ones.length\n        val zerosDecimal = zerosCount / zeros.length\n\
    \        val onesDecimalDecimal = onesDecimal / onesDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal =\
    \ zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprsza9qdk.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprsza9qdk.scala:32:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprsza9qdk.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprsza9qdk.scala:34:76\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mva"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZeros\
    \ = onesZeros / 2\n        val onesZeros = onesZero / 2\n        val onesZero\
    \ = onesZero % 2\n        val onesZeros = onesZeros % 2\n        val onesZero\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcj5wwneo.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcj5wwneo.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros\e[0m = onesZero / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZeros is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcj5wwneo.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZero\e[0m = onesZero\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesZero is already defined as \e[33mvalue\e[0m \e[35monesZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcj5wwneo.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros % \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcj5wwneo.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros / \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcj5wwneo.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = ones.map(x => x.toString.toInt).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toInt).sum\n        val\
    \ onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmparbbbkla.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmparbbbkla.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmparbbbkla.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmparbbbkla.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m                 "
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => (onesZeros - x))\n        val onesZeros_sorted2 = onesZeros_sorted.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted3 = onesZeros_sorted2.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted4 = onesZeros_sorted3.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted5 = onesZeros_sorted4.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted6 = onesZeros_sorted5.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted7 = onesZeros_sorted6.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted8 = onesZeros_sorted7.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted9 = onesZeros_sorted8.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted10 = onesZeros_sorted9.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted11 = onesZeros_sorted10.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted12 = onesZeros_sorted11.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted13 = onesZeros_sorted12.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted14 = onesZeros_sorted13.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted15 = onesZeros_sorted14.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted16 = onesZeros_sorted15.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted17 = onesZeros_sorted16.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted18 = onesZeros_sorted17.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted19 = onesZeros_sorted18.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted20 = onesZeros_sorted19.sortBy(x\
    \ => (onesZeros - x))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_4hg5o8d.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * 10\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxsw4sze9.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpxsw4sze9.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \     Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxsw4sze9.scala:26:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \           ^\e[0m\n\e[31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxsw4sze9.scala:39:96\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDe"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => 1l).sum\n        val zerosCount = zeros.map(x => 0l).sum\n        val onesDecimal\
    \ = ones.map(x => x.toString.toDouble).sum\n        val zerosDecimal = zeros.map(x\
    \ => x.toString.toDouble).sum\n        val onesDecimalDecimal = onesDecimal /\
    \ onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n   \
    \     val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n       \
    \ val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n \
    \       val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zeros\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8_opb90i.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_opb90i.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8_opb90i.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp8_opb90i.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / one"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x % 2 == 0).toList\n  \
    \      val zeros = arr.filter(x => x % 2 == 1).toList\n        val onesCount =\
    \ ones.map(x => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n\
    \        val onesDecimal = ones.map(x => x.toLong).map(x => x.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toLong).map(x => x.toDouble).sum\n\
    \        val onesDecimalDecimal = ones.map(x => x.toLong).map(x => x.toDouble).map(x\
    \ => x.toDouble).sum\n        val zerosDecimalDecimal = zeros.map(x => x.toLong).map(x\
    \ => x.toDouble).map(x => x.toDouble).sum\n        val onesDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toDouble).map(x => x.toDouble).map(x =>\
    \ x.toDouble).sum\n        val zerosDecimalDecimalDecimal = zeros.map(x => x.toLong).map(x\
    \ => x.toDouble).map(x => x.toDouble).map(x => x.toDouble).sum\n        val onesDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toDouble).map(x => x.toDouble).map(x =>\
    \ x.toDouble).map(x => x.toDouble).sum\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zeros.map(x => x.toLong).map(x => x.toDouble).map(x => x.toDouble).map(x =>\
    \ x.toDouble).map(x => x.toDouble).sum\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toDouble).map(x => x.toDouble).map(x =>\
    \ x.toDouble).map(x => x.toDouble).map(x => x.toDouble).sum\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zeros.map(x => x.toLong).map(x => x.toDouble).map(x => x.toDouble).map(x =>\
    \ x.toDouble).map(x => x.toDouble).map(x => x.toDouble).sum\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toDouble).map(x => x.toDouble).map(x =>\
    \ x.toDouble).map(x => x.toDouble).map(x => x.toDouble).map(x => x.toDouble).sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu7nzjh1_.scala:30:5\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l).toList\n     \
    \   val zeros = arr.filter(x => x == 0l).toList\n        val onesCount = ones.map(x\
    \ => 1l).sum\n        val zerosCount = zeros.map(x => 0l).sum\n        val onesDecimal\
    \ = ones.map(x => x.toString.toInt).sum\n        val zerosDecimal = zeros.map(x\
    \ => x.toString.toInt).sum\n        val onesDecimalCount = ones.map(x => x.toString.toInt).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n    \
    \    val onesDecimalCount = ones.map(x => x.toString.toInt).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toInt).count\n        val zerosDecimalCount = zeros.map(x\
    \ => x.toString.toInt).count\n        val onesDecimalCount = ones.map(x => x.toString.toInt).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n    \
    \    val onesDecimalCount = ones.map(x => x.toString.toInt).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toInt).count\n        val zerosDecimalCount = zeros.map(x\
    \ => x.toString.toInt).count\n        val onesDecimalCount = ones.map(x => x.toString.toInt).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n    \
    \    val onesDecimalCount = ones.map(x => x.toString.toInt).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toInt).count\n        val zerosDecimalCount = zeros.map(x\
    \ => x.toString.toInt).count\n        val onesDecimalCount = ones.map(x => x.toString.toInt).count\n\
    \        val zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n    \
    \    val onesDecimalCount = ones.map(x => x.toString.toInt).count\n        val\
    \ zerosDecimalCount = zeros.map(x => x.toString.toInt).count\n        val onesDecimalCount\
    \ = ones.map(x => x.toString.toInt).count\n        val zerosDecimalCount = zer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg0h78oi8.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\e[36mx\e[0m => x.toString.toInt).count\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e[35monesDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg0h78oi8.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m = zeros.map(\e\
    [36mx\e[0m => x.toString.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpg0h78oi8.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\e[36mx\e[0m => x.toString.toInt).count\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e[35monesDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg0h78oi8.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m = zeros.map(\e\
    [36mx\e[0m => x.toString.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definiti"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesArr2 = onesArr.sortBy(_.toString.toInt)\n        val zerosArr2 = zerosArr.sortBy(_.toString.toInt)\n\
    \        val onesArr3 = onesArr2.sortBy(_.toString.toInt)\n        val zerosArr3\
    \ = zerosArr2.sortBy(_.toString.toInt)\n        val onesArr4 = onesArr3.sortBy(_.toString.toInt)\n\
    \        val zerosArr4 = zerosArr3.sortBy(_.toString.toInt)\n        val onesArr5\
    \ = onesArr4.sortBy(_.toString.toInt)\n        val zerosArr5 = zerosArr4.sortBy(_.toString.toInt)\n\
    \        val onesArr6 = onesArr5.sortBy(_.toString.toInt)\n        val zerosArr6\
    \ = zerosArr5.sortBy(_.toString.toInt)\n        val onesArr7 = onesArr6.sortBy(_.toString.toInt)\n\
    \        val zerosArr7 = zerosArr6.sortBy(_.toString.toInt)\n        val onesArr8\
    \ = onesArr7.sortBy(_.toString.toInt)\n        val zerosArr8 = zerosArr7.sortBy(_.toString.toInt)\n\
    \        val onesArr9 = onesArr8.sortBy(_.toString.toInt)\n        val zerosArr9\
    \ = zerosArr8.sortBy(_.toString.toInt)\n        val onesArr10 = onesArr9.sortBy(_.toString.toInt)\n\
    \        val zerosArr10 = zerosArr9.sortBy(_.toString.toInt)\n        val onesArr11\
    \ = onesArr10.sortBy(_.toString.toInt)\n        val zerosArr11 = zerosArr10.sortBy(_.toString.toInt)\n\
    \        val onesArr12 = onesArr11.sortBy(_.toString.toInt)\n        val zerosArr12\
    \ = zerosArr11.sortBy(_.toString.toInt)\n        val onesArr13 = onesArr12.sortBy(_.toString.toInt)\n\
    \        val zerosArr13 = zerosArr12.sortBy(_.toString.toInt)\n        val onesArr14\
    \ = onesArr13.sortBy(_.toString.to\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr0o1umdy.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpr0o1umdy.scala:43:54\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m43 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesArr14\e[0m = onesArr13.sortBy(_.toString.to\n\e[31m\e\
    [31m   |\e[0m                                                      ^\e[0m\n\e\
    [31m   |\e[0mNo implicit Ordering defined for (scala.collection.Factory[Char,\
    \ Any] => Any)..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  \
    \  scala.math.Ordering.comparatorToOrdering[\n\e[31m   |\e[0m      \e[35m(scala.collection.Factory[Char,\
    \ Any] => Any)\e[0m\n\e[31m   |\e[0m    ](\n\e[31m   |\e[0m      /* missing */\n\
    \e[31m   |\e[0m        summon[java.util.Comparator[scala.collection.Factory[Char,\
    \ Any] => Any]]\n\e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no\
    \ implicit values were found that match type java.util.Comparator[scala.collection.Factory[Char,\
    \ Any] => Any].\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr0o1umdy.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val maxOnes = arr.filter(_ == 1).max\n\
    \        val maxZeros = arr.filter(_ == 0).max\n        val maxOnesDecimal = maxOnes.toString.toInt\n\
    \        val maxZerosDecimal = maxZeros.toString.toInt\n        val maxOnesDecimalDecimal\
    \ = maxOnesDecimal.toString.toInt\n        val maxZerosDecimalDecimal = maxZerosDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n  \
    \      val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n \
    \       val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val max\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprekf2dmp.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprekf2dmp.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprekf2dmp.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmprekf2dmp.scala:39:5 ---------------------\e[0m\e[0m\n\
    \e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation a"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x % 2l.toLong == 0l.toLong)\n\
    \        val zeros = arr.filter(x => x % 2l.toLong != 0l.toLong)\n        val\
    \ onesCount = ones.map(x => x.toLong).sum\n        val zerosCount = zeros.map(x\
    \ => x.toLong).sum\n        val onesDecimal = onesCount / 2l.toLong\n        val\
    \ zerosDecimal = zerosCount / 2l.toLong\n        val onesDecimalDecimal = onesDecimal\
    \ / 2l.toLong\n        val zerosDecimalDecimal = zerosDecimal / 2l.toLong\n  \
    \      val onesDecimalDecimalDecimal = onesDecimalDecimal / 2l.toLong\n      \
    \  val zerosDecimalDecimalDecimal = zerosDecimalDecimal / 2l.toLong\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / 2l.toLong\n \
    \       val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal / 2l.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2l.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2l.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi3ippfsx.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal / \e[31m2l\e[0m.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi3ippfsx.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2l\e[0m.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpi3ippfsx.scala:36:76 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2l\e\
    [0m.toLong\n\e[31m\e[31m   |\e[0m                                            \
    \                                ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi3ippfsx.scala:38:5\
    \ ----"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).count(_ == 1)\n        val zerosCount = zeros.map(x => x.toLong).count(_\
    \ == 0)\n        val onesDecimal = ones.map(x => x.toLong).map(x => x.toInt).sum\n\
    \        val zerosDecimal = zeros.map(x => x.toLong).map(x => x.toInt).sum\n \
    \       val onesDecimalDecimal = ones.map(x => x.toLong).map(x => x.toInt).map(x\
    \ => x.toLong).sum\n        val zerosDecimalDecimal = zeros.map(x => x.toLong).map(x\
    \ => x.toInt).map(x => x.toLong).sum\n        val onesDecimalDecimalDecimal =\
    \ ones.map(x => x.toLong).map(x => x.toInt).map(x => x.toLong).map(x => x.toLong).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(x => x.toLong).map(x => x.toInt).map(x\
    \ => x.toLong).map(x => x.toLong).sum\n        val onesDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toInt).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).sum\n        val zerosDecimalDecimalDecimalDecimal = zeros.map(x\
    \ => x.toLong).map(x => x.toInt).map(x => x.toLong).map(x => x.toLong).map(x =>\
    \ x.toLong).sum\n        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(x\
    \ => x.toLong).map(x => x.toInt).map(x => x.toLong).map(x => x.toLong).map(x =>\
    \ x.toLong).map(x => x.toLong).sum\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zeros.map(x => x.toLong).map(x => x.toInt).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).map(x => x.toLong).sum\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toInt).map(x => x.toLong).map(x => x.toLong).map(x\
    \ => x.toLong).map(x => x.toLong).map(x => x.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0m0pl2gx.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp0m0pl2gx.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = ones / onesCount\n        val\
    \ zerosDecimal = zeros / zerosCount\n        val onesDecimalDecimal = onesDecimal\
    \ / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n     \
    \   val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm2261ca9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm2261ca9.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpm2261ca9.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong).length\n\
    \        val zeros = arr.filter(x => x == 0l.toLong).length\n        val onesZeros\
    \ = ones + zeros\n        val onesZeros_sorted = arr.sortBy(x => (onesZeros -\
    \ x))\n        val onesZeros_sorted_reversed = onesZeros_sorted.reverse\n    \
    \    val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed =\
    \ onesZeros_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros - x))\n \
    \       val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros\
    \ - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzri4cgok.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpzri4cgok.scala:29:120 --------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(\e\
    [36mx\e[0m => (onesZeros - x))\n\e[31m\e[31m   |\e[0m                        \
    \                                                                            \
    \                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\
    \e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpzri4cgok.scala:30:127 --------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzri4cgok.scala:31:5 ---------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Lon"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = onesCount / arr.length\n        val zerosDecimal = zerosCount / arr.length\n\
    \        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalInt = onesDecimalString.toInt\n\
    \        val zerosDecimalInt = zerosDecimalString.toInt\n        val onesDecimalDecimal\
    \ = onesDecimalInt * 10\n        val zerosDecimalDecimal = zerosDecimalInt * 10\n\
    \        val onesDecimalDecimalString = onesDecimalDecimal.toString\n        val\
    \ zerosDecimalDecimalString = zerosDecimalDecimal.toString\n        val onesDecimalDecimalInt\
    \ = onesDecimalDecimalString.toInt\n        val zerosDecimalDecimalInt = zerosDecimalDecimalString.toInt\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimalInt * 10\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimalInt * 10\n        val onesDecimalDecimalDecimalString\
    \ = onesDecimalDecimalDecimal.toString\n        val zerosDecimalDecimalDecimalString\
    \ = zerosDecimalDecimalDecimal.toString\n        val onesDecimalDecimalDecimalInt\
    \ = onesDecimalDecimalDecimalString.toInt\n        val zerosDecimalDecimalDecimalInt\
    \ = zerosDecimalDecimalDecimalString.toInt\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalInt * 10\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalInt * 10\n        val onesDecimalDecimalDecimalDecimalString\
    \ = onesDecimalDecimalDecimalDecimal.toString\n        val zerosDecimalDecimalDecimalDecimalString\
    \ = zerosDecimalDecimalDecimalDecimal.toString\n        val onesDecimalDecimalDecimalDecimalInt\
    \ = onesDecimalDecimalDecimalDecimalString.toInt\n        val zerosDecimalDecimalDecimalDecimalInt\
    \ = zerosDecimalDecimalDecimalDecimalString.toInt\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalInt * 10\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalInt * 10\n        val onesDecimalDecimalDecimalDecimalDecimalString\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toString\n        val zerosDecimalDecimalDecimalDecimalString\
    \ = zerosDecimalDecimalDecimalDecimal.toString\n        val onesDecimalDecimalDecimalDecimalDecimalInt\
    \ = onesDecimalDecimalDecimalDecimalString.toInt\n        val zerosDecimalDecimalDecimalDecimalInt\
    \ = zerosDecimalDecimalDecimalDecimalString.toInt\n        val ones\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5awpdq26.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5awpdq26.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalInt\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimal is already defined as \e\
    [33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5awpdq26.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalString\e[0m = zerosDecimalDecimalDecimalDecimal.toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalString is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalString\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5awpdq26.scala:48:12 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalInt\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalInt is already defined as\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5awpdq26.scala:50:5\
    \ ----------------"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count(_ == 1l)\n       \
    \ val zerosCount = zeros.count(_ == 0l)\n        val onesDecimal = onesCount /\
    \ arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_a_pcjnf.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_a_pcjnf.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp_a_pcjnf.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_arr = arr.map(x => (x % 2 == 0 ? 1 : 0, x))\n        val\
    \ onesZeros_arr2 = onesZeros_arr.sortBy(_._1).map(x => x._2)\n        val onesZeros_arr3\
    \ = onesZeros_arr2.sortBy(_._2).map(x => x._1)\n        val onesZeros_arr4 = onesZeros_arr3.sortBy(_._1).map(x\
    \ => x._2)\n        val onesZeros_arr5 = onesZeros_arr4.sortBy(_._2).map(x =>\
    \ x._1)\n        val onesZeros_arr6 = onesZeros_arr5.sortBy(_._1).map(x => x._2)\n\
    \        val onesZeros_arr7 = onesZeros_arr6.sortBy(_._2).map(x => x._1)\n   \
    \     val onesZeros_arr8 = onesZeros_arr7.sortBy(_._2).map(x => x._2)\n      \
    \  val onesZeros_arr9 = onesZeros_arr8.sortBy(_._2).map(x => x._1)\n        val\
    \ onesZeros_arr10 = onesZeros_arr9.sortBy(_._2).map(x => x._2)\n        val onesZeros_arr11\
    \ = onesZeros_arr10.sortBy(_._2).map(x => x._1)\n        val onesZeros_arr12 =\
    \ onesZeros_arr11.sortBy(_._2).map(x => x._2)\n        val onesZeros_arr13 = onesZeros_arr12.sortBy(_._2).map(x\
    \ => x._1)\n        val onesZeros_arr14 = onesZeros_arr13.sortBy(_._2).map(x =>\
    \ x._2)\n        val onesZeros_arr15 = onesZeros_arr14.sortBy(_._2).map(x => x._1)\n\
    \        val onesZeros_arr16 = onesZeros_arr15.sortBy(_._2).map(x => x._2)\n \
    \       val onesZeros_arr17 = onesZeros_arr16.sortBy(_._2).map(x => x._1)\n  \
    \      val onesZeros_arr18 = onesZeros_arr17.sortBy(_._2).map(x => x._2)\n   \
    \     val onesZeros_arr19 = onesZero\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6069d3qd.scala:18:53 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeros_arr\e[0m = arr.map(\e\
    [36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e[0m : \e[31m0\e[0m,\
    \ x))\n\e[31m\e[31m   |\e[0m                                                 \
    \  ^^^\e[0m\n\e[31m   |\e[0m                                          value ?\
    \ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6069d3qd.scala:20:53\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_arr3\e[0m = onesZeros_arr2.sortBy(_._2).map(\e[36mx\e[0m => x._1)\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _2 is not a\
    \ member of Long\n\e[31m\e[31m-- Error: /tmp/tmp6069d3qd.scala:20:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZeros_arr3\e[0m = onesZeros_arr2.sortBy(_._2).map(\e\
    [36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m                                   \
    \                     ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e\
    [33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e\
    [33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6069d3qd.scala:36:30\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_arr19\e[0m = onesZero\n\e[31m\e[31m   |\e[0m                   \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ onesZero\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6069d3qd.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`"
  stdout: ''
  timestamp: 1659979880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr2 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr3\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr4 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr5 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr6\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr7 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr9\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr10 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr11 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr12\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr13 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr14 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr15\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr16 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr17 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr18\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr19 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr20 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr21\
    \ = onesZeros.sortBy(\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfg0lo9s0.scala:40:45 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr21\e[0m = onesZeros.sortBy(\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:20:36\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr\e[0m = onesZeros.sortBy(_.toString.toInt)\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                value sortBy is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpfg0lo9s0.scala:21:37 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:24:37 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                "
  stdout: ''
  timestamp: 1659979883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => (onesZeros - x))\n        val onesZeros_sorted_reversed =\
    \ onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed =\
    \ onesZeros_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros - x))\n \
    \       val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros\
    \ - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcfyycb0g.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcfyycb0g.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpcfyycb0g.scala:30:120 --------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(\e\
    [36mx\e[0m => (onesZeros - x))\n\e[31m\e[31m   |\e[0m                        \
    \                                                                            \
    \                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\
    \e[31m   |\e[0m  onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpcfy"
  stdout: ''
  timestamp: 1659979885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_arr = arr.map(x => (x % 2 == 0 ? 1 : 0, x))\n        val\
    \ onesZeros_sorted = onesZeros_arr.sortBy(_._1).map(_._2)\n        val onesZeros_sorted_arr\
    \ = onesZeros_sorted.map(x => x.toLong)\n        val onesZeros_sorted_sorted =\
    \ onesZeros_sorted_arr.sortBy(_ % 2 == 0).map(_._1)\n        val onesZeros_sorted_sorted_arr\
    \ = onesZeros_sorted_sorted.map(x => x.toLong)\n        val onesZeros_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_arr.sortBy(_ % 2 == 1).map(_._1)\n        val onesZeros_sorted_sorted_sorted_arr\
    \ = onesZeros_sorted_sorted_sorted.map(x => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_arr.sortBy(_._1).map(_._2)\n        val onesZeros_sorted_sorted_sorted_sorted_arr\
    \ = onesZeros_sorted_sorted_sorted_sorted.map(x => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_arr.sortBy(_ % 2 == 0).map(_._1)\n \
    \       val onesZeros_sorted_sorted_sorted_sorted_sorted_arr = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted.map(x\
    \ => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_arr.sortBy(_ % 2 == 1).map(_._1)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_arr = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted.map(x\
    \ => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_arr.sortBy(_._1).map(_._2)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_arr =\
    \ onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.map(x => x.toLong)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_arr.sortBy(_\
    \ % 2 == 0).map(_._1)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk20wgrun.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk20wgrun.scala:18:53\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_arr\e[0m = arr.map(\e[36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e\
    [0m ? \e[31m1\e[0m : \e[31m0\e[0m, x))\n\e[31m\e[31m   |\e[0m                \
    \                                   ^^^\e[0m\n\e[31m   |\e[0m                \
    \                          value ? is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpk20wgrun.scala:21:84 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_sorted\e[0m\
    \ = onesZeros_sorted_arr.sortBy(_ % \e[31m2\e[0m == \e[31m0\e[0m).map(_._1)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                        ^^^^\e[0m\n\e[31m   |\e[0m                          \
    \              value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpk20wgrun.scala:22:77 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_sorted_arr\e[0m = onesZeros_sorted_sorted.map(\e\
    [36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m                               \
    \                                            ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk20wgrun.scala:23:82 -----------"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5v6kwp7n.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp5v6kwp7n.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5v6kwp7n.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: "
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsfg1tusk.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsfg1tusk.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                    ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsfg1tusk.scala:34:76\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsfg1tusk.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp39op7t6o.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp39op7t6o.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp39op7t6o.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5v6kwp7n.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp5v6kwp7n.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5v6kwp7n.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: "
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x.toInt == 1).size\n  \
    \      val zeros = arr.filter(x => x.toInt == 0).size\n        val onesZeros =\
    \ ones + zeros\n        val onesZerosList = onesZeros.toList.sortWith(_ < _)\n\
    \        val onesZeros = onesZerosList.toList\n        val onesZeros = onesZeros.sortWith(_\
    \ < _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = onesZeros.sortWith(_ <\
    \ _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = onesZeros.sortWith(_ <\
    \ _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = onesZeros.sortWith(_ <\
    \ _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = onesZeros.sortWith(_ <\
    \ _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = onesZeros.sortWith(_ <\
    \ _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = onesZeros.sortWith(_ <\
    \ _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = onesZeros.sortWith(_ <\
    \ _)\n        val onesZeros = onesZeros.sortWith(_ < _)\n        val onesZeros\
    \ = onesZeros.sortWith(_ < _)\n        val onesZeros = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp30z10pa5.scala:44:23 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp30z10pa5.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZerosList.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp30z10pa5.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros.sortWith(_ < _)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp30z10pa5.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp30z10pa5.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.max\n \
    \       val maxZeros = arr.min\n        val onesArr = arr.filter(_ % 2 == 0).sortBy(x\
    \ => x.toLong)\n        val zerosArr = arr.filter(_ % 2 == 1).sortBy(x => x.toLong)\n\
    \        val maxOnesArr = onesArr.max\n        val maxZerosArr = zerosArr.min\n\
    \        val maxOnesZeros = maxOnes - maxZeros\n        val maxOnesOnes = maxZeros\
    \ - maxOnes\n        val maxOnesZeroArr = onesArr.filter(_ % 2 == 0).sortBy(x\
    \ => x.toLong).max\n        val maxOnesOneArr = zerosArr.filter(_ % 2 == 1).sortBy(x\
    \ => x.toLong).min\n        val maxOnesZeroZeroArr = onesArr.filter(_ % 2 == 0).sortBy(x\
    \ => x.toLong).filter(_ % 2 == 0).sortBy(x => x.toLong).max\n        val maxOnesOneOneArr\
    \ = zerosArr.filter(_ % 2 == 1).sortBy(x => x.toLong).filter(_ % 2 == 1).sortBy(x\
    \ => x.toLong).min\n        val maxOnesZeroOneArr = onesArr.filter(_ % 2 == 0).sortBy(x\
    \ => x.toLong).filter(_ % 2 == 1).sortBy(x => x.toLong).max\n        val maxOnesOneZeroArr\
    \ = zerosArr.filter(_ % 2 == 1).sortBy(x => x.toLong).filter(_ % 2 == 0).sortBy(x\
    \ => x.toLong).min\n        val maxOnesZeroZeroArr = onesArr.filter(_ % 2 == 0).sortBy(x\
    \ => x.toLong).filter(_ % 2 == 1).sortBy(x => x.toLong).max\n        val maxOnesOneOneZeroArr\
    \ = zerosArr.filter(_ % 2 == 1).sortBy(x => x.toLong).filter(_ % 2 == 0).sortBy(x\
    \ => x.toLong).min\n        val maxOnesZeroOneZeroArr = onesArr.filter(_ % 2 ==\
    \ 0).sortBy(x => x.toLong).filter(_ % 2 == 1).sortBy(x => x.toLong).max\n    \
    \    val maxOnesOneZeroZeroArr = zerosArr.filter(_ % 2 == 1).sortBy(x => x.toLong).filter(_\
    \ % 2 == 0).sortBy(x => x.to\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4flyf1_7.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4flyf1_7.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxOnesZeroZeroArr\e[0m = onesArr.filter(_ % \e[31m2\e[0m == \e[31m0\e\
    [0m).sortBy(\e[36mx\e[0m => x.toLong).filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).sortBy(\e\
    [36mx\e[0m => x.toLong).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesZeroZeroArr is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxOnesZeroZeroArr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E051] Reference Error: /tmp/tmp4flyf1_7.scala:34:119 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesOneZeroZeroArr\e\
    [0m = zerosArr.filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).sortBy(\e[36mx\e[0m =>\
    \ x.toLong).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(\e[36mx\e[0m => x.to\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                             ^^^^\e[0m\n\e[31m\
    \   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35mto\e[0m in \e[33mtrait\e[0m \e[35mIntegralProxy\e[0m with types\n\e[31m\
    \   |\e[0m (end: Long, step: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0m (end: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0mboth match expected type B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4flyf1_7.scala:35:5 ---------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when c"
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count\n\
    \        val zerosCount = zeros.count\n        val onesDecimal = ones.map(_.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toString.toDouble).sum\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprgdtsm3c.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprgdtsm3c.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprgdtsm3c.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDeci"
  stdout: ''
  timestamp: 1659979890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = arr.count(_ == 1 && _ == 0)\n   \
    \     val onesOnes = arr.count(_ == 1 && _ == 1)\n        val onesZeroOnes = arr.count(_\
    \ == 1 && _ == 0 && _ == 1)\n        val onesOnesOnes = arr.count(_ == 1 && _\
    \ == 1 && _ == 1)\n        val onesZeroOnesOnes = arr.count(_ == 1 && _ == 0 &&\
    \ _ == 1 && _ == 1)\n        val onesOnesZeroOnesOnes = arr.count(_ == 1 && _\
    \ == 1 && _ == 0 && _ == 1)\n        val onesZeroOnesOnesOnes = arr.count(_ ==\
    \ 1 && _ == 0 && _ == 1 && _ == 1)\n        val onesOnesZeroOnesZeroOnes = arr.count(_\
    \ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes =\
    \ arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && _ == 0)\n        val onesZeroOnesOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 0 && _ == 1 && _ == 0)\n        val onesOnesZeroOnesZeroOnes\
    \ = arr.count(_ == 1 && _ == 1 && _ == 0 && \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpetgwcfeu.scala:36:78 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36monesOnesZeroOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m0\e[0m &&\
    \ \n\e[31m\e[31m   |\e[0m                                                    \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpetgwcfeu.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesOnesZeroOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m0\e[0m &&\
    \ _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesOnesZeroOnesZeroOnes is already defined as \e[33mvalue\e\
    [0m \e[35monesOnesZeroOnesZeroOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpetgwcfeu.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36monesZeroOnesOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m && _ == \e[31m1\e[0m &&\
    \ _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroOnesOnesZeroOnes is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroOnesOnesZeroOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpetgwcfeu.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesOnesZeroOnesZeroOnes\e\
    [0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m1\e[0m && _ == \e[31m0\e[0m &&\
    \ _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n \
    \       val onesDecSorted = onesDec.takeWhile(_ < ones)\n        val zerosDecSorted\
    \ = zerosDec.takeWhile(_ < zeros)\n        val onesDecSortedSorted: Seq[Long]\
    \ = onesDecSorted.take(ones)\n        val zerosDecSortedSorted: Seq[Long] = zerosDecSorted.take(zeros)\n\
    \        val onesDecSortedSortedSorted: Seq[Long] = onesDecSortedSorted.takeWhile(_\
    \ < onesDecSortedSorted)\n        val zerosDecSortedSortedSorted: Seq[Long] =\
    \ zerosDecSortedSorted.takeWhile(_ < zerosDecSortedSorted)\n        val onesDecSortedSortedSortedSorted:\
    \ Seq[Long] = onesDecSortedSortedSorted.takeWhile(_ < onesDecSortedSortedSortedSorted)\n\
    \        val zerosDecSortedSortedSortedSorted: Seq[Long] = zerosDecSortedSortedSorted.takeWhile(_\
    \ < zerosDecSortedSortedSortedSorted)\n        val onesDecSortedSortedSortedSortedSorted:\
    \ Seq[Long] = onesDecSortedSortedSortedSorted.takeWhile(_ < onesDecSortedSortedSortedSortedSorted)\n\
    \        val zerosDecSortedSortedSortedSortedSorted: Seq[Long] = zerosDecSortedSortedSortedSorted.takeWhile(_\
    \ < zerosDecSortedSortedSortedSortedSortedSorted)\n        val onesDecSortedSortedSortedSortedSortedSorted:\
    \ Seq[Long] = onesDecSortedSortedSortedSortedSortedSorted.takeWhile(_ < onesDecSortedSortedSortedSortedSortedSortedSortedSorted)\n\
    \        val zerosDecSortedSortedSortedSortedSortedSortedSorted: Seq[Long] = zerosDecSortedSortedSortedSortedSortedSortedSorted.takeWhile(_\
    \ < zerosDecSortedSortedSortedSortedSortedSortedSortedSorted)\n        val onesDecSortedSortedSortedSortedSortedSortedSortedSorted:\
    \ Seq[Long] = onesDecSortedSortedSortedSortedSortedSortedSortedSortedSorted.takeWhile(_\
    \ < onesDecSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted)\n   \
    \     val zerosDecSortedSortedSortedSortedSortedSortedSortedSorted: Seq[Long]\
    \ = zerosDecSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted.takeWhile(_\
    \ < zerosDecSortedSortedSortedSortedSorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpedwsyriu.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpedwsyriu.scala:21:63 --------------------\e[0m\e[0m\n\e[31m21 |\e[0m\
    \        \e[33mval\e[0m \e[36monesDecSortedSorted\e[0m: \e[35mSeq\e[0m[\e[35mLong\e\
    [0m] = onesDecSorted.take(ones)\n\e[31m\e[31m   |\e[0m                       \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                          Found:    List[Int]\n\e[31m   |\e[0m              \
    \                    Required: collection.mutable.Seq[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpedwsyriu.scala:22:65 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosDecSortedSorted\e[0m:\
    \ \e[35mSeq\e[0m[\e[35mLong\e[0m] = zerosDecSorted.take(zeros)\n\e[31m\e[31m \
    \  |\e[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    List[Int]\n\e\
    [31m   |\e[0m                                  Required: collection.mutable.Seq[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpedwsyriu.scala:23:83 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecSortedSortedSorted\e\
    [0m: \e[35mSeq\e[0m[\e[35mLong\e[0m] = onesDecSortedSorted.takeWhile(_ < onesDecSortedSorted)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                         ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e\
    [31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m  \
    \ |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e\
    [0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((o"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => if (x == 0) y else x)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfisifebz.scala:15:43\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x == \e[31m0\e[0m) y \e[33melse\e[0m x)\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                           Found:    (y : Long)\n\e\
    [31m   |\e[0m                                           Required: Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfisifebz.scala:15:50\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x == \e[31m0\e[0m) y \e[33melse\e[0m x)\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    (x\
    \ : Long)\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0).sorted\n\
    \        val zerosArray = arr.map(x => if (x == 0) 0 else 1).sorted\n        val\
    \ onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zeroArrayLength = onesArrayLength - zerosArrayLength\n        val onesArray\
    \ = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zeroArrayLength = onesArrayLength - zerosArrayLength\n        val\
    \ onesArray = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zeroArrayLength = onesArrayLength - zerosArrayLength\n        val\
    \ onesArray = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zeroArrayLength = onesArrayLength - zerosArrayLength\n        val\
    \ onesArray = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zeroArrayLength = onesArrayLength - zerosArrayLength\n        val\
    \ onesArray = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zeroArrayLength = onesArrayLength - zerosArrayLength\n        val\
    \ onesArray = onesArray.take\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj4bzvl_7.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ + zerosArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpj4bzvl_7.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = onesArray.take(onesArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArray is already defined as \e[33mvalue\e[0m \e[35monesArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj4bzvl_7.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArray\e[0m = zerosArray.take(zerosArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArray is already defined as \e[33mvalue\e[0m \e[35mzerosArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj4bzvl_7.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj4bzvl_7.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m = zerosArray."
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x % 2l.toLong == 0l.toLong).length\n\
    \        val zeros = arr.filter(x => x % 2l.toLong != 0l.toLong).length\n    \
    \    val onesArr = arr.filter(x => x % 2l.toLong == 0l.toLong).toList\n      \
    \  val zerosArr = arr.filter(x => x % 2l.toLong != 0l.toLong).toList\n       \
    \ val onesSortedArr = onesArr.sortBy(x => x.toString.toInt)\n        val zerosSortedArr\
    \ = zerosArr.sortBy(x => x.toString.toInt)\n        val onesSortedSortedArr =\
    \ onesSortedArr.sortBy(x => x.toString.toInt)\n        val zerosSortedSortedArr\
    \ = zerosSortedArr.sortBy(x => x.toString.toInt)\n        val onesSortedSortedSortedArr\
    \ = onesSortedSortedArr.sortBy(x => x.toString.toInt)\n        val zerosSortedSortedSortedArr\
    \ = zerosSortedSortedArr.sortBy(x => x.toString.toInt)\n        val onesSortedSortedSortedSortedArr\
    \ = onesSortedSortedSortedArr.sortBy(x => x.toString.toInt)\n        val zerosSortedSortedSortedSortedArr\
    \ = zerosSortedSortedSortedArr.sortBy(x => x.toString.toInt)\n        val onesSortedSortedSortedSortedSortedArr\
    \ = onesSortedSortedSortedSortedArr.sortBy(x => x.toString.toInt)\n        val\
    \ zerosSortedSortedSortedSortedSortedArr = zerosSortedSortedSortedSortedArr.sortBy(x\
    \ => x.toString.toInt)\n        val onesSortedSortedSortedSortedSortedSortedArr\
    \ = onesSortedSortedSortedSortedSortedSortedArr.sortBy(x => x.toString.toInt)\n\
    \        val zerosSortedSortedSortedSortedSortedSortedArr = zerosSortedSortedSortedSortedSortedArr.sortBy(x\
    \ => x.toString.toInt)\n        val onesSortedSortedSortedSortedSortedSortedSortedArr\
    \ = onesSortedSortedSortedSortedSortedSortedSortedArr.sortBy(x => x.toString.toInt)\n\
    \        val zerosSortedSortedSortedSortedSortedSortedSortedArr = zerosSortedSortedSortedSortedSortedSortedArr.sortBy(x\
    \ => x.toString.toInt)\n        val onesSortedSortedSortedSortedSortedSortedSortedSortedArr\
    \ = onesSortedSortedSortedSortedSortedSortedSortedSortedArr.sortBy(x => x.toString.toInt)\n\
    \        val zerosSorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6i5ijlft.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6i5ijlft.scala:29:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesSortedSortedSortedSortedSortedSortedArr\e[0m = onesSortedSortedSortedSortedSortedSortedArr.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m                       \
    \                                   ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e\
    [0m \e[35monesSortedSortedSortedSortedSortedSortedArr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6i5ijlft.scala:31:64 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesSortedSortedSortedSortedSortedSortedSortedArr\e\
    [0m = onesSortedSortedSortedSortedSortedSortedSortedArr.sortBy(\e[36mx\e[0m =>\
    \ x.toString.toInt)\n\e[31m\e[31m   |\e[0m                                   \
    \                             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35monesSortedSortedSortedSortedSortedSortedSortedArr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6i5ijlft.scala:33:70\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesSortedSortedSortedSortedSortedSortedSortedSortedArr\e[0m = onesSortedSortedSortedSortedSortedSortedSortedSortedArr.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m                       \
    \                                               ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35monesSortedSortedSortedSortedSortedSortedSortedSortedArr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6i5ijlft.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal /\
    \ onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / zerosDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / onesDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ onesDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhy27t0n.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpuhy27t0n.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuhy27t0n.scala:30:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuhy27t0n.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mones"
  stdout: ''
  timestamp: 1659979890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = ones.map(x => x.toLong).sum / onesCount\n        val\
    \ zerosDecimal = zeros.map(x => x.toLong).sum / zerosCount\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toLong\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toLong\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toLong\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toLong\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn8b39ky7.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong / zerosCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn8b39ky7.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn8b39ky7.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).sum\n        val zerosDecimal\
    \ = zeros.map(_.toString.toInt).map(_.toString.toInt).sum\n        val onesDecimalDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_fw2kws2.scala:29:136 --------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_fw2kws2.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count(_ == 1l)\n       \
    \ val zerosCount = zeros.count(_ == 0l)\n        val onesDecimal = onesCount.toDouble\
    \ / arr.length\n        val zerosDecimal = zerosCount.toDouble / arr.length\n\
    \        val onesDecimalInt = onesDecimal.toInt\n        val zerosDecimalInt =\
    \ zerosDecimal.toInt\n        val onesDecimalLong = onesDecimal.toLong\n     \
    \   val zerosDecimalLong = zerosDecimal.toLong\n        val onesDecimalFloat =\
    \ onesDecimal.toFloat\n        val zerosDecimalFloat = zerosDecimal.toFloat\n\
    \        val onesDecimalDouble = onesDecimal.toDouble\n        val zerosDecimalDouble\
    \ = zerosDecimal.toDouble\n        val onesDecimalDecimal = onesDecimal.toDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal.toDecimal\n        val onesDecimalDecimalInt\
    \ = onesDecimalDecimal.toInt\n        val zerosDecimalDecimalInt = zerosDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalLong = onesDecimalDecimal.toLong\n        val zerosDecimalDecimalLong\
    \ = zerosDecimalDecimal.toLong\n        val onesDecimalDecimalFloat = onesDecimalDecimal.toFloat\n\
    \        val zerosDecimalDecimalFloat = zerosDecimalDecimal.toFloat\n        val\
    \ onesDecimalDecimalDouble = onesDecimalDecimal.toDouble\n        val zerosDecimalDecimalDouble\
    \ = zerosDecimalDecimal.toDouble\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDecimal\n    \
    \    val onesDecimalDecimalDecimalInt = onesDecimalDecimalDecimal.toInt\n    \
    \    val zerosDecimalDecimalDecimalInt = zerosDecimalDecimalDecimal.toInt\n  \
    \      val onesDecimalDecimalDecimalLong = onesDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalLong = zerosDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalFloat = onesDecimalDecimalDecimal.toFloat\n\
    \        val zerosDecimalDecimalDecimalFloat = zerosDecimalDecimalDecimal.toFloat\n\
    \        val onesDecimalDecimalDecimalDouble = onesDecimalDecimalDecimal.toDouble\n\
    \        val zerosDecimalDecimalDecimalDouble = zerosDecimalDecimalDecimal.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal.toDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalInt = onesDecimalDecimal\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdnw33rt9.scala:29:45 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimal\e[0m\
    \ = onesDecimal.toDecimal\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \  value toDecimal is not a member of Double\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpdnw33rt9.scala:30:47 ------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimal\e[0m = zerosDecimal.toDecimal\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toDecimal is not a member\
    \ of Double\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdnw33rt9.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.count(x\
    \ => x == 1).toLong\n        val zerosCount = zeros.count(x => x == 0).toLong\n\
    \        val onesDecimal = ones.count(x => x == 1).toLong / onesCount\n      \
    \  val zerosDecimal = zeros.count(x => x == 0).toLong / zerosCount\n        val\
    \ onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp8t9f9uk4.scala:38:11 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp8t9f9uk4.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t9f9uk4.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp8t9f9uk4.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalD"
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / 10\n        val\
    \ zerosDecimalDecimal = zerosDecimal / 10\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe6uxpytz.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe6uxpytz.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe6uxpytz.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpe6uxpytz.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m10\e[0m\n\e\
    [3"
  stdout: ''
  timestamp: 1659979892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeroSum\
    \ = onesZeros * ones\n        val onesZeroSum2 = onesZeroSum * onesZeroSum\n \
    \       val onesZeroSum3 = onesZeroSum2 * onesZeroSum\n        val onesZeroSum4\
    \ = onesZeroSum3 * onesZeroSum\n        val onesZeroSum5 = onesZeroSum4 * onesZeroSum\n\
    \        val onesZeroSum6 = onesZeroSum5 * onesZeroSum\n        val onesZeroSum7\
    \ = onesZeroSum6 * onesZeroSum\n        val onesZeroSum8 = onesZeroSum7 * onesZeroSum\n\
    \        val onesZeroSum9 = onesZeroSum8 * onesZeroSum\n        val onesZeroSum10\
    \ = onesZeroSum9 * onesZeroSum\n        val onesZeroSum11 = onesZeroSum10 * onesZeroSum\n\
    \        val onesZeroSum12 = onesZeroSum11 * onesZeroSum\n        val onesZeroSum13\
    \ = onesZeroSum12 * onesZeroSum\n        val onesZeroSum14 = onesZeroSum13 * onesZeroSum\n\
    \        val onesZeroSum15 = onesZeroSum14 * onesZeroSum\n        val onesZeroSum16\
    \ = onesZeroSum15 * onesZeroSum\n        val onesZeroSum17 = onesZeroSum16 * onesZeroSum\n\
    \        val onesZeroSum18 = onesZeroSum17 * onesZeroSum\n        val onesZeroSum19\
    \ = onesZeroSum18 * onesZeroSum\n        val onesZeroSum20 = onesZeroSum19 * onesZeroSum\n\
    \        val onesZeroSum21 = onesZeroSum20 * onesZeroSum\n        val onesZeroSum22\
    \ = onesZeroSum21 * onesZeroSum\n        val onesZeroSum23 = onesZeroSum22 * onesZeroSum\n\
    \        val onesZeroSum24 = onesZeroSum23 * onesZeroSum\n        val onesZeroSum25\
    \ = onesZeroSum24 * onesZeroSum\n        val onesZeroSum26 = onesZeroSum25 * onesZeroSum\n\
    \        val onesZeroSum27 = onesZero\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbc24rr7o.scala:44:28 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesZeroSum27\e[0m = onesZero\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: onesZero\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpbc24rr7o.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0kxkejrh.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0kxkejrh.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0kxkejrh.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp0kxkejrh.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecim"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = ones / onesCount\n        val\
    \ zerosDecimal = zeros / zerosCount\n        val onesDecimalDecimal = onesDecimal\
    \ / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n     \
    \   val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm2261ca9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm2261ca9.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpm2261ca9.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr2 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr3\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr4 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr5 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr6\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr7 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr9\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr10 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr11 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr12\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr13 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr14 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr15\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr16 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr17 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr18\
    \ = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr19 = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr20 = onesZeros.sortBy(_.toString.toInt)\n        val onesZeroArr21\
    \ = onesZeros.sortBy(\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfg0lo9s0.scala:40:45 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr21\e[0m = onesZeros.sortBy(\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:20:36\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr\e[0m = onesZeros.sortBy(_.toString.toInt)\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                value sortBy is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpfg0lo9s0.scala:21:37 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfg0lo9s0.scala:24:37 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                "
  stdout: ''
  timestamp: 1659979883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => if (x == 0) y else x)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfisifebz.scala:15:43\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x == \e[31m0\e[0m) y \e[33melse\e[0m x)\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                           Found:    (y : Long)\n\e\
    [31m   |\e[0m                                           Required: Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfisifebz.scala:15:50\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x == \e[31m0\e[0m) y \e[33melse\e[0m x)\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    (x\
    \ : Long)\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx7s2wdco.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx7s2wdco.scala:31:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m    \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7s2wdco.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx7s2wdco.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l.toLong)\n        val\
    \ zeros = arr.filter(_ == 0l.toLong)\n        val onesCount = ones.count\n   \
    \     val zerosCount = zeros.count\n        val onesDecimal = onesCount / arr.length\n\
    \        val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_m3apvat.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_m3apvat.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp_m3apvat.scala:19:36 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = onesCount / arr.length\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue / is not a member of (Long => Boolean) => Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing "
  stdout: ''
  timestamp: 1659979894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = onesCount / arr.length\n        val zerosDecimal = zerosCount / arr.length\n\
    \        val onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpydieh5_x.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpydieh5_x.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpydieh5_x.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArray = arr.filter(_ == 1).map(_.toLong).toArray\n\
    \        val zerosArray = arr.filter(_ == 0).map(_.toLong).toArray\n        val\
    \ onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArrayLength / 2\n        val zerosArrayLength\
    \ = zerosArrayLength / 2\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zerosArrayLength = zerosArrayLength + onesArrayLength\n        val\
    \ onesArrayLength = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength\
    \ / 2\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n    \
    \    val zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength + onesArrayLength\n        val onesArrayLength\
    \ = onesArrayLength / 2\n\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmnqefw_u.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmnqefw_u.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmnqefw_u.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ + zerosArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmnqefw_u.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength + onesArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmnqefw_u.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    "
  stdout: ''
  timestamp: 1659979896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count()\n\
    \        val zerosCount = zeros.count()\n        val onesDecimal = onesCount /\
    \ 2\n        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * 10\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp21nby7l1.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp21nby7l1.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp21nby7l1.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp21nby7l1.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[3"
  stdout: ''
  timestamp: 1659979898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val twos = arr.filter(_ % 2 == 1).length\n        val decimals = arr.filter(_\
    \ % 1 == 0).length\n        val sorted = arr.sortBy(x => (ones - x % ones, twos\
    \ - x % twos, decimals - x % decimals))\n        sorted.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp22ftc0ev.scala:22)\n\tat Problem.main(tmp22ftc0ev.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr2 = onesZeros.toList.sortBy(_.toString.toInt)\n      \
    \  val onesZeroArr3 = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr4\
    \ = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr5 = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr6 = onesZeros.toList.sortBy(_.toString.toInt)\n      \
    \  val onesZeroArr7 = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr8\
    \ = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr9 = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr10 = onesZeros.toList.sortBy(_.toString.toInt)\n     \
    \   val onesZeroArr11 = onesZeros.toList.sortBy(_.toString.toInt)\n        val\
    \ onesZeroArr12 = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr13\
    \ = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr14 = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr15 = onesZeros.toList.sortBy(_.toString.toInt)\n     \
    \   val onesZeroArr16 = onesZeros.toList.sortBy(_.toString.toInt)\n        val\
    \ onesZeroArr17 = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr18\
    \ = onesZeros.toList.sortBy(_.toString.toInt)\n        val onesZeroArr19 = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnphpmnib.scala:20:36 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnphpmnib.scala:21:37 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnphpmnib.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnphpmnib.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnphpmnib.scala:24:37 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList is not a member of Int - did you mean onesZeros.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnphpmnib.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr6\e[0m = onesZeros.toList.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m     value toList"
  stdout: ''
  timestamp: 1659979906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count()\n        val zerosCount\
    \ = zeros.count()\n        val maxOnesCount = onesCount + zerosCount\n       \
    \ val maxZeroCount = zerosCount + onesCount\n        val maxCount = maxOnesCount\
    \ + maxZeroCount\n        val onesArray = ones.toArray\n        val zerosArray\
    \ = zeros.toArray\n        val onesArrayLength = onesArray.length\n        val\
    \ zerosArrayLength = zerosArray.length\n        val onesArrayCopy = onesArray.clone()\n\
    \        val zerosArrayCopy = zerosArray.clone()\n        val onesArrayCopyLength\
    \ = onesArrayCopy.length\n        val zerosArrayCopyLength = zerosArrayCopy.length\n\
    \        val onesArrayCopyCopy = onesArrayCopy.clone()\n        val zerosArrayCopyCopy\
    \ = zerosArrayCopy.clone()\n        val onesArrayCopyCopyLength = onesArrayCopyCopy.length\n\
    \        val zerosArrayCopyCopyLength = zerosArrayCopyCopy.length\n        val\
    \ onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n        val zerosArrayCopyCopyLength\
    \ = zerosArrayCopyCopy.length\n        val onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n\
    \        val zerosArrayCopyCopyLength = zerosArrayCopyCopy.length\n        val\
    \ onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n        val zerosArrayCopyCopyLength\
    \ = zerosArrayCopyCopy.length\n        val onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n\
    \        val zerosArrayCopyCopyLength = zerosArrayCopyCopy.length\n        val\
    \ onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n        val zerosArrayCopyCopyLength\
    \ = zerosArrayCopyCopy.length\n        val onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n\
    \        val zerosArrayCopyCopyLength = zerosArrayCopyCopy.length\n        val\
    \ onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n        val zerosArrayCopyCopyLength\
    \ = zerosArrayCopyCopy.length\n        val onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n\
    \        val zerosArrayCopyCopyLength = zerosArrayCopyCopy.length\n        val\
    \ onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n        val zerosArrayCopyCopyLength\
    \ = zerosArrayCopyCopy.length\n        val onesArrayCopyCopyCopyLength = onesArrayCopyCopy.length\n\
    \        val zerosArrayCopyCopyLength = zerosArrayCopyCopy.length\n        val\
    \ ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6gcky27n.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6gcky27n.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArrayCopyCopyLength\e[0m = zerosArrayCopyCopy.length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosArrayCopyCopyLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosArrayCopyCopyLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6gcky27n.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36monesArrayCopyCopyCopyLength\e\
    [0m = onesArrayCopyCopy.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayCopyCopyCopyLength is already defined as \e[33mvalue\e\
    [0m \e[35monesArrayCopyCopyCopyLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6gcky27n.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayCopyCopyLength\e\
    [0m = zerosArrayCopyCopy.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayCopyCopyLength is already defined as \e[33mvalue\e\
    [0m \e[35mzerosArrayCopyCopyLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6gcky27n.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36monesArrayCopyCopyCopyLength\e\
    [0m = onesArrayCopyCopy.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayCopyCopyCopy"
  stdout: ''
  timestamp: 1659979903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count\n    \
    \    val zerosCount = zeros.count\n        val onesDecimal = ones.map(_.toString.toDouble).sum\n\
    \        val zerosDecimal = zeros.map(_.toString.toDouble).sum\n        val onesDecimalInt\
    \ = onesDecimal.toInt\n        val zerosDecimalInt = zerosDecimal.toInt\n    \
    \    val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt =\
    \ zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toInt\n\
    \        val zerosDecimalInt = zerosDecimalInt.toInt\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \        val onesDecimalInt = onesDecimalInt.toInt\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toInt\n        val onesDecimalInt = onesDecimalInt.toLong\n\
    \        val zerosDecimalInt = zerosDecimalInt.toLong\n        val onesDecimalInt\
    \ = onesDecimalInt.toInt\n        val zerosDecimalInt = zerosDecimalInt.toInt\n\
    \        val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toInt\n\
    \        val zerosDecimalInt = zerosDecimalInt.toInt\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \        val onesDecimalInt = onesDecimalInt.toInt\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toInt\n        val onesDecimalInt = onesDecimalInt.toLong\n\
    \        val zerosDecimalInt = zerosDecimalInt.toLong\n        val onesDecimalInt\
    \ = onesDecimalInt.toInt\n        val zerosDecimalInt = zerosDecimalInt.toInt\n\
    \        val onesDecimalInt = onesDecimalInt.toLong\n        val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n        val onesDecimalInt = onesDecimalInt.toInt\n\
    \        val zerosDecimalInt = zerosDecimalInt.toInt\n        val onesDecimalInt\
    \ = onesDecimalInt.toLong\n        val zerosDecimalInt = zerosDecimalInt.\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9471lr5r.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9471lr5r.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalInt\e[0m = onesDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimalInt is already defined as \e[33mvalue\e[0m \e[35monesDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9471lr5r.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = zerosDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimalInt is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9471lr5r.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalInt\e[0m = onesDecimalInt.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0monesDecimalInt is already defined as \e[33mvalue\e[0m \e[35monesDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9471lr5r.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = zerosDecimalInt.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimalInt is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definit"
  stdout: ''
  timestamp: 1659979904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l.toLong)\n        val\
    \ zeros = arr.filter(_ == 0l.toLong)\n        val onesCount = ones.count\n   \
    \     val zerosCount = zeros.count\n        val onesDecimal = onesCount / arr.length\n\
    \        val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecim\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpimr6cl8c.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpimr6cl8c.scala:19:36 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = onesCount / arr.length\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue / is not a member of (Long => Boolean) => Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpimr6cl8c.scala:20:38 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimal\e[0m = zerosCount\
    \ / arr.length\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue / is not a member of (Long => Boolean) => Int, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E045] C"
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesZeros = ones + zeros\n\
    \        val onesZeroCount = onesZeros.map(x => x.toLong).count(_ > 0).toLong\n\
    \        val onesZeroCountSorted = onesZeroCount.sortBy(x => x.toLong)\n     \
    \   val onesZeroCountSortedSorted: Seq[Long] = onesZeroCountSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.sortBy(x\
    \ => x.toLong)\n        val onesZeroCountSortedSortedSorted: Seq[Long] = onesZeroCountSortedSortedSorted.toSeq.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6j41izow.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6j41izow.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroCountSortedSortedSorted\e[0m: \e\
    [35mSeq\e[0m[\e[35mLong\e[0m] = onesZeroCountSortedSortedSorted.toSeq.sortBy(\e\
    [36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroCountSortedSortedSorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroCountSortedSortedSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6j41izow.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroCountSortedSortedSorted\e[0m: \e[35mSeq\e[0m[\e[35mLong\e[0m]\
    \ = onesZeroCountSortedSortedSorted.toSeq.sortBy(\e[36mx\e[0m => x.toLong)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroCountSortedSortedSorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroCountSortedSortedSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6j41izow.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroCountSortedSortedSorted\e[0m: \e[35mSeq\e[0m[\e[35mLong\e[0m]\
    \ = onesZeroCountSortedSortedSorted.toSeq.sortBy(\e[36mx\e[0m => x.toLong)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroCountSortedSortedSorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroCountSortedSortedSorted\e[0m\n\e[3"
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n        val zerosArr\
    \ = arr.filter(_ == 0)\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesSum = onesArr.sum\n        val zerosSum =\
    \ zerosArr.sum\n        val onesSumArr = onesArr.map(_.toLong)\n        val zerosSumArr\
    \ = zerosArr.map(_.toLong)\n        val onesSumCount = onesSumArr.length\n   \
    \     val zerosSumCount = zerosSumArr.length\n        val onesSumArr = onesSumArr.sortBy(_\
    \ - onesSum)\n        val zerosSumArr = zerosSumArr.sortBy(_ - zerosSum)\n   \
    \     val onesSumCount = onesSumArr.length\n        val zerosSumCount = zerosSumArr.length\n\
    \        val onesSumArr = onesSumArr.sortBy(_ - onesSum)\n        val zerosSumArr\
    \ = zerosSumArr.sortBy(_ - zerosSum)\n        val onesSumCount = onesSumArr.length\n\
    \        val zerosSumCount = zerosSumArr.length\n        val onesSumArr = onesSumArr.sortBy(_\
    \ - onesSum)\n        val zerosSumArr = zerosSumArr.sortBy(_ - zerosSum)\n   \
    \     val onesSumCount = onesSumArr.length\n        val zerosSumCount = zerosSumArr.length\n\
    \        val onesSumArr = onesSumArr.sortBy(_ - onesSum)\n        val zerosSumArr\
    \ = zerosSumArr.sortBy(_ - zerosSum)\n        val onesSumCount = onesSumArr.length\n\
    \        val zerosSumCount = zerosSumArr.length\n        val onesSumArr = onesSumArr.sortBy(_\
    \ - onesSum)\n        val zerosSumArr = zerosSumArr.sortBy(_ - zerosSum)\n   \
    \     val onesSumCount = onesSumArr.length\n        val zerosSumCount = zerosSumArr.length\n\
    \        val onesSumArr = onesSumArr.sortBy(_ - onesSum)\n        val zerosSumArr\
    \ = zerosSumArr.sortBy(_ - zerosSum)\n        val onesSumCount = onesSumArr.length\n\
    \        val zerosSum\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpie2lxvt6.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpie2lxvt6.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesSumArr\e[0m = onesSumArr.sortBy(_ - onesSum)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesSumArr\
    \ is already defined as \e[33mvalue\e[0m \e[35monesSumArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpie2lxvt6.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosSumArr\e[0m = zerosSumArr.sortBy(_ - zerosSum)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mzerosSumArr is already defined as \e[33mvalue\e[0m \e[35mzerosSumArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpie2lxvt6.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36monesSumCount\e[0m = onesSumArr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0monesSumCount is already defined as \e[33mvalue\e[0m \e[35monesSumCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpie2lxvt6.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosSumCount\e[0m = zerosSumArr.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mzerosSumCount is already defined as \e[33mvalue\e[0m \e[35mzerosSumCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming "
  stdout: ''
  timestamp: 1659979904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * 10\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxsw4sze9.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpxsw4sze9.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \     Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxsw4sze9.scala:26:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \           ^\e[0m\n\e[31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxsw4sze9.scala:39:96\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDe"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).max\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).max\n        val onesDecimal = ones.map(x => x.toString.toDouble).max\n\
    \        val zerosDecimal = zeros.map(x => x.toString.toDouble).max\n        val\
    \ onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount\
    \ = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x\
    \ => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_\
    \ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n        val\
    \ zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n        val onesDecimalCount\
    \ = ones.map(x => ones.count(_ == x)).max\n        val zerosDecimalCount = zeros.map(x\
    \ => zeros.count(_ == x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_\
    \ == x)).max\n        val zerosDecimalCount = zeros.map(x => zeros.count(_ ==\
    \ x)).max\n        val onesDecimalCount = ones.map(x => ones.count(_ == x)).max\n\
    \        val zerosDecimalCount = zeros.map(x => zeros.count(_ == x)).max\n   \
    \     val onesDecimalCount = ones.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp87m8t_40.scala:43:40 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ ones.map(\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp87m8t_40.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e[36mx\e\
    [0m => ones.count(_ == x)).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp87m8t_40.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zeros.map(\e[36mx\e[0m => zeros.count(_ == x)).max\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp87m8t_40.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = ones.map(\e\
    [36mx\e[0m => ones.count(_ == x)).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp87m8t_40.scala:26:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count()\n\
    \        val zerosCount = zeros.count()\n        val onesDecimal = ones.map(x\
    \ => x.toString.toDouble).sum\n        val zerosDecimal = zeros.map(x => x.toString.toDouble).sum\n\
    \        val onesDecimalDecimal = onesDecimal.toString.toDouble\n        val zerosDecimalDecimal\
    \ = zerosDecimal.toString.toDouble\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplwr74u0o.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimal is already defined as \e\
    [33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplwr74u0o.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimal\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmplwr74u0o.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmplwr74u0o.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDe"
  stdout: ''
  timestamp: 1659979904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count(_ == 1l)\n       \
    \ val zerosCount = zeros.count(_ == 0l)\n        val onesDecimal = onesCount /\
    \ arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcsxmhhzi.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpcsxmhhzi.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcsxmhhzi.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e"
  stdout: ''
  timestamp: 1659979903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x.toInt == 1)\n       \
    \ val zeros = arr.filter(x => x.toInt == 0)\n        val onesCount = ones.map(x\
    \ => x.toInt).sum\n        val zerosCount = zeros.map(x => x.toInt).sum\n    \
    \    val onesDecimal = onesCount / ones.length\n        val zerosDecimal = zerosCount\
    \ / zeros.length\n        val onesDecimalDecimal = onesDecimal / onesDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecim\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2p9ttkq3.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2p9ttkq3.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp2p9ttkq3.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimal"
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeroArray\
    \ = Array.ofDim[Long](onesZeros)\n        val onesZeroArrayCopy = onesZeroArray.clone()\n\
    \        val onesZeroArrayCopySorted = onesZeroArrayCopy.sortWith(_ < _)\n   \
    \     val onesZeroArraySortedCopy = onesZeroArrayCopySorted.clone()\n        val\
    \ onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_ < _)\n  \
    \      val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val onesZeroArraySortedCopySorted = onesZeroArraySortedCopy.sortWith(_\
    \ < _)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9v6gigqa.scala:39:11 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9v6gigqa.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySorted\e\
    [0m = onesZeroArraySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroArraySortedCopySorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9v6gigqa.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySorted\e\
    [0m = onesZeroArraySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroArraySortedCopySorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9v6gigqa.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedCopySorted\e\
    [0m = onesZeroArraySortedCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroArraySortedCopySorted is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroArraySortedCopySorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9v6gigqa.scala:26:12 ----------------"
  stdout: ''
  timestamp: 1659979904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = onesCount / 2\n        val zerosDecimal = zerosCount\
    \ / 2\n        val onesDecimalDecimal = onesDecimal / 2\n        val zerosDecimalDecimal\
    \ = zerosDecimal / 2\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / 2\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / 2\n  \
    \      val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal / 2\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeyktik_3.scala:29:61 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                             ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeyktik_3.scala:30:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeyktik_3.scala:37:89 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeyktik_3.scala:38:90\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDeci"
  stdout: ''
  timestamp: 1659979904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9xmhdn3j.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp9xmhdn3j.scala:29:61 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9xmhdn3j.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count\n\
    \        val zerosCount = zeros.count\n        val onesDecimal = onesCount / 2\n\
    \        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal\
    \ / 2\n        val zerosDecimalDecimal = zerosDecimal / 2\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 2\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpghprffap.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpghprffap.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpghprffap.scala:19:36 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = onesCount / \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue / is not a member of (Long => Boolean) => Int, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  impor"
  stdout: ''
  timestamp: 1659979906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => (onesZeros - x))\n        val onesZeros_sorted_reversed =\
    \ onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed =\
    \ onesZeros_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros - x))\n \
    \       val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        onesZeros_sorted_reversed_sorted_reversed_sorted_reversed\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8k3y8oyk.scala:27)\n\tat Problem.main(tmp8k3y8oyk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.size\n     \
    \   val zerosCount = zeros.size\n        val onesDecimal = onesCount.toDouble\
    \ / onesCount.toDouble\n        val zerosDecimal = zerosCount.toDouble / zerosCount.toDouble\n\
    \        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalString = onesDecimalString.toUpperCase\n\
    \        val zerosDecimalString = zerosDecimalString.toUpperCase\n        val\
    \ onesDecimalString = onesDecimalString.replace(\".\", \"\")\n        val zerosDecimalString\
    \ = zerosDecimalString.replace(\".\", \"\")\n        val onesDecimalString = onesDecimalString.replace(\"\
    -\", \"\")\n        val zerosDecimalString = zerosDecimalString.replace(\"-\"\
    , \"\")\n        val onesDecimalString = onesDecimalString.replace(\"+\", \"\"\
    )\n        val zerosDecimalString = zerosDecimalString.replace(\"+\", \"\")\n\
    \        val onesDecimalString = onesDecimalString.replace(\"E\", \"\")\n    \
    \    val zerosDecimalString = zerosDecimalString.replace(\"E\", \"\")\n      \
    \  val onesDecimalString = onesDecimalString.replace(\"+\", \"\")\n        val\
    \ zerosDecimalString = zerosDecimalString.replace(\"+\", \"\")\n        val onesDecimalString\
    \ = onesDecimalString.replace(\"E\", \"\")\n        val zerosDecimalString = zerosDecimalString.replace(\"\
    E\", \"\")\n        val onesDecimalString = onesDecimalString.replace(\"+\", \"\
    \")\n        val zerosDecimalString = zerosDecimalString.replace(\"+\", \"\")\n\
    \        val onesDecimalString = onesDecimalString.replace(\"E\", \"\")\n    \
    \    val zerosDecimalString = zerosDecimalString.replace(\"E\", \"\")\n      \
    \  val onesDecimalString = onesDecimalString.replace(\"+\", \"\")\n        val\
    \ zerosDecimalString = zerosDecimalString.replace(\"+\", \"\")\n        val onesDecimalString\
    \ = onesDecimalString.replace(\"E\", \"\")\n        val zerosDecimalString = zerosDecimalString.replace(\"\
    E\", \"\")\n        val onesDecimalString = onesDecimalString.replace(\"+\", \"\
    \")\n        val zerosDecimalString = zerosDecimalString.replace(\"+\", \"\")\n\
    \        val onesDecimalString = onesDecimalString.replace(\"E\", \"\")\n    \
    \    val zerosDecimalString = zerosDecimalString.replace(\"E\", \"\")\n      \
    \  val onesDecimalString = onesDecimalString.replace(\"+\", \"\")\n        val\
    \ zerosDecimalString = zerosDecimalString.replace(\"+\", \"\")\n        val onesDecimalString\
    \ = onesDecimalString.replace(\"E\", \"\")\n        val zerosDecimalString = zerosDecimalString.replace(\"\
    E\", \"\")\n        val onesDecimalString = onesDecimalString.replace(\"+\", \"\
    \")\n        val zerosDecimalString = zerosDecimalString.replace(\"+\", \"\")\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps_fwr26y.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalString\e[0m =\
    \ onesDecimalString.toUpperCase\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalString is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmps_fwr26y.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalString\e[0m\
    \ = zerosDecimalString.toUpperCase\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalString is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmps_fwr26y.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalString\e[0m =\
    \ onesDecimalString.replace(\e[31m\".\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalString is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmps_fwr26y.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalString\e[0m\
    \ = zerosDecimalString.replace(\e[31m\".\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalString is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Nami"
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = onesCount / 2\n        val zerosDecimal = zerosCount\
    \ / 2\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n        val\
    \ zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toDouble / 2\n        val zerosDecimalDecimalDecimal =\
    \ zerosDecimalDecimal.toDouble / 2\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toDouble / 2\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / 2\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toDouble / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toDouble / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / 2\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / 2\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp8qt9i2zj.scala:39:11 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp8qt9i2zj.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8qt9i2zj.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8qt9i2zj.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosD"
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdevtvzpn.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdevtvzpn.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpdevtvzpn.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659979867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp20rog_6p.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp20rog_6p.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp20rog_6p.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDe\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mo"
  stdout: ''
  timestamp: 1659979905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnv798c_n.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnv798c_n.scala:32:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                                     ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnv798c_n.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnv798c_n.scala:36:83\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1659979906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = ones + zeros\n\
    \        val onesZeros_arr = arr.map(x => (x % 2 == 0 ? 1 : 0, x))\n        val\
    \ onesZeros_sorted = onesZeros_arr.sortBy(_._1).map(x => x._2)\n        val onesZeros_sorted_arr\
    \ = onesZeros_sorted.map(x => x.toLong)\n        val onesZeros_sorted_sorted =\
    \ onesZeros_sorted_arr.sortBy(_ % 2 == 0).map(x => x.toLong)\n        val onesZeros_sorted_sorted_arr\
    \ = onesZeros_sorted_sorted.map(x => x.toLong)\n        val onesZeros_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_arr.sortBy(_ % 2 == 1).map(x => x.toLong)\n      \
    \  val onesZeros_sorted_sorted_sorted_arr = onesZeros_sorted_sorted_sorted.map(x\
    \ => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_arr.sortBy(_\
    \ % 2 == 0).map(x => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_arr\
    \ = onesZeros_sorted_sorted_sorted_sorted.map(x => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_arr.sortBy(_ % 2 == 1).map(x => x.toLong)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_arr = onesZeros_sorted_sorted_sorted_sorted_sorted.map(x\
    \ => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_arr.sortBy(_ % 2 == 0).map(x\
    \ => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_arr =\
    \ onesZeros_sorted_sorted_sorted_sorted_sorted_sorted.map(x => x.toLong)\n   \
    \     val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_arr.sortBy(_\
    \ % 2 == 1).map(x => x.toLong)\n        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_arr\
    \ = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted.map(x => x.toLong)\n\
    \        val onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_sorted_arr.sortBy(_\
    \ % 2 == 0).map(x => x.to\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfiybslsl.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfiybslsl.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_arr\e[0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted.map(\e\
    [36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros_sorted_sorted_sorted_sorted_sorted_arr is already\
    \ defined as \e[33mvalue\e[0m \e[35monesZeros_sorted_sorted_sorted_sorted_sorted_arr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfiybslsl.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = onesZeros_sorted_sorted_sorted_sorted_sorted_sorted_arr.sortBy(_ % \e[31m2\e\
    [0m == \e[31m1\e[0m).map(\e[36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros_sorted_sorted_sorted_sorted_sorted_sorted is already\
    \ defined as \e[33mvalue\e[0m \e[35monesZeros_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpfiybslsl.scala:18:53 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeros_arr\e[0m = arr.map(\e[36mx\e\
    [0m => (x % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e[0m : \e[31m0\e[0m, x))\n\e\
    [31m\e[31m   |\e[0m                                                   ^^^\e[0m\n\
    \e[31m   |\e[0m                                          "
  stdout: ''
  timestamp: 1659979907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.map(_.toString.toInt).sortBy(_\
    \ < _)\n        val onesZeroArr2 = onesZeros.map(_.toString.toInt).sortBy(_ >\
    \ _)\n        val onesZeroArr3 = onesZeros.map(_.toString.toInt).sortBy(_ == _)\n\
    \        val onesZeroArr4 = onesZeros.map(_.toString.toInt).sortBy(_ != _)\n \
    \       val onesZeroArr5 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr6 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr7 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr9 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr10 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr11 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr12 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr13 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr14 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr15 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesZeroArr16 = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcyxu1zav.scala:20:36 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.map(_.toString.toInt).sortBy(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          value map is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpcyxu1zav.scala:21:37 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.map(_.toString.toInt).sortBy(_\
    \ > _)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           value map is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpcyxu1zav.scala:22:37 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.map(_.toString.toInt).sortBy(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           value map is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpcyxu1zav.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.map(_.toString.toInt).sortBy(_\
    \ != _)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           value map is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpcyxu1zav.scala:24:37 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value map is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcyxu1zav.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr6\e[0m = onesZeros.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value map is not a member "
  stdout: ''
  timestamp: 1659979910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * 10\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxsw4sze9.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpxsw4sze9.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \     Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxsw4sze9.scala:26:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \           ^\e[0m\n\e[31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxsw4sze9.scala:39:96\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDe"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesSum = onesArr.sum\n        val zerosSum = zerosArr.sum\n        val\
    \ onesMax = onesArr.max\n        val zerosMax = zerosArr.max\n        val onesMin\
    \ = onesArr.min\n        val zerosMin = zerosArr.min\n        val onesAvg = onesArr.sum\
    \ / onesCount\n        val zerosAvg = zerosArr.sum / zerosCount\n        val onesDev\
    \ = onesArr.map(x => (x - onesAvg) * (x - onesAvg)).sum / onesCount\n        val\
    \ zerosDev = zerosArr.map(x => (x - zerosAvg) * (x - zerosAvg)).sum / zerosCount\n\
    \        val onesDeviation = onesArr.map(x => (x - onesAvg) * (x - onesAvg)).sum\
    \ / onesCount / onesCount / onesCount / onesCount / onesCount\n        val zerosDeviation\
    \ = zerosArr.map(x => (x - zerosAvg) * (x - zerosAvg)).sum / zerosCount / zerosCount\
    \ / zerosCount / zerosCount / zerosCount\n        val onesVariance = onesArr.map(x\
    \ => (x - onesAvg) * (x - onesAvg)).sum / onesCount / onesCount / onesCount /\
    \ onesCount / onesCount / onesCount\n        val zerosVariance = zerosArr.map(x\
    \ => (x - zerosAvg) * (x - zerosAvg)).sum / zerosCount / zerosCount / zerosCount\
    \ / zerosCount / zerosCount / zerosCount\n        val onesStdDev = onesArr.map(x\
    \ => (x - onesAvg) * (x - onesAvg)).sum / onesCount / onesCount / onesCount /\
    \ onesCount / onesCount / onesCount / onesCount\n        val zerosStdDev = zerosArr.map(x\
    \ => (x - zerosAvg) * (x - zerosAvg)).sum / zerosCount / zerosCount / zerosCount\
    \ / zerosCount / zerosCount / zerosCount / zerosCount\n        val onesVarianceDeviation\
    \ = onesArr.map(x \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqlzsv7e4.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqlzsv7e4.scala:37:48\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36monesVarianceDeviation\e[0m = onesArr.map(x \n\e[31m\e[31m   |\e[0m       \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                    Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpqlzsv7e4.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n    \
    \    val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n     \
    \   val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkx5vauzs.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkx5vauzs.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpkx5vauzs.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => 1l).sum\n        val zerosCount = zeros.map(x => 0l).sum\n        val onesDecimal\
    \ = ones.map(x => x.toString.toDouble).sum\n        val zerosDecimal = zeros.map(x\
    \ => x.toString.toDouble).sum\n        val onesDecimalInt = ones.map(x => x.toString.toInt).sum\n\
    \        val zerosDecimalInt = zeros.map(x => x.toString.toInt).sum\n        val\
    \ onesDecimalLong = ones.map(x => x.toString.toLong).sum\n        val zerosDecimalLong\
    \ = zeros.map(x => x.toString.toLong).sum\n        val onesDecimalFloat = ones.map(x\
    \ => x.toString.toFloat).sum\n        val zerosDecimalFloat = zeros.map(x => x.toString.toFloat).sum\n\
    \        val onesDecimalDouble = ones.map(x => x.toString.toDouble).sum\n    \
    \    val zerosDecimalDouble = zeros.map(x => x.toString.toDouble).sum\n      \
    \  val onesDecimalBigDecimal = ones.map(x => x.toString.toBigDecimal).sum\n  \
    \      val zerosDecimalBigDecimal = zeros.map(x => x.toString.toBigDecimal).sum\n\
    \        val onesDecimalDecimal = ones.map(x => x.toString.toDecimal).sum\n  \
    \      val zerosDecimalDecimal = zeros.map(x => x.toString.toDecimal).sum\n  \
    \      val onesDecimalBigInt = ones.map(x => x.toString.toBigInt).sum\n      \
    \  val zerosDecimalBigInt = zeros.map(x => x.toString.toBigInt).sum\n        val\
    \ onesDecimalBigLong = ones.map(x => x.toString.toBigLong).sum\n        val zerosDecimalBigLong\
    \ = zeros.map(x => x.toString.toBigLong).sum\n        val onesDecimalBigFloat\
    \ = ones.map(x => x.toString.toBigFloat).sum\n        val zerosDecimalBigFloat\
    \ = zeros.map(x => x.toString.toBigFloat).sum\n        val onesDecimalBigDouble\
    \ = ones.map(x => x.toString.toBigDouble).sum\n        val zerosDecimalBigDouble\
    \ = zeros.map(x => x.toString.toBigDouble).sum\n        val onesDecimalBigDecimal\
    \ = ones.map(x => x.toString.toBigDecimal).sum\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg6475wki.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36monesDecimalBigDecimal\e\
    [0m = ones.map(\e[36mx\e[0m => x.toString.toBigDecimal).sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalBigDecimal is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalBigDecimal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg6475wki.scala:29:61 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalBigDecimal\e\
    [0m = ones.map(\e[36mx\e[0m => x.toString.toBigDecimal).sum\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value toBigDecimal is not a member\
    \ of String\n\e[31m\e[31m-- Error: /tmp/tmpg6475wki.scala:29:78 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalBigDecimal\e\
    [0m = ones.map(\e[36mx\e[0m => x.toString.toBigDecimal).sum\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \    ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mCharIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mFloatIsFractional\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match\
    \ type Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg6475wki.scala:30:63\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalBigDecimal\e[0m = zeros.map(\e[36mx\e[0m => x.toString.toBigDecimal).sum\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value toBigDecimal is not a member\
    \ of String\n\e[31m\e[31m-- Error: /tmp/tmpg6475wki.scala:30:80 -----------------"
  stdout: ''
  timestamp: 1659979918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toLong).sum\n\
    \        val zerosCount = zeros.map(_.toLong).sum\n        val onesDecimal = onesCount\
    \ / ones.size\n        val zerosDecimal = zerosCount / zeros.size\n        val\
    \ onesDecimalDecimal = onesDecimal / onesDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal =\
    \ zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgyd7oznc.scala:31:68 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgyd7oznc.scala:32:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgyd7oznc.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgyd7oznc.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mva"
  stdout: ''
  timestamp: 1659979916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n \
    \       val onesDecSorted = onesDec.take(ones)\n        val zerosDecSorted = zerosDec.take(zeros)\n\
    \        val onesDecSortedSorted: Seq[Long] = onesDecSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSorted: Seq[Long] = zerosDecSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSorted: Seq[Long] = onesDecSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSorted: Seq[Long] = zerosDecSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSorted: Seq[Long] = onesDecSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSorted: Seq[Long] = zerosDecSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSorted: Seq[Long] = onesDecSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSortedSorted: Seq[Long] = zerosDecSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSortedSorted: Seq[Long] = onesDecSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSortedSortedSorted: Seq[Long] = zerosDecSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSortedSortedSorted: Seq[Long] = onesDecSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSortedSortedSortedSorted: Seq[Long] = zerosDecSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSortedSortedSorted: Seq[Long] = onesDecSortedSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSortedSortedSortedSortedSorted: Seq[Long]\
    \ = zerosDec\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8bx_a3nj.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecSortedSortedSortedSortedSortedSortedSorted\e\
    [0m: \e[35mSeq\e[0m[\e[35mLong\e[0m] = onesDecSortedSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecSortedSortedSortedSortedSortedSortedSorted is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecSortedSortedSortedSortedSortedSortedSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp8bx_a3nj.scala:21:45 --------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesDecSortedSorted\e[0m: \e[35mSeq\e\
    [0m[\e[35mLong\e[0m] = onesDecSorted.sortBy(_.toString.toInt)\n\e[31m\e[31m  \
    \ |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    List[Int]\n\e\
    [31m   |\e[0m                                  Required: collection.mutable.Seq[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8bx_a3nj.scala:22:46\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosDecSortedSorted\e\
    [0m: \e[35mSeq\e[0m[\e[35mLong\e[0m] = zerosDecSorted.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    List[Int]\n\e\
    [31m   |\e[0m                                  Required: collection.mutable.Seq[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8bx_a3nj.scala:34:82\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mz"
  stdout: ''
  timestamp: 1659979917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = onesCount / ones.length\n        val zerosDecimal = zerosCount / zeros.length\n\
    \        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalInt = onesDecimalString.toInt\n\
    \        val zerosDecimalInt = zerosDecimalString.toInt\n        val onesDecimalDecimal\
    \ = onesDecimalInt * 10 + onesDecimal\n        val zerosDecimalDecimal = zerosDecimalInt\
    \ * 10 + zerosDecimal\n        val onesDecimalDecimalString = onesDecimalDecimal.toString\n\
    \        val zerosDecimalDecimalString = zerosDecimalDecimal.toString\n      \
    \  val onesDecimalDecimalInt = onesDecimalDecimalString.toInt\n        val zerosDecimalDecimalInt\
    \ = zerosDecimalDecimalString.toInt\n        val onesDecimalDecimalDecimal = onesDecimalDecimalInt\
    \ * 10 + onesDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimalInt\
    \ * 10 + zerosDecimalDecimal\n        val onesDecimalDecimalDecimalString = onesDecimalDecimalDecimal.toString\n\
    \        val zerosDecimalDecimalDecimalString = zerosDecimalDecimalDecimal.toString\n\
    \        val onesDecimalDecimalDecimalInt = onesDecimalDecimalDecimalString.toInt\n\
    \        val zerosDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalString.toInt\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalInt *\
    \ 10 + onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalInt * 10 + zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalString = onesDecimalDecimalDecimalDecimal.toString\n\
    \        val zerosDecimalDecimalDecimalDecimalString = zerosDecimalDecimalDecimalDecimalString.toString\n\
    \        val onesDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimalString.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalDecimalString.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalInt\
    \ * 10 + onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalInt * 10 + zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalString = onesDecimalDecimalDecimalDecimal.toString\n\
    \        val zerosDecimalDecimalDecimalDecimalString = zerosDecimalDecimalDecimalDecimalString.toString\n\
    \        val one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy4747ori.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy4747ori.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalInt\
    \ * \e[31m10\e[0m + zerosDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimal is already defined as \e\
    [33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy4747ori.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalString\e[0m = onesDecimalDecimalDecimalDecimal.toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalString is already defined\
    \ as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalString\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpy4747ori.scala:46:12 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalString\e\
    [0m = zerosDecimalDecimalDecimalDecimalString.toString\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalString is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalString\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659979916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x % 2 == 0).toList\n  \
    \      val zeros = arr.filter(x => x % 2 == 1).toList\n        val onesCount =\
    \ ones.map(x => x.toLong).count(_ == 1)\n        val zerosCount = zeros.map(x\
    \ => x.toLong).count(_ == 0)\n        val onesDecimal = ones.map(x => x.toLong).map(x\
    \ => x.toString.toDouble).sum\n        val zerosDecimal = zeros.map(x => x.toLong).map(x\
    \ => x.toString.toDouble).sum\n        val onesDecimalDecimal = onesDecimal /\
    \ onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n   \
    \     val onesDecimalDecimalDecimal = onesDecimalDecimal / zerosCount\n      \
    \  val zerosDecimalDecimalDecimal = zerosDecimalDecimal / onesCount\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / zerosCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz1g4xym9.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz1g4xym9.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpz1g4xym9.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz1g4xym9.scala:35:75\
    \ ------------------------\e[0m\e[0m\n\e[3"
  stdout: ''
  timestamp: 1659979916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArray = arr.filter(_\
    \ % 2 == 0).map(_.toLong).toArray\n        val zerosArray = arr.filter(_ % 2 ==\
    \ 1).map(_.toLong).toArray\n        val onesArrayLength = onesArray.length\n \
    \       val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArrayLength / 2\n        val zerosArrayLength = zerosArrayLength / 2\n\
    \        val onesArrayLength = onesArrayLength * onesArrayLength\n        val\
    \ zerosArrayLength = zerosArrayLength * zerosArrayLength\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val zerosArrayLength = onesArrayLength\
    \ + zerosArrayLength\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zerosArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ onesArrayLength = onesArrayLength + zerosArrayLength\n        val zerosArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val onesArrayLength = onesArrayLength\
    \ + zerosArrayLength\n        val zerosArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = onesArrayLength + zerosArrayLength\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val zerosArrayLength = onesArrayLength\
    \ + zerosArrayLength\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zerosArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ onesArrayLength = onesArrayLength + zerosArrayLength\n        val zerosArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val onesArrayLength = onesArrayLength\
    \ + zerosArrayLength\n        val zerosArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ zerosArrayLength = onesArrayLength + zerosArrayLength\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val zerosArrayLength = onesArrayLength\
    \ + zerosArrayLength\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val zerosArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ onesArrayLength = onesArrayLength + zerosArrayLength\n        val zerosArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6hhapf4s.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6hhapf4s.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6hhapf4s.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ * onesArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6hhapf4s.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength * zerosArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6hhapf4s.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    "
  stdout: ''
  timestamp: 1659979917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesZeros = ones + zeros\n\
    \        val onesZerosInv = onesZeros / arr.length\n        val onesZerosInv2\
    \ = onesZeros / 2\n        val onesZerosInv3 = onesZeros / 3\n        val onesZerosInv4\
    \ = onesZeros / 4\n        val onesZerosInv5 = onesZeros / 5\n        val onesZerosInv6\
    \ = onesZeros / 6\n        val onesZerosInv7 = onesZeros / 7\n        val onesZerosInv8\
    \ = onesZeros / 8\n        val onesZerosInv9 = onesZeros / 9\n        val onesZerosInv10\
    \ = onesZeros / 10\n        val onesZerosInv11 = onesZeros / 11\n        val onesZerosInv12\
    \ = onesZeros / 12\n        val onesZerosInv13 = onesZeros / 13\n        val onesZerosInv14\
    \ = onesZeros / 14\n        val onesZerosInv15 = onesZeros / 15\n        val onesZerosInv16\
    \ = onesZeros / 16\n        val onesZerosInv17 = onesZeros / 17\n        val onesZerosInv18\
    \ = onesZeros / 18\n        val onesZerosInv19 = onesZeros / 19\n        val onesZerosInv20\
    \ = onesZeros / 20\n        val onesZerosInv21 = onesZeros / 21\n        val onesZerosInv22\
    \ = onesZeros / 22\n        val onesZerosInv23 = onesZeros / 23\n        val onesZerosInv24\
    \ = onesZeros / 24\n        val onesZerosInv25 = onesZeros / 25\n        val onesZerosInv26\
    \ = onesZeros / 26\n        val onesZerosInv27 = onesZeros / 27\n        val onesZerosInv28\
    \ = onesZeros / 28\n        val onesZerosInv29 = onesZeros / 29\n        val onesZerosInv30\
    \ = onesZeros / 30\n        val onesZerosInv31 = onesZeros / 31\n        val onesZerosInv32\
    \ = onesZeros / 32\n        val onesZerosInv33 = onesZeros / 33\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbncm2q6u.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpx4rz8_qf.scala:40:11 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpx4rz8_qf.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx4rz8_qf.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx4rz8_qf.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((a, b) => a.toLong > b.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwzj04elf.scala:18)\n\tat Problem.main(tmpwzj04elf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = ones / onesCount\n        val\
    \ zerosDecimal = zeros / zerosCount\n        val onesDecimalDecimal = onesDecimal\
    \ / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n     \
    \   val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc94e8sfh.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc94e8sfh.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpc94e8sfh.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659979916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesArr2 = onesArr.sortBy(_.toString.toInt)\n        val zerosArr2 = zerosArr.sortBy(_.toString.toInt)\n\
    \        val onesArr3 = onesArr2.sortBy(_.toString.toInt)\n        val zerosArr3\
    \ = zerosArr2.sortBy(_.toString.toInt)\n        val onesArr4 = onesArr3.sortBy(_.toString.toInt)\n\
    \        val zerosArr4 = zerosArr3.sortBy(_.toString.toInt)\n        val onesArr5\
    \ = onesArr4.sortBy(_.toString.toInt)\n        val zerosArr5 = zerosArr4.sortBy(_.toString.toInt)\n\
    \        val onesArr6 = onesArr5.sortBy(_.toString.toInt)\n        val zerosArr6\
    \ = zerosArr5.sortBy(_.toString.toInt)\n        val onesArr7 = onesArr6.sortBy(_.toString.toInt)\n\
    \        val zerosArr7 = zerosArr6.sortBy(_.toString.toInt)\n        val onesArr8\
    \ = onesArr7.sortBy(_.toString.toInt)\n        val zerosArr8 = zerosArr7.sortBy(_.toString.toInt)\n\
    \        val onesArr9 = onesArr8.sortBy(_.toString.toInt)\n        val zerosArr9\
    \ = zerosArr8.sortBy(_.toString.toInt)\n        val onesArr10 = onesArr9.sortBy(_.toString.toInt)\n\
    \        val zerosArr10 = zerosArr9.sortBy(_.toString.toInt)\n        val onesArr11\
    \ = onesArr10.sortBy(_.toString.toInt)\n        val zerosArr11 = zerosArr10.sortBy(_.toString.toInt)\n\
    \        val onesArr12 = onesArr11.sortBy(_.toString.toInt)\n        val zerosArr12\
    \ = zerosArr11.sortBy(_.toString.toInt)\n        val onesArr13 = onesArr12.sortBy(_.toString.toInt)\n\
    \        val zerosArr13 = zerosArr12.sortBy(_.toString.toInt)\n        val onesArr14\
    \ = onesArr13.sortBy(_.toString.to\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr0o1umdy.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpr0o1umdy.scala:43:54\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m43 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesArr14\e[0m = onesArr13.sortBy(_.toString.to\n\e[31m\e\
    [31m   |\e[0m                                                      ^\e[0m\n\e\
    [31m   |\e[0mNo implicit Ordering defined for (scala.collection.Factory[Char,\
    \ Any] => Any)..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  \
    \  scala.math.Ordering.comparatorToOrdering[\n\e[31m   |\e[0m      \e[35m(scala.collection.Factory[Char,\
    \ Any] => Any)\e[0m\n\e[31m   |\e[0m    ](\n\e[31m   |\e[0m      /* missing */\n\
    \e[31m   |\e[0m        summon[java.util.Comparator[scala.collection.Factory[Char,\
    \ Any] => Any]]\n\e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no\
    \ implicit values were found that match type java.util.Comparator[scala.collection.Factory[Char,\
    \ Any] => Any].\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr0o1umdy.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = onesCount / arr.length\n        val zerosDecimal =\
    \ zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8srfac_l.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8srfac_l.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8srfac_l.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp8srfac_l.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / one"
  stdout: ''
  timestamp: 1659979916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count(_ == 1l)\n       \
    \ val zerosCount = zeros.count(_ == 0l)\n        val onesDecimal = onesCount.toDouble\
    \ / ones.length\n        val zerosDecimal = zerosCount.toDouble / zeros.length\n\
    \        val onesDecimalDecimal = onesDecimal.toDouble / onesDecimal\n       \
    \ val zerosDecimalDecimal = zerosDecimal.toDouble / zerosDecimal\n        val\
    \ onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble / zerosDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal.toDouble\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal =\
    \ zerosDecimalDecimalDecimal.toDouble / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toDouble / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3wcejjl4.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3wcejjl4.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3wcejjl4.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).sum\n        val zerosDecimal\
    \ = zeros.map(_.toString.toInt).map(_.toString.toInt).sum\n        val onesDecimalDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc_oxj6mq.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpc_oxj6mq.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.map(_.toLong).sum\n    \
    \    val zerosCount = zeros.map(_.toLong).sum\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / 10\n        val zerosDecimalDecimal = zerosDecimal\
    \ / 10\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / 10\n    \
    \    val zerosDecimalDecimalDecimal = zerosDecimalDecimal / 10\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / 10\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / 10\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / 10\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc404rdqy.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc404rdqy.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpc404rdqy.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m10\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n"
  stdout: ''
  timestamp: 1659979917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith((x, y) => x.toLong == y.toLong ? x.toLong\
    \ - y.toLong : x.toLong - y.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu4hzgjax.scala:15:85 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                               Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpu4hzgjax.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x.toLong == y.toLong ? x.toLong - y.toLong : x.toLong \e[35m-\e[0m y.toLong)\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         value ? is not a member\
    \ of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659979917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count(_\
    \ == 1l.toLong)\n        val zerosCount = zeros.count(_ == 0l.toLong)\n      \
    \  val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n     \
    \   val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n     \
    \   val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7_4emmdo.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7_4emmdo.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7_4emmdo.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDec"
  stdout: ''
  timestamp: 1659979918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count\n    \
    \    val zerosCount = zeros.count\n        val onesDecimal = onesCount / arr.length\n\
    \        val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ arr.length\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * arr.length\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * arr.length\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8xctzuif.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8xctzuif.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xctzuif.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * arr.length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xctzuif.scal"
  stdout: ''
  timestamp: 1659979920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = ones.map(x => x.toLong).sum / onesCount\n        val\
    \ zerosDecimal = zeros.map(x => x.toLong).sum / zerosCount\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal +\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ + onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal +\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2eghqckv.scala:29:61 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal + zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2eghqckv.scala:30:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2eghqckv.scala:33:75\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ + zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2eghqckv.scala:32:69\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDeci"
  stdout: ''
  timestamp: 1659979918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal * 10\n    \
    \    val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal *\
    \ 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxsw4sze9.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpxsw4sze9.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \     Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxsw4sze9.scala:26:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \           ^\e[0m\n\e[31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxsw4sze9.scala:39:96\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDe"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val onesZeros = onesZero % 2\n        val onesZero\
    \ = onesZeros / 2\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpl1urlaim.scala:55:11 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpl1urlaim.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZero\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl1urlaim.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36monesZero\e[0m = onesZeros / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesZero is already defined as \e[33mvalue\e[0m \e[35monesZero\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpl1urlaim.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZero % \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZeros\
    \ is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl1urlaim.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZero\e[0m = onesZeros / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZero is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZero\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming"
  stdout: ''
  timestamp: 1659979919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpx4rz8_qf.scala:40:11 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpx4rz8_qf.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx4rz8_qf.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx4rz8_qf.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvhzyp36r.scala:38:153 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpvhzyp36r.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvhzyp36r.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = ones.map(x => x.toLong).sum / onesCount\n        val\
    \ zerosDecimal = zeros.map(x => x.toLong).sum / zerosCount\n        val onesDecimalDecimal\
    \ = onesDecimal + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ + onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsw6ks9lj.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsw6ks9lj.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsw6ks9lj.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimal"
  stdout: ''
  timestamp: 1659979919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu1s2zqsm.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu1s2zqsm.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpu1s2zqsm.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659979877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = onesCount / arr.length\n        val zerosDecimal =\
    \ zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyspu609f.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyspu609f.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpyspu609f.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyspu609f.scala:37:89\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeroSum\
    \ = onesZeros * (onesZeros - 1) / 2\n        val onesZeroSum2 = onesZeroSum *\
    \ (onesZeroSum - 1) / 2\n        val onesZeroSum3 = onesZeroSum2 * (onesZeroSum2\
    \ - 1) / 2\n        val onesZeroSum4 = onesZeroSum3 * (onesZeroSum3 - 1) / 2\n\
    \        val onesZeroSum5 = onesZeroSum4 * (onesZeroSum4 - 1) / 2\n        val\
    \ onesZeroSum6 = onesZeroSum5 * (onesZeroSum5 - 1) / 2\n        val onesZeroSum7\
    \ = onesZeroSum6 * (onesZeroSum6 - 1) / 2\n        val onesZeroSum8 = onesZeroSum7\
    \ * (onesZeroSum7 - 1) / 2\n        val onesZeroSum9 = onesZeroSum8 * (onesZeroSum8\
    \ - 1) / 2\n        val onesZeroSum10 = onesZeroSum9 * (onesZeroSum9 - 1) / 2\n\
    \        val onesZeroSum11 = onesZeroSum10 * (onesZeroSum10 - 1) / 2\n       \
    \ val onesZeroSum12 = onesZeroSum11 * (onesZeroSum11 - 1) / 2\n        val onesZeroSum13\
    \ = onesZeroSum12 * (onesZeroSum12 - 1) / 2\n        val onesZeroSum14 = onesZeroSum13\
    \ * (onesZeroSum13 - 1) / 2\n        val onesZeroSum15 = onesZeroSum14 * (onesZeroSum14\
    \ - 1) / 2\n        val onesZeroSum16 = onesZeroSum15 * (onesZeroSum15 - 1) /\
    \ 2\n        val onesZeroSum17 = onesZeroSum16 * (onesZeroSum16 - 1) / 2\n   \
    \     val onesZeroSum18 = onesZeroSum17 * (onesZeroSum17 - 1) / 2\n        val\
    \ onesZeroSum19 = onesZeroSum18 * (onesZeroSum18 - 1) / 2\n        val onesZeroSum20\
    \ = onesZeroSum19 * (onesZeroSum19 - 1) / 2\n        val onesZeroSum21 = onesZeroSum20\
    \ * (onesZeroSum20 - 1) / 2\n        val onesZeroSum22 = onesZeroSum21 * (onesZeroSum21\
    \ - 1) / 2\n        val onesZeroSum23 = onesZeroSum22 * (\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr7f_8a0_.scala:40:45 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36monesZeroSum23\e[0m = onesZeroSum22\
    \ * (\n\e[31m\e[31m   |\e[0m                                             ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpr7f_8a0_.scala:40:42\
    \ -----------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e\
    [0m \e[36monesZeroSum23\e[0m = onesZeroSum22 * (\n\e[31m\e[31m   |\e[0m      \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float):\
    \ Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e\
    [31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e\
    [0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments (Null)\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpr7f_8a0_.scala:41:5 ---------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).sum\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).sum\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu_rq1mq9.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpu_rq1mq9.scala:27:54 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m      Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu_rq1mq9.scala:28:55\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m           \
    \                                            ^\e[0m\n\e[31m   |\e[0m     Recursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu_rq1mq9.scala:35:82\
    \ ----------------"
  stdout: ''
  timestamp: 1659979922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count(_ == 1)\n\
    \        val zerosCount = zeros.count(_ == 0)\n        val onesDecimal = onesCount.toDouble\
    \ / ones.size\n        val zerosDecimal = zerosCount.toDouble / zeros.size\n \
    \       val onesDecimalDecimal = onesDecimal.toDouble / onesCount\n        val\
    \ zerosDecimalDecimal = zerosDecimal.toDouble / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toDouble / onesCount\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal.toDouble / zerosCount\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal.toDouble / onesCount\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal.toDouble / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toDouble / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toDouble / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toDouble / onesCount\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesCount\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyulx36gs.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble /\
    \ zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyulx36gs.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpyulx36gs.scala:35:82 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^\e[0m\n\e[31m   |\e[0mRecursive \e\
    [33mvalue\e[0m \e[35mones"
  stdout: ''
  timestamp: 1659979926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count\n\
    \        val zerosCount = zeros.count\n        if (onesCount == zerosCount) {\n\
    \            val onesDecimal = ones.map(x => x.toString.toDouble).sum\n      \
    \      val zerosDecimal = zeros.map(x => x.toString.toDouble).sum\n          \
    \  val onesDecimalInt = onesDecimal.toInt\n            val zerosDecimalInt = zerosDecimal.toInt\n\
    \            val onesDecimalInt = onesDecimalInt.toLong\n            val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n            val onesDecimalInt = onesDecimalInt.toLong\n\
    \            val zerosDecimalInt = zerosDecimalInt.toLong\n            val onesDecimalInt\
    \ = onesDecimalInt.toLong\n            val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \            val onesDecimalInt = onesDecimalInt.toLong\n            val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n            val onesDecimalInt = onesDecimalInt.toLong\n\
    \            val zerosDecimalInt = zerosDecimalInt.toLong\n            val onesDecimalInt\
    \ = onesDecimalInt.toLong\n            val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \            val onesDecimalInt = onesDecimalInt.toLong\n            val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n            val onesDecimalInt = onesDecimalInt.toLong\n\
    \            val zerosDecimalInt = zerosDecimalInt.toLong\n            val onesDecimalInt\
    \ = onesDecimalInt.toLong\n            val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \            val onesDecimalInt = onesDecimalInt.toLong\n            val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n            val onesDecimalInt = onesDecimalInt.toLong\n\
    \            val zerosDecimalInt = zerosDecimalInt.toLong\n            val onesDecimalInt\
    \ = onesDecimalInt.toLong\n            val zerosDecimalInt = zerosDecimalInt.toLong\n\
    \            val onesDecimalInt = onesDecimalInt.toLong\n            val zerosDecimalInt\
    \ = zerosDecimalInt.toLong\n            val onesDecimalInt = onesDecimalInt.toLong\n\
    \            val zerosDecimalInt = zerosDecimalInt.toLong\n            val onesDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplsr8o8sy.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplsr8o8sy.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplsr8o8sy.scala:24:16 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m            \e[33mval\e[0m \e[36monesDecimalInt\e[0m = onesDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalInt is already defined as \e[33mvalue\e[0m \e[35monesDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplsr8o8sy.scala:25:16 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m            \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = zerosDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalInt is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplsr8o8sy.scala:26:16 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36monesDecimalInt\e[0m\
    \ = onesDecimalInt.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalInt is already defined as \e[33mvalue\e[0m \e[35monesDecimalInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplsr8o8sy.scala:27:16 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m            \e[33mval\e[0m \e[36mzerosDecimalInt\e[0m = zerosDecimalInt.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n"
  stdout: ''
  timestamp: 1659979928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong).length\n\
    \        val zeros = arr.filter(x => x == 0l.toLong).length\n        val maxOnes\
    \ = arr.filter(x => x == 1l.toLong).max\n        val maxZeros = arr.filter(x =>\
    \ x == 0l.toLong).max\n        val maxOnesDecimal = maxOnes.toString.toInt\n \
    \       val maxZerosDecimal = maxZeros.toString.toInt\n        val maxOnesDecimalDecimal\
    \ = maxOnesDecimal.toString.toInt\n        val maxZerosDecimalDecimal = maxZerosDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcmnp69uz.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmnp69uz.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpcmnp69uz.scala:34:72 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcmnp69uz."
  stdout: ''
  timestamp: 1659979927
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n \
    \       val onesDecSorted = onesDec.take(ones)\n        val zerosDecSorted = zerosDec.take(zeros)\n\
    \        val onesDecSortedSorted: Array[Long] = onesDecSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSorted: Array[Long] = zerosDecSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSorted: Array[Long] = onesDecSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSorted: Array[Long] = zerosDecSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSorted: Array[Long] = onesDecSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSorted: Array[Long] = zerosDecSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSorted: Array[Long] = onesDecSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSortedSorted: Array[Long] = zerosDecSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSortedSorted: Array[Long] = onesDecSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSortedSortedSorted: Array[Long] = zerosDecSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSortedSortedSorted: Array[Long] =\
    \ onesDecSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n     \
    \   val zerosDecSortedSortedSortedSortedSortedSortedSorted: Array[Long] = zerosDecSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val onesDecSortedSortedSortedSortedSortedSortedSorted: Array[Long] =\
    \ onesDecSortedSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \        val zerosDecSortedSortedSortedSortedSortedSortedSorted: Array[Long] =\
    \ zerosDecSorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkxj25k_r.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecSortedSortedSortedSortedSortedSortedSorted\e\
    [0m: \e[35mArray\e[0m[\e[35mLong\e[0m] = onesDecSortedSortedSortedSortedSortedSortedSorted.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecSortedSortedSortedSortedSortedSortedSorted is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecSortedSortedSortedSortedSortedSortedSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkxj25k_r.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecSortedSortedSortedSortedSortedSortedSorted\e\
    [0m: \e[35mArray\e[0m[\e[35mLong\e[0m] = zerosDecSorted\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecSortedSortedSortedSortedSortedSortedSorted is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecSortedSortedSortedSortedSortedSortedSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpkxj25k_r.scala:21:47 --------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesDecSortedSorted\e[0m: \e[35mArray\e\
    [0m[\e[35mLong\e[0m] = onesDecSorted.sortBy(_.toString.toInt)\n\e[31m\e[31m  \
    \ |\e[0m                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                               Found:    List[Int]\n\
    \e[31m   |\e[0m                                               Required: Array[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkxj25k_r.scala:22:48 "
  stdout: ''
  timestamp: 1659979930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count(_ == 1l)\n       \
    \ val zerosCount = zeros.count(_ == 0l)\n        val onesDecimal = onesCount.toDouble\
    \ / ones.size\n        val zerosDecimal = zerosCount.toDouble / zeros.size\n \
    \       val onesDecimalInt = onesDecimal.toInt\n        val zerosDecimalInt =\
    \ zerosDecimal.toInt\n        val onesDecimalDecimal = onesDecimalInt * Math.pow(10,\
    \ zerosDecimalInt)\n        val zerosDecimalDecimal = zerosDecimalInt * Math.pow(10,\
    \ zerosDecimalInt)\n        val onesDecimalDecimalInt = onesDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalInt = zerosDecimalDecimal.toInt\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalInt)\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalInt)\n\
    \        val onesDecimalDecimalDecimalInt = onesDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalInt = zerosDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalInt *\
    \ Math.pow(10, zerosDecimalDecimalDecimalInt)\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalDecimalInt)\n\
    \        val onesDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalInt\
    \ * Math.pow(10, zerosDecimalDecimalDecimalInt)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalDecimalDecimalInt)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalInt\
    \ * Math.pow(10, zerosDecimalDecimalDecimalDecimalDecimalInt)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalDecimalDecimalInt)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy8dr6uxj.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy8dr6uxj.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalInt\
    \ * Math.pow(\e[31m10\e[0m, zerosDecimalDecimalDecimalDecimalInt)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpy8dr6uxj.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.size\n\
    \        val zerosCount = zeros.size\n        val onesDecimal = onesCount / 2\n\
    \        val zerosDecimal = zerosCount / 2\n        val onesDecimalDecimal = onesDecimal\
    \ / 2\n        val zerosDecimalDecimal = zerosDecimal / 2\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / 2\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 2\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / 2\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprli5qzy_.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprli5qzy_.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmprli5qzy_.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / \e[31m2\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m"
  stdout: ''
  timestamp: 1659979928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n \
    \       val onesDec = onesDec.takeWhile(_ < ones).reverse\n        val zerosDec\
    \ = zerosDec.takeWhile(_ < zeros).reverse\n        val onesDec = onesDec.takeWhile(_\
    \ < ones).reverse\n        val zerosDec = zerosDec.takeWhile(_ < zeros).reverse\n\
    \        val onesDec = onesDec.takeWhile(_ < ones).reverse\n        val zerosDec\
    \ = zerosDec.takeWhile(_ < zeros).reverse\n        val onesDec = onesDec.takeWhile(_\
    \ < ones).reverse\n        val zerosDec = zerosDec.takeWhile(_ < zeros).reverse\n\
    \        val onesDec = onesDec.takeWhile(_ < ones).reverse\n        val zerosDec\
    \ = zerosDec.takeWhile(_ < zeros).reverse\n        val onesDec = onesDec.takeWhile(_\
    \ < ones).reverse\n        val zerosDec = zerosDec.takeWhile(_ < zeros).reverse\n\
    \        val onesDec = onesDec.takeWhile(_ < ones).reverse\n        val zerosDec\
    \ = zerosDec.takeWhile(_ < zeros).reverse\n        val onesDec = onesDec.takeWhile(_\
    \ < ones).reverse\n        val zerosDec = zerosDec.takeWhile(_ < zeros).reverse\n\
    \        val onesDec = onesDec.takeWhile(_ < ones).reverse\n        val zerosDec\
    \ = zerosDec.takeWhile(_ < zeros).reverse\n        val onesDec = onesDec.takeWhile(_\
    \ < ones).reverse\n        val zerosDec = zerosDec.takeWhile(_ < zeros).reverse\n\
    \        val onesDec = onesDec.takeWhile(_ < ones).reverse\n        val zerosDec\
    \ = zerosDec.takeWhile(_ < zeros).reverse\n        val onesDec = onesDec.takeWhile(_\
    \ < ones).reverse\n        val zerosDec = zerosDec.takeWhile(_ < zeros).reverse\n\
    \        val onesDec = onesDec.takeWhile(_ < ones).reverse\n        val zerosDec\
    \ = zerosDec.takeWhile(_ < zeros).reverse\n        val ones\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpftdj_9sa.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpftdj_9sa.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDec\e[0m = onesDec.takeWhile(_ < ones).reverse\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpftdj_9sa.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosDec.takeWhile(_ < zeros).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpftdj_9sa.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.takeWhile(_ <\
    \ ones).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpftdj_9sa.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosDec.takeWhile(_\
    \ < zeros).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitio"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortBy(x => (onesZeros - x))\n        val onesZeros_sorted_reversed =\
    \ onesZeros_sorted.reverse\n        val onesZeros_sorted_reversed_sorted = onesZeros_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed =\
    \ onesZeros_sorted_reversed_sorted.reverse\n        val onesZeros_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros - x))\n \
    \       val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed = onesZeros_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x => (onesZeros\
    \ - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => (onesZeros - x))\n        val onesZeros_sorted_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpev3gyf7h.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpev3gyf7h.scala:30:127\
    \ -----------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(\e\
    [36mx\e[0m => (onesZeros - x))\n\e[31m\e[31m   |\e[0m                        \
    \                                                                            \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesZeros_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpev3gyf7h.scala:32:5\
    \ ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9ly5p8w.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa9ly5p8w.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa9ly5p8w.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l)\n        val zeros\
    \ = arr.filter(_ == 0l)\n        val onesCount = ones.count\n        val zerosCount\
    \ = zeros.count\n        val onesDecimal = onesCount / arr.length\n        val\
    \ zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal\
    \ / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n     \
    \   val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqr3_qkxz.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqr3_qkxz.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpqr3_qkxz.scala:19:36 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = onesCount / arr.length\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue / is not a member of (Long => Boolean) => Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing "
  stdout: ''
  timestamp: 1659979931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvhzyp36r.scala:38:153 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpvhzyp36r.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvhzyp36r.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvhzyp36r.scala:38:153 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpvhzyp36r.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvhzyp36r.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1659795367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toLong).sum\n        val zerosCount = zeros.map(x => x.toLong).sum\n  \
    \      val onesDecimal = ones.map(x => x.toLong).map(x => x.toInt).sum\n     \
    \   val zerosDecimal = zeros.map(x => x.toLong).map(x => x.toInt).sum\n      \
    \  val onesDecimalDecimal = ones.map(x => x.toLong).map(x => x.toInt).map(x =>\
    \ x.toInt).sum\n        val zerosDecimalDecimal = zeros.map(x => x.toLong).map(x\
    \ => x.toInt).map(x => x.toInt).sum\n        val onesDecimalDecimalDecimal = ones.map(x\
    \ => x.toLong).map(x => x.toInt).map(x => x.toInt).map(x => x.toInt).sum\n   \
    \     val zerosDecimalDecimalDecimal = zeros.map(x => x.toLong).map(x => x.toInt).map(x\
    \ => x.toInt).map(x => x.toInt).sum\n        val onesDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toInt).map(x => x.toInt).map(x => x.toInt).map(x\
    \ => x.toInt).sum\n        val zerosDecimalDecimalDecimalDecimal = zeros.map(x\
    \ => x.toLong).map(x => x.toInt).map(x => x.toInt).map(x => x.toInt).map(x =>\
    \ x.toInt).sum\n        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(x\
    \ => x.toLong).map(x => x.toInt).map(x => x.toInt).map(x => x.toInt).map(x =>\
    \ x.toInt).map(x => x.toInt).sum\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zeros.map(x => x.toLong).map(x => x.toInt).map(x => x.toInt).map(x => x.toInt).map(x\
    \ => x.toInt).map(x => x.toInt).sum\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = ones.map(x => x.toLong).map(x => x.toInt).map(x => x.toInt).map(x => x.toInt).map(x\
    \ => x.toInt).map(x => x.toInt).map(x => x.toInt).sum\n        val zeros\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpojvzme78.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpojvzme78.scala:31:5 ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.map(_.toString.toInt).sum\n\
    \        val zerosCount = zeros.map(_.toString.toInt).sum\n        val onesDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).sum\n        val zerosDecimal\
    \ = zeros.map(_.toString.toInt).map(_.toString.toInt).sum\n        val onesDecimalDecimal\
    \ = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = ones.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zeros.map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).map(_.toString.toInt).sum\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = ones.map(\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8hhucd9r.scala:29:70 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = ones.map(\n\e[31m\e[31m   |\e[0m                                       \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8hhucd9r.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9ly5p8w.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa9ly5p8w.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa9ly5p8w.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesSum = onesArr.foldLeft(0l) { (sum, elem) => sum + elem.toLong }\n\
    \        val zerosSum = zerosArr.foldLeft(0l) { (sum, elem) => sum + elem.toLong\
    \ }\n        val onesMax = onesSum / onesCount\n        val zerosMax = zerosSum\
    \ / zerosCount\n        val onesMin = onesSum / onesCount * -1\n        val zerosMin\
    \ = zerosSum / zerosCount * -1\n        val onesAvg = onesSum / onesCount\n  \
    \      val zerosAvg = zerosSum / zerosCount\n        val onesDev = onesSum / onesCount\
    \ * onesCount - onesSum * onesAvg\n        val zerosDev = zerosSum / zerosCount\
    \ * zerosCount - zerosSum * zerosAvg\n        val onesDeviation = onesDev / onesCount\
    \ * onesCount * onesCount / onesSum\n        val zerosDeviation = zerosDev / zerosCount\
    \ * zerosCount * zerosCount / zerosSum\n        val onesVariance = onesDeviation\
    \ / onesCount * onesCount * onesCount / onesSum\n        val zerosVariance = zerosDeviation\
    \ / zerosCount * zerosCount * zerosCount / zerosSum\n        val onesStdDev =\
    \ onesVariance / onesCount\n        val zerosStdDev = zerosVariance / zerosCount\n\
    \        val onesStdDeviation = onesStdDev / onesCount * onesCount * onesCount\
    \ / onesSum\n        val zerosStdDeviation = zerosStdDev / zerosCount * zerosCount\
    \ * zerosCount / zerosSum\n        val onesVarianceDeviation = onesStdDeviation\
    \ / onesCount * onesCount * onesCount / onesSum\n        val zerosVarianceDeviation\
    \ = zerosStdDeviation / zerosCount * zerosCount * zerosCount / zerosSum\n    \
    \    val onesStdDevDeviation = onesVarianceDevi\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphl31syrf.scala:41:34 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36monesStdDevDeviation\e[0m\
    \ = onesVarianceDevi\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: onesVarianceDevi\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphl31syrf.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n        val zerosArr\
    \ = arr.filter(_ == 0)\n        val onesCount = onesArr.length\n        val zerosCount\
    \ = zerosArr.length\n        val onesSum = onesArr.sum\n        val zerosSum =\
    \ zerosArr.sum\n        val onesMax = onesSum / onesCount\n        val zerosMax\
    \ = zerosSum / zerosCount\n        val onesMin = onesSum / onesCount\n       \
    \ val zerosMin = zerosSum / zerosCount\n        val onesAvg = onesSum / onesCount\n\
    \        val zerosAvg = zerosSum / zerosCount\n        val onesDev = onesSum /\
    \ onesCount\n        val zerosDev = zerosSum / zerosCount\n        val onesStd\
    \ = onesDev / onesCount\n        val zerosStd = zerosDev / zerosCount\n      \
    \  val onesSumSqr = onesArr.reduce((x, y) => x + y)\n        val zerosSumSqr =\
    \ zerosArr.reduce((x, y) => x + y)\n        val onesAvgSqr = onesSumSqr / (onesCount\
    \ * 1.0)\n        val zerosAvgSqr = zerosSumSqr / (zerosCount * 1.0)\n       \
    \ val onesDev = onesSumSqr / (onesCount * 1.0)\n        val zerosDev = zerosSumSqr\
    \ / (zerosCount * 1.0)\n        val onesStd = onesDev / onesCount\n        val\
    \ zerosStd = zerosDev / zerosCount\n        val onesSumSqr = onesArr.reduce((x,\
    \ y) => x + y)\n        val zerosSumSqr = zerosArr.reduce((x, y) => x + y)\n \
    \       val onesAvgSqr = onesSumSqr / (onesCount * 1.0)\n        val zerosAvgSqr\
    \ = zerosSumSqr / (zerosCount * 1.0)\n        val onesDev = onesSumSqr / (onesCount\
    \ * 1.0)\n        val zerosDev = zerosSumSqr / (zerosCount * 1.0)\n        val\
    \ onesStd = onesDev / onesCount\n        val zerosStd = zerosDev / zerosCount\n\
    \        val onesSumSqr = onesArr.reduce((x, y) => x + y)\n        val zerosSumSqr\
    \ = zerosArr.reduce((x, y) => x + y)\n        val onesAvgSqr = onesSumSqr / (one\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp38dgs4n9.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp38dgs4n9.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDev\e[0m = onesSumSqr / (onesCount * \e[31m1.0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesDev is already defined as \e[33mvalue\e[0m \e[35monesDev\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp38dgs4n9.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDev\e[0m = zerosSumSqr / (zerosCount\
    \ * \e[31m1.0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDev is already defined as \e[33mvalue\e[0m \e[35mzerosDev\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp38dgs4n9.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36monesStd\e[0m = onesDev / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesStd is already defined as \e[33mvalue\e[0m \e[35monesStd\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp38dgs4n9.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosStd\e[0m = zerosDev / zerosCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mzerosStd is already defined as \e[33mvalue\e[0m \e[35mzerosStd\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp38dgs4n9.scala:41:12 "
  stdout: ''
  timestamp: 1659979930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp39onmrs.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp39onmrs.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp39onmrs.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpp39onmrs.scala:37:82 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                "
  stdout: ''
  timestamp: 1659979930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x.toInt == 1)\n       \
    \ val zeros = arr.filter(x => x.toInt == 0)\n        val onesCount = ones.map(x\
    \ => x.toInt).sum\n        val zerosCount = zeros.map(x => x.toInt).sum\n    \
    \    val onesDecimal = onesCount / arr.length\n        val zerosDecimal = zerosCount\
    \ / arr.length\n        val onesDecimalDecimal = onesDecimal / zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcjgu035p.scala:27:54 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m      Recursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcjgu035p.scala:28:55\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m           \
    \                                            ^\e[0m\n\e[31m   |\e[0m     Recursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcjgu035p.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m          \
    \                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcjgu035p.scala:32:69\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDe"
  stdout: ''
  timestamp: 1659979931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.map(x\
    \ => 1l.toLong).sum\n        val zerosCount = zeros.map(x => 0l.toLong).sum\n\
    \        val onesDecimal = ones.map(x => x.toLong).sum / onesCount\n        val\
    \ zerosDecimal = zeros.map(x => x.toLong).sum / zerosCount\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxjc5or6l.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxjc5or6l.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxjc5or6l.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659979931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count(x\
    \ => x == 1l.toLong)\n        val zerosCount = zeros.count(x => x == 0l.toLong)\n\
    \        val onesDecimal = onesCount / arr.length\n        val zerosDecimal =\
    \ zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphznjb7qu.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphznjb7qu.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphznjb7qu.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmphznjb7qu.scala:33:75 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / one"
  stdout: ''
  timestamp: 1659979931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1l.toLong)\n     \
    \   val zeros = arr.filter(x => x == 0l.toLong)\n        val onesCount = ones.count\n\
    \        val zerosCount = zeros.count\n        val onesDecimal = onesCount / arr.length\n\
    \        val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9833l53a.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp9833l53a.scala:19:36 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = onesCount / arr.length\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue / is not a member of (Long => Boolean) => Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9833l53a.scala:20:38 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimal\e[0m = zerosCount\
    \ / arr.length\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue / is not a member of (Long => Boolean) => Int, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E045] C"
  stdout: ''
  timestamp: 1659979933
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.size\n      \
    \  val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal =\
    \ onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n    \
    \    val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n     \
    \   val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecim\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2jk3ogxn.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp2jk3ogxn.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2jk3ogxn.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tm"
  stdout: ''
  timestamp: 1659979932
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesArr2 = onesArr.sortBy(_ % 10).reverse\n\
    \        val zerosArr2 = zerosArr.sortBy(_ % 10).reverse\n        val onesArr3\
    \ = onesArr2.sortBy(_ % 100).reverse\n        val zerosArr3 = zerosArr2.sortBy(_\
    \ % 100).reverse\n        val onesArr4 = onesArr3.sortBy(_ % 1000).reverse\n \
    \       val zerosArr4 = zerosArr3.sortBy(_ % 1000).reverse\n        val onesArr5\
    \ = onesArr4.sortBy(_ % 10000).reverse\n        val zerosArr5 = zerosArr4.sortBy(_\
    \ % 10000).reverse\n        val onesArr6 = onesArr5.sortBy(_ % 100000).reverse\n\
    \        val zerosArr6 = zerosArr5.sortBy(_ % 100000).reverse\n        val onesArr7\
    \ = onesArr6.sortBy(_ % 1000000).reverse\n        val zerosArr7 = zerosArr6.sortBy(_\
    \ % 1000000).reverse\n        val onesArr8 = onesArr7.sortBy(_ % 10000000).reverse\n\
    \        val zerosArr8 = zerosArr7.sortBy(_ % 10000000).reverse\n        val onesArr9\
    \ = onesArr8.sortBy(_ % 100000000).reverse\n        val zerosArr9 = zerosArr8.sortBy(_\
    \ % 100000000).reverse\n        val onesArr10 = onesArr9.sortBy(_ % 1000000000).reverse\n\
    \        val zerosArr10 = zerosArr9.sortBy(_ % 1000000000).reverse\n        val\
    \ onesArr11 = onesArr10.sortBy(_ % 10000000000).reverse\n        val zerosArr11\
    \ = zerosArr10.sortBy(_ % 10000000000).reverse\n        val onesArr12 = onesArr11.sortBy(_\
    \ % 100000000000).reverse\n        val zerosArr12 = zerosArr11.sortBy(_ % 100000000000).reverse\n\
    \        val onesArr13 = onesArr12.sortBy(_ % 1000000000000).reverse\n       \
    \ val zerosArr13 = zerosArr12.sortBy(_ % 1000000000000).reverse\n        val onesArr14\
    \ = onesArr13.sortBy(_ % 10000000000000).reverse\n        val zerosArr14 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpenizidlz.scala:44:24 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mzerosArr14\e[0m = \n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpenizidlz.scala:37:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36monesArr11\e[0m = onesArr10.sortBy(_\
    \ % \e[31m10000000000\e[0m).reverse\n\e[31m\e[31m   |\e[0m                   \
    \                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                            number too large\n\e[31m\e[31m-- Error: /tmp/tmpenizidlz.scala:38:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m38 |\e[0m       \
    \ \e[33mval\e[0m \e[36mzerosArr11\e[0m = zerosArr10.sortBy(_ % \e[31m10000000000\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m                                          \
    \     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \         number too large\n\e[31m\e[31m-- Error: /tmp/tmpenizidlz.scala:39:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesArr12\e[0m = onesArr11.sortBy(_ % \e[31m100000000000\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m                                          \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \      number too large\n\e[31m\e[31m-- Error: /tmp/tmpenizidlz.scala:40:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mzerosArr12\e[0m = zerosArr11.sortBy(_\
    \ % \e[31m100000000000\e[0m).reverse\n\e[31m\e[31m   |\e[0m                  \
    \                             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                  number too large\n\e[31m\e[31m-- Error: /tmp/tmpenizidlz.scala:41:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m41 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesArr13\e[0m = onesArr12.sortBy(_ % \e[31m1000000000000\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659979933
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toString.toInt).sum\n        val zerosCount = zeros.map(x => x.toString.toInt).sum\n\
    \        val onesDecimal = onesCount / 2\n        val zerosDecimal = zerosCount\
    \ / 2\n        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalInt = onesDecimalString.toInt\n\
    \        val zerosDecimalInt = zerosDecimalString.toInt\n        val onesDecimalLong\
    \ = onesDecimalInt.toLong\n        val zerosDecimalLong = zerosDecimalInt.toLong\n\
    \        val onesDecimalFloat = onesDecimalLong.toFloat\n        val zerosDecimalFloat\
    \ = zerosDecimalLong.toFloat\n        val onesDecimalDouble = onesDecimalFloat.toDouble\n\
    \        val zerosDecimalDouble = zerosDecimalFloat.toDouble\n        val onesDecimalDecimal\
    \ = onesDecimalDouble.toBigDecimal\n        val zerosDecimalDecimal = zerosDecimalDouble.toBigDecimal\n\
    \        val onesDecimalDecimalString = onesDecimalDecimal.toString\n        val\
    \ zerosDecimalDecimalString = zerosDecimalDecimal.toString\n        val onesDecimalDecimalInt\
    \ = onesDecimalDecimalString.toInt\n        val zerosDecimalDecimalInt = zerosDecimalDecimalString.toInt\n\
    \        val onesDecimalDecimalLong = onesDecimalDecimalInt.toLong\n        val\
    \ zerosDecimalDecimalLong = zerosDecimalDecimalInt.toLong\n        val onesDecimalDecimalFloat\
    \ = onesDecimalDecimalLong.toFloat\n        val zerosDecimalDecimalFloat = zerosDecimalDecimalLong.toFloat\n\
    \        val onesDecimalDecimalDouble = onesDecimalDecimalFloat.toDouble\n   \
    \     val zerosDecimalDecimalDouble = zerosDecimalDecimalFloat.toDouble\n    \
    \    val onesDecimalDecimalDecimal = onesDecimalDecimalDouble.toBigDecimal\n \
    \       val zerosDecimalDecimalDecimal = zerosDecimalDecimalDouble.toBigDecimal\n\
    \        val onesDecimalDecimalDecimalString = onesDecimalDecimalDecimal.toString\n\
    \        val zerosDecimalDecimalDecimalString = zerosDecimalDecimalDecimal.toString\n\
    \        val onesDecimalDecimalDecimalInt = onesDecimalDecimalDecimalString.toInt\n\
    \        val zerosDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalString.toInt\n\
    \        val onesDecimalDecimalDecimalLong = onesDecimalDecimalDecimalInt.toLong\n\
    \        val zerosDecimalDecimalDecimalLong = zerosDecimalDecimalDecimalInt.toLong\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp20m3_bsp.scala:31:51 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimal\e[0m\
    \ = onesDecimalDouble.toBigDecimal\n\e[31m\e[31m   |\e[0m                    \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                 value toBigDecimal is not a member of Double\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp20m3_bsp.scala:32:53 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimal\e[0m\
    \ = zerosDecimalDouble.toBigDecimal\n\e[31m\e[31m   |\e[0m                   \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                    value toBigDecimal is not a member of Double\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp20m3_bsp.scala:52:5 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeros_sorted\
    \ = arr.sortWith(x => (onesZeros - x.toLong))\n        val onesZeros_sortedWithZeros\
    \ = onesZeros_sorted.takeWhile(x => x == 0)\n        val onesZeros_sortedWithOnes\
    \ = onesZeros_sorted.dropWhile(x => x == 0)\n        val onesZeros_sortedWithOnesAndZeros\
    \ = onesZeros_sortedWithOnes ++ onesZeros_sortedWithZeros\n        onesZeros_sortedWithOnesAndZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmperpe8b4h.scala:18:46 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeros_sorted\e[0m =\
    \ arr.sortWith(\e[36mx\e[0m => (onesZeros - x.toLong))\n\e[31m\e[31m   |\e[0m\
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n1 error found\n"
  stdout: ''
  timestamp: 1659979931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZerosInv\
    \ = onesZeros / arr.length\n        val onesZerosInv2 = onesZerosInv * onesZerosInv\n\
    \        val onesZerosInv3 = onesZerosInv2 * onesZerosInv\n        val onesZerosInv4\
    \ = onesZerosInv3 * onesZerosInv\n        val onesZerosInv5 = onesZerosInv4 *\
    \ onesZerosInv\n        val onesZerosInv6 = onesZerosInv5 * onesZerosInv\n   \
    \     val onesZerosInv7 = onesZerosInv6 * onesZerosInv\n        val onesZerosInv8\
    \ = onesZerosInv7 * onesZerosInv\n        val onesZerosInv9 = onesZerosInv8 *\
    \ onesZerosInv\n        val onesZerosInv10 = onesZerosInv9 * onesZerosInv\n  \
    \      val onesZerosInv11 = onesZerosInv10 * onesZerosInv\n        val onesZerosInv12\
    \ = onesZerosInv11 * onesZerosInv\n        val onesZerosInv13 = onesZerosInv12\
    \ * onesZerosInv\n        val onesZerosInv14 = onesZerosInv13 * onesZerosInv\n\
    \        val onesZerosInv15 = onesZerosInv14 * onesZerosInv\n        val onesZerosInv16\
    \ = onesZerosInv15 * onesZerosInv\n        val onesZerosInv17 = onesZerosInv16\
    \ * onesZerosInv\n        val onesZerosInv18 = onesZerosInv17 * onesZerosInv\n\
    \        val onesZerosInv19 = onesZerosInv18 * onesZerosInv\n        val onesZerosInv20\
    \ = onesZerosInv19 * onesZerosInv\n        val onesZerosInv21 = onesZerosInv20\
    \ * onesZerosInv\n        val onesZerosInv22 = onesZerosInv21 * onesZerosInv\n\
    \        val onesZerosInv23 = onesZerosInv22 * onesZerosInv\n        val onesZerosIn\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwhrj8g8z.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwhrj8g8z.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979936
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqc1gnikt.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpqc1gnikt.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqc1gnikt.scala:35:82\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m                                         \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: "
  stdout: ''
  timestamp: 1659979937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1l.toLong)\n        val\
    \ zeros = arr.filter(_ == 0l.toLong)\n        val onesCount = ones.count()\n \
    \       val zerosCount = zeros.count()\n        val onesDecimal = onesCount.toDouble\
    \ / arr.length\n        val zerosDecimal = zerosCount.toDouble / arr.length\n\
    \        val onesDecimalInt = onesDecimal.toInt\n        val zerosDecimalInt =\
    \ zerosDecimal.toInt\n        val onesDecimalDecimal = onesDecimalInt * Math.pow(10,\
    \ onesDecimalInt)\n        val zerosDecimalDecimal = zerosDecimalInt * Math.pow(10,\
    \ zerosDecimalInt)\n        val onesDecimalDecimalInt = onesDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalInt = zerosDecimalDecimal.toInt\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimalInt * Math.pow(10, onesDecimalDecimalInt)\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalInt)\n        val\
    \ onesDecimalDecimalDecimalInt = onesDecimalDecimalDecimal.toInt\n        val\
    \ zerosDecimalDecimalDecimalInt = zerosDecimalDecimalDecimal.toInt\n        val\
    \ onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalInt * Math.pow(10,\
    \ onesDecimalDecimalDecimalInt)\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalDecimalInt)\n\
    \        val onesDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalInt\
    \ * Math.pow(10, onesDecimalDecimalDecimalInt)\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalInt * Math.pow(10, zerosDecimalDecimalDecimalDecimalInt)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalInt = onesDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalInt = zerosDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalInt\
    \ * Math.pow(10, onesDecimalDecimalDecimalDecimalInt)\n        val zerosDecimalDecimalDecimalDecimalDecimalInt\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toInt\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalInt * Math.pow(10, onesDecimalDecimalDecimalDecimalInt)\n\
    \        val zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4idvzioc.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4idvzioc.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalInt\e[0m = zerosDecimalDecimalDecimalDecimalDecimal.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalInt is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalInt\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4idvzioc.scala:41:12 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalInt * Math.pow(\e[31m10\e[0m, onesDecimalDecimalDecimalDecimalInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmp4idvzioc.scala:17:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesCount\e[0m = ones.count()\n\e[31m\e[31m   |\e[0m  \
    \                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter p of \e[33mmethod\e[0m \e[35mcount\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m: (p: Long => Boolean): Int\n\e[31m\e[31m-- Error: /tmp/tmp4idvzioc.scala:18:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e["
  stdout: ''
  timestamp: 1659979937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(x => x == 1).toList\n      \
    \  val zeros = arr.filter(x => x == 0).toList\n        val onesCount = ones.map(x\
    \ => ones.count(_ == x)).max\n        val zerosCount = zeros.map(x => zeros.count(_\
    \ == x)).max\n        val onesDecimal = ones.map(x => ones.count(_ == x)).sum\
    \ / onesCount.toDouble\n        val zerosDecimal = zeros.map(x => zeros.count(_\
    \ == x)).sum / zerosCount.toDouble\n        val onesDecimalDecimal = onesDecimal\
    \ + zerosDecimal\n        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal.toLong\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal.toLong\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal.toLong\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal.toLong\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal.toLong\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal.toLong\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprxow0le5.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprxow0le5.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmprxow0le5.scala:25:47 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimal\e[0m\
    \ = onesDecimalDecimalDecimalDecimal.toLong\n\e[31m\e[31m   |\e[0m           \
    \                                    ^\e[0m\n\e[31m   |\e[0m             Recursive\
    \ \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimal\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprxow0le5.scala:26:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal.toLong\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprxow0le5.scala:27:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36"
  stdout: ''
  timestamp: 1659979938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZeroArray\
    \ = arr.map(x => (x, onesZeros)).toArray\n        val onesZeroArraySorted = onesZeroArray.sortWith((x,\
    \ y) => x._2 < y._2)\n        val onesZeroArraySortedSortedWithZeros = onesZeroArraySorted.sortWith((x,\
    \ y) => x._1 < y._1)\n        val onesZeroArraySortedSortedWithOnes = onesZeroArraySortedSortedWithZeros.sortWith((x,\
    \ y) => x._2 < y._2)\n        val onesZeroArraySortedSortedWithOnesAndZeros =\
    \ onesZeroArraySortedSortedWithOnes.sortWith((x, y) => x._1 < y._1)\n        val\
    \ onesZeroArraySortedSortedWithOnesAndOnes = onesZeroArraySortedSortedWithOnesAndZeros.sortWith((x,\
    \ y) => x._2 < y._2)\n        val onesZeroArraySortedSortedWithOnesAndOnesAndZeros\
    \ = onesZeroArraySortedSortedWithOnesAndOnes.sortWith((x, y) => x._1 < y._1)\n\
    \        val onesZeroArraySortedSortedWithOnesAndOnesAndOnes = onesZeroArraySortedSortedWithOnesAndOnesAndZeros.sortWith((x,\
    \ y) => x._2 < y._2)\n        val onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndZeros\
    \ = onesZeroArraySortedSortedWithOnesAndOnesAndOnes.sortWith((x, y) => x._1 <\
    \ y._1)\n        val onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnes =\
    \ onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndZeros.sortWith((x, y) => x._2\
    \ < y._2)\n        val onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnesAndZeros\
    \ = onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnes.sortWith((x, y) =>\
    \ x._1 < y._1)\n        val onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnesAndOnes\
    \ = onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnesAndZeros.sortWith((x,\
    \ y) => x._2 < y._2)\n        val onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnesAndOnesAndZeros\
    \ = onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnesAndOnes.sortWith((x,\
    \ y) => \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp48mmfg1k.scala:30:164 --------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnesAndOnesAndZeros\e\
    [0m = onesZeroArraySortedSortedWithOnesAndOnesAndOnesAndOnesAndOnes.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => \n\e[31m\e[31m   |\e[0m                         \
    \                                                                            \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48mmfg1k.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).toList\n       \
    \ val zeros = arr.filter(_ % 2 == 1).toList\n        val onesCount = ones.map(x\
    \ => x.toString.toInt).sum\n        val zerosCount = zeros.map(x => x.toString.toInt).sum\n\
    \        val onesDecimal = onesCount / 2\n        val zerosDecimal = zerosCount\
    \ / 2\n        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalInt = onesDecimalString.toInt\n\
    \        val zerosDecimalInt = zerosDecimalString.toInt\n        val onesDecimalLong\
    \ = onesDecimalInt.toLong\n        val zerosDecimalLong = zerosDecimalInt.toLong\n\
    \        val onesDecimalLongString = onesDecimalLong.toString\n        val zerosDecimalLongString\
    \ = zerosDecimalLong.toString\n        val onesDecimalLongInt = onesDecimalLongString.toInt\n\
    \        val zerosDecimalLongInt = zerosDecimalLongString.toInt\n        val onesDecimalLongLong\
    \ = onesDecimalLongInt.toLong\n        val zerosDecimalLongLong = zerosDecimalLongInt.toLong\n\
    \        val onesDecimalLongLongString = onesDecimalLongLong.toString\n      \
    \  val zerosDecimalLongLongString = zerosDecimalLongLong.toString\n        val\
    \ onesDecimalLongLongInt = onesDecimalLongLongString.toInt\n        val zerosDecimalLongLongInt\
    \ = zerosDecimalLongLongString.toInt\n        val onesDecimalLongLongLong = onesDecimalLongLongInt.toLong\n\
    \        val zerosDecimalLongLongLong = zerosDecimalLongLongInt.toLong\n     \
    \   val onesDecimalLongLongLongString = onesDecimalLongLongLong.toString\n   \
    \     val zerosDecimalLongLongLongString = zerosDecimalLongLongLong.toString\n\
    \        val onesDecimalLongLongLongInt = onesDecimalLongLongLongString.toInt\n\
    \        val zerosDecimalLongLongLongInt = zerosDecimalLongLongLongString.toInt\n\
    \        val onesDecimalLongLongLongLong = onesDecimalLongLongLongInt.toLong\n\
    \        val zerosDecimalLongLongLongLong = zerosDecimalLongLongLongInt.toLong\n\
    \        val onesDecimalLongLongLongLongString = onesDecimalLongLongLongLong.toString\n\
    \        val zerosDecimalLongLongLongLongString = zerosDecimalLongLongLongLong.toString\n\
    \        val onesDecimalLongLongLongLongInt = onesDecimalLongLongLongLongString.toInt\n\
    \        val zerosDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjgpoafx8.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpjgpoafx8.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        arr.sortWith(compare)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2xzluyh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(compare)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).length\n        val\
    \ zeros = arr.filter(_ == 0).length\n        val onesZeros = ones + zeros\n  \
    \      val onesZero = onesZeros / 2\n        val onesZeroMinusOne = onesZero -\
    \ 1\n        val onesZeroMinusOneMinusOne = onesZeroMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOne - 1\n        val\
    \ onesZeroMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n   \
    \     val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne -\
    \ 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpag6fofsb.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpag6fofsb.scala:23:63\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                         ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpag6fofsb.scala:24:71 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpag6fofsb.scala:25:79\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m\
    \ = onesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35monesZeroMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpag6fofsb.scala:26:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroMinu"
  stdout: ''
  timestamp: 1659979937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ == 1).toList\n        val\
    \ zeros = arr.filter(_ == 0).toList\n        val onesCount = ones.count\n    \
    \    val zerosCount = zeros.count\n        val onesDecimal = onesCount / arr.length\n\
    \        val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg9z61wqz.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg9z61wqz.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpg9z61wqz.scala:19:36 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = onesCount / arr.length\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue / is not a member of (Long => Boolean) => Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing "
  stdout: ''
  timestamp: 1659979938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n       \
    \ val zeros = arr.filter(_ % 2 == 1).length\n        val decimals = arr.filter(_\
    \ % 10 == 0).length\n        val decimalsDecimals = arr.filter(_ % 10 == 1).length\n\
    \        val decimalsDecimalsDecimals = arr.filter(_ % 10 == 2).length\n     \
    \   val decimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 3).length\n  \
    \      val decimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 4).length\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ %\
    \ 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 10).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 11).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 12).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 13).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 14).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 15).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf6eernmg.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpf6eernmg.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / ones\n        val\
    \ zerosDecimal = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal\
    \ / onesDecimal\n        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9xgx8psj.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9xgx8psj.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xgx8psj.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xgx8psj.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDe"
  stdout: ''
  timestamp: 1659979938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZero\
    \ = onesZeros / (onesZeros + zeros)\n        val onesZeros = onesZeros * (onesZeros\
    \ + zeros) / onesZero\n        val onesZeros = onesZeros * (onesZeros + zeros)\
    \ / onesZero\n        val onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n\
    \        val onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n        val\
    \ onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n        val onesZeros\
    \ = onesZeros * (onesZeros + zeros) / onesZero\n        val onesZeros = onesZeros\
    \ * (onesZeros + zeros) / onesZero\n        val onesZeros = onesZeros * (onesZeros\
    \ + zeros) / onesZero\n        val onesZeros = onesZeros * (onesZeros + zeros)\
    \ / onesZero\n        val onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n\
    \        val onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n        val\
    \ onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n        val onesZeros\
    \ = onesZeros * (onesZeros + zeros) / onesZero\n        val onesZeros = onesZeros\
    \ * (onesZeros + zeros) / onesZero\n        val onesZeros = onesZeros * (onesZeros\
    \ + zeros) / onesZero\n        val onesZeros = onesZeros * (onesZeros + zeros)\
    \ / onesZero\n        val onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n\
    \        val onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n        val\
    \ onesZeros = onesZeros * (onesZeros + zeros) / onesZero\n        val onesZeros\
    \ = onesZeros * (onesZeros + zeros) / onesZero\n        val onesZeros = onesZeros\
    \ * (onesZeros + zeros) / onesZero\n        val onesZeros = onesZeros * (onesZeros\
    \ + zeros) / onesZero\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpm1tjlqyq.scala:41:11 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpm1tjlqyq.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros\
    \ * (onesZeros + zeros) / onesZero\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm1tjlqyq.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros * (onesZeros\
    \ + zeros) / onesZero\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm1tjlqyq.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros * (onesZeros\
    \ + zeros) / onesZero\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm1tjlqyq.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros * (onesZeros\
    \ + zeros) / onesZero\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mon"
  stdout: ''
  timestamp: 1659979938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesZeros = ones + zeros\n        val onesZerosList\
    \ = arr.map(x => (x, onesZeros)).toList\n        val onesZerosListSorted = onesZerosList.toList.sortBy(_._1).reverse\n\
    \        val onesZerosListSortedWithOnes = onesZerosListSorted.filter(_._2 ==\
    \ ones)\n        val onesZerosListSortedWithZeros = onesZerosListSorted.filter(_._2\
    \ == zeros)\n        val onesZerosListSortedWithOnesAndZeros = onesZerosListSorted.filter(_._2\
    \ == onesZeros)\n        val onesZerosListSortedWithOnesAndZerosSorted = onesZerosListSortedWithOnesAndZeros.sortBy(_._1).reverse\n\
    \        val onesZerosListSortedWithOnesAndZerosSortedWithOnes = onesZerosListSortedWithOnesAndZerosSorted.filter(_._2\
    \ == ones)\n        val onesZerosListSortedWithOnesAndZerosSortedWithZeros = onesZerosListSortedWithOnesAndZerosSorted.filter(_._2\
    \ == zeros)\n        val onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZeros\
    \ = onesZerosListSortedWithOnesAndZerosSorted.filter(_._2 == onesZeros)\n    \
    \    val onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZerosSorted = onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZeros.sortBy(_._1).reverse\n\
    \        val onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnes\
    \ = onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZerosSorted.filter(_._2\
    \ == ones)\n        val onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithZeros\
    \ = onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZerosSorted.filter(_._2\
    \ == zeros)\n        val onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZerosSortedWithOnesAndZeros\
    \ = onesZerosListSortedWithOnesAndZerosSortedWithOnesAndZerosSorted.filter(_._2\
    \ == onesZeros)\n        val onesZerosListSortedWithOnesAndZerosSortedWith\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpslittu1k.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpslittu1k.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n    // >>> sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))\n    // (List[Long](-6l.toLong,\
    \ -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))\n    // >>> sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))\n    def sortArray(arr : List[Long])\
    \ : List[Long] = {\n        val ones = arr.count(_ == 1)\n        val zeros =\
    \ arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount\
    \ = arr.count(_ == 0)\n        val onesDecimal = onesCount / arr.length\n    \
    \    val zerosDecimal = zerosCount / arr.length\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu1s2zqsm.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu1s2zqsm.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpu1s2zqsm.scala:31:68 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659979877
