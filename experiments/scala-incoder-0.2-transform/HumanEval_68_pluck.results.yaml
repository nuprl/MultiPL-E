language: scala
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     evens\n        } else {\n            evens.take(smalest_index + 1)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_29s6h7.scala:40)\n\tat Problem.main(tmpa_29s6h7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = if (index == -1) List(even) else List(even, index)\n   \
    \     result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk5kf2zm2.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).take(index).toList\n        if (result.isEmpty)\
    \ Nil\n        else result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcfw588rc.scala:38)\n\tat Problem.main(tmpcfw588rc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.head\n            val smalest_index = evens.indexOf(0)\n\
    \            val evens_without_smalest_value = evens.filterNot(x => x == smalest_value)\n\
    \            if (evens_without_smalest_value.isEmpty) List()\n            else\
    \ {\n                val smallest_even = evens_without_smalest_value.head\n  \
    \              val smallest_even_index = evens_without_smalest_value.indexOf(smallest_even)\n\
    \                val smallest_even_index_plus_one = smallest_even_index + 1\n\
    \                val smallest_even_index_plus_two = smallest_even_index + 2\n\
    \                val smallest_even_index_plus_three = smallest_even_index + 3\n\
    \                val smallest_even_index_plus_four = smallest_even_index + 4\n\
    \                val smallest_even_index_plus_five = smallest_even_index + 5\n\
    \                val smallest_even_index_plus_six = smallest_even_index + 6\n\
    \                val smallest_even_index_plus_seven = smallest_even_index + 7\n\
    \                val smallest_even_index_plus_eight = smallest_even_index + 8\n\
    \                val smallest_even_index_plus_nine = smallest_even_index + 9\n\
    \                val smallest_even_index_plus_ten = smallest_even_index + 10\n\
    \                val smallest_even_index_plus_eleven = smallest_even_index + 11\n\
    \                val smallest_even_index_plus_twelve = smallest_even_index + 12\n\
    \                val smallest_even_index_plus_thirteen = smallest_even_index +\
    \ 13\n                val smallest_even_index_plus_fourteen = smallest_even_index\
    \ + 14\n                val smallest_even_index_plus_fifteen = smallest_even_index\
    \ + 15\n                val smallest_even_index_plus_sixteen = smallest_even_index\
    \ + 16\n                val smallest_even_index_plus_seventeen = smallest_even_index\
    \ + 17\n                val smallest_even_index_plus_eighteen = smallest_even_index\
    \ + 18\n                val smallest_even_index_plus_nineteen = smallest_even_index\
    \ + 19\n                val smallest_even_index_plus_twenty = smallest_even_index\
    \ + 20\n                val smallest_even_index_plus_twenty_one = smallest_even_index\
    \ + 21\n                val smallest_even_index_plus_twenty_two = smallest_even_index\
    \ + 22\n                val smallest_even_index_plus_twenty_three = smallest_even_index\
    \ + 23\n                val smalle\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjjv4qus5.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjjv4qus5.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjjv4qus5.scala:76:1 ---------------------\e[0m\e[0m\n\
    \e[31m76 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpjjv4qus5.scala:65:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m65 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        if (evens.isEmpty) List()\n        else if (index == 0) List(even)\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.pluck(tmp7b1x43sq.scala:31)\n\
    \tat Problem$.main(tmp7b1x43sq.scala:40)\n\tat Problem.main(tmp7b1x43sq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(0)\n        val result = List(smallest, index)\n\
    \        if (evens.isEmpty) result\n        else result.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywg_v0eo.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywg_v0eo.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val min = evens.min\n            val index = arr.indexOf(min)\n  \
    \          val result = List(min, index)\n            if (evens.size == 1) result\n\
    \            else result :+ pluck(arr.filterNot(x => x == min))\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpovado2ej.scala:36:33\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.size\
    \ == \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                                 Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpovado2ej.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\
    \ :+ pluck(arr.filterNot(x => x == min))\n\e[31m\e[31m   |\e[0m              \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \           Found:    List[Matchable]\n\e[31m   |\e[0m                 Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        if (evens.isEmpty) {\n            List[Long]()\n        } else {\n  \
    \          List[Long](smallest, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk7x106ib.scala:41)\n\tat Problem.main(tmpk7x106ib.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        if (evens.isEmpty) List()\n        else List(smalest_value,\
    \ smalest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplmolq7gg.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = if (index == -1) List[Long]() else List(even, index)\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxvl6slf.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = smalest_index match {\n            case x if\
    \ x < arr.length => x\n            case _ => arr.length\n        }\n        val\
    \ smalest_even_value = smalest_even match {\n            case x if x < arr.length\
    \ => x\n            case _ => arr.length\n        }\n        val smalest_even_index\
    \ = smalest_index match {\n            case x if x < arr.length => x\n       \
    \     case _ => arr.length\n        }\n        val smalest_even_value = smalest_even\
    \ match {\n            case x if x < arr.length => x\n            case _ => arr.length\n\
    \        }\n        val smalest_even_index = smalest_index match {\n         \
    \   case x if x < arr.length => x\n            case _ => arr.length\n        }\n\
    \        val smalest_even_value = smalest_even match {\n            case x if\
    \ x < arr.length => x\n            case _ => arr.length\n        }\n        val\
    \ smalest_even_index = smalest_index match {\n            case x if x < arr.length\
    \ => x\n            case _ => arr.length\n        }\n        val smalest_even_value\
    \ = smalest_even match {\n            case x if x < arr.length => x\n        \
    \    case _ => arr.length\n        }\n        val smalest_even_index = smalest_index\
    \ match {\n            case x if x < arr.length => x\n            case _ => arr.length\n\
    \        }\n        val smalest_even_value = smalest_even match {\n          \
    \  case x if x < arr.length => x\n            case _ => arr.length\n        }\n\
    \        val smalest_even_index = smalest_index match {\n            case x if\
    \ x < arr.length => x\n            case _ => arr.length\n        }\n        val\
    \ smalest_even_value = smalest_even match {\n            case x if x < arr.length\
    \ => x\n            case _ => arr.length\n        }\n        val smalest_even_index\
    \ = smalest_index match {\n            case x if x < arr.length => x\n       \
    \     case _ => arr.length\n        }\n        val smalest_even_value = smalest_even\
    \ match {\n            case x if x < arr.length => x\n            case _ => arr.length\n\
    \        }\n        val smalest_even_index = smalest_index match {\n         \
    \   case x if x < arr.length => x\n            case _ => arr.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxcqnbosq.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpxcqnbosq.scala:106:0 ---------------------------\e[0m\e[0m\n\e[31m106\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxcqnbosq.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_index \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m43 |\e[0m         \
    \   \e[33mcase\e[0m x \e[33mif\e[0m x < arr.length => x\n\e[31m44 |\e[0m     \
    \       \e[33mcase\e[0m _ => arr.length\n\e[31m45 |\e[0m        }\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpxcqnbosq.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m47 |\e[0m         \
    \   \e[33mcase\e[0m x \e[33mif\e[0m x < arr.length => x\n\e[31m48 |\e[0m     \
    \       \e[33mcase\e[0m _ => arr.length\n\e[31m49 |\e[0m        }\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpxcqnbosq.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_index \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m51 |\e[0m         \
    \   \e[33mcase\e[0m x \e"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        if (evens.isEmpty) List()\n        else {\n   \
    \         val smalest_value = evens.head\n            val smalest_index = evens.indexOf(0)\n\
    \            val index = evens.indexOf(smalest_value)\n            if (index ==\
    \ -1) List()\n            else {\n                val smalest_even = evens(index)\n\
    \                val smalest_even_index = index\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val sm\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpifp__dmk.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpifp__dmk.scala:79:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmpifp__dmk.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mAny\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[Any].\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpifp__dmk.scala:42:20 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m                \e[33mval\e[0m \e[36msmalest_odd_index\e[0m = evens.lastIndexOf(smalest_value)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_odd_index is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_odd_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpifp__dmk.scala:43:20 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                \e[33mval\e[0m \e[36msmalest_odd_value\e\
    [0m = evens(smalest_odd_index)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_odd_value is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_odd_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpifp_"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x == smalest_value)\n        if (smalest_evens.isEmpty) Nil\n        else smalest_evens.minIndex.map(x\
    \ => arr(x))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6gjg2ro3.scala:35:27 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m smalest_evens.minIndex.map(x\
    \ => arr(x))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             value minIndex is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = arr.indexOf(smallest)\n\
    \        val result = if (evens.isEmpty) Nil else List(smallest, index)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpibcnw784.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted =\
    \ evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evens\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8xqjoni6.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mevensSorte"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedSortedWithIndex = evensSorted.zipWithIndex.toList\n\
    \        val smalest_value = evensSortedSortedWithIndex.head._2\n        val smalest_index\
    \ = evensSortedSortedWithIndex.head._1\n        val smalest_even = evensSortedSortedWithIndex.filter(x\
    \ => x._2 == smalest_value).head._1\n        val smalest_even_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 == smalest_value).head._2\n        val smalest_odd_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._1\n        val smalest_odd_value = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._2\n        val smalest_odd_even_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._3\n        val smalest_odd_odd_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._4\n        val smalest_odd_odd_value = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._5\n        val smalest_odd_odd_even_index =\
    \ evensSortedSortedWithIndex.filter(x => x._2 != smalest_value).head._6\n    \
    \    val smalest_odd_odd_odd_index = evensSortedSortedWithIndex.filter(x => x._2\
    \ != smalest_value).head._7\n        val smalest_odd_odd_odd_value = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._8\n        val smalest_odd_odd_odd_even_index\
    \ = evensSortedSortedWithIndex.filter(x => x._2 != smalest_value).head._9\n  \
    \      val smalest_odd_odd_odd_odd_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._10\n        val smalest_odd_odd_odd_odd_value\
    \ = evensSortedSortedWithIndex.filter(x => x._2 != \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8q7ggjiu.scala:47:90 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36msmalest_odd_odd_odd_odd_value\e\
    [0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m => x._2 != \n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:39:104 -----------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_odd_even_index\e\
    [0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m => x._2 != smalest_value).head._3\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value _3 is not a member of (Long, Int) - did you mean (Long,\
    \ Int)._1?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:40:103\
    \ -----------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_odd_odd_index\e[0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m\
    \ => x._2 != smalest_value).head._4\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value _4 is not a member of (Long, Int) - did you mean (Long,\
    \ Int)._1?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:41:103\
    \ -----------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_odd_odd_value\e[0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m\
    \ => x._2 != smalest_value).head._5\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value _5 is not a member of (Long, Int) - did you mean (Long,\
    \ Int)._1?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:42:108\
    \ -----------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36msma"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        if (evens.isEmpty) List()\n        else if (smalest_index\
    \ == 0) List(smalest_value)\n        else List(smalest_value, smalest_index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9perwq2.scala:38)\n\tat Problem.main(tmpn9perwq2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(_ != even).sortBy(x => x).takeWhile(x => x <\
    \ even).take(index).toList\n        if (result.isEmpty) result else result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl5zo01l4.scala:37)\n\tat Problem.main(tmpl5zo01l4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = if (index == -1) List[Long]() else List(even, index)\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyrkf3_ta.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n1 error found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (evens.isEmpty) result\n\
    \        else (List(even, index), result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw_zy4aru.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m (List(even,\
    \ index), result)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    \e[1m\e[31m(\e[0mList[\e[1m\e[31mAnyVal\e\
    [0m\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0mLong]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = evens.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (evens.size ==\
    \ 1) result\n            else result ::: pluck(arr.filter(_ != smallest))\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphf122n1m.scala:36:33\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.size\
    \ == \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                                 Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphf122n1m.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\
    \ ::: pluck(arr.filter(_ != smallest))\n\e[31m\e[31m   |\e[0m                \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smalest_value = evensSorted.head\n        val smalest_index = evensSorted.indexOf(0)\n\
    \        val result = evensSorted.takeWhile(x => x != smalest_value).takeWhile(x\
    \ => x != smalest_index).map(x => smalest_value)\n        if (result.isEmpty)\
    \ result\n        else result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3nlh55jp.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith(_ <\
    \ _)\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedIndex = evenSmallestValueListSorted.indexOf(0)\n\
    \        val evenSmallestValueListSortedValue = evenSmallestValueListSorted\n\
    \        val evenSmallestValueListSortedIndexList = evenSmallestValueListSortedIndex.toList\n\
    \        val evenSmallestValueListSortedValueList = evenSmallestValueListSortedValue.toList\n\
    \        val evenSmallestValueListSortedIndexListSorted = evenSmallestValueListSortedIndexListSorted.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedIndexListSortedValue = evenSmallestValueListSortedIndexListSortedValue.toList\n\
    \        val evenSmallestValueListSortedIndexListSortedValueList = evenSmallestValueListSortedIndexListSortedValue.toList\n\
    \        val evenSmallestValueListSortedIndexListSortedValueListSorted = evenSmallestValueListSortedIndexListSortedValueListSorted.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedIndexListSortedValueListSortedValue\
    \ = evenSmallestValueListSortedIndexListSortedValueListSortedValue.toList\n  \
    \      val evenSmallestValueListSortedIndexListSortedValueListSortedValueListSorted\
    \ = evenSmallestValueListSortedIndexListSortedValueListSortedValueListSorted.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedIndexListSortedValueListSortedValueListSortedValue\
    \ = evenSmallestValueListSortedIndexListSortedValueListSortedValueListSortedValueListSorted.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedIndexListSortedValueListSortedValueListSortedValueListSorted\
    \ = evenSmallestValueListSortedIndexListSortedValueListSortedValueListSortedValueList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp16ywjrow.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp16ywjrow.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp16ywjrow.scala:43:57 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedIndexListSorted\e\
    [0m = evenSmallestValueListSortedIndexListSorted.sortWith(_ < _)\n\e[31m\e[31m\
    \   |\e[0m                                                         ^\e[0m\n\e\
    [31m   |\e[0m   Recursive \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedIndexListSorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp16ywjrow.scala:44:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestValueListSortedIndexListSortedValue\e[0m = evenSmallestValueListSortedIndexListSortedValue.toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedIndexListSortedValue\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp16ywjrow.scala:46:72\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestValueListSortedIndexListSortedValueListSorted\e[0m = evenSmallestValueListSortedIndexListSortedValueListSorted.sortWith(_\
    \ < _)"
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n     \
    \   val evensSorted = evens.sortWith((x, y) => x.compare(y))\n        val evensSortedSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val evensSortedSortedWithIndexSortedWithValue\
    \ = evensSortedSortedWithIndex.sortWith((x, y) => x._2 < y._2)\n        val evensSortedSortedWithIndexSortedWithValueSortedWithIndex\
    \ = evensSortedSortedWithIndexSortedWithValue.sortWith((x, y) => x._1 < y._1)\n\
    \        val evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithValue\
    \ = evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndex.sortWith((x,\
    \ y) => x._2 < y._2)\n        val evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithValue\
    \ = evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithValue.sortWith((x,\
    \ y) => x._1 < y._1)\n        val evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue\
    \ = evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue.sortWith((x,\
    \ y) => x._2 < y._1)\n        val evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue\
    \ = evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue.sortWith((x,\
    \ y) => x._1 < y._1)\n        val evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue\
    \ = evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue.sortWith((x,\
    \ y) => x._2 < y._1)\n        val evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue\
    \ = evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithValue.sortWith((x,\
    \ y\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxnxmcjd9.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxnxmcjd9.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensSorted\e[0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpxnxmcjd9.scala:31:60 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m            \
    \                                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                Found:    Int\n\e[31m   |\e[0m\
    \                                                   Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxnxmcjd9.scala:39:86 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithValue\e\
    [0m = evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndex.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x._2 < y._2)\n\e[31m\e[31m   |\e[0m             \
    \                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evensSortedSortedWithIndexSortedWithValueSortedWithIndexSortedWithIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxnxmcjd9.scala:40:101\
    \ --------------------------\e[0m\e[0m\n\e[31m40 "
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List(even, index)\n        else result.sortWith((a, b) => a.compareTo(b) < 0).head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptujivnxj.scala:35:59\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortWith((a,\
    \ b) => a.compareTo(b) < \e[31m0\e[0m).head\n\e[31m\e[31m   |\e[0m           \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \           Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(_ ==\
    \ smalest_value)\n        if (smalest_evens.isEmpty) List(smalest_value, smalest_index)\n\
    \        else smalest_evens.minIndex.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwemzzeis.scala:35:27 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m smalest_evens.minIndex.toLong\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \             value minIndex is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660009580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ > y.toLong)\n        val evensSortedIndex = evensSorted.zipWithIndex.toList\n\
    \        val smalestValue = evensSortedIndex.find(x => x._1.toLong == evensSortedIndex.minBy(x\
    \ => x._1.toLong)._1.toLong).get._1\n        val smalestIndex = evensSortedIndex.find(x\
    \ => x._1.toLong == evensSortedIndex.minBy(x => x._1.toLong)._1.toLong).get._2\n\
    \        val smalestValueAndIndex = smalestValue -> smalestIndex\n        val\
    \ smalestValueAndIndexList = smalestValueAndIndex.map(x => x._1 -> x._2)\n   \
    \     val smalestValueAndIndexListSorted = smalestValueAndIndexList.sortWith((x,\
    \ y) => x._1 > y._1)\n        val smalestValueAndIndexListSortedWithIndex = smalestValueAndIndexListSorted.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndex.sortWith((x, y) => x._1 > y._1)\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndex = smalestValueAndIndexListSortedWithIndexSortedWithIndex.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSorted.sortWith((x,\
    \ y) => x._1 > y._1)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndex.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortWith((x,\
    \ y) => x._1 > y._1)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map(x\
    \ => x._1 -> x.\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp39w5xqub.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmp39w5xqub.scala:36:64 -----------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalestValueAndIndexList\e[0m = smalestValueAndIndex.map(\e\
    [36mx\e[0m => x._1 -> x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \          Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m          \
    \                I could not infer the type of the parameter x.\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp39w5xqub.scala:37:70 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalestValueAndIndexListSorted\e\
    [0m = smalestValueAndIndexList.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x._1 >\
    \ y._1)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value sortWith is not a member of (Nothing,\
    \ Nothing)\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp39w5xqub.scala:40:69 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalestValueAndIndexListSortedWithIndexSortedWithIndex\e\
    [0m = smalestValueAndIndexListSortedWithIndexSortedWithIndex.map(\e[36mx\e[0m\
    \ => x._1 -> x._2)\n\e[31m\e[31m   |\e[0m                                    \
    \                                 ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35msmalestValueAndIndexListSortedWithIndexSortedWithIndex\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp39w5xqub.scala:41:75\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalestValueAndIndexListSortedWithIndexSortedWithIndexSorted\e[0m = smalestValueAndIndexListSortedWithIndexSortedWithIndexSorted.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x._1 > y._1)\n\e[31m\e[31m   |\e[0m             \
    \           "
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smalestEven = evensSorted.head\n        val smalestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smalestEvenValue = smalestEven.toLong\n\
    \        val smalestEvenIndex = smalestEvenIndex.toLong\n        val smalestEvenValue\
    \ = smalestEvenValue.toLong\n        val smalestEvenIndex = smalestEvenIndex.toLong\n\
    \        val smalestEvenValue = smalestEvenValue.toLong\n        val smalestEvenIndex\
    \ = smalestEvenIndex.toLong\n        val smalestEvenValue = smalestEvenValue.toLong\n\
    \        val smalestEvenIndex = smalestEvenIndex.toLong\n        val smalestEvenValue\
    \ = smalestEvenValue.toLong\n        val smalestEvenIndex = smalestEvenIndex.toLong\n\
    \        val smalestEvenValue = smalestEvenValue.toLong\n        val smalestEvenIndex\
    \ = smalestEvenIndex.toLong\n        val smalestEvenValue = smalestEvenValue.toLong\n\
    \        val smalestEvenIndex = smalestEvenIndex.toLong\n        val smalestEvenValue\
    \ = smalestEvenValue.toLong\n        val smalestEvenIndex = smalestEvenIndex.toLong\n\
    \        val smalestEvenValue = smalestEvenValue.toLong\n        val smalestEvenIndex\
    \ = smalestEvenIndex.toLong\n        val smalestEvenValue = smalestEvenValue.toLong\n\
    \        val smalestEvenIndex = smalestEvenIndex.toLong\n        val smalestEvenValue\
    \ = smalestEvenValue.toLong\n        val smalestEvenIndex = smalestEvenIndex.toLong\n\
    \        val smalestEvenValue = smalestEvenValue.toLong\n        val smalestEvenIndex\
    \ = smalestEvenIndex.toLong\n        val smalestEvenValue = smalestEvenValue.toLong\n\
    \        val smalestEvenIndex = smalestEvenIndex.toLong\n        val smalestEvenValue\
    \ = smalestEvenValue.toLong\n        val smalestEvenIndex = smalestEvenIndex.toLong\n\
    \        val smalestEvenValue = smalestEvenValue.toLong\n        val smalestEvenIndex\
    \ = smalestEvenIndex.toLong\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2bmqbt6p.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ smalestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2bmqbt6p.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValue\e[0m =\
    \ smalestEvenValue.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2bmqbt6p.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ smalestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2bmqbt6p.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValue\e[0m =\
    \ smalestEvenValue.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2bmqbt6p.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e["
  stdout: ''
  timestamp: 1660009581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x.toLong)\n        val even = evens.head\n\
    \        val index = evens.indexOf(even)\n        val result = arr.filter(x =>\
    \ x % 2 == 0).sortBy(x => x).map(x => x.toLong).takeWhile(x => x != even).take(index).toList\n\
    \        if (result.isEmpty) Nil\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpain7b9rg.scala:38)\n\tat Problem.main(tmpain7b9rg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortBy(x => x)\n    \
    \    val evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(evenSmallest)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestIndexListSorted = evenSmallestIndexList.sortBy(x\
    \ => x)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortBy(x\
    \ => x)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortBy(x\
    \ => x)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortBy(x\
    \ => x)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortBy(x\
    \ => x)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortBy(x\
    \ => x)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortBy(x\
    \ => x)\n        val evenSmallestIndexListSorted = evenSmallest\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp03k8_5w1.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp03k8_5w1.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp03k8_5w1.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp03k8_5w1.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSort"
  stdout: ''
  timestamp: 1660009582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = List(even, index)\n        if (arr.isEmpty) result\n   \
    \     else pluck(arr.drop(index))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphnlsnbj0.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        if (evens.isEmpty) {\n            List[Long]()\n        } else if (index\
    \ == 0) {\n            List[Long](even)\n        } else {\n            List[Long](even,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6r_i0gw_.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven.toLong\n\
    \        val smallestEvenIndexList = List(smallestEvenIndex, smallestEvenIndex\
    \ + 1)\n        val smallestEvenValueList = List(smallestEvenValue, smallestEvenValue\
    \ + 1)\n        if (evensSorted.isEmpty) {\n            List[Long]()\n       \
    \ } else {\n            val smallestEvenIndexPair = smallestEvenIndexList.zip(smallestEvenValueList)\n\
    \            smallestEvenIndexPair.filter(_._1 == smallestEvenValue).map(_._2)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1h5nk79_.scala:45)\n\tat Problem.main(tmp1h5nk79_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_).reverse\n        if(evens.isEmpty) Nil\n        else {\n\
    \            val smalest_value = evens.head\n            val smalest_index = evens.indexWhere(_\
    \ == smalest_value)\n            val evens_without_smalest_value = evens.filter(_\
    \ != smalest_value)\n            val smalest_value_and_index = smalest_value ->\
    \ smalest_index\n            evens_without_smalest_value.map(smalest_value_and_index)\
    \ match {\n                case Nil => Nil\n                case x => x\n    \
    \        }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpvsiqej37.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmpvsiqej37.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val smallest = evens.head\n        val index =\
    \ evens.indexOf(0)\n        val result = (smallest :: arr.filter(_ == smallest).sortBy(_).take(index\
    \ - 1))\n        if (result.isEmpty) result else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpx4fvsiug.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmpx4fvsiug.scala:33:67 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (smallest\
    \ :: arr.filter(_ == smallest).sortBy(_).take(index - \e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \   ^\e[0m\n\e[31m   |\e[0mMissing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mI could not infer the type of the parameter _$4 of expanded function:\n\e[31m\
    \   |\e[0m_$4 => \n\e[31m   |\e[0m  smallest :: arr.filter(_$3 => _$3 == smallest).sortBy(_$4).take(index\
    \ - 1).\n\e[31m\e[31m-- Error: /tmp/tmpx4fvsiug.scala:33:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (smallest\
    \ :: arr.filter(_ == smallest).sortBy(_).take(index - \e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \     ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mShort\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest\n     \
    \   val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3vpb151p.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3vpb151p.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3vpb151p.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3vpb151p.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all b"
  stdout: ''
  timestamp: 1660009583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgptnetsz.scala:39)\n\tat Problem.main(tmpgptnetsz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmpe6rdojq7.scala:31)\n\tat Problem$.main(tmpe6rdojq7.scala:40)\n\
    \tat Problem.main(tmpe6rdojq7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortBy(x => x)\n    \
    \    val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(smallestEven)\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val result = List(smallestEvenValue, smallestEvenIndex)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2istf7ub.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2istf7ub.scala:37:15 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mreturn\e[0m result\n\e[31m\e[31m   |\e\
    [0m               ^^^^^^\e[0m\n\e[31m   |\e[0m               Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmpe6rdojq7.scala:31)\n\tat Problem$.main(tmpe6rdojq7.scala:40)\n\
    \tat Problem.main(tmpe6rdojq7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     List[Long]()\n        } else {\n            evens.take(smalest_index).reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwabn3rt4.scala:40)\n\tat Problem.main(tmpwabn3rt4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n      \
    \      val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val smalest_even = evens(smalest_index)\n            val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n            if (smalest_even_index == smalest_index)\
    \ List(smalest_value)\n            else List(smalest_value, smalest_even_index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcqaqsnz4.scala:42)\n\tat Problem.main(tmpcqaqsnz4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index > 0) {\n         \
    \   evens.take(smalest_index).map(x => (x, smalest_index)).toList\n        } else\
    \ {\n            evens.map(x => (x, 0)).filter(_._1 == smalest_value).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7v2yd8w4.scala:34:67\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            evens.take(smalest_index).map(\e\
    [36mx\e[0m => (x, smalest_index)).toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7v2yd8w4.scala:36:65 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            evens.map(\e[36mx\e[0m => (x, \e[31m0\e[0m)).filter(_._1 ==\
    \ smalest_value).toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ > y.toLong)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven.toLong\n\
    \        val result = arr.filter(_ != smallestEvenValue)\n        if (result.isEmpty)\
    \ Nil\n        else result.filter(_ == smallestEvenValue).map(x => (smallestEvenValue,\
    \ x))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp785lg0t5.scala:37:60\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33melse\e[0m result.filter(_\
    \ == smallestEvenValue).map(x => (smallestEvenValue, x))\n\e[31m\e[31m   |\e[0m\
    \                                                            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (Long, Long)\n\e[31m   |\e[0m                                            \
    \      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (arr.contains(smallest))\
    \ result :+ smallest\n            else result\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbpg8_1z.scala:36:40\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (arr.contains(smallest))\
    \ result :+ smallest\n\e[31m\e[31m   |\e[0m                                  \
    \      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \          Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m           \
    \                             Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbpg8_1z.scala:37:17 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009597
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ == even).take(index).toList\n        if (result.isEmpty)\
    \ Nil\n        else result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4o0pgsra.scala:38)\n\tat Problem.main(tmp4o0pgsra.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortBy(x => x)\n    \
    \    val evensSorted = evensSorted.takeWhile(x => x < arr.last)\n        val evensSorted\
    \ = evensSorted.reverse\n        val evensSorted = evensSorted.takeWhile(x =>\
    \ x < arr.last)\n        val evensSorted = evensSorted.reverse\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.last)\n        val evensSorted = evensSorted.reverse\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.last)\n        val\
    \ evensSorted = evensSorted.reverse\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.last)\n        val evensSorted = evensSorted.reverse\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.last)\n        val evensSorted\
    \ = evensSorted.reverse\n        val evensSorted = evensSorted.takeWhile(x =>\
    \ x < arr.last)\n        val evensSorted = evensSorted.reverse\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.last)\n        val evensSorted = evensSorted.reverse\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.last)\n        val\
    \ evensSorted = evensSorted.reverse\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.last)\n        val evensSorted = evensSorted.reverse\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.last)\n        val evensSorted\
    \ = evensSorted.reverse\n        val evensSorted = evensSorted.takeWhile(x =>\
    \ x < arr.last)\n        val evensSorted = evensSorted.reverse\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.last)\n        val evensSorted = evensSorted.reverse\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.last)\n        val\
    \ evensSorted = evensSorted.reverse\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.last)\n        val evensSorted = evensSorted.reverse\n        val\
    \ even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprb0dgks1.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprb0dgks1.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e[36mx\e[0m => x < arr.last)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprb0dgks1.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprb0dgks1.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.last)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprb0dgks1.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group"
  stdout: ''
  timestamp: 1660009602
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n\
    \        val smalest_index = evens.indexWhere(x => x == smalest_value)\n     \
    \   val result = evens.takeWhile(x => x != smalest_value).takeWhile(x => x !=\
    \ smalest_index).reverse\n        if (result.isEmpty) List(smalest_value, smalest_index)\n\
    \        else result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp61o9ig0.scala:38)\n\tat Problem.main(tmpp61o9ig0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val minEven = evens.min\n            val minIndex = evens.indexOf(minEven)\n\
    \            val minEvenIndex = minIndex\n            val minEvenValue = minEven\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp97agmo0l.scala:82:15 ---------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp97agmo0l.scala:96:0 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp97agmo0l.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminEvenValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp97agmo0l.scala:39:16 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp97agmo0l.scala:40:16 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp97agmo0l.scala:41:16 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEv"
  stdout: ''
  timestamp: 1660009605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) Nil\n        else {\n    \
    \        val smallestEven = evens.min\n            val index = arr.indexOf(smallestEven)\n\
    \            val result = List(smallestEven, index)\n            if (arr.contains(smallestEven))\
    \ result ::: arr.filterNot(x => x == smallestEven)\n            else result\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf2yn5wq4.scala:36:44\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (arr.contains(smallestEven))\
    \ result ::: arr.filterNot(\e[36mx\e[0m => x == smallestEven)\n\e[31m\e[31m  \
    \ |\e[0m                                            ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                       Found:    (result : List[AnyVal])\n\e\
    [31m   |\e[0m                                       Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf2yn5wq4.scala:37:17 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) List(smalest_value)\n\
    \        else evens.take(smalest_index).map(x => (x, smalest_index)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy_m7khzw.scala:34:68\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33melse\e[0m evens.take(smalest_index).map(x\
    \ => (x, smalest_index)).toList\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \          Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val smallest = evens.minBy(_ % 2)\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) Nil else List(smallest, index)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6hb9t40b.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) return evens\n\
    \        val smalest_even = evens(smalest_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ evens\n        val smalest_even_index = evens.indexOf(smalest_even)\n      \
    \  if (smalest_even_index == -1) return evens\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppqbiw2lf.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppqbiw2lf.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppqbiw2lf.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppqbiw2lf.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppqbiw2lf.scala:45:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List(arr.head.toLong)\n\
    \        else {\n            val smalest_value = evens.head\n            val smalest_index\
    \ = evens.indexWhere(x => x == smalest_value)\n            val smalest_even =\
    \ evens(smalest_index)\n            val smalest_even_index = evens.indexWhere(x\
    \ => x == smalest_even)\n            val smalest_even_value = evens(smalest_even_index)\n\
    \            val smalest_even_index_plus_one = smalest_even_index + 1\n      \
    \      val smalest_even_value_plus_one = evens(smalest_even_index_plus_one)\n\
    \            val smalest_even_value_plus_two = evens(smalest_even_index_plus_two)\n\
    \            val smalest_even_value_plus_three = evens(smalest_even_index_plus_three)\n\
    \            val smalest_even_value_plus_four = evens(smalest_even_index_plus_four)\n\
    \            val smalest_even_value_plus_five = evens(smalest_even_index_plus_five)\n\
    \            val smalest_even_value_plus_six = evens(smalest_even_index_plus_six)\n\
    \            val smalest_even_value_plus_seven = evens(smalest_even_index_plus_seven)\n\
    \            val smalest_even_value_plus_eight = evens(smalest_even_index_plus_eight)\n\
    \            val smalest_even_value_plus_nine = evens(smalest_even_index_plus_nine)\n\
    \            val smalest_even_value_plus_ten = evens(smalest_even_index_plus_ten)\n\
    \            val smalest_even_value_plus_eleven = evens(smalest_even_index_plus_eleven)\n\
    \            val smalest_even_value_plus_twelve = evens(smalest_even_index_plus_twelve)\n\
    \            val smalest_even_value_plus_thirteen = evens(smalest_even_index_plus_thirteen)\n\
    \            val smalest_even_value_plus_fourteen = evens(smalest_even_index_plus_fourteen)\n\
    \            val smalest_even_value_plus_fifteen = evens(smalest_even_index_plus_fifteen)\n\
    \            val smalest_even_value_plus_sixteen = evens(smalest_even_index_plus_sixteen)\n\
    \            val smalest_even_value_plus_seventeen = evens(smalest_even_index_plus_seventeen)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpogog3vrk.scala:70:0 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpogog3vrk.scala:40:52\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_plus_two\e[0m = evens(smalest_even_index_plus_two)\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: smalest_even_index_plus_two\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpogog3vrk.scala:41:54\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_plus_three\e[0m = evens(smalest_even_index_plus_three)\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: smalest_even_index_plus_three\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpogog3vrk.scala:42:53\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_plus_four\e[0m = evens(smalest_even_index_plus_four)\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: smalest_even_index_plus_four\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpogog3vrk.scala:43:53\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_plus_five\e[0m = evens(smalest_even_index_plus_five)\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: smalest_even_index_plus"
  stdout: ''
  timestamp: 1660009606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List()\n \
    \       else {\n            val smalest_value = evens.head\n            val smalest_index\
    \ = evens.indexOf(0)\n            val smalest_even = evens.filter(x => x % 2 ==\
    \ 0).min\n            val smalest_even_index = evens.indexOf(smalest_even)\n \
    \           val smalest_even_value = evens(smalest_even_index)\n            val\
    \ smalest_even_index_list = evens.indexOf(smalest_even_index).toList\n       \
    \     val smalest_even_index_list_sorted = smalest_even_index_list.sortBy(x =>\
    \ x)\n            val smalest_even_index_list_sorted_reversed = smalest_even_index_list_sorted.reverse\n\
    \            val smalest_even_index_list_sorted_reversed_sorted = smalest_even_index_list_sorted_reversed.sortBy(x\
    \ => x)\n            val smalest_even_index_list_sorted_reversed_sorted_reversed\
    \ = smalest_even_index_list_sorted_reversed_sorted.reverse\n            val smalest_even_index_list_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_even_index_list_sorted_reversed_sorted_reversed.sortBy(x => x)\n \
    \           val smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_even_index_list_sorted_reversed_sorted_reversed_sorted.reverse\n \
    \           val smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => x)\n            val smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \            val smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => x)\n            val smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \            val smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_even_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(x\
    \ => x)\n            val smalest_even_index_list_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgelubrsx.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgelubrsx.scala:64:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpgelubrsx.scala:38:76 ------------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list\e[0m =\
    \ evens.indexOf(smalest_even_index).toList\n\e[31m\e[31m   |\e[0m            \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m           value toList is not a member of Int - did you mean Int.toInt?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgelubrsx.scala:63:1 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpgelubrsx.scala:52:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009606
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexWhere(_\
    \ == even)\n        arr.take(index).filter(_ % 2 == 0).takeWhile(_ < even).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4mn7o0z5.scala:36)\n\tat Problem.main(tmp4mn7o0z5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = if (index == -1) List[Long]() else List(even, index)\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmgbiqafa.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallest = evens.min\n        val index =\
    \ evens.indexOf(smallest)\n        val result = arr.filter(_ == smallest).toList\n\
    \        if (result.isEmpty) result\n        else (smallest, index)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpes7gji1j.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m (smallest,\
    \ index)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m             Found:    (Long, Int)\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        if (evens.isEmpty) {\n            List[Long]()\n        } else {\n  \
    \          List[Long](even, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfrmoh9l5.scala:41)\n\tat Problem.main(tmpfrmoh9l5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallest = evens.min\n        val index =\
    \ evens.indexOf(smallest)\n        val result = List(smallest, index)\n      \
    \  if (evens.isEmpty) result\n        else result.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp90rd2prx.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp90rd2prx.scala:35:41 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n\e[31m\e[31m   |\e[0m                                       ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of AnyVal, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n\
    \        val smalest_index = evens.indexOf(0)\n        val result = evens.takeWhile(x\
    \ => x != smalest_value).takeWhile(x => x != smalest_index).reverse\n        if\
    \ (result.isEmpty) Nil\n        else List(smalest_value, smalest_index) :: result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4z90y55.scala:35:17\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m List(smalest_value,\
    \ smalest_index) :: result\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[AnyVal]\n\e[31m   |\e[0m     \
    \        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) List[Long]() else List(smallest, index)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcsgp59pq.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val result = evens.takeWhile(x => x\
    \ != smalest_value).takeWhile(x => x != smalest_index).reverse\n        if (result.isEmpty)\
    \ Nil\n        else result.map(x => (x, evens.indexOf(x)))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnpodaaz9.scala:35:29\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.map(x\
    \ => (x, evens.indexOf(x)))\n\e[31m\e[31m   |\e[0m                           \
    \  ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:\
    \    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e\
    [1m\e[31m)\e[0m\n\e[31m   |\e[0m                             Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2)\n        if (evens.isEmpty) List(arr.head.toLong)\n\
    \        else evens.take(1).map(_ % 2 == 0).foldLeft(arr.head.toLong)((x, y) =>\
    \ if (x == y) x else y)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvqnpj2wp.scala:32:83 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e[31m1\e[0m).map(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).foldLeft(arr.head.toLong)((x, y) => \e[33mif\e\
    [0m (x == y) x \e[33melse\e[0m y)\n\e[31m\e[31m   |\e[0m                     \
    \                                                              ^^^^^^\e[0m\n\e\
    [31m   |\e[0m       Values of types Long and Boolean cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvqnpj2wp.scala:32:98\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e\
    [31m1\e[0m).map(_ % \e[31m2\e[0m == \e[31m0\e[0m).foldLeft(arr.head.toLong)((x,\
    \ y) => \e[33mif\e[0m (x == y) x \e[33melse\e[0m y)\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \               Found:    (y : Boolean)\n\e[31m   |\e[0m                     \
    \                            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009606
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) Nil\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7_2abot3.scala:39)\n\tat Problem.main(tmp7_2abot3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (arr.contains(smallest))\
    \ result :+ smallest\n            else result\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbpg8_1z.scala:36:40\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (arr.contains(smallest))\
    \ result :+ smallest\n\e[31m\e[31m   |\e[0m                                  \
    \      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \          Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m           \
    \                             Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbpg8_1z.scala:37:17 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009597
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) List(smalest_value)\n\
    \        else evens.take(smalest_index).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdgt8z7h.scala:37)\n\tat Problem.main(tmpgdgt8z7h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).take(index).sorted\n        result\
    \ match {\n            case Nil => Nil\n            case x :: xs => x :: pluck(xs)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmpdajo39rs.scala:31)\n\tat Problem$.pluck(tmpdajo39rs.scala:36)\n\
    \tat Problem$.main(tmpdajo39rs.scala:40)\n\tat Problem.main(tmpdajo39rs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x % 2 == 0)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        if (smalest_evens_index > smalest_index) {\n            smalest_evens.take(smalest_evens_index)\n\
    \        } else {\n            smalest_evens\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbc8a29ma.scala:42)\n\tat Problem.main(tmpbc8a29ma.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List()\n \
    \       else {\n            val smalest_value = evens.head\n            val smalest_index\
    \ = evens.indexWhere(x => x == smalest_value)\n            val smalest_even =\
    \ evens(smalest_index)\n            val smalest_even_index = evens.indexWhere(x\
    \ => x == smalest_even && x > smalest_value)\n            if (smalest_even_index\
    \ == evens.size - 1) List(smalest_even)\n            else List(smalest_even, smalest_even_index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphkaqwmp1.scala:42)\n\tat Problem.main(tmphkaqwmp1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        if (evens.isEmpty) List()\n        else evens.take(1).zipWithIndex.filter(_._2\
    \ % 2 == 0).map(_._1).headOption.getOrElse(List())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnh5hev0m.scala:32:92\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e\
    [31m1\e[0m).zipWithIndex.filter(_._2 % \e[31m2\e[0m == \e[31m0\e[0m).map(_._1).headOption.getOrElse(List())\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Matchable\n\e[31m   |\e[0m        \
    \     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(0)\n        if (evens.isEmpty) List()\n    \
    \    else List(smallest, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1j0u51_k.scala:37)\n\tat Problem.main(tmp1j0u51_k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009628
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        if (evens.isEmpty) {\n            List[Long]()\n        } else if (index\
    \ == evens.indexOf(0)) {\n            List[Long](even)\n        } else {\n   \
    \         List[Long](even, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.pluck(tmpejqvutu_.scala:31)\n\
    \tat Problem$.main(tmpejqvutu_.scala:44)\n\tat Problem.main(tmpejqvutu_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortBy(x => x)\n    \
    \    val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val result = evensSorted.takeWhile(x => x != smallestEven).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smallestEvenIndex).takeWhile(x => x != smallestEvenIndex).takeWhile(x\
    \ => x != smalle\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptdax4jch.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptdax4jch.scala:34:1491\
    \ ----------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = evensSorted.takeWhile(\e[36mx\e[0m => x != smallestEven).takeWhile(\e[36mx\e\
    [0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0m => x != smallestEvenIndex).takeWhile(\e[36mx\e[0m => x != smallestEvenIndex).takeWhile(\e\
    [36mx\e[0"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(0)\n        val result = List(smallest, index)\n\
    \        if (evens.isEmpty) result\n        else pluck(arr.filterNot(x => x %\
    \ 2 == 0).sortBy(x => x).reverse)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5393we19.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(_ ==\
    \ smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_index_plus_one = smalest_evens_index + 1 // +1 because\
    \ we want the smallest even value\n        val smalest_evens_index_plus_two =\
    \ smalest_evens_index_plus_one + 1 // +1 because we want the smallest even value\n\
    \        val smalest_evens_index_plus_three = smalest_evens_index_plus_two + 1\
    \ // +1 because we want the smallest even value\n        val smalest_evens_index_plus_four\
    \ = smalest_evens_index_plus_three + 1 // +1 because we want the smallest even\
    \ value\n        val smalest_evens_index_plus_five = smalest_evens_index_plus_four\
    \ + 1 // +1 because we want the smallest even value\n        val smalest_evens_index_plus_six\
    \ = smalest_evens_index_plus_five + 1 // +1 because we want the smallest even\
    \ value\n        val smalest_evens_index_plus_seven = smalest_evens_index_plus_six\
    \ + 1 // +1 because we want the smallest even value\n        val smalest_evens_index_plus_eight\
    \ = smalest_evens_index_plus_seven + 1 // +1 because we want the smallest even\
    \ value\n        val smalest_evens_index_plus_nine = smalest_evens_index_plus_eight\
    \ + 1 // +1 because we want the smallest even value\n        val smalest_evens_index_plus_ten\
    \ = smalest_evens_index_plus_nine + 1 // +1 because we want the smallest even\
    \ value\n        val smalest_evens_index_plus_eleven = smalest_evens_index_plus_ten\
    \ + 1 // +1 because we want the smallest even value\n        val smalest_evens_index_plus_twelve\
    \ = smalest_evens_index_plus_eleven + 1 // +1 because we want the smallest even\
    \ value\n        val smalest_evens_index_plus_thirteen = smalest_evens_index_plus_twelve\
    \ + 1 // +1 because we want the smallest even value\n        val smalest_evens_index_plus_fourteen\
    \ = smalest_evens_index_plus_thirteen + \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7intwtn0.scala:48:83 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index_plus_fourteen\e\
    [0m = smalest_evens_index_plus_thirteen + \n\e[31m\e[31m   |\e[0m            \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7intwtn0.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = arr.take(index).min\n        val smalest_index =\
    \ arr.indexOf(smalest_value)\n        val smalest_evens = arr.take(smalest_index).filter(x\
    \ => x % 2 == 0).toList\n        val smalest_even = smalest_evens.min\n      \
    \  val smalest_even_index = smalest_evens.indexOf(smalest_even)\n        val smalest_evens_index\
    \ = smalest_index\n        val smalest_evens_value = smalest_value\n        val\
    \ smalest_evens_smalest_index = smalest_evens_index\n        val smalest_evens_smalest_value\
    \ = smalest_evens_value\n        val smalest_evens_smalest_evens_index = smalest_evens_smalest_index\n\
    \        val smalest_evens_smalest_evens_value = smalest_evens_smalest_evens_value\n\
    \        val smalest_evens_smalest_evens_smalest_index = smalest_evens_smalest_evens_smalest_index\n\
    \        val smalest_evens_smalest_evens_smalest_value = smalest_evens_smalest_evens_smalest_value\n\
    \        val smalest_evens_smalest_evens_smalest_evens_index = smalest_evens_smalest_evens_smalest_evens_index\n\
    \        val smalest_evens_smalest_evens_smalest_evens_value = smalest_evens_smalest_evens_smalest_evens_value\n\
    \        val smalest_evens_smalest_evens_smalest_evens_smalest_index = smalest_evens_smalest_evens_smalest_evens_smalest_index\n\
    \        val smalest_evens_smalest_evens_smalest_evens_smalest_value = smalest_evens_smalest_evens_smalest_evens_smalest_value\n\
    \        val smalest_evens_smalest_evens_smalest_evens_smalest_evens_index = smalest_evens_smalest_evens_smalest_evens_smalest_evens_index\n\
    \        val smalest_evens_smalest_evens_smalest_evens_smalest_evens_value = smalest_even\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbn7sbpcx.scala:43:48 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_smalest_evens_value\e\
    [0m = smalest_evens_smalest_evens_value\n\e[31m\e[31m   |\e[0m               \
    \                                 ^\e[0m\n\e[31m   |\e[0m            Recursive\
    \ \e[33mvalue\e[0m \e[35msmalest_evens_smalest_evens_value\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbn7sbpcx.scala:44:56\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evens_smalest_evens_smalest_index\e[0m = smalest_evens_smalest_evens_smalest_index\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m    Recursive \e[33mvalue\e[0m \e[35msmalest_evens_smalest_evens_smalest_index\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbn7sbpcx.scala:45:56\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evens_smalest_evens_smalest_value\e[0m = smalest_evens_smalest_evens_smalest_value\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m    Recursive \e[33mvalue\e[0m \e[35msmalest_evens_smalest_evens_smalest_value\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbn7sbpcx.scala:46:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evens_smalest_evens_smalest_evens_index\e[0m = smalest_evens_smalest_evens_smalest_evens_index\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35msmalest_evens_smalest_evens_smalest_evens_index\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbn7sbpcx.s"
  stdout: ''
  timestamp: 1660009624
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n\
    \        val smalest_index = evens.indexOf(0)\n        val result = evens.takeWhile(x\
    \ => x != smalest_value).takeWhile(x => x != smalest_index).reverse\n        if\
    \ (result.isEmpty) Nil\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpip6fjihi.scala:38)\n\tat Problem.main(tmpip6fjihi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedWithIndex = evensSorted.zipWithIndex\n \
    \       val smalest_value = evensSortedWithIndex.minBy(_._1)._2.toLong\n     \
    \   val smalest_index = evensSortedWithIndex.minBy(_._1)._2.toLong\n        val\
    \ smalest_evens = evensSorted.filter(x => x == smalest_value)\n        val smalest_evensSorted\
    \ = smalest_evens.sortWith((x, y) => x.toLong < y.toLong)\n        val smalest_evensSortedWithIndex\
    \ = smalest_evensSorted.zipWithIndex\n        val smalest_evensSortedWithIndexMin\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndex\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndexAndSmallestEven\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndexAndSmallestEvenIndex\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndexAndSmallestEvenIndexAndSmalestEven\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndexAndSmallestEvenIndexAndSmalestEvenIndex\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndexAndSmallestEvenIndexAndSmalestEvenIndexAndSmalestEven\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndexAndSmallestEvenIndexAndSmalestEvenIndexAndSmalestEvenIndex\
    \ = smalest_evensSortedWithIndex.minBy(_._1)._2.toLong\n        val smalest_evensSortedWithIndexMinIndexAndSmallestEvenIndexAndSmalestEvenIndexAndSmalestEven\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnofrgdss.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpnofrgdss.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.map(x => arr.indexOf(x))\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestIndexListSortedHead = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSortedTail = evenSmallestIndexListSorted.tail\n\
    \        val evenSmallestIndexListSortedHeadValue = evenSmallestIndexListSortedHead.toLong\n\
    \        val evenSmallestIndexListSortedTailValue = evenSmallestIndexListSortedTail.toLong\n\
    \        val evenSmallestIndexListSortedHeadIndex = evenSmallestIndexListSortedHead.map(x\
    \ => arr.indexOf(x))\n        val evenSmallestIndexListSortedTailIndex = evenSmallestIndexListSortedTail.map(x\
    \ => arr.indexOf(x))\n        val evenSmallestIndexListSortedHeadIndexSorted =\
    \ evenSmallestIndexListSortedHeadIndex.sortWith((x, y) => x < y)\n        val\
    \ evenSmallestIndexListSortedTailIndexSorted = evenSmallestIndexListSortedTailIndex.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestIndexListSortedHeadIndexSortedHead = evenSmallestIndexListSortedHeadIndexSorted.head\n\
    \        val evenSmallestIndexListSortedTailIndexSortedTail = evenSmallestIndexListSortedTailIndexSorted.tail\n\
    \        val evenSmallestIndexListSortedHeadIndexSortedTailValue = evenSmallestIndexListSortedHeadIndexSortedTail.toLong\n\
    \        val evenSmallestIndexListSortedTailIndexSortedHeadValue = evenSmallestIndexListSortedTailIndexSortedHead.toLong\n\
    \        val evenSmallestIndexListSortedHeadIndexSortedTailIndex = evenSmallestIndexListSortedHeadIndexSortedTail.map(x\
    \ => arr.indexOf(x))\n        val evenSmallestIndexListSortedTailIndexSortedHeadIndex\
    \ = evenSmallestIndexListSortedTailIndexSortedHead.map(x => arr.indexOf(x))\n\
    \        val evenSmallestIndexListSortedHeadIndexSortedTailIndex\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1rcei74t.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1rcei74t.scala:35:54\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexList\e[0m = evenSmallestIndex.map(\e[36mx\e[0m => arr.indexOf(x))\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value map is not a member\
    \ of Int\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1rcei74t.scala:47:66\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexListSortedHeadIndexSortedTailValue\e[0m = evenSmallestIndexListSortedHeadIndexSortedTail.toLong\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \               Not found: evenSmallestIndexListSortedHeadIndexSortedTail\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1rcei74t.scala:48:66\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexListSortedTailIndexSortedHeadValue\e[0m = evenSmallestIndexListSortedTailIndexSortedHead.toLong\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \               Not found: evenSmallestIndexListSortedTailIndexSortedHead\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1rcei74t.scala:49:66\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexListSortedHeadIndexSortedTailIndex\e[0m = evenSmallestIndexListSortedHeadIndexSortedTail.map(\e\
    [36mx\e[0m => arr.indexOf(x))\n\e[31m\e[31m   |\e[0m                         \
    \                                       "
  stdout: ''
  timestamp: 1660009627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortBy(x => x).take(index)\n     \
    \   if (result.isEmpty) Nil\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp342e09_d.scala:38)\n\tat Problem.main(tmp342e09_d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List()\n \
    \       else {\n            val smalest_value = evens.head\n            val smalest_index\
    \ = evens.indexWhere(x => x == smalest_value)\n            val smalest_evens =\
    \ evens.filter(_ == smalest_value)\n            val smalest_evens_index = smalest_evens.indexWhere(x\
    \ => x == smalest_value)\n            val smalest_evens_index_plus_1 = smalest_evens_index\
    \ + 1\n            val smalest_evens_index_plus_2 = smalest_evens_index_plus_1\
    \ + 1\n            val smalest_evens_index_plus_3 = smalest_evens_index_plus_2\
    \ + 1\n            val smalest_evens_index_plus_4 = smalest_evens_index_plus_3\
    \ + 1\n            val smalest_evens_index_plus_5 = smalest_evens_index_plus_4\
    \ + 1\n            val smalest_evens_index_plus_6 = smalest_evens_index_plus_5\
    \ + 1\n            val smalest_evens_index_plus_7 = smalest_evens_index_plus_6\
    \ + 1\n            val smalest_evens_index_plus_8 = smalest_evens_index_plus_7\
    \ + 1\n            val smalest_evens_index_plus_9 = smalest_evens_index_plus_8\
    \ + 1\n            val smalest_evens_index_plus_10 = smalest_evens_index_plus_9\
    \ + 1\n            val smalest_evens_index_plus_11 = smalest_evens_index_plus_10\
    \ + 1\n            val smalest_evens_index_plus_12 = smalest_evens_index_plus_11\
    \ + 1\n            val smalest_evens_index_plus_13 = smalest_evens_index_plus_12\
    \ + 1\n            val smalest_evens_index_plus_14 = smalest_evens_index_plus_13\
    \ + 1\n            val smalest_evens_index_plus_15 = smalest_evens_index_plus_14\
    \ + 1\n            val smalest_evens_index_plus_16 = smalest_evens_index_plus_15\
    \ + 1\n            val smalest_evens_index_plus_17 = smalest_evens_index_plus_16\
    \ + 1\n            val smalest_evens_index_plus_18 = smalest_evens_index_plus_17\
    \ + 1\n            val smalest_evens_index_plus_19 = smalest_evens_index_plus_18\
    \ + 1\n            val smalest_evens_index_plus_20 = smalest_evens_index_plus_19\
    \ + 1\n            val smalest_evens_index_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp78wwjjwo.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp78wwjjwo.scala:71:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp78wwjjwo.scala:70:1 ---------------------\e[0m\e[0m\n\
    \e[31m70 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp78wwjjwo.scala:59:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m59 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).take(index).sorted\n        result.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt2fx348i.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e\
    [32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValue\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all b"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = List(even, index)\n        if (evens.isEmpty) result\n \
    \       else result.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mb72rgm.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1mb72rgm.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        if(evens.isEmpty) List()\n        else {\n    \
    \        val smalest_value = evens.head\n            val smalest_index = evens.indexWhere(_\
    \ == smalest_value)\n            val smalest_even = evens(smalest_index)\n   \
    \         val smalest_even_index = evens.indexWhere(_ == smalest_even)\n     \
    \       if(smalest_even_index == 0) List(smalest_value)\n            else List(smalest_value,\
    \ smalest_even_index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmj8a0rt0.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ > y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x.toLong > y.toLong)\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x,\
    \ y) => x.toLong > y.toLong)\n        val evenSmallestValueListSortedReversed\
    \ = evenSmallestValueListSorted.reverse\n        val evenSmallestValueListSortedReversedSorted\
    \ = evenSmallestValueListSortedReversed.sortWith((x, y) => x.toLong > y.toLong)\n\
    \        val evenSmallestValueListSortedReversedSortedReversed = evenSmallestValueListSortedReversedSorted.reverse\n\
    \        val evenSmallestValueListSortedReversedSortedReversedSorted = evenSmallestValueListSortedReversedSortedReversed.sortWith((x,\
    \ y) => x.toLong > y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSortedReversed\
    \ = evenSmallestValueListSortedReversedSortedReversedSorted.reverse\n        val\
    \ evenSmallestValueListSortedReversedSortedReversedSortedReversedSorted = evenSmallestValueListSortedReversedSortedReversedSortedReversed.sortWith((x,\
    \ y) => x.toLong > y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed\
    \ = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed.sortWith((x,\
    \ y) => x.toLong > y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted\
    \ = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted.reverse\n\
    \        val evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversed\
    \ = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujc9imwz.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpujc9imwz.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpujc9imwz.scala:45:92 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed\e\
    [0m = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong > y.toLong)\n\e[31m\e[31m   |\e[0m     \
    \                                                                            \
    \           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m \
    \  |\e[0m  evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpujc9imwz.scala:46:98 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted\e\
    [0m = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                          ^\e[0m\n\e[31m   |\e[0mRecursive \e\
    [33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted\n\
    \e[31m   "
  stdout: ''
  timestamp: 1660009630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n      \
    \      val even = evens.min\n            val index = arr.indexWhere(_ == even)\n\
    \            List(even, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValue\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo6sp89ma.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all b"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallestEven = evens.min\n        val index\
    \ = evens.indexOf(smallestEven)\n        val result = List(smallestEven, index)\n\
    \        if (evens.isEmpty) result\n        else result.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsgk8zr65.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpsgk8zr65.scala:35:41 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n\e[31m\e[31m   |\e[0m                                       ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of AnyVal, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smalest_value = evensSorted.head\n        val smalest_index\
    \ = evensSorted.indexOf(0)\n        val smalest_evens = evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evens.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n\
    \        if (smalest_evensSorted.isEmpty) {\n            List[Long]()\n      \
    \  } else {\n            smalest_evensSorted.take(smalest_evensSorted_index).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp13_i3scf.scala:44)\n\tat Problem.main(tmp13_i3scf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest\n     \
    \   val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.length == 0)\n\
    \            evenSmallestValueList.empty\n        else if (evenSmallestIndexList.length\
    \ == 1)\n            evenSmallestValueList\n        else\n            evenSmallestValueList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpanktf3bt.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpanktf3bt.scala:35:54\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpanktf3bt.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(0)\n        val result = arr.filter(_ != even).sortBy(x\
    \ => x).reverse\n        if (result.isEmpty) List()\n        else List(even, index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpofrx6dzo.scala:38)\n\tat Problem.main(tmpofrx6dzo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_).reverse\n        val smallest = evens.head\n        val\
    \ index = evens.indexWhere(_ == smallest)\n        val result = List(smallest,\
    \ index)\n        if (evens.isEmpty) result\n        else pluck(arr.drop(index))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpumrrmomj.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmpumrrmomj.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mString\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        if (evenSmallestIndexListLength\
    \ == 1) {\n            val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \            val evenSmallestValueListLength = evenSmallestValueListLength\n \
    \           val evenSmallestIndexListLength = evenSmallestIndexListLength\n  \
    \          val evenSmallestValueListLength = evenSmallestValueListLength\n   \
    \         val evenSmallestIndexListLength = evenSmallestIndexListLength\n    \
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \       val evenSmallestIndexListLength = evenSmallestIndexListLength\n      \
    \      val evenSmallestValueListLength = evenSmallestValueListLength\n       \
    \     val evenSmallestIndexListLength = evenSmallestIndexListLength\n        \
    \    val evenSmallestValueListLength = evenSmallestValueListLength\n         \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n          \
    \  val evenSmallestValueListLength = evenSmallestValueListLength\n           \
    \ val evenSmallestIndexListLength = evenSmallestIndexListLength\n            val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n            val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n            val evenSmallestValueListLength =\
    \ evenSmallestValueListLength\n            val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \            val evenSmallestValueListLength = evenSmallestValueListLength\n \
    \           val evenSmallestIndexListLength = evenSmallestIndexListLength\n  \
    \          val even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjwvgg25_.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjwvgg25_.scala:75:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjwvgg25_.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e[0m = evenSmallestIndexListLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjwvgg25_.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjwvgg25_.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpjwvgg25_.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallest = evens.min\n        val index =\
    \ evens.indexOf(smallest)\n        val result = List(smallest, index)\n      \
    \  if (evens.isEmpty) result\n        else result.sortBy(_._1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbtlajqno.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpbtlajqno.scala:35:29 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1)\n\e[31m\e\
    [31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0m           \
    \                value _1 is not a member of AnyVal\n\e[31m\e[31m-- Error: /tmp/tmpbtlajqno.scala:35:32\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \ \e[33melse\e[0m result.sortBy(_._1)\n\e[31m\e[31m   |\e[0m                 \
    \               ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009648
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val even = evens.min\n            val index = arr.indexOf(even)\n\
    \            List(even, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvl9o4w1h.scala:39)\n\tat Problem.main(tmpvl9o4w1h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = arr.take(index).min\n        val smalest_index =\
    \ arr.indexOf(smalest_value)\n        val smalest_even = evens.take(smalest_index).min\n\
    \        val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_value\
    \ = evens.take(smalest_even_index).min\n        val smalest_even_count = evens.count(x\
    \ => x == smalest_even)\n        val smalest_even_count_index = evens.indexOf(smalest_even_count)\n\
    \        val smalest_even_count_value = evens.take(smalest_even_count_index).min\n\
    \        val smalest_even_count_count = evens.count(x => x == smalest_even_count)\n\
    \        val smalest_even_count_count_index = evens.indexOf(smalest_even_count_count)\n\
    \        val smalest_even_count_count_value = evens.take(smalest_even_count_count_index).min\n\
    \        val smalest_even_count_count_count = evens.count(x => x == smalest_even_count_count_value)\n\
    \        val smalest_even_count_count_count_index = evens.indexOf(smalest_even_count_count_count)\n\
    \        val smalest_even_count_count_count_value = evens.take(smalest_even_count_count_count_index).min\n\
    \        val smalest_even_count_count_count_count = evens.count(x => x == smalest_even_count_count_count_value)\n\
    \        val smalest_even_count_count_count_count_index = evens.indexOf(smalest_even_count_count_count_count)\n\
    \        val smalest_even_count_count_count_count_value = evens.take(smalest_even_count_count_count_count_index).min\n\
    \        val smalest_even_count_count_count_count_count_index = evens.indexOf(smalest_even_count_count_count_count_count_value)\n\
    \        val smalest_even_count_count_count_count_count_value = evens.take(smalest_even_count_count_count_count_count_index).min\n\
    \        val smalest_even_count_count_count_count_count_index = evens.indexOf(smalest_even_count_count_count_count_count_count_value)\n\
    \        val smalest_even_count_count_count_count_count_value = evens.take(smalest_even_count_count_count_count_count_count_index\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5_wcmrah.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5_wcmrah.scala:52:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_count_count_count_count_count_index\e[0m = evens.indexOf(smalest_even_count_count_count_count_count_count_value)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_count_count_count_count_count_index is already\
    \ defined as \e[33mvalue\e[0m \e[35msmalest_even_count_count_count_count_count_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5_wcmrah.scala:53:12 ---------------------------\e[0m\e[0m\n\e\
    [31m53 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_count_count_count_count_count_value\e\
    [0m = evens.take(smalest_even_count_count_count_count_count_count_index\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_count_count_count_count_count_value is already\
    \ defined as \e[33mvalue\e[0m \e[35msmalest_even_count_count_count_count_count_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp5_wcmrah.scala:51:74 ---------------------------\e[0m\e[0m\n\e\
    [31m51 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_count_count_count_count_count_value\e\
    [0m = evens.take(smalest_even_count_count_count_count_count_index).min\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35msmalest_even_count_count_count_count_count_index\e\
    [0m needs type\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1660009645
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgptnetsz.scala:39)\n\tat Problem.main(tmpgptnetsz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val result = evens.filter(x => x % 2 == 0).map(x => (x, smalest_index)).sortBy(_._1).takeWhile(_._1\
    \ < smalest_value).map(_._1)\n            if (result.isEmpty) List()\n       \
    \     else result\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsjrjaf4k.scala:41)\n\tat Problem.main(tmpsjrjaf4k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.min\n            val smalest_index = arr.indexOf(smalest_value)\n\
    \            val smalest_evens = arr.filter(x => x % 2 == smalest_value).toList\n\
    \            val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \            if (smalest_evens_index == -1) smalest_evens_index\n            else\
    \ smalest_evens_index\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp457x3_42.scala:37:43\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (smalest_evens_index\
    \ == -\e[31m1\e[0m) smalest_evens_index\n\e[31m\e[31m   |\e[0m               \
    \                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                            Found:    (smalest_evens_index : Int)\n\e[31m   |\e\
    [0m                                   Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp457x3_42.scala:38:17 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33melse\e[0m smalest_evens_index\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \           Found:    (smalest_evens_index : Int)\n\e[31m   |\e[0m           \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evensSortedWithIndex = evensSorted.zipWithIndex\n        val smallestEven =\
    \ evensSortedWithIndex.minBy(_._1)\n        val smallestEvenIndex = evensSortedWithIndex.indexOf(smallestEven)\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenValue._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenValue._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenValue._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenValue._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenValue._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenValue._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenValue._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenValue._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenValue._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenValue._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenValue._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenValue._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenValue._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenValue._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenValue._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenValue._1\n\
    \        val smallestEven\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjilrgv3d.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjilrgv3d.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = smallestEvenIndex._2\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmallestEvenIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjilrgv3d.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEvenValue._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e[35msmallestEvenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjilrgv3d.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjilrgv3d.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEvenValue._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e[35msmallestEvenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same gro"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List(arr.head.toLong)\n  \
    \      else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n\
    \            arr.take(index).filter(_ % 2 == 0).min\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yc6wlla.scala:35:12\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            arr.take(index).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).min\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Long\n\e[31m   |\e[0m            Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009648
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n\
    \        val smalest_index = evens.indexOf(0)\n        if (smalest_index == -1)\
    \ evens.toList\n        else evens.take(smalest_index).sortBy(x => x).reverse.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6x_fpdrx.scala:37)\n\tat Problem.main(tmp6x_fpdrx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n        val\
    \ evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        val evensSorted = evensSorted.sortWith((x,\
    \ y) => x.compare(y))\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val evensSorted = evensSorted.toList\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc7_gh4a_.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc7_gh4a_.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc7_gh4a_.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc7_gh4a_.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc7_gh4a_.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e["
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evensSortedWithIndex = evensSorted.zipWithIndex\n        val smallestEven =\
    \ evensSortedWithIndex.minBy(_._1)\n        val smallestEvenIndex = evensSortedWithIndex.indexOf(smallestEven)\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEven._2\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp3sketd9e.scala:74:11 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp3sketd9e.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEven._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3sketd9e.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3sketd9e.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3sketd9e.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_).reverse\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        if (evens.isEmpty) {\n            List[Long]()\n\
    \        } else if (index == 0) {\n            List[Long](even)\n        } else\
    \ {\n            List[Long](even, index)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp2mtxc7ta.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmp2mtxc7ta.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009645
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallestEven = evens.min\n        val smallestEvenIndex\
    \ = arr.indexOf(smallestEven)\n        val result = arr.filter(_ == smallestEven).toList\n\
    \        if (smallestEvenIndex == -1) {\n            List()\n        } else {\n\
    \            result :+ smallestEven\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw15od63r.scala:41)\n\tat Problem.main(tmpw15od63r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val smalest_value = evens.head\n  \
    \      val smalest_index = evens.indexWhere(_ == smalest_value)\n        val smalest_evens\
    \ = evens.take(smalest_index)\n        if (smalest_evens.isEmpty) {\n        \
    \    List[Long]()\n        } else {\n            smalest_evens.map(x => (x, smalest_index)).sortBy(_._1).reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv62yz35c.scala:37:68\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            smalest_evens.map(\e\
    [36mx\e[0m => (x, smalest_index)).sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even).take(index).map(x => x % 2 == 0).foldLeft(List[Long]())((x,\
    \ y) => x ++ y)\n        if (result.isEmpty) result else (result, index)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpagldzgty.scala:33:114\
    \ -------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = arr.filter(_ != even).take(index).map(\e[36mx\e[0m => x % \e[31m2\e[0m ==\
    \ \e[31m0\e[0m).foldLeft(List[\e[35mLong\e[0m]())((\e[36mx\e[0m, \e[36my\e[0m)\
    \ => x ++ y)\n\e[31m\e[31m   |\e[0m                                          \
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0m                                            Found:    (y : Boolean)\n\
    \e[31m   |\e[0m                                            Required: IterableOnce[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpagldzgty.scala:34:40\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result \e[33melse\e[0m (result, index)\n\e[31m\e[31m   |\e[0m              \
    \                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                           Found:    \e[1m\e[31m(\e[0mList[Long]\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m    \
    \                                    Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) return List()\n\
    \        val smalest_even = evens(smalest_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) return\
    \ List()\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   if (smalest_even_index == -1) return List()\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        if (\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzch6sm1z.scala:68:12 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mif\e[0m (\n\e[31m\e[31m   |\e[0m      \
    \      ^\e[0m\n\e[31m   |\e[0m            expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzch6sm1z.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = evens.indexOf(smalest_even)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzch6sm1z.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = evens.indexOf(smalest_even)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzch6sm1z.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzch6sm1z.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        val smalest_evens = evens.takeWhile(x => x % 2 ==\
    \ 0)\n        val smalest_evens_index = evens.indexOf(smalest_evens.head)\n  \
    \      if (smalest_evens_index == -1)\n            smalest_evens_index = evens.length\n\
    \        if (smalest_evens_index == evens.length)\n            smalest_evens_index\
    \ = evens.length - 1\n        if (smalest_evens_index == evens.length - 1)\n \
    \           smalest_evens_index = evens.length - 2\n        if (smalest_evens_index\
    \ == evens.length - 2)\n            smalest_evens_index = evens.length - 3\n \
    \       if (smalest_evens_index == evens.length - 3)\n            smalest_evens_index\
    \ = evens.length - 4\n        if (smalest_evens_index == evens.length - 4)\n \
    \           smalest_evens_index = evens.length - 5\n        if (smalest_evens_index\
    \ == evens.length - 5)\n            smalest_evens_index = evens.length - 6\n \
    \       if (smalest_evens_index == evens.length - 6)\n            smalest_evens_index\
    \ = evens.length - 7\n        if (smalest_evens_index == evens.length - 7)\n \
    \           smalest_evens_index = evens.length - 8\n        if (smalest_evens_index\
    \ == evens.length - 8)\n            smalest_evens_index = evens.length - 9\n \
    \       if (smalest_evens_index == evens.length - 9)\n            smalest_evens_index\
    \ = evens.length - 10\n        if (smalest_evens_index == evens.length - 10)\n\
    \            smalest_evens_index = evens.length - 11\n        if (smalest_evens_index\
    \ == evens.length - 11)\n            smalest_evens_index = evens.length - 12\n\
    \        if (smalest_evens_index == evens.length - 12)\n            smalest_evens_index\
    \ = evens.length - 13\n        if (smalest_evens_index == evens.length - 13)\n\
    \            smalest_evens_index = evens.length - 14\n        if (smalest_evens_index\
    \ == evens.length - 14)\n            smalest_evens_index = evens.length - 15\n\
    \        if (smalest_evens_index == evens.length - 15)\n            smalest_evens_index\
    \ = evens.length - 16\n        if (smalest_evens_index == evens.length - 16)\n\
    \            smalest_evens_index = evens.length - \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj85nfzgx.scala:70:48 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m            smalest_evens_index = evens.length - \n\e\
    [31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                                  expression expected but \e[31munindent\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpj85nfzgx.scala:36:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            smalest_evens_index\
    \ = evens.length\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val smalest_evens_index\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpj85nfzgx.scala:38:32 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            smalest_evens_index = evens.length - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val smalest_evens_index\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpj85nfzgx.scala:40:32 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            smalest_evens_index = evens.length - \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val smalest_evens_index\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpj85nfzgx.scala:42:32 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            smalest_evens_index = evens.length - \e[31m3\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val smalest_evens_index\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpj85nfzgx.scala:4"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val smalest_evens = evens.filter(x => x % 2 == 0)\n            val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_value)\n            val\
    \ smalest_evens_value = smalest_evens(smalest_evens_index)\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value\
    \ + 1\n            val smalest_evens_index = smalest_evens_index + 1\n       \
    \     val smalest_evens_value = smalest_evens_value + 1\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value\
    \ + 1\n            val smalest_evens_index = smalest_evens_index + 1\n       \
    \     val smalest_evens_value = smalest_evens_value + 1\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value\
    \ + 1\n            val smalest_evens_index = smalest_evens_index + 1\n       \
    \     val smalest_evens_value = smalest_evens_value + 1\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value\
    \ + 1\n            val smalest_evens_index = smalest_evens_index + 1\n       \
    \     val smalest_evens_value = smalest_evens_value + 1\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value\
    \ + 1\n            val smalest_evens_index = smalest_evens_index + 1\n       \
    \     val smalest_evens_value = smalest_evens_value + 1\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value\
    \ + 1\n            val smalest_evens_index = smalest_evens_index + 1\n       \
    \     val smalest_evens_value = smalest_evens_value + 1\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqj2ws_g_.scala:63:37 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m            \e[33mval\e[0m \e[36msmalest_evens_value\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqj2ws_g_.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqj2ws_g_.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36msmalest_evens_index\e[0m = smalest_evens_index\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqj2ws_g_.scala:39:16 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36msmalest_evens_value\e\
    [0m = smalest_evens_value + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqj2ws_g_.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36msmalest_evens_index\e\
    [0m = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be def"
  stdout: ''
  timestamp: 1660009654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(even)\n        val result = arr.filter(x => x %\
    \ 2 == 0).sortBy(x => x).reverse.takeWhile(x => x != even).take(index).toList\n\
    \        if (result.isEmpty) List(even.toLong)\n        else result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvfai_wtp.scala:38)\n\tat Problem.main(tmpvfai_wtp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009656
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        arr.filter(_ == even).sortWith(_ < _).take(1).map(_.toLong).toList :+\
    \ even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpygovnxht.scala:36)\n\tat Problem.main(tmpygovnxht.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = evens.take(index).min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.take(smalest_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = evens.take(smalest_even_index)\n\
    \        val smalest_even = smalest_evens.min\n        val smalest_even_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens = \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptu8q2kop.scala:62:27 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptu8q2kop.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens\e[0m = evens.take(smalest_even_index)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens is already defined as \e[33mvalue\e[0m \e[35msmalest_evens\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptu8q2kop.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even\e[0m = smalest_evens.min\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even is already defined as \e[33mvalue\e[0m \e[35msmalest_even\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptu8q2kop.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_evens.indexOf(smalest_even)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptu8q2kop.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens\e[0m = evens.take(smalest_even_index)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallest = evens.min\n        val index =\
    \ evens.indexOf(smallest)\n        val result = (smallest, index)\n        if\
    \ (evens.isEmpty) result\n        else result::pluck(arr.filter(x => x != smallest\
    \ && x != index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpepjqbtvt.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : (Long, Int))\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpepjqbtvt.scala:35:13 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result::pluck(arr.filter(x =>\
    \ x != smallest && x != index))\n\e[31m\e[31m   |\e[0m             ^^^^^^\e[0m\n\
    \e[31m   |\e[0m             Found:    (result : (Long, Int))\n\e[31m   |\e[0m\
    \             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).take(index).sortWith(_ < _)\n    \
    \    if (result.isEmpty) Nil\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa7k7tpid.scala:38)\n\tat Problem.main(tmpa7k7tpid.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = (if (index == -1) List(even) else evens.take(index)).sorted\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdwuxzwqr.scala:37)\n\tat Problem.main(tmpdwuxzwqr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestIndexListSortedReversed\
    \ = evenSmallestIndexListSorted.reverse\n        val evenSmallestValueListSortedReversed\
    \ = evenSmallestValueListSorted.reverse\n        val evenSmallestIndexListSortedReversedSorted\
    \ = evenSmallestIndexListSortedReversed.sortWith((x, y) => x.toLong < y.toLong)\n\
    \        val evenSmallestValueListSortedReversedSorted = evenSmallestValueListSortedReversed.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestIndexListSortedReversedSortedReversed\
    \ = evenSmallestIndexListSortedReversedSorted.reverse\n        val evenSmallestValueListSortedReversedSortedReversed\
    \ = evenSmallestValueListSortedReversedSorted.reverse\n        val evenSmallestIndexListSortedReversedSortedReversedSorted\
    \ = evenSmallestIndexListSortedReversedSortedReversed.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSorted\
    \ = evenSmallestValueListSortedReversedSortedReversed.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallestIndexListSortedReversedSortedReversedSortedReversed\
    \ = evenSmallestIndexListSortedReversedSortedReversedSorted.reverse\n        val\
    \ evenSmallestValueListSortedReversedSortedReversedSortedReversed = evenSmallestValueListSortedReversedSortedReversedSorted.reverse\n\
    \        val evenSmallestIndexListSortedReversedSortedReversedSortedReversedSorted\
    \ = evenSmallestIndexListSortedReverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmponr316ph.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmponr316ph.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmponr316ph.scala:49:84 ------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSortedReversedSortedReversedSortedReversedSorted\e\
    [0m = evenSmallestIndexListSortedReverse\n\e[31m\e[31m   |\e[0m              \
    \                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: evenSmallestIndexListSortedReverse\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmponr316ph.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallestEven = evens.min\n            val index = arr.indexOf(smallestEven)\n\
    \            val result = List(smallestEven, index)\n            if (index ==\
    \ arr.length - 1) result\n            else result :+ arr.take(index + 1)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1zsvvr_l.scala:36:41\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (index\
    \ == arr.length - \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                \
    \                         ^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                Found:    (result : List[AnyVal])\n\e[31m   |\e[0m          \
    \                             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1zsvvr_l.scala:37:17 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result :+ arr.take(index\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    List[Matchable]\n\e[31m   |\e[0m\
    \                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmwb_omb_.scala:39)\n\tat Problem.main(tmpmwb_omb_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedWithIndex = evensSorted.zipWithIndex.toList\n\
    \        val smalestValue = evensSortedWithIndex.head._2\n        val smalestIndex\
    \ = evensSortedWithIndex.head._1\n        val smalestEven = evensSortedWithIndex.filter(x\
    \ => x._2 == smalestValue).head._1\n        val smalestEvenIndex = evensSortedWithIndex.filter(x\
    \ => x._2 == smalestValue).head._2\n        val smalestEvenIndex = smalestEvenIndex.toLong\n\
    \        val smalestEvenValue = evensSortedWithIndex.filter(x => x._2 == smalestValue).head._1\n\
    \        val smalestEvenValueIndex = evensSortedWithIndex.filter(x => x._2 ==\
    \ smalestValue).head._2\n        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n\
    \        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val\
    \ smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n\
    \        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val\
    \ smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n\
    \        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val\
    \ smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n\
    \        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val\
    \ smalestEvenValueIndex = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.toLong\n        val smalestEvenValueIndex = smalestEvenValueIndex.toLong\n\
    \        val smalestEvenValueIndex = sm\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6pds_37w.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ smalestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6pds_37w.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValueIndex\e\
    [0m = smalestEvenValueIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmalestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6pds_37w.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValueIndex\e\
    [0m = smalestEvenValueIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmalestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6pds_37w.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValueIndex\e\
    [0m = smalestEvenValueIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmalestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6pds_37w.scala:43:12 ---"
  stdout: ''
  timestamp: 1660009669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) Nil\n    \
    \    else evens.take(1).head\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_g210gcm.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e\
    [31m1\e[0m).head\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).toList\n        if (evens.isEmpty)\
    \ result\n        else (List(even, index), result)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbj20b7v5.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m (List(even,\
    \ index), result)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    \e[1m\e[31m(\e[0mList[\e[1m\e[31mAnyVal\e\
    [0m\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0mLong]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val even = evens.head\n        val\
    \ index = arr.indexOf(even)\n        val result = List(even, index)\n        if\
    \ (evens.isEmpty) result\n        else result.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb7zt3o8k.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb7zt3o8k.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (evens.size ==\
    \ 1) result\n            else result ::: pluck(arr.filter(_ != smallest))\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_op3g61i.scala:36:33\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.size\
    \ == \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                                 Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_op3g61i.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\
    \ ::: pluck(arr.filter(_ != smallest))\n\e[31m\e[31m   |\e[0m                \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_value\
    \ = evens(smalest_even_index)\n        val smalest_even_index_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list = evens.indexOf(smalest_even)\n    \
    \    val smalest_even_index_list_list_list = evens.indexOf(smalest_even)\n   \
    \     val smalest_even_index_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk02ipivr.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk02ipivr.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk02ipivr.scala:49:12 ---------------------------\e[0m\e[0m\n\e\
    [31m49 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] N"
  stdout: ''
  timestamp: 1660009670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = (even, index)\n        if (evens.isEmpty) result\n     \
    \   else result::pluck(arr.filter(_ != even).toList)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpko44wcwe.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : (Long, Int))\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpko44wcwe.scala:35:13 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result::pluck(arr.filter(_ !=\
    \ even).toList)\n\e[31m\e[31m   |\e[0m             ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \             Found:    (result : (Long, Int))\n\e[31m   |\e[0m             Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortWith(_ < _).take(index).reverse\n\
    \        if (result.isEmpty) List(even.toLong)\n        else result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx1w9z06j.scala:38)\n\tat Problem.main(tmpx1w9z06j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n      \
    \      val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (evens.size ==\
    \ 1) result\n            else pluck(arr.filter(_ != smallest))\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaaoga3bf.scala:36:33\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.size\
    \ == \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                                 Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        if (smalest_index == -1) {\n            evens\n\
    \        } else {\n            evens.take(smalest_index).sortBy(_).reverse\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqg3no3ip.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpqg3no3ip.scala:36:45\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            evens.take(smalest_index).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$3 of expanded function:\n\e[31m   |\e\
    [0m   _$3 => evens.take(smalest_index).sortBy(_$3).reverse.\n2 errors found\n"
  stdout: ''
  timestamp: 1660009674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        arr.take(index).filter(_ % 2 == 0).min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9eu3yzkz.scala:33:8\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m        arr.take(index).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallestEven = evens.min\n        val smallestIndex\
    \ = evens.indexOf(smallestEven)\n        val result = arr.filter(_ == smallestEven)\n\
    \        if (result.isEmpty) List()\n        else List(smallestEven, smallestIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpznyajzj3.scala:39)\n\tat Problem.main(tmpznyajzj3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = List(even, index)\n        if (evens.isEmpty) result\n \
    \       else result.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6k81lgbs.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6k81lgbs.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n      \
    \      val minEven = evens.min\n            val index = arr.indexOf(minEven)\n\
    \            val minIndex = arr.indexOf(minEven, index + 1)\n            val smalest_value\
    \ = minEven + minIndex\n            val smalest_value_index = arr.indexOf(smalest_value)\n\
    \            val smalest_value_index_list = List(smalest_value, smalest_value_index)\n\
    \            val smalest_value_index_list_sorted = smalest_value_index_list.sortBy(_._1)\n\
    \            val smalest_value_index_list_sorted_reversed = smalest_value_index_list_sorted.reverse\n\
    \            val smalest_value_index_list_sorted_reversed_sorted = smalest_value_index_list_sorted_reversed.sortBy(_._1)\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed = smalest_value_index_list_sorted_reversed_sorted.reverse\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_value_index_list_sorted_reversed_sorted_reversed.sortBy(_._1)\n  \
    \          val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_value_index_list_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_._1)\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_._1)\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortBy(_._1)\n\
    \            val smalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smale\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpakaim4sd.scala:64:0 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakaim4sd.scala:39:84\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_value_index_list_sorted\e[0m = smalest_value_index_list.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^\e[0m\n\e[31m   |\e[0m                        \
    \              value _1 is not a member of AnyVal\n\e[31m\e[31m-- Error: /tmp/tmpakaim4sd.scala:39:87\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \     \e[33mval\e[0m \e[36msmalest_value_index_list_sorted\e[0m = smalest_value_index_list.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpakaim4sd.scala:50:139 -----------------------\e[0m\e[0m\n\e[31m50 |\e\
    [0m            \e[33mval\e[0m \e[36msmalest_value_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\e\
    [0m = smale\n\e[31m\e[31m   |\e[0m                                           \
    \                                                                            \
    \                    ^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                           Not found: smale\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpakaim4sd.scala:63:1 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660009678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest\n     \
    \   val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.length == 1) {\n\
    \            val smallestEven = evenSmallestValue\n            val smallestEvenIndex\
    \ = evenSmallestIndex\n            val smallestEvenValueList = evenSmallestValueList\n\
    \            val smallestEvenIndexList = evenSmallestIndexList\n            val\
    \ smallestEvenValueListLength = smallestEvenValueList.length\n            val\
    \ smallestEvenIndexListLength = smallestEvenIndexList.length\n            val\
    \ smallestEvenValueListLength = smallestEvenValueListLength\n            val smallestEvenIndexListLength\
    \ = smallestEvenIndexListLength\n            val smallestEvenValueListLength =\
    \ smallestEvenValueListLength\n            val smallestEvenIndexListLength = smallestEvenIndexListLength\n\
    \            val smallestEvenValueListLength = smallestEvenValueListLength\n \
    \           val smallestEvenIndexListLength = smallestEvenIndexListLength\n  \
    \          val smallestEvenValueListLength = smallestEvenValueListLength\n   \
    \         val smallestEvenIndexListLength = smallestEvenIndexListLength\n    \
    \        val smallestEvenValueListLength = smallestEvenValueListLength\n     \
    \       val smallestEvenIndexListLength = smallestEvenIndexListLength\n      \
    \      val smallestEvenValueListLength = smallestEvenValueListLength\n       \
    \     val smallestEvenIndexListLength = smallestEvenIndexListLength\n        \
    \    val smallestEvenValueListLength = smallestEvenValueListLength\n         \
    \   val smallestEvenIndexListLength = smallestEvenIndexListLength\n          \
    \  val smallestEvenValueListLength = smallestEvenValueListLength\n           \
    \ val smallestEvenIndexListLength = smallestEvenIndexListLength\n            val\
    \ smallestEvenValueListLength = smallestEvenValueListLength\n            val smallestEvenIndexListLength\
    \ = smallestEvenIndexListLength\n            val smallestEvenValueListLength =\
    \ smallestEvenValueListLength\n            val smallestEvenIndexListLength = smallestEvenIndexListLength\n\
    \            val smallestEvenValueListLength = smallestEvenValueListLength\n \
    \           \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7rtp7dru.scala:79:0 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7rtp7dru.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7rtp7dru.scala:35:54\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7rtp7dru.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmp7rtp7dru.scala:44:16 ---------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m            \e[33mval\e[0m \e[36msmallestEvenValueListLength\e\
    [0m = smallestEvenValueListLength\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7rtp7dru.scala:45:16 "
  stdout: ''
  timestamp: 1660009682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = smalest_index match {\n            case -1 =>\
    \ -1\n            case _ => evens.indexOf(smalest_even)\n        }\n        val\
    \ smalest_even_value = evens(smalest_even_index)\n        val smalest_even_index_list\
    \ = evens.take(smalest_even_index).map(x => x.toLong).toList\n        val smalest_even_index_list_sorted\
    \ = smalest_even_index_list.sortWith(_ < _)\n        val smalest_even_index_list_sorted\
    \ = smalest_even_index_list_sorted.take(1).map(x => x.toLong).toList\n       \
    \ val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(x\
    \ => x.toLong).toList\n        val smalest_even_index_list_sorted = smalest_even_index_list_sorted.take\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqxnorh3x.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_sorted\e\
    [0m = smalest_even_index_list_sorted.take(\e[31m1\e[0m).map(\e[36mx\e[0m => x.toLong).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqxnorh3x.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_sorted\e\
    [0m = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqxnorh3x.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_sorted\e\
    [0m = smalest_even_index_list_sorted.take(smalest_even_index_list_sorted.length).map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /"
  stdout: ''
  timestamp: 1660009679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = arr.take(index).min\n        val smalest_index =\
    \ arr.indexOf(smalest_value)\n        val result = List(smalest_value, smalest_index)\n\
    \        if (arr.isEmpty) result\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2b7f4csc.scala:36:25\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp2b7f4csc.scala:37:13 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m\
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009682
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) Nil\n\
    \        else result.take(index).sortBy(x => x).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5dt9jzfh.scala:38)\n\tat Problem.main(tmp5dt9jzfh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(_ ==\
    \ smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_index_plus_one = smalest_evens_index + 1\n        if\
    \ (smalest_evens_index_plus_one == evens.length)\n            smalest_evens_index_plus_one\n\
    \        else\n            smalest_evens_index_plus_one\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9q1t5fqc.scala:37:12\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            smalest_evens_index_plus_one\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Found:    (smalest_evens_index_plus_one : Int)\n\e[31m   |\e[0m\
    \            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9q1t5fqc.scala:39:12 --------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            smalest_evens_index_plus_one\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:  \
    \  (smalest_evens_index_plus_one : Int)\n\e[31m   |\e[0m            Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        if (evens.isEmpty) List()\n        else {\n   \
    \         val smallest = evens.head\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (arr.contains(smallest))\
    \ result :+ smallest\n            else result\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpfdqs1f5p.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfdqs1f5p.scala:36:40 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (arr.contains(smallest)) result\
    \ :+ smallest\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    List[\e\
    [1m\e[31mInt\e[0m]\n\e[31m   |\e[0m                                        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfdqs1f5p.scala:37:17 --------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m            \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result : List[Int])\n\
    \e[31m   |\e[0m                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009694
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else result.take(index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpthafrb7f.scala:38)\n\tat Problem.main(tmpthafrb7f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        if (evens.isEmpty) List()\n        else\
    \ evens.take(1).head\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2ps6updj.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e\
    [31m1\e[0m).head\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n        \
    \    val even = evens.min\n            val index = arr.indexOf(even)\n       \
    \     List(even, index)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = (smallest, index)\n        if (evens.isEmpty) result\n \
    \       else result :: pluck(arr.filter(_ != smallest))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphxiaw2lf.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : (Long, Int))\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphxiaw2lf.scala:35:13 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result :: pluck(arr.filter(_\
    \ != smallest))\n\e[31m\e[31m   |\e[0m             ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \             Found:    (result : (Long, Int))\n\e[31m   |\e[0m             Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val smallest = evens.head\n        val index =\
    \ evens.indexOfFirst { _ == smallest }\n        if (index == -1) List(smallest)\
    \ else evens.take(index).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpag7gpmde.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n1 error found\n"
  stdout: ''
  timestamp: 1660009694
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.take(smalest_index)\n\
    \        if (smalest_evens.isEmpty) List()\n        else List(smalest_value, smalest_index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkg6bo6vl.scala:39)\n\tat Problem.main(tmpkg6bo6vl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x == smalest_value).toList\n        if (smalest_evens.isEmpty) List(smalest_value,\
    \ smalest_index)\n        else smalest_evens.minIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyy6ekur1.scala:35:27 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m smalest_evens.minIndex\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value minIndex is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660009693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) List(smallest) else List(smallest, index)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu5juz19v.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009693
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smalest_value = evensSorted.head\n        val smalest_index\
    \ = evensSorted.indexOf(0)\n        if (evensSorted.isEmpty) {\n            List[Long]()\n\
    \        } else {\n            evensSorted.takeWhile(x => x != smalest_value).takeWhile(x\
    \ => x != smalest_index).map(x => x.toLong)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt08jc2kq.scala:41)\n\tat Problem.main(tmpt08jc2kq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedWithIndex = evensSorted.zipWithIndex\n \
    \       val smalest_value = evensSortedWithIndex.head._2\n        val smalest_index\
    \ = evensSortedWithIndex.head._1\n        val smalest_evens = evensSorted.filter(_\
    \ == smalest_value)\n        val smalest_evensSorted = smalest_evens.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val smalest_evensSortedWithIndex = smalest_evensSorted.zipWithIndex\n\
    \        val smalest_evensSortedWithIndexSorted = smalest_evensSortedWithIndex.sortWith((x,\
    \ y) => x._1 < y._1)\n        val smalest_evensSortedWithIndexSortedWithIndex\
    \ = smalest_evensSortedWithIndexSorted.zipWithIndex\n        val smalest_evensSortedWithIndexSortedWithIndexSorted\
    \ = smalest_evensSortedWithIndexSortedWithIndex.sortWith((x, y) => x._1 < y._1)\n\
    \        val smalest_evensSortedWithIndexSortedWithIndexSortedWithIndex = smalest_evensSortedWithIndexSortedWithIndexSorted.zipWithIndex\n\
    \        val smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalest_evensSortedWithIndexSortedWithIndexSortedWithIndex.sortWith((x, y)\
    \ => x._1 < y._1)\n        val smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.zipWithIndex\n\
    \        val smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.sortWith((x,\
    \ y) => x._1 < y._1)\n        val smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.zipWithIndex\n\
    \        val smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.sortWith\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy8rq6sr5.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\e\
    [0m = smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.zipWithIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpy8rq6sr5.scala:40:132 -----------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSortedWithIndexSortedWithIndexSorted\e\
    [0m = smalest_evensSortedWithIndexSortedWithIndex.sortWith((\e[36mx\e[0m, \e[36my\e\
    [0m) => x._1 < y._1)\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                            \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of (Long,\
    \ Int), but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m \
    \ import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpy8rq6sr5.scala:42:162 -----------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSortedWithIndexSortedWithIndexSortedWithIndexSorted\e\
    [0m = smalest_evensSortedWithIndexSortedWithIndexSortedWithIndex.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x._1 < y._1)\n\e[31m\e[31m   |\e[0m             \
    \                "
  stdout: "Cancelling test of (math.Ordering.Implicits.infixOrderingOps : \n  [T](x:\
    \ T)(\e[33mimplicit \e[0mord: Ordering[T]): Ordering[T]#OrderingOps\n) when making\
    \ suggestions for error in /tmp/tmpy8rq6sr5.scala\n"
  timestamp: 1660009696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n\
    \        val smalest_index = evens.indexWhere(x => x == smalest_value)\n     \
    \   val result = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse.takeWhile(x\
    \ => x != smalest_value).takeWhile(x => x != smalest_index).reverse\n        if\
    \ (result.isEmpty) Nil\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj3ank2cz.scala:38)\n\tat Problem.main(tmpj3ank2cz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = arr.indexOf(even)\n        val result = List(even, index)\n  \
    \      if (evens.isEmpty) result\n        else result.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8f434ydl.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8f434ydl.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = (even, index)\n        if (evens.isEmpty) Nil\n        else\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi51rz5qp.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    (result : (Long, Int))\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     evens.toList\n        } else {\n            evens.take(smalest_index).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpssq05ch6.scala:40)\n\tat Problem.main(tmpssq05ch6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgptnetsz.scala:39)\n\tat Problem.main(tmpgptnetsz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgptnetsz.scala:39)\n\tat Problem.main(tmpgptnetsz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smalest_value = evensSorted.head\n        val smalest_index\
    \ = evensSorted.indexOf(0)\n        if (evensSorted.size == 0) {\n           \
    \ List[Long]()\n        } else if (evensSorted.size == 1) {\n            List[Long](smalest_value)\n\
    \        } else {\n            List[Long](smalest_value, smalest_index)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxaugk9yn.scala:43)\n\tat Problem.main(tmpxaugk9yn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.head\n            val index = arr.indexOf(smallest)\n\
    \            val even = smallest % 2 == 0\n            val result = (if (even)\
    \ List(smallest, index) else List(smallest, index)).sortBy(_._1).reverse\n   \
    \         result\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppmos4mms.scala:36:95 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = (\e[33mif\e\
    [0m (even) List(smallest, index) \e[33melse\e[0m List(smallest, index)).sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                     ^^^^\e[0m\n\e[31m   |\e[0m             \
    \                         value _1 is not a member of AnyVal\n\e[31m\e[31m-- Error:\
    \ /tmp/tmppmos4mms.scala:36:98 -----------------------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = (\e[33mif\e\
    [0m (even) List(smallest, index) \e[33melse\e[0m List(smallest, index)).sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                          ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) Nil\n\
    \        else (List(even, index), result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplytyv7ag.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m (List(even,\
    \ index), result)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    \e[1m\e[31m(\e[0mList[\e[1m\e[31mAnyVal\e\
    [0m\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0mLong]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val even = evens.head\n        val index\
    \ = evens.indexOf(even)\n        val result = (if (index == 0) even else evens.take(index)).sortBy(x\
    \ => x)\n        val resultList = result.map(x => x.toLong).toList\n        resultList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0wuf_fuu.scala:33:67 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (\e[33mif\e\
    [0m (index == \e[31m0\e[0m) even \e[33melse\e[0m evens.take(index)).sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              value sortBy is not a member of (even : Long)\
    \ | List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660009700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result: List[Long] = if (index == -1) Nil else\
    \ List(even, index)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw_ale3q5.scala:37)\n\tat Problem.main(tmpw_ale3q5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        if (evens.isEmpty) List()\n        else List(even, index)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp08pj4fik.scala:38)\n\tat Problem.main(tmp08pj4fik.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x % 2 == 0)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value + 1\n        val sm\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl6tii6lm.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl6tii6lm.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evens_index\e[0m = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m \e[35msmalest_evens_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl6tii6lm.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m = smalest_evens_value\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl6tii6lm.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl6tii6lm.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens_value + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m"
  stdout: ''
  timestamp: 1660009709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smallestEven = evens.min\n        val index = evens.indexOf(smallestEven)\n\
    \        val result = if (index == -1) List(smallestEven) else List(smallestEven,\
    \ index)\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpla49nrn3.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        arr.take(index).filter(_ % 2 == 0).min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9eu3yzkz.scala:33:8\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m        arr.take(index).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        if (evens.isEmpty) List()\n        else\
    \ evens.take(1).map(x => (x, evens.indexOf(x)))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbbwi_zuz.scala:32:36\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e\
    [31m1\e[0m).map(x => (x, evens.indexOf(x)))\n\e[31m\e[31m   |\e[0m           \
    \                         ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                            Found:    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e\
    [1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m         \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val smalest_even = evens(smalest_index)\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjyqr8kza.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjyqr8kza.scala:87:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjyqr8kza.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjyqr8kza.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjyqr8kza.scala:40:16 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjyqr8kza.scala:41:16 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmale"
  stdout: ''
  timestamp: 1660009716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = if (evens.isEmpty) Nil else List(even, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3x3p_l36.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smalest_value = evensSorted.head\n        val smalest_index\
    \ = evensSorted.indexOf(0)\n        val smalest_evens = evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evens.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp2g086cc.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp2g086cc.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evensSorted\e[0m = smalest_evensSorted.takeWhile(\e[36mx\e[0m\
    \ => x != smalest_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evensSorted is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evensSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpp2g086cc.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted\e[0m\
    \ = smalest_evensSorted.takeWhile(\e[36mx\e[0m => x != smalest_value)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evensSorted is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evensSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpp2g086cc.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted\e[0m\
    \ = smalest_evensSorted.takeWhile(\e[36mx\e[0m => x != smalest_value)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evensSorted is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evensSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of to"
  stdout: ''
  timestamp: 1660009712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n     \
    \   val smallestEvenIndexList = List(smallestEvenIndex, smallestEvenIndex + 1)\n\
    \        val smallestEvenValueList = List(smallestEvenValue, smallestEvenValue\
    \ + 1)\n        if (evensSorted.isEmpty) {\n            List[Long]()\n       \
    \ } else {\n            val smallestEvenIndexSet = evensSorted.toSet\n       \
    \     val smallestEvenIndexSetSize = smallestEvenIndexSet.size\n            if\
    \ (smallestEvenIndexSetSize == 1) {\n                smallestEvenIndexSet.head\n\
    \            } else if (smallestEvenIndexSetSize == 2) {\n                smallestEvenIndexSet.head\n\
    \            } else if (smallestEvenIndexSetSize == 3) {\n                smallestEvenIndexSet.head\n\
    \            } else if (smallestEvenIndexSetSize == 4) {\n                smallestEvenIndexSet.head\n\
    \            } else if (smallestEvenIndexSetSize == 5) {\n                smallestEvenIndexSet.head\n\
    \            } else {\n                smallestEvenIndexSet.toList\n         \
    \   }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06pobfxo.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06pobfxo.scala:43:37\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                smallestEvenIndexSet.head\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Found:    Long\n\e[31m   |\e[0m                Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06pobfxo.scala:45:37 --------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                smallestEvenIndexSet.head\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Found:    Long\n\e[31m   |\e[0m                Required: \e[1m\e\
    [32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp06pobfxo.scala:47:37 --------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                smallestEvenIndexSet.head\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Found:    Long\n\e[31m   |\e[0m                Required: \e[1m\e\
    [32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp06pobfxo.scala:49:37 --------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                smallestEvenIndexSet.head\n\e[31m\e[31m\
    \   |\e[0m            "
  stdout: ''
  timestamp: 1660009717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestIndexListSorted\
    \ = evenSmallestIndexList.sortWith((x, y) => x.toLong < y.toLong)\n        val\
    \ evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n        val\
    \ evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n        val\
    \ evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x, y) =>\
    \ x.toLong < y.toLong)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSm\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcvxd_xy0.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcvxd_xy0.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestIndexListSorted\e[0m = evenSmallestIndexListSorted.head\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcvxd_xy0.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcvxd_xy0.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.toLong\
    \ < y.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcvxd_xy0.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListS"
  stdout: ''
  timestamp: 1660009716
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(x => x % 2 == 0).filter(x => x != even).take(index).sorted\n\
    \        if (result.isEmpty) List()\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5e993ocl.scala:38)\n\tat Problem.main(tmp5e993ocl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) Nil\n        else {\n    \
    \        val minEven = evens.min\n            val minIndex = evens.indexOf(minEven)\n\
    \            val minEvenIndex = minIndex\n            val minEvenValue = minEven\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc1ayxfy7.scala:96:0 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc1ayxfy7.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminEvenValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc1ayxfy7.scala:39:16 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc1ayxfy7.scala:40:16 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc1ayxfy7.scala:41:16 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161"
  stdout: ''
  timestamp: 1660009717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) Nil else List(smallest, index)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2vls1p1.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     List[Long]()\n        } else {\n            evens.take(smalest_index).map(x\
    \ => x -> smalest_index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06h440tl.scala:36:47\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            evens.take(smalest_index).map(\e\
    [36mx\e[0m => x -> smalest_index)\n\e[31m\e[31m   |\e[0m                     \
    \                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                     Found:    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m    \
    \                                           Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSorted = evensSorted.takeWhile(_ < arr.length)\n\
    \        val smalest_value = evensSorted.head\n        val smalest_index = evensSorted.indexOf(0)\n\
    \        val smalest_evens = evensSorted.take(evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evens.sortWith((x, y) => x.toLong <\
    \ y.toLong)\n        val smalest_evensSorted = smalest_evensSorted.takeWhile(_\
    \ < arr.length)\n        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\
    \        val smalest_evensSorted = smalest_evensSorted.take(smale\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk32k4bbs.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk32k4bbs.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensSorted\e[0m = evensSorted.takeWhile(_ < arr.length)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk32k4bbs.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted\e[0m = smalest_evensSorted.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evensSorted is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evensSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk32k4bbs.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted\e[0m\
    \ = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evensSorted is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evensSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk32k4bbs.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted\e[0m\
    \ = smalest_evensSorted.take(smalest_evensSorted.indexOf(smalest_value))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009718
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n\
    \        val smalest_index = evens.indexOf(0)\n        if (evens.isEmpty) List()\n\
    \        else evens.take(smalest_index).map(x => smalest_value + x.toLong)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1p7esjxk.scala:37)\n\tat Problem.main(tmp1p7esjxk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List()\n \
    \       else {\n            val smallest = evens.head\n            val index =\
    \ evens.indexOf(smallest)\n            val result = List(smallest, index)\n  \
    \          if (evens.tail.isEmpty) result\n            else result ++ pluck(evens.tail)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5k3n3m9v.scala:36:36\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.tail.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                                    ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                    Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m                                    Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5k3n3m9v.scala:37:17 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result ++ pluck(evens.tail)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                 Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e\
    [0m                 Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009719
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            arr.filterNot(x =>\
    \ x == smallest).filterNot(x => x == index).filterNot(x => x == smallest + index).filterNot(x\
    \ => x == smallest - index).filterNot(x => x == smallest + index - 1).filterNot(x\
    \ => x == smallest - index - 1)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfaq1mmx5.scala:40)\n\tat Problem.main(tmpfaq1mmx5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x % 2 == 0)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        if (smalest_evens_index == -1) smalest_evens_index = 0\n        smalest_evens.take(smalest_evens_index).map(x\
    \ => (x, smalest_index)).sortBy(_._1).reverse.head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmph5dkcmrd.scala:35:59 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mif\e[0m (smalest_evens_index == -\e[31m1\e\
    [0m) smalest_evens_index = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m               \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                          Reassignment to val smalest_evens_index\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph5dkcmrd.scala:36:98 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        smalest_evens.take(smalest_evens_index).map(\e\
    [36mx\e[0m => (x, smalest_index)).sortBy(_._1).reverse.head\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (Long, Int)\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.map(x => arr.indexOf(x))\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.reverse\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.map(x =>\
    \ arr.indexOf(x))\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.reverse\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.map(x =>\
    \ arr.indexOf(x))\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.reverse\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.map(x =>\
    \ arr.indexOf(x))\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.head\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexListSorted.toList\n\
    \        val evenSmallestIndexListSorted = evenSmalle\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc9s9nanv.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc9s9nanv.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc9s9nanv.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc9s9nanv.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListSorted\e\
    [0m = evenSmallestIndexListSorted.map(\e[36mx\e[0m => arr.indexOf(x))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListSorted is already defined as \e[33mvalue\e\
    [0m \e[35"
  stdout: ''
  timestamp: 1660009721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfm5h9tu1.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfm5h9tu1.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfm5h9tu1.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfm5h9tu1.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfm5h9tu1.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660009721
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        arr.filter(_ == even).sortWith(_ < _).take(index).toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8oj8ceio.scala:36)\n\tat Problem.main(tmp8oj8ceio.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n      \
    \      val smallest = evens.min\n            val index = evens.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (index == evens.length)\
    \ result\n            else result ++ pluck(arr.drop(index))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp23kb289n.scala:36:39\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (index\
    \ == evens.length) result\n\e[31m\e[31m   |\e[0m                             \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \ Found:    (result : List[AnyVal])\n\e[31m   |\e[0m                         \
    \              Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp23kb289n.scala:37:17 --------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33melse\e[0m result ++ pluck(arr.drop(index))\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                 Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e\
    [0m                 Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        if (evenSmallestIndexList.length == 1) {\n            val evenSmallestIndexListLength\
    \ = evenSmallestIndexList.length\n            val evenSmallestValueListLength\
    \ = evenSmallestValueList.length\n            if (evenSmallestIndexListLength\
    \ == evenSmallestValueListLength) {\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n                val evenSmallestIndexListLength\
    \ = evenSm\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp36sfcj5y.scala:75:0 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp36sfcj5y.scala:35:54\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp36sfcj5y.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmp36sfcj5y.scala:43:20 ---------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m                \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp36sfcj5y.scala:44:20 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp36sfcj5y.scala:45:2"
  stdout: ''
  timestamp: 1660009725
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) Nil\n\
    \        else result.take(index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqyop4d40.scala:38)\n\tat Problem.main(tmpqyop4d40.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009727
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(0)\n        val result = (List(even, index)).toList\n\
    \        if (arr.isEmpty) result\n        else pluck(arr.drop(index))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pmflq7h.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallest = evens.min\n        val index =\
    \ evens.indexOf(smallest)\n        val result = if (index == -1) List[Long]()\
    \ else List(smallest, index)\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvz9ohlrx.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009727
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = if (index == -1) List[Long]() else arr.take(index).reverse\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu1auut9l.scala:37)\n\tat Problem.main(tmpu1auut9l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) Nil else List(smallest, index)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2vls1p1.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortBy(x => x)\n    \
    \    val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n     \
    \   val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n      \
    \  val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n       \
    \ val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.last).toList\n        val evensSorted =\
    \ evensSorted.takeWhile(x => x < arr.last).toList\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.last).toList\n        val evensSorted = evensSorted.takeWhile(x =>\
    \ x < arr.last).toList\n        val evensSorted = evensSorted.takeWhile(x => x\
    \ < arr.last).toList\n        val evensSorted = evensSorted.takeWhile(x => x <\
    \ arr.last).toList\n        val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n \
    \       val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n  \
    \      val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n   \
    \     val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n    \
    \    val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n     \
    \   val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n      \
    \  val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n       \
    \ val evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.last).toList\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.last).toList\n        val evensSorted =\
    \ evensSorted.takeWhile(x => x < arr.last).toList\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvpy54wa0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.last).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvpy54wa0.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.last).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvpy54wa0.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.last).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvpy54wa0.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.last).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[3"
  stdout: ''
  timestamp: 1660009728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqjgabs_g.scala:39)\n\tat Problem.main(tmpqjgabs_g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evensSorted.isEmpty) {\n           \
    \ List[Long]()\n        } else {\n            evenSmallestValueList.zip(evenSmallestIndexList).filter(_._1\
    \ == evenSmallestValue).map(_._2)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps9jnq5hv.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmps9jnq5hv.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        arr.take(index).filter(_ % 2 == 0).min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9eu3yzkz.scala:33:8\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m        arr.take(index).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) Nil\n        else {\n         \
    \   val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val smalest_even = evens(smalest_index)\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = smalest_value\n      \
    \      val smalest_even_index = smalest_index\n            val smalest_even_value\
    \ = smalest_value\n            val smalest_even_index = smalest_index\n      \
    \      val smalest_even_value = smalest_value\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1st5t8ew.scala:73:36 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m\
    \   |\e[0m                                    expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1st5t8ew.scala:87:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1st5t8ew.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1st5t8ew.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1st5t8ew.scala:40:16 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1st5t8ew.scal"
  stdout: ''
  timestamp: 1660009729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmwb_omb_.scala:39)\n\tat Problem.main(tmpmwb_omb_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_).reverse\n        if (evens.isEmpty) List()\n        else\
    \ {\n            val smalest_value = evens.head\n            val smalest_index\
    \ = evens.indexOf(0)\n            val smalest_even = evens.takeWhile(_ < smalest_value).takeWhile(_\
    \ % 2 == 0).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).take\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvl0zo1xw.scala:49:0 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpvl0zo1xw.scala:30:50\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e\
    [0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I\
    \ could not infer the type of the parameter _$2 of expanded function:\n\e[31m\
    \   |\e[0m   _$2 => arr.filter(_$1 => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e\
    [31m-- Error: /tmp/tmpvl0zo1xw.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                                 ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpvl0zo1xw.scala:48:1 ---------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpvl0zo1xw.scala:37:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m37 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009729
