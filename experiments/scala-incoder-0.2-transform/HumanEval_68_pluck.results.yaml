language: scala
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     evens\n        } else {\n            evens.take(smalest_index + 1)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_29s6h7.scala:40)\n\tat Problem.main(tmpa_29s6h7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = if (index == -1) List(even) else List(even, index)\n   \
    \     result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk5kf2zm2.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).take(index).toList\n        if (result.isEmpty)\
    \ Nil\n        else result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcfw588rc.scala:38)\n\tat Problem.main(tmpcfw588rc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.head\n            val smalest_index = evens.indexOf(0)\n\
    \            val evens_without_smalest_value = evens.filterNot(x => x == smalest_value)\n\
    \            if (evens_without_smalest_value.isEmpty) List()\n            else\
    \ {\n                val smallest_even = evens_without_smalest_value.head\n  \
    \              val smallest_even_index = evens_without_smalest_value.indexOf(smallest_even)\n\
    \                val smallest_even_index_plus_one = smallest_even_index + 1\n\
    \                val smallest_even_index_plus_two = smallest_even_index + 2\n\
    \                val smallest_even_index_plus_three = smallest_even_index + 3\n\
    \                val smallest_even_index_plus_four = smallest_even_index + 4\n\
    \                val smallest_even_index_plus_five = smallest_even_index + 5\n\
    \                val smallest_even_index_plus_six = smallest_even_index + 6\n\
    \                val smallest_even_index_plus_seven = smallest_even_index + 7\n\
    \                val smallest_even_index_plus_eight = smallest_even_index + 8\n\
    \                val smallest_even_index_plus_nine = smallest_even_index + 9\n\
    \                val smallest_even_index_plus_ten = smallest_even_index + 10\n\
    \                val smallest_even_index_plus_eleven = smallest_even_index + 11\n\
    \                val smallest_even_index_plus_twelve = smallest_even_index + 12\n\
    \                val smallest_even_index_plus_thirteen = smallest_even_index +\
    \ 13\n                val smallest_even_index_plus_fourteen = smallest_even_index\
    \ + 14\n                val smallest_even_index_plus_fifteen = smallest_even_index\
    \ + 15\n                val smallest_even_index_plus_sixteen = smallest_even_index\
    \ + 16\n                val smallest_even_index_plus_seventeen = smallest_even_index\
    \ + 17\n                val smallest_even_index_plus_eighteen = smallest_even_index\
    \ + 18\n                val smallest_even_index_plus_nineteen = smallest_even_index\
    \ + 19\n                val smallest_even_index_plus_twenty = smallest_even_index\
    \ + 20\n                val smallest_even_index_plus_twenty_one = smallest_even_index\
    \ + 21\n                val smallest_even_index_plus_twenty_two = smallest_even_index\
    \ + 22\n                val smallest_even_index_plus_twenty_three = smallest_even_index\
    \ + 23\n                val smalle\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjjv4qus5.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjjv4qus5.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjjv4qus5.scala:76:1 ---------------------\e[0m\e[0m\n\
    \e[31m76 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpjjv4qus5.scala:65:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m65 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        if (evens.isEmpty) List()\n        else if (index == 0) List(even)\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.pluck(tmp7b1x43sq.scala:31)\n\
    \tat Problem$.main(tmp7b1x43sq.scala:40)\n\tat Problem.main(tmp7b1x43sq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(0)\n        val result = List(smallest, index)\n\
    \        if (evens.isEmpty) result\n        else result.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywg_v0eo.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywg_v0eo.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val min = evens.min\n            val index = arr.indexOf(min)\n  \
    \          val result = List(min, index)\n            if (evens.size == 1) result\n\
    \            else result :+ pluck(arr.filterNot(x => x == min))\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpovado2ej.scala:36:33\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.size\
    \ == \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                                 Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpovado2ej.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\
    \ :+ pluck(arr.filterNot(x => x == min))\n\e[31m\e[31m   |\e[0m              \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \           Found:    List[Matchable]\n\e[31m   |\e[0m                 Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        if (evens.isEmpty) {\n            List[Long]()\n        } else {\n  \
    \          List[Long](smallest, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk7x106ib.scala:41)\n\tat Problem.main(tmpk7x106ib.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        if (evens.isEmpty) List()\n        else List(smalest_value,\
    \ smalest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplmolq7gg.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = if (index == -1) List[Long]() else List(even, index)\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxvl6slf.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = smalest_index match {\n            case x if\
    \ x < arr.length => x\n            case _ => arr.length\n        }\n        val\
    \ smalest_even_value = smalest_even match {\n            case x if x < arr.length\
    \ => x\n            case _ => arr.length\n        }\n        val smalest_even_index\
    \ = smalest_index match {\n            case x if x < arr.length => x\n       \
    \     case _ => arr.length\n        }\n        val smalest_even_value = smalest_even\
    \ match {\n            case x if x < arr.length => x\n            case _ => arr.length\n\
    \        }\n        val smalest_even_index = smalest_index match {\n         \
    \   case x if x < arr.length => x\n            case _ => arr.length\n        }\n\
    \        val smalest_even_value = smalest_even match {\n            case x if\
    \ x < arr.length => x\n            case _ => arr.length\n        }\n        val\
    \ smalest_even_index = smalest_index match {\n            case x if x < arr.length\
    \ => x\n            case _ => arr.length\n        }\n        val smalest_even_value\
    \ = smalest_even match {\n            case x if x < arr.length => x\n        \
    \    case _ => arr.length\n        }\n        val smalest_even_index = smalest_index\
    \ match {\n            case x if x < arr.length => x\n            case _ => arr.length\n\
    \        }\n        val smalest_even_value = smalest_even match {\n          \
    \  case x if x < arr.length => x\n            case _ => arr.length\n        }\n\
    \        val smalest_even_index = smalest_index match {\n            case x if\
    \ x < arr.length => x\n            case _ => arr.length\n        }\n        val\
    \ smalest_even_value = smalest_even match {\n            case x if x < arr.length\
    \ => x\n            case _ => arr.length\n        }\n        val smalest_even_index\
    \ = smalest_index match {\n            case x if x < arr.length => x\n       \
    \     case _ => arr.length\n        }\n        val smalest_even_value = smalest_even\
    \ match {\n            case x if x < arr.length => x\n            case _ => arr.length\n\
    \        }\n        val smalest_even_index = smalest_index match {\n         \
    \   case x if x < arr.length => x\n            case _ => arr.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxcqnbosq.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpxcqnbosq.scala:106:0 ---------------------------\e[0m\e[0m\n\e[31m106\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxcqnbosq.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_index \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m43 |\e[0m         \
    \   \e[33mcase\e[0m x \e[33mif\e[0m x < arr.length => x\n\e[31m44 |\e[0m     \
    \       \e[33mcase\e[0m _ => arr.length\n\e[31m45 |\e[0m        }\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpxcqnbosq.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m47 |\e[0m         \
    \   \e[33mcase\e[0m x \e[33mif\e[0m x < arr.length => x\n\e[31m48 |\e[0m     \
    \       \e[33mcase\e[0m _ => arr.length\n\e[31m49 |\e[0m        }\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpxcqnbosq.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_index \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m51 |\e[0m         \
    \   \e[33mcase\e[0m x \e"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        if (evens.isEmpty) List()\n        else {\n   \
    \         val smalest_value = evens.head\n            val smalest_index = evens.indexOf(0)\n\
    \            val index = evens.indexOf(smalest_value)\n            if (index ==\
    \ -1) List()\n            else {\n                val smalest_even = evens(index)\n\
    \                val smalest_even_index = index\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val smalest_odd_value =\
    \ evens(smalest_odd_index)\n                val smalest_odd_index = evens.lastIndexOf(smalest_value)\n\
    \                val smalest_odd_value = evens(smalest_odd_index)\n          \
    \      val smalest_odd_index = evens.lastIndexOf(smalest_value)\n            \
    \    val smalest_odd_value = evens(smalest_odd_index)\n                val smalest_odd_index\
    \ = evens.lastIndexOf(smalest_value)\n                val sm\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpifp__dmk.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpifp__dmk.scala:79:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmpifp__dmk.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mAny\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[Any].\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpifp__dmk.scala:42:20 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m                \e[33mval\e[0m \e[36msmalest_odd_index\e[0m = evens.lastIndexOf(smalest_value)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_odd_index is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_odd_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpifp__dmk.scala:43:20 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                \e[33mval\e[0m \e[36msmalest_odd_value\e\
    [0m = evens(smalest_odd_index)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_odd_value is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_odd_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpifp_"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x == smalest_value)\n        if (smalest_evens.isEmpty) Nil\n        else smalest_evens.minIndex.map(x\
    \ => arr(x))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6gjg2ro3.scala:35:27 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m smalest_evens.minIndex.map(x\
    \ => arr(x))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             value minIndex is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = arr.indexOf(smallest)\n\
    \        val result = if (evens.isEmpty) Nil else List(smallest, index)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpibcnw784.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted =\
    \ evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_ < arr.max)\n \
    \       val evensSorted = evens\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8xqjoni6.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8xqjoni6.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mevensSorte"
  stdout: ''
  timestamp: 1659799054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedSortedWithIndex = evensSorted.zipWithIndex.toList\n\
    \        val smalest_value = evensSortedSortedWithIndex.head._2\n        val smalest_index\
    \ = evensSortedSortedWithIndex.head._1\n        val smalest_even = evensSortedSortedWithIndex.filter(x\
    \ => x._2 == smalest_value).head._1\n        val smalest_even_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 == smalest_value).head._2\n        val smalest_odd_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._1\n        val smalest_odd_value = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._2\n        val smalest_odd_even_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._3\n        val smalest_odd_odd_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._4\n        val smalest_odd_odd_value = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._5\n        val smalest_odd_odd_even_index =\
    \ evensSortedSortedWithIndex.filter(x => x._2 != smalest_value).head._6\n    \
    \    val smalest_odd_odd_odd_index = evensSortedSortedWithIndex.filter(x => x._2\
    \ != smalest_value).head._7\n        val smalest_odd_odd_odd_value = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._8\n        val smalest_odd_odd_odd_even_index\
    \ = evensSortedSortedWithIndex.filter(x => x._2 != smalest_value).head._9\n  \
    \      val smalest_odd_odd_odd_odd_index = evensSortedSortedWithIndex.filter(x\
    \ => x._2 != smalest_value).head._10\n        val smalest_odd_odd_odd_odd_value\
    \ = evensSortedSortedWithIndex.filter(x => x._2 != \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8q7ggjiu.scala:47:90 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36msmalest_odd_odd_odd_odd_value\e\
    [0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m => x._2 != \n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:39:104 -----------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_odd_even_index\e\
    [0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m => x._2 != smalest_value).head._3\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value _3 is not a member of (Long, Int) - did you mean (Long,\
    \ Int)._1?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:40:103\
    \ -----------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_odd_odd_index\e[0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m\
    \ => x._2 != smalest_value).head._4\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value _4 is not a member of (Long, Int) - did you mean (Long,\
    \ Int)._1?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:41:103\
    \ -----------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_odd_odd_value\e[0m = evensSortedSortedWithIndex.filter(\e[36mx\e[0m\
    \ => x._2 != smalest_value).head._5\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value _5 is not a member of (Long, Int) - did you mean (Long,\
    \ Int)._1?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8q7ggjiu.scala:42:108\
    \ -----------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36msma"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        if (evens.isEmpty) List()\n        else if (smalest_index\
    \ == 0) List(smalest_value)\n        else List(smalest_value, smalest_index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9perwq2.scala:38)\n\tat Problem.main(tmpn9perwq2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(_ != even).sortBy(x => x).takeWhile(x => x <\
    \ even).take(index).toList\n        if (result.isEmpty) result else result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl5zo01l4.scala:37)\n\tat Problem.main(tmpl5zo01l4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = if (index == -1) List[Long]() else List(even, index)\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyrkf3_ta.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n1 error found\n"
  stdout: ''
  timestamp: 1659799055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (evens.isEmpty) result\n\
    \        else (List(even, index), result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw_zy4aru.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m (List(even,\
    \ index), result)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    \e[1m\e[31m(\e[0mList[\e[1m\e[31mAnyVal\e\
    [0m\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0mLong]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799054
