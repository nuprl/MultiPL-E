{
  "language": "scala",
  "name": "HumanEval_159_eat",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsLeft = carrots - remaining\n        val needsLeft  = needs - remaining\n        val carrotEaten = carrots - carrotsLeft\n        val needEaten  = needs - needsLeft\n        val carrotEatenList = List(carrotEaten.toLong)\n        val needEatenList = List(needEaten.toLong)\n        val carrotLeftList = List(carrotsLeft.toLong)\n        val needLeftList = List(needLeft.toLong)\n        (carrotEatenList, needEatenList, carrotLeftList, needLeftList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp07yjvwpq.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp07yjvwpq.scala:41:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneedLeftList\u001b[0m = List(needLeft.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: needLeft\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp07yjvwpq.scala:42:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        (carrotEatenList, needEatenList, carrotLeftList, needLeftList)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  Found:    (List[Nothing], List[Nothing], List[Nothing], List[Nothing])\n\u001b[31m   |\u001b[0m  Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = List(needs_left, carrots_left)\n        meals.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpaud8b0bi.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659804746
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = remaining - carrots\n        val meals = carrots - need\n        val meals_left = carrots_left - meals\n        val meals_left_to_eat = (meals_left / meals).toInt\n        val meals_left_to_eat_2 = meals_left % meals\n        val meals_left_to_eat_3 = meals_left_to_eat + meals_left_to_eat_2\n        val meals_left_to_eat_4 = meals_left_to_eat_3 + meals_left_to_eat_3\n        val meals_left_to_eat_5 = meals_left_to_eat_4 + meals_left_to_eat_4\n        val meals_left_to_eat_6 = meals_left_to_eat_5 + meals_left_to_eat_5\n        val meals_left_to_eat_7 = meals_left_to_eat_6 + meals_left_to_eat_6\n        val meals_left_to_eat_8 = meals_left_to_eat_7 + meals_left_to_eat_7\n        val meals_left_to_eat_9 = meals_left_to_eat_8 + meals_left_to_eat_8\n        val meals_left_to_eat_10 = meals_left_to_eat_9 + meals_left_to_eat_9\n        val meals_left_to_eat_11 = meals_left_to_eat_10 + meals_left_to_eat_10\n        val meals_left_to_eat_12 = meals_left_to_eat_11 + meals_left_to_eat_11\n        val meals_left_to_eat_13 = meals_left_to_eat_12 + meals_left_to_eat_12\n        val meals_left_to_eat_14 = meals_left_to_eat_13 + meals_left_to_eat_13\n        val meals_left_to_eat_15 = meals_left_to_eat_14 + meals_left_to_eat_14\n        val meals_left_to_eat_16 = meals_left_to_eat_15 + meals_left_to_eat_15\n        val meals_left_to_eat_17 = meals_left_to_eat_16\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7ruyym17.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7ruyym17.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val carrots_needed = needs - carrots_left\n        val carrots_needed_to_eat = (carrots_needed / carrots).toInt\n        val carrots_left_to_eat = (carrots_needed % carrots).toInt\n        val carrots_to_eat = (carrots_left_to_eat + carrots_needed_to_eat).toInt\n        val carrots_to_eat_left = carrots_to_eat - carrots_needed\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed = (carrots_to_eat_left_to_eat / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat = (carrots_to_eat_left_to_eat_needed / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat_left = carrots_to_eat_left_to_eat_needed - carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_needed_to_eat / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed = (carrots_to_eat_left_to_eat_needed_to_eat_left / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed_to_eat = (carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed_to_eat_left = carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat - carrots_to_eat_left_to_eat_needed\n        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed = (carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed / carrots).toInt\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp6s373wsl.scala:49:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6s373wsl.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6s373wsl.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n        val left  = need - remaining\n        if(hungry <= 0) List(number.toLong)\n        else List(number.toLong, hungry.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnw6bkohe.scala:37)\n\tat Problem.main(tmpnw6bkohe.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659804750
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val remaining = remaining + meals\n        val mealsLeft = meals + carrots\n        val mealsRight = meals - carrots\n        val mealsLeft = mealsLeft.toString.toLong\n        val mealsRight = mealsRight.toString.toLong\n        List(mealsLeft, mealsRight)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm3yflj9u.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toString.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm3yflj9u.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsRight\u001b[0m = mealsRight.toString.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsRight is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsRight\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpm3yflj9u.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining + meals\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659804745
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left / needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n        val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n        val needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val carrots_left_to_eat_4 = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4 = (needs_left / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left / needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n        val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7 = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n        val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10 = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphwmzperf.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmphwmzperf.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphwmzperf.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphwmzperf.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots.toLong\n        val hungryMeals = meals.toLong\n        val hungryRemaining = remaining.toLong\n        val hungryRemainingCarrots = hungryRemaining - hungryCarrots\n        val hungryRemainingMeals = hungryRemaining - hungryMeals\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingCarrots\u001b[0m = hungryRemainingCarrots.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingMeals\u001b[0m = hungryRemainingMeals.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingCarrots\u001b[0m = hungryRemainingCarrots.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingMeals\u001b[0m = hungryRemainingMeals.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /t",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_minus_1 = (carrots_left - carrots_left_to_eat).toInt\n        val needs_left_to_eat_minus_1 = (needs_left - needs_left_to_eat).toInt\n        val carrots_left_to_eat_minus_2 = (carrots_left - carrots_left_to_eat_minus_1).toInt\n        val needs_left_to_eat_minus_2 = (needs_left - needs_left_to_eat_minus_1).toInt\n        val carrots_left_to_eat_minus_3 = (carrots_left - carrots_left_to_eat_minus_2).toInt\n        val needs_left_to_eat_minus_3 = (needs_left - needs_left_to_eat_minus_2).toInt\n        val carrots_left_to_eat_minus_4 = (carrots_left - carrots_left_to_eat_minus_3).toInt\n        val needs_left_to_eat_minus_4 = (needs_left - needs_left_to_eat_minus_3).toInt\n        val carrots_left_to_eat_minus_5 = (carrots_left - carrots_left_to_eat_minus_4).toInt\n        val needs_left_to_eat_minus_5 = (needs_left - needs_left_to_eat_minus_4).toInt\n        val carrots_left_to_eat_minus_6 = (carrots_left - carrots_left_to_eat_minus_5).toInt\n        val needs_left_to_eat_minus_6 = (needs_left - needs_left_to_eat_minus_5).toInt\n        val carrots_left_to_eat_minus_7 = (carrots_left - carrots_left_to_eat_minus_6).toInt\n        val needs_left_to_eat_minus_7 = (needs_left - needs_left_to_eat_minus_6).toInt\n        val carrots_left_to_eat_min\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5y5anzbf.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5y5anzbf.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5y5anzbf.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5y5anzbf.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n        val hungryRemaining = remaining - hungry\n        if (hungryRemaining < 0l) {\n            val hungryRemainingList = List(hungryRemaining.toLong)\n            hungryRemainingList :+ 0l.toLong\n        } else {\n            val hungryRemainingList = List(hungryRemaining.toLong)\n            hungryRemainingList :+ hungry.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7uap1al4.scala:42)\n\tat Problem.main(tmp7uap1al4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659804750
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_after_meals = carrots_left - needs_left\n        val needs_left_after_meals = needs_left - carrots_left\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals - needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals - needs_left_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meal\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsn65h1to.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:44:87 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:45:85 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /t",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result: List[Long] = new ArrayList[Long]()\n        var carrots_left = remaining\n        var carrots_eaten = 0\n        var carrots_left_after_meals = 0\n        var carrots_eaten_after_meals = 0\n        var carrots_left_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcp0juv87.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcp0juv87.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcp0juv87.scala:34:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcp0juv87.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result: List[Long] = new ArrayList[Long]()\n        val carrots_remaining = remaining - carrots\n        val needs_remaining = carrots_remaining - needs\n        val carrots_needs = carrots - needs\n        val needs_carrots = needs - carrots\n        val carrots_remaining_needs = carrots_remaining - needs_remaining\n        val needs_remaining_carrots = needs_remaining - carrots_remaining\n        val needs_carrots_remaining = needs_carrots - carrots_remaining\n        val needs_carrots_needs = needs_carrots - needs_carrots\n        val needs_carrots_remaining_needs = needs_carrots_remaining - needs_remaining_carrots\n        val needs_carrots_needs_remaining = needs_carrots_needs - needs_carrots_remaining\n        val needs_carrots_needs_remaining_needs = needs_carrots_needs_remaining - needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_remaining = needs_carrots_needs_needs_remaining - needs_needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_needs_remaining = needs_carrots_needs_needs_needs_remaining - needs_needs_needs_needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_needs_needs_remaining = needs_carrots_needs_needs_needs_needs_remaining - needs_needs_needs_needs_needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_needs_needs_remaining = needs_carrots_needs_needs_needs_needs_needs_remaining - needs_needs_needs_needs_needs_needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_needs_needs_needs_remaining = needs_carrots_needs_needs_needs_needs_needs_needs_needs_remaining - needs_needs_needs_needs_needs_needs_needs_needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_needs_needs_need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpohs0tcke.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpohs0tcke.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_carrots_needs_needs_needs_needs_remaining\u001b[0m = needs_carrots_needs_needs_needs_needs_needs_remaining - needs_needs_needs_needs_needs_needs_needs_remaining_carrots\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_carrots_needs_needs_needs_needs_remaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_carrots_needs_needs_needs_needs_remaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpohs0tcke.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpohs0tcke.scala:34:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpohs0tcke.scala:46:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_carrots_needs_needs_remaining\u001b[0m = needs_carrots_needs_needs_remaining",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat = (needs_left / carrots).toInt\n        val needs_left_to_eat = (carrots_left / needs).toInt\n        val carrots_left_to_eat_left = carrots_left - carrots_left_to_eat * carrots\n        val needs_left_to_eat_left = carrots_left - needs_left_to_eat * needs\n        val carrots_left_to_eat_left_to_eat = (needs_left_to_eat_left / carrots).toInt\n        val needs_left_to_eat_left_to_eat = (carrots_left_to_eat_left / needs).toInt\n        val carrots_left_to_eat_left_to_eat_left = carrots_left_to_eat_left - carrots_left_to_eat_left_to_eat * carrots\n        val needs_left_to_eat_left_to_eat_left = carrots_left_to_eat_left - needs_left_to_eat_left_to_eat * needs\n        val carrots_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left / carrots).toInt\n        val needs_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat_left / needs).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left * carrots\n        val needs_left_to_eat_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat_left - needs_left_to_eat_left_to_eat_left * needs\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left_to_eat / carrots).toInt\n        val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat_left_to_eat / needs)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0lxfhjjz.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0lxfhjjz.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0lxfhjjz.scala:51:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining <= 0) {\n            result ++= List(number.toLong)\n        } else {\n            val carrots_left = carrots - remaining\n            val needs_left = needs - remaining\n            result ++= List(needs_left.toLong, carrots_left.toLong)\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpp4yey2_4.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp4yey2_4.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659804745
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsNeeded = needs - remaining\n        val carrotsNeededList = List(carrotsNeeded)\n        val carrotsNeededList2 = List(carrotsNeeded)\n        val carrotsNeededList3 = List(carrotsNeeded)\n        val carrotsNeededList4 = List(carrotsNeeded)\n        val carrotsNeededList5 = List(carrotsNeeded)\n        val carrotsNeededList6 = List(carrotsNeeded)\n        val carrotsNeededList7 = List(carrotsNeeded)\n        val carrotsNeededList8 = List(carrotsNeeded)\n        val carrotsNeededList9 = List(carrotsNeeded)\n        val carrotsNeededList10 = List(carrotsNeeded)\n        val carrotsNeededList11 = List(carrotsNeeded)\n        val carrotsNeededList12 = List(carrotsNeeded)\n        val carrotsNeededList13 = List(carrotsNeeded)\n        val carrotsNeededList14 = List(carrotsNeeded)\n        val carrotsNeededList15 = List(carrotsNeeded)\n        val carrotsNeededList16 = List(carrotsNeeded)\n        val carrotsNeededList17 = List(carrotsNeeded)\n        val carrotsNeededList18 = List(carrotsNeeded)\n        val carrotsNeededList19 = List(carrotsNeeded)\n        val carrotsNeededList20 = List(carrotsNeeded)\n        val carrotsNeededList21 = List(carrotsNeeded)\n        val carrotsNeededList22 = List(carrotsNeeded)\n        val carrotsNeededList23 = List(carrotsNeeded)\n        val carrotsNeededList24 = List(carrotsNeeded)\n        val carrotsNeededList25 = List(carrotsNeeded)\n        val carrotsNeededList26 = List(c\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1v4xd11x.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1v4xd11x.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1v4xd11x.scala:60:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsNeededList26\u001b[0m = List(c\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1v4xd11x.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        var carrots_left = 0\n        var meals_left = 0\n        var i = 0\n        while (i < carrots && carrots_left < meals) {\n            carrots_left += number\n            meals_left += need\n            i += 1\n        }\n        if (meals_left > carrots) {\n            carrots_left = carrots - meals_left\n        }\n        result(0) = carrots_left\n        result(1) = meals_left\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmppixurz3f.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppixurz3f.scala:39:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            carrots_left += number\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppixurz3f.scala:40:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            meals_left += need\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppixurz3f.scala:48:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n        val carrots_to_eat = carrots_left_to_eat + needs_left_to_eat\n        val needs_to_eat = needs_left_to_eat + carrots_left_to_eat\n        val carrots_to_eat2 = carrots_to_eat.toInt\n        val needs_to_eat2 = needs_to_eat.toInt\n        val carrots_to_eat3 = carrots_to_eat2 * carrots_to_eat2\n        val needs_to_eat3 = needs_to_eat2 * needs_to_eat2\n        val carrots_to_eat4 = carrots_to_eat3 * carrots_to_eat3\n        val needs_to_eat4 = needs_to_eat3 * needs_to_eat3\n        val carrots_to_eat5 = carrots_to_eat4 * carrots_to_eat4\n        val needs_to_eat5 = needs_to_eat4 * needs_to_eat4\n        val carrots_to_eat6 = carrots_to_eat5 * carrots_to_eat5\n        val needs_to_eat6 = needs_to_eat5 * needs_to_eat5\n        val carrots_to_eat7 = carrots_to_eat6 * carrots_to_eat6\n        val needs_to_eat7 = needs_to_eat6 * needs_to_eat6\n        val carrots_to_eat8 = carrots_to_eat7 * carrots_to_eat7\n        val needs_to_eat8 = needs_to_eat7 * needs_to_eat7\n        val carrots_to_eat9 = carrots_to_eat8 * carrots_to_eat8\n        val needs_to_eat9 = needs_to_eat8 * needs_to_eat8\n        val carrots_to_eat10 = carrots_to_eat9 * carrots_to_eat9\n        val needs_to_eat10 = needs_to_eat9 * needs_to_eat9\n        val carrots_to_eat11 = carrots_to_eat10 * carrots_to_eat10\n        val needs_to_eat11 = needs_to_eat10 * needs_to_eat10\n        val carrots_to_eat12 = carrots_to_eat11 * carrots_to_eat11\n        val needs_to_eat12 = needs_to_eat11 * needs_to_eat11\n        val carrots_to_eat13 = carrots_to_eat12\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpp66c3oov.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp66c3oov.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp66c3oov.scala:64:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result: List[Long] = new ArrayList[Long]()\n        if (remaining < needs) {\n            val carrots_left = carrots - remaining\n            val carrots_left_to_eat = (needs - remaining).toInt\n            val carrots_to_eat = (carrots_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left = carrots_to_eat - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat = (carrots_to_eat_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp2l_1mla.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp2l_1mla.scala:61:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpp2l_1mla.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp2l_1mla.scala:34:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp2l_1mla.scala:60:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpp2l_1mla.scala:51:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m51 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = needToEat - remainingToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        if (carrotLeftToEatList.size < needToEat) {\n            carrotLeftToEatList.take(needToEat.toInt)\n        } else {\n            carrotLeftToEatList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpktuud_ii.scala:44)\n\tat Problem.main(tmpktuud_ii.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659804750
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        val meals = List(need + carrots)\n        val hungry = List(need + carrots, remaining + carrots)\n        if (remaining <= 0) {\n            hungry\n        } else {\n            meals :: eat(number, need, remaining)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpoq9h8b59.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoq9h8b59.scala:38:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            meals :: eat(number, need, remaining)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (meals : List[Long])\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010249
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val meals_left = carrots - meals\n        val carrots_left_to_eat = (carrots_left - meals_left).toInt\n        val meals_left_to_eat = (meals_left - carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left - meals_left_to_eat).toInt\n        val meals_left_to_eat_2 = (meals_left_to_eat - carrots_left_to_eat).toInt\n        val carrots_left_to_eat_3 = (carrots_left_to_eat_2 - meals_left_to_eat_2).toInt\n        val meals_left_to_eat_3 = (meals_left_to_eat_2 - carrots_left_to_eat_2).toInt\n        val carrots_left_to_eat_4 = (carrots_left_to_eat_3 - meals_left_to_eat_3).toInt\n        val meals_left_to_eat_4 = (meals_left_to_eat_3 - carrots_left_to_eat_3).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4 - meals_left_to_eat_4).toInt\n        val meals_left_to_eat_5 = (meals_left_to_eat_4 - carrots_left_to_eat_4).toInt\n        val carrots_left_to_eat_6 = (carrots_left_to_eat_5 - meals_left_to_eat_5).toInt\n        val meals_left_to_eat_6 = (meals_left_to_eat_5 - carrots_left_to_eat_5).toInt\n        val carrots_left_to_eat_7 = (carrots_left_to_eat_6 - meals_left_to_eat_6).toInt\n        val meals_left_to_eat_7 = (meals_left_to_eat_6 - carrots_left_to_eat_6).toInt\n        val carrots_left_to_eat_8 = (carrots_left_to_eat_7 - meals_left_to_eat_7).toInt\n        val meals_left_to_eat_8 = (meals_left_to_eat_7\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyzavuf0p.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyzavuf0p.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyzavuf0p.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyzavuf0p.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010248
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = carrots_left - carrots_left_to_eat * needs_left\n        val needs_left_to_eat_2 = needs_left - needs_left_to_eat * carrots_left\n        val carrots_left_to_eat_3 = carrots_left - carrots_left_to_eat * needs_left_2\n        val needs_left_to_eat_3 = needs_left - needs_left_to_eat * carrots_left_2\n        val carrots_left_to_eat_4 = carrots_left - carrots_left_to_eat * needs_left_3\n        val needs_left_to_eat_4 = needs_left - needs_left_to_eat * carrots_left_3\n        val carrots_left_to_eat_5 = carrots_left - carrots_left_to_eat * needs_left_4\n        val needs_left_to_eat_5 = needs_left - needs_left_to_eat * carrots_left_4\n        val carrots_left_to_eat_6 = carrots_left - carrots_left_to_eat * needs_left_5\n        val needs_left_to_eat_6 = needs_left - needs_left_to_eat * carrots_left_5\n        val carrots_left_to_eat_7 = carrots_left - carrots_left_to_eat * needs_left_6\n        val needs_left_to_eat_7 = needs_left - needs_left_to_eat * carrots_left_6\n        val carrots_left_to_eat_8 = carrots_left - carrots_left_to_eat * needs_left_7\n        val needs_left_to_eat_8 = needs_left - needs_left_to_eat * carrots_left_7\n        val carrots_left_to_eat_9 = carrots_left - carrots_left_to_eat * needs_left_8\n        val needs_left_to_eat_9 = needs_left - needs_left_to_eat * carrots_left_8\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmlcy308r.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmlcy308r.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmlcy308r.scala:56:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010248
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n        val left  = need.toInt\n        val total = hungry + left\n        val remaining = total - hungry\n        val result = if (remaining <= 0) List(number.toLong) else List(number.toLong, remaining.toLong)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp305pvalz.scala:39)\n\tat Problem.main(tmp305pvalz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010251
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val lefts = remaining - needs\n        if (meals > 0) {\n            List(meals.toLong, lefts.toLong)\n        } else {\n            List(meals.toLong, 0l.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmprxs0kwox.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010241
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - need\n        val remaining = remaining - meals\n        val mealsLeft = meals - remaining\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrots - mealsLeft\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp0jivfgmz.scala:72:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0jivfgmz.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - meals\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0jivfgmz.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0jivfgmz.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsLeft\u001b[0m = carrotsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrotsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrotsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0jivfgmz.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m--",
      "stdout": "",
      "timestamp": 1660010249
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - need\n        val carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n        val carrots_to_eat = carrots_left_to_eat + needs_left_to_eat\n        val needs_to_eat = needs_left_to_eat + carrots_left_to_eat\n        val carrots_to_eat2 = carrots_to_eat.toInt\n        val needs_to_eat2 = needs_to_eat.toInt\n        val carrots_to_eat3 = carrots_to_eat2 * carrots_to_eat2\n        val needs_to_eat3 = needs_to_eat2 * needs_to_eat2\n        val carrots_to_eat4 = carrots_to_eat3 * carrots_to_eat3\n        val needs_to_eat4 = needs_to_eat3 * needs_to_eat3\n        val carrots_to_eat5 = carrots_to_eat4 * carrots_to_eat4\n        val needs_to_eat5 = needs_to_eat4 * needs_to_eat4\n        val carrots_to_eat6 = carrots_to_eat5 * carrots_to_eat5\n        val needs_to_eat6 = needs_to_eat5 * needs_to_eat5\n        val carrots_to_eat7 = carrots_to_eat6 * carrots_to_eat6\n        val needs_to_eat7 = needs_to_eat6 * needs_to_eat6\n        val carrots_to_eat8 = carrots_to_eat7 * carrots_to_eat7\n        val needs_to_eat8 = needs_to_eat7 * needs_to_eat7\n        val carrots_to_eat9 = carrots_to_eat8 * carrots_to_eat8\n        val needs_to_eat9 = needs_to_eat8 * needs_to_eat8\n        val carrots_to_eat10 = carrots_to_eat9 * carrots_to_eat9\n        val needs_to_eat10 = needs_to_eat9 * needs_to_eat9\n        val carrots_to_eat11 = carrots_to_eat10 * carrots_to_eat10\n        val needs_to_eat11 = needs_to_eat10 * needs_to_eat10\n        val carrots_to_eat12 = carrots_to_eat11 * carrots_to_eat11\n        val needs_to_eat12 = needs_to_eat11 * needs_to_eat11\n        val carrots_to_eat13 = carrots_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp87h4ede_.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp87h4ede_.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp87h4ede_.scala:63:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_to_eat13\u001b[0m = carrots_to_\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: carrots_to_\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp87h4ede_.scala:64:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010249
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList, carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjd074aux.scala:38:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        (carrotEatenList, carrotLeftToEatList)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0mList[Long\u001b[1m\u001b[31m]\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0m\u001b[1m\u001b[31mLong\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n        result :: eat(remaining, need, carrots)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2cpzuzp1.scala:34:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        result :: eat(remaining, need, carrots)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : List[Long])\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val hungry = meals > 0\n        val left = (meals - needs).toInt\n        val result = if (hungry) List(meals, left) else List(meals)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpchdb6jvj.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010242
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        val result = List(carrots, remaining)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpu3khxp34.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010242
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val carrots_left_to_eat = (carrots_left - needs).toInt\n        val carrots_to_eat = (carrots_left_to_eat + needs).toInt\n        val carrots_to_eat_left = carrots_to_eat - carrots_left\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left + carrots_left_to_eat).toInt\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - carrots_to_eat_left\n        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left + carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left + carrots_to_eat_left_to_eat_left_to_eat).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat + carrots_to_eat_left_to_eat_left_to_eat_left_to_eat).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left + carrots_to_eat_left_to_eat_left_to_eat_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfynk11bn.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpfynk11bn.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfynk11bn.scala:47:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010248
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n        val rest = remaining - need\n        val hungryList = List(hungry.toLong)\n        val restList = List(rest.toLong)\n        if (hungry > 0) {\n            hungryList :+ hungry\n        }\n        if (rest > 0) {\n            restList :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList :+ 0\n        }\n        if (hungry == 0 && rest > 0) {\n            restList :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList :+ 0\n            restList :+ 0\n        }\n        if (hungry > 0 && rest == 0) {\n            hungryList :+ hungry\n        }\n        if (hungry == 0 && rest > 0) {\n            restList :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList :+ hungry\n            restList :+ rest\n        }\n        if (hungry > 0 && rest == 0) {\n            hungryList :+ hungry\n        }\n        if (hungry == 0 && rest > 0) {\n            restList :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList :+ hungry\n            restList :+ rest\n        }\n        if (hungry > 0 && rest == 0) {\n            hungryList :+ hungry\n        }\n        if (hungry == 0 && rest > 0) {\n            restList :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList :+ hungry\n            restList :+ rest\n        }\n        if (hungry > 0 && rest == 0) {\n            hungryList :+ hungry\n        }\n        if (hungry == 0 && rest > 0) {\n            restList :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList :+ \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpb6ahia6h.scala:100:25 --------------------------\u001b[0m\u001b[0m\n\u001b[31m100 |\u001b[0m            hungryList :+ \n\u001b[31m\u001b[31m    |\u001b[0m                         ^\u001b[0m\n\u001b[31m    |\u001b[0m                         expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb6ahia6h.scala:112:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m112 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb6ahia6h.scala:111:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m111 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m    |\u001b[0m Required: List[Long]\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpb6ahia6h.scala:102:4 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[33m102 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m    |\u001b[0m    ^\u001b[0m\n\u001b[33m    |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010251
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n        val left  = remaining - need\n        if (hungry < 0) left else hungry\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9u7b_sjl.scala:33:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (hungry < \u001b[31m0\u001b[0m) left \u001b[33melse\u001b[0m hungry\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (left : Long)\n\u001b[31m   |\u001b[0m                        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9u7b_sjl.scala:33:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (hungry < \u001b[31m0\u001b[0m) left \u001b[33melse\u001b[0m hungry\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (hungry : Long)\n\u001b[31m   |\u001b[0m                                  Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val need_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / need_left).toInt\n        val need_left_to_eat = (need_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left / need_left_to_eat).toInt\n        val need_left_to_eat_2 = (need_left / carrots_left_to_eat).toInt\n        val carrots_left_to_eat_3 = (carrots_left / need_left_to_eat_2).toInt\n        val need_left_to_eat_3 = (need_left / carrots_left_to_eat_2).toInt\n        val carrots_left_to_eat_4 = (carrots_left / need_left_to_eat_3).toInt\n        val need_left_to_eat_4 = (need_left / carrots_left_to_eat_3).toInt\n        val carrots_left_to_eat_5 = (carrots_left / need_left_to_eat_4).toInt\n        val need_left_to_eat_5 = (need_left / carrots_left_to_eat_4).toInt\n        val carrots_left_to_eat_6 = (carrots_left / need_left_to_eat_5).toInt\n        val need_left_to_eat_6 = (need_left / carrots_left_to_eat_5).toInt\n        val carrots_left_to_eat_7 = (carrots_left / need_left_to_eat_6).toInt\n        val need_left_to_eat_7 = (need_left / carrots_left_to_eat_6).toInt\n        val carrots_left_to_eat_8 = (carrots_left / need_left_to_eat_7).toInt\n        val need_left_to_eat_8 = (need_left / carrots_left_to_eat_7).toInt\n        val carrots_left_to_eat_9 = (carrots_left / need_left_to_eat_8).toInt\n        val need_left_to_eat_9 = (need_left / carrots_left_to_eat_8).toInt\n        val carrots_left_to_eat_10 = (carrots_left / need_left_to_eat_9).toInt\n        val need_left_to_eat_10 = (need_left / carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp465tpa5z.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp465tpa5z.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp465tpa5z.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp465tpa5z.scala:57:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val leftCarrots = remaining - carrots\n        val result = List(carrots, leftCarrots)\n        if (leftCarrots > 0) {\n            val newRemaining = remaining - carrots\n            val newNumber = number + need\n            val newNeed = newNumber - newRemaining\n            val newResult = eat(newNumber, newNeed, remaining)\n            result ::: newResult\n        } else {\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjcq583eq.scala:45)\n\tat Problem.main(tmpjcq583eq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010251
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        val meals = List(number - carrots, carrots)\n        if (remaining <= 0) meals :: Nil\n        else meals :: eat(remaining, need, carrots)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1uk4set7.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1uk4set7.scala:34:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mif\u001b[0m (remaining <= \u001b[31m0\u001b[0m) meals :: Nil\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (meals : List[Long])\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1uk4set7.scala:35:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33melse\u001b[0m meals :: eat(remaining, need, carrots)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (meals : List[Long])\n\u001b[31m   |\u001b[0m             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010251
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsLeft = carrots - remaining\n        val needsToEat = needs - remaining\n        val meals = List(needsToEat.toLong, carrotsLeft.toLong)\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt63otimn.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010242
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val result: List[Long] = new ArrayList[Long]()\n        val carrotEaten = remainingToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotLeftToEat2 = carrots - carrotEaten - carrotLeftToEat\n        val carrotLeftToEat3 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2\n        val carrotLeftToEat4 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3\n        val carrotLeftToEat5 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4\n        val carrotLeftToEat6 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4 - carrotLeftToEat5\n        val carrotLeftToEat7 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4 - carrotLeftToEat5 - carrotLeftToEat6\n        val carrotLeftToEat8 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4 - carrotLeftToEat5 - carrotLeftToEat6 - carrotLeftToEat7\n        val carrotLeftToEat9 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4 - carrotLeftToEat5 - carrotLeftToEat6 - carrotLeftToEat7 - carrotLeftToEat8\n        val carrotLeftToEat10 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToE\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiyzu7h7k.scala:34:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiyzu7h7k.scala:45:74 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEat10\u001b[0m = carrots - carrotEaten - carrotLeftToEat - carrotLeftToE\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: carrotLeftToE\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiyzu7h7k.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010249
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val lefts = carrots - meals\n        if (meals > 0) {\n            List(meals.toLong, lefts.toLong)\n        } else {\n            List(meals.toLong, needs.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpd2isuo1v.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010241
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_le",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n        val carrots_left_to_eat2 = carrots_left_to_eat * carrots_left_to_eat\n        val needs_left_to_eat2 = needs_left_to_eat * needs_left_to_eat\n        val carrots_left_to_eat3 = carrots_left_to_eat2 * carrots_left_to_eat\n        val needs_left_to_eat3 = needs_left_to_eat2 * needs_left_to_eat\n        val carrots_left_to_eat4 = carrots_left_to_eat3 * carrots_left_to_eat\n        val needs_left_to_eat4 = needs_left_to_eat3 * needs_left_to_eat\n        val carrots_left_to_eat5 = carrots_left_to_eat4 * carrots_left_to_eat\n        val needs_left_to_eat5 = needs_left_to_eat4 * needs_left_to_eat\n        val carrots_left_to_eat6 = carrots_left_to_eat5 * carrots_left_to_eat\n        val needs_left_to_eat6 = needs_left_to_eat5 * needs_left_to_eat\n        val carrots_left_to_eat7 = carrots_left_to_eat6 * carrots_left_to_eat\n        val needs_left_to_eat7 = needs_left_to_eat6 * needs_left_to_eat\n        val carrots_left_to_eat8 = carrots_left_to_eat7 * carrots_left_to_eat\n        val needs_left_to_eat8 = needs_left_to_eat7 * needs_left_to_eat\n        val carrots_left_to_eat9 = carrots_left_to_eat8 * carrots_left_to_eat\n        val needs_left_to_eat9 = needs_left_to_eat8 * needs_left_to_eat\n        val carrots_left_to_eat10 = carrots_left_to_eat9 * carrots_left_to_eat\n        val needs_left_to_eat10 = needs_left_to_eat9 * needs_left_to_eat\n        val carrots_left_to_eat11 = carrots_left_to_eat10 * carrots_left_to_eat\n        val need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppdimsarf.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppdimsarf.scala:32:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds\u001b[0m = need.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m  import math.BigInt.javaBigInteger2bigInt\n\u001b[31m   |\u001b[0m  import math.Numeric.BigDecimalAsIfIntegral.mkNumericOps\n\u001b[31m   |\u001b[0m  import math.Numeric.BigDecimalIsFractional.mkNumericOps\n\u001b[31m   |\u001b[0m  import math.Numeric.BigIntIsIntegral.mkNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmppdimsarf.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppdimsarf.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppdimsarf.scala:59:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 ",
      "stdout": "",
      "timestamp": 1660010251
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val needs_left_to_eat = (needs_left - carrots_left).toInt\n        val carrots_to_eat = if (carrots_left_to_eat > 0) carrots_left_to_eat else 0\n        val needs_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 0\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp61dkk2ic.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp61dkk2ic.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_to_eat\u001b[0m = (carrots_to_eat * needs_to_eat).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp61dkk2ic.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_to_eat\u001b[0m = (needs_to_eat * carrots_to_eat).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp61dkk2ic.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_to_eat\u001b[0m = (carrots_to_eat * needs_to_eat).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp61dkk2ic.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_to_eat\u001b[0m = (needs_to_eat * carrots_to_eat).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m",
      "stdout": "",
      "timestamp": 1660010249
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_right_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_right_right_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_right_right_right_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_right_right_right_right_right_right_right_left = List(need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9fcoumk_.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9fcoumk_.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9fcoumk_.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left_to_eat * carrots_left_to_eat).toInt\n        val needs_left_to_eat_2 = (needs_left_to_eat * needs_left_to_eat).toInt\n        val carrots_left_to_eat_3 = (carrots_left_to_eat_2 * carrots_left_to_eat_2).toInt\n        val needs_left_to_eat_3 = (needs_left_to_eat_2 * needs_left_to_eat_2).toInt\n        val carrots_left_to_eat_4 = (carrots_left_to_eat_3 * carrots_left_to_eat_3).toInt\n        val needs_left_to_eat_4 = (needs_left_to_eat_3 * needs_left_to_eat_3).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4 * carrots_left_to_eat_4).toInt\n        val needs_left_to_eat_5 = (needs_left_to_eat_4 * needs_left_to_eat_4).toInt\n        val carrots_left_to_eat_6 = (carrots_left_to_eat_5 * carrots_left_to_eat_5).toInt\n        val needs_left_to_eat_6 = (needs_left_to_eat_5 * needs_left_to_eat_5).toInt\n        val carrots_left_to_eat_7 = (carrots_left_to_eat_6 * carrots_left_to_eat_6).toInt\n        val needs_left_to_eat_7 = (needs_left_to_eat_6 * needs_left_to_eat_6).toInt\n        val carrots_left_to_eat_8 = (carrots_left_to_eat_7 * carrots_left_to_eat_7).toInt\n        val needs_left_to_eat_8 = (needs_left_to_eat_7 * needs_left_to_eat_7).toInt\n        val carrots_left_to_eat_9 = (carrots_left_to_eat_8 * car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnwva9ivg.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnwva9ivg.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnwva9ivg.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnwva9ivg.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010262
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - needs\n        val needs_left_carrots = needs_left.toInt\n        val needs_left_carrots_left = needs_left_carrots - 1\n        val needs_left_carrots_left_carrots = needs_left_carrots_left.toInt\n        val needs_left_carrots_left_carrots_left = needs_left_carrots_left_carrots - 1\n        val needs_left_carrots_left_carrots_left_carrots = needs_left_carrots_left_carrots_left.toInt\n        val needs_left_carrots_left_carrots_left_carrots_carrots = needs_left_carrots_left_carrots_left_carrots_left.toInt\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpphwbf_9k.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpphwbf_9k.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpphwbf_9k.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpphwbf_9k.scala:42:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_carrots_left_carrots_left_carrots_carrots\u001b[0m = needs_left_carrots_left_carrots_left_carrots_left.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: needs_left_carrots_left_carrots_left_carrots_left\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpphwbf_9k.scala:43:75 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_carrots_left_carrots_left_carrots_carrots_carrots\u001b[0m = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: needs_left_carrots_lef",
      "stdout": "",
      "timestamp": 1660010263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_in_stock = carrots_left.toLong\n        val needs_left_in_stock = needs_left.toLong\n        val carrots_left_in_stock2 = carrots_left_in_stock * carrots_left_in_stock\n        val needs_left_in_stock2 = needs_left_in_stock * needs_left_in_stock\n        val carrots_left_in_stock3 = carrots_left_in_stock2 * carrots_left_in_stock\n        val needs_left_in_stock3 = needs_left_in_stock2 * needs_left_in_stock\n        val carrots_left_in_stock4 = carrots_left_in_stock3 * carrots_left_in_stock\n        val needs_left_in_stock4 = needs_left_in_stock3 * needs_left_in_stock\n        val carrots_left_in_stock5 = carrots_left_in_stock4 * carrots_left_in_stock\n        val needs_left_in_stock5 = needs_left_in_stock4 * needs_left_in_stock\n        val carrots_left_in_stock6 = carrots_left_in_stock5 * carrots_left_in_stock\n        val needs_left_in_stock6 = needs_left_in_stock5 * needs_left_in_stock\n        val carrots_left_in_stock7 = carrots_left_in_stock6 * carrots_left_in_stock\n        val needs_left_in_stock7 = needs_left_in_stock6 * needs_left_in_stock\n        val carrots_left_in_stock8 = carrots_left_in_stock7 * carrots_left_in_stock\n        val needs_left_in_stock8 = needs_left_in_stock7 * needs_left_in_stock\n        val carrots_left_in_stock9 = carrots_left_in_stock8 * carrots_left_in_stock\n        val needs_left_in_stock9 = needs_left_in_stock8 * needs_left_in_stock\n        val carrots_left_in_stock10 = carrots_left_in_stock9 * carrots_left_in_stock\n        val needs_left_in_stock10 = needs_left_in_stock9 * needs_left_in_stock\n        val carrots_left_in_stock11 = carrots_left_in_stock10 * carrots_left_in_stock\n        val needs_left_in_stock11 = needs_left_in_stock10 * needs_left_in_stock\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcbjemg8n.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcbjemg8n.scala:59:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val carrots_left_to_eat = (needs - carrots).toInt\n        val carrots_left_to_eat_max = carrots_left - carrots_left_to_eat\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left_to_eat_max\n        val carrots_left_to_eat_max_index = carrots_left_to_eat - 1\n        val carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_max_value = carrots_left_to_eat_max\n        val carrots_left_to_eat_min_value = carrots_left_to_eat_min\n        val carrots_left_to_eat_max_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_max_value = carrots_left_to_eat_max\n        val carrots_left_to_eat_min_value = carrots_left_to_eat_min\n        val carrots_left_to_eat_max_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_max_value = carrots_left_to_eat_max\n        val carrots_left_to_eat_min_value = carrots_left_to_eat_min\n        val carrots_left_to_eat_max_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_max_value = carrots_left_to_eat_max\n        val carrots_left_to_eat_min_value = carrots_left_to_eat_min\n        val carrots_left_to_eat_max_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_max_value = carrots_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_max_index\u001b[0m = carrots_left_to_eat_max + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_max_index is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_max_index\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_min_index\u001b[0m = carrots_left_to_eat_max + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_min_index is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_min_index\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_max_value\u001b[0m = carrots_left_to_eat_max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_max_value is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_max_value\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_min_value\u001b[0m = carrots_left_to_eat_min\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_min_value is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_min_value\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote ",
      "stdout": "",
      "timestamp": 1660010262
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val meals_left = meals - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list_2 = List(carrots_left.toLong)\n        val meals_left_list_2 = List(meals_left.toLong)\n        val carrots_left_list_3 = List(carrots_left.toLong)\n        val meals_left_list_3 = List(meals_left.toLong)\n        val carrots_left_list_4 = List(carrots_left.toLong)\n        val meals_left_list_4 = List(meals_left.toLong)\n        val carrots_left_list_5 = List(carrots_left.toLong)\n        val meals_left_list_5 = List(meals_left.toLong)\n        val carrots_left_list_6 = List(carrots_left.toLong)\n        val meals_left_list_6 = List(meals_left.toLong)\n        val carrots_left_list_7 = List(carrots_left.toLong)\n        val meals_left_list_7 = List(meals_left.toLong)\n        val carrots_left_list_8 = List(carrots_left.toLong)\n        val meals_left_list_8 = List(meals_left.toLong)\n        val carrots_left_list_9 = List(carrots_left.toLong)\n        val meals_left_list_9 = List(meals_left.toLong)\n        val carrots_left_list_10 = List(carrots_left.toLong)\n        val meals_left_list_10 = List(meals_left.toLong)\n        val carrots_left_list_11 = List(carrots_left.toLong)\n        val meals_left_list_11 = List(meals_left.toLong)\n        val carrots_left_list_12 = List(carrots_left.toLong)\n        val meals_left_list_12 = List(meals_left.toLong)\n        val carrots_left_list_13 = List(carrots_left.toLong)\n        val meals_left_list_13 = List(meals_left.toLong)\n        val carrots_left_list_14\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2otkw9bo.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2otkw9bo.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2otkw9bo.scala:63:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010269
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n        if (meals.toLong > 0) {\n            val newRemaining = remaining + meals\n            val newNumber = number - newRemaining\n            val newNeed = need - newRemaining\n            val newResult = eat(newNumber, newNeed, newRemaining)\n            result ::: newResult\n        } else {\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp85y2228y.scala:45)\n\tat Problem.main(tmp85y2228y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010271
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat * 2).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger + needs_left).toInt\n        val carrots_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpls5fthf4.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_with_hunger\u001b[0m = (carrots_left_to_eat_with_hunger + needs_left).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_with_hunger is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_with_hunger\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_with_hunger\u001b[0m = (carrots_left_to_eat_with_hunger + needs_left).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_with_hunger is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_with_hunger\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_with_hunger\u001b[0m = (carrots_left_to_eat_with_hunger + needs_left).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_with_hunger is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_with_hunger\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:41:12 ---------------------",
      "stdout": "",
      "timestamp": 1660010269
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        if (remaining == 0) {\n            result(0) = carrots.toLong\n            result(1) = 0l.toLong\n        } else {\n            val carrots_left = carrots - remaining\n            val needs_left = needs - remaining\n            if (carrots_left == 0) {\n                result(0) = carrots.toLong\n                result(1) = needs.toLong\n            } else {\n                result(0) = carrots_left.toLong\n                result(1) = needs_left.toLong\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcs0uzeju.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcs0uzeju.scala:49:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010268
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals = carrots_left % needs_left\n        val meals_left = carrots_left_after_meals / needs_left\n        val carrots_left_after_meals_left = carrots_left_after_meals % needs_left\n        val meals_left_left = carrots_left_after_meals_left / needs_left\n        val carrots_left_after_meals_left_left = carrots_left_after_meals_left % needs_left\n        val meals_left_left_left = carrots_left_after_meals_left_left / needs_left\n        val carrots_left_after_meals_left_left_left = carrots_left_after_meals_left_left % needs_left\n        val meals_left_left_left_left = carrots_left_after_meals_left_left_left / needs_left\n        val carrots_left_after_meals_left_left_left_left = carrots_left_after_meals_left_left_left % needs_left\n        val meals_left_left_left_left_left = carrots_left_after_meals_left_left_left_left / needs_left\n        val carrots_left_after_meals_left_left_left_left_left = carrots_left_after_meals_left_left_left_left % needs_left\n        val meals_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left / needs_left\n        val carrots_left_after_meals_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left % needs_left\n        val meals_left_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left_left / needs_left\n        val carrots_left_after_meals_left_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left_left % needs_left\n        val meals_left_left_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left_left_left / needs_left\n        val carrots_left_after_meals_left_left_left_left_left_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8si_t4ht.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8si_t4ht.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8si_t4ht.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010269
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list_sorted\u001b[0m = carrots_left_list.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list_sorted is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list_sorted\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list_sorted\u001b[0m = needs_left_list.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list_sorted is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list_sorted\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list_sorted\u001b[0m = carrots_left_list.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list_sorted is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list_sorted\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list_sorted\u001b[0m = needs_left_list.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list_sorted is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list_sorted\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same gr",
      "stdout": "",
      "timestamp": 1660010273
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val needs_left_to_eat = (needs_left - carrots_left).toInt\n        val carrots_left_to_eat = carrots_left_to_eat.toLong\n        val needs_left_to_eat = needs_left_to_eat.toLong\n        val carrots_left_to_eat_2 = carrots_left_to_eat * 2\n        val needs_left_to_eat_2 = needs_left_to_eat * 2\n        val carrots_left_to_eat_3 = carrots_left_to_eat * 3\n        val needs_left_to_eat_3 = needs_left_to_eat * 3\n        val carrots_left_to_eat_4 = carrots_left_to_eat * 4\n        val needs_left_to_eat_4 = needs_left_to_eat * 4\n        val carrots_left_to_eat_5 = carrots_left_to_eat * 5\n        val needs_left_to_eat_5 = needs_left_to_eat * 5\n        val carrots_left_to_eat_6 = carrots_left_to_eat * 6\n        val needs_left_to_eat_6 = needs_left_to_eat * 6\n        val carrots_left_to_eat_7 = carrots_left_to_eat * 7\n        val needs_left_to_eat_7 = needs_left_to_eat * 7\n        val carrots_left_to_eat_8 = carrots_left_to_eat * 8\n        val needs_left_to_eat_8 = needs_left_to_eat * 8\n        val carrots_left_to_eat_9 = carrots_left_to_eat * 9\n        val needs_left_to_eat_9 = needs_left_to_eat * 9\n        val carrots_left_to_eat_10 = carrots_left_to_eat * 10\n        val needs_left_to_eat_10 = needs_left_to_eat * 10\n        val carrots_left_to_eat_11 = carrots_left_to_eat * 11\n        val needs_left_to_eat_11 = needs_left_to_eat * 11\n        val carrots_left_to_eat_12 = carrots_left_to_eat * 12\n        val needs_left_to_eat_12 = needs_left_to_eat * 12\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp40134o8s.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat\u001b[0m = carrots_left_to_eat.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp40134o8s.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat\u001b[0m = needs_left_to_eat.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp40134o8s.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp40134o8s.scala:62:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010269
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val leftCarrots = remaining - carrots\n        val result = List(carrots, leftCarrots)\n        if (leftCarrots == 0) {\n            List(number * need)\n        } else {\n            List(number * need, leftCarrots)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplvrlnnny.scala:41)\n\tat Problem.main(tmplvrlnnny.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010272
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsLeft = carrots - remaining\n        val needLeft = needs - remaining\n        val meals = carrotsLeft + needLeft\n        val mealsLeft = meals - needLeft\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppkp3k573.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppkp3k573.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsLeft\u001b[0m = carrotsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrotsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrotsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppkp3k573.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneedLeft\u001b[0m = needLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneedLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneedLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppkp3k573.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppkp3k573.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsLeft\u001b[0m = carrotsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrotsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrotsLe",
      "stdout": "",
      "timestamp": 1660010270
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val carrots_left_to_eat = (carrots_left / meals).toInt\n        val carrots_left_to_eat = if (carrots_left_to_eat == 0) 1 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 1) 1 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 2) 2 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 3) 3 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 4) 4 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 5) 5 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 6) 6 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 7) 7 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 8) 8 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 9) 9 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 10) 10 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 11) 11 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 12) 12 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 13) 13 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 14) 14 else carrots_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 15\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn_qymhgt.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (carrots_left_to_eat == \u001b[31m0\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m carrots_left_to_eat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (carrots_left_to_eat == \u001b[31m1\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m carrots_left_to_eat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (carrots_left_to_eat == \u001b[31m2\u001b[0m) \u001b[31m2\u001b[0m \u001b[33melse\u001b[0m carrots_left_to_eat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:40:12 ---------------------------\u001b[0m\u001b[",
      "stdout": "",
      "timestamp": 1660010271
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val carrots_needed = needs - carrots\n        val carrots_left_needed = carrots_left - carrots_needed\n        val carrots_left_needed_to_eat = carrots_left_needed + carrots\n        val carrots_left_needed_to_eat2 = carrots_left_needed + carrots_needed\n        val carrots_left_needed_to_eat3 = carrots_left_needed + carrots_needed + carrots\n        val carrots_left_needed_to_eat4 = carrots_left_needed + carrots_needed + carrots + carrots\n        val carrots_left_needed_to_eat5 = carrots_left_needed + carrots_needed + carrots + carrots + carrots\n        val carrots_left_needed_to_eat6 = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat7 = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat8 = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat9 = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat10 = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat11 = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpkxefl1t4.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkxefl1t4.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkxefl1t4.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010270
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new ArrayList[Long]()\n        val carrots_left = remaining\n        val carrots_needed = carrots - carrots_left\n        val carrots_left_needed = carrots_needed - carrots_left\n        val carrots_left_needed_2 = carrots_left_needed - carrots_left\n        val carrots_left_needed_3 = carrots_left_needed_2 - carrots_left\n        val carrots_left_needed_4 = carrots_left_needed_3 - carrots_left\n        val carrots_left_needed_5 = carrots_left_needed_4 - carrots_left\n        val carrots_left_needed_6 = carrots_left_needed_5 - carrots_left\n        val carrots_left_needed_7 = carrots_left_needed_6 - carrots_left\n        val carrots_left_needed_8 = carrots_left_needed_7 - carrots_left\n        val carrots_left_needed_9 = carrots_left_needed_8 - carrots_left\n        val carrots_left_needed_10 = carrots_left_needed_9 - carrots_left\n        val carrots_left_needed_11 = carrots_left_needed_10 - carrots_left\n        val carrots_left_needed_12 = carrots_left_needed_11 - carrots_left\n        val carrots_left_needed_13 = carrots_left_needed_12 - carrots_left\n        val carrots_left_needed_14 = carrots_left_needed_13 - carrots_left\n        val carrots_left_needed_15 = carrots_left_needed_14 - carrots_left\n        val carrots_left_needed_16 = carrots_left_needed_15 - carrots_left\n        val carrots_left_needed_17 = carrots_left_needed_16 - carrots_left\n        val carrots_left_needed_18 = carrots_left_needed_17 - carrots_left\n        val carrots_left_needed_19 = carrots_left_needed_18 - carrots_left\n        val carrots_left_needed_20 = carrots_left_needed_19 - carrots_left\n        val carrots_left_needed_21 = carrots_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4_680sok.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4_680sok.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4_680sok.scala:57:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_needed_21\u001b[0m = carrots_left_\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: carrots_left_\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4_680sok.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010271
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val leftOver = remaining - carrots\n        val result = List(number.toLong, leftOver.toLong)\n        if (leftOver > 0) result :+ eat(leftOver, need, remaining)\n        else result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxr0dv8fw.scala:34:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mif\u001b[0m (leftOver > \u001b[31m0\u001b[0m) result :+ eat(leftOver, need, remaining)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010270
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - meals\n        val carrots_left_after_meals = carrots_left - remaining\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - remaining\n        val carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpktz97id0.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpktz97id0.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpktz97id0.scala:41:111 --------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - remaining\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpktz97id0.scala:42:123 -----------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - remaining\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: carrots_left_after_meals_",
      "stdout": "",
      "timestamp": 1660010271
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining == 0) {\n            result ++= List(number.toLong)\n        } else {\n            val carrots_left = carrots - remaining\n            val needs_left = needs - remaining\n            val carrots_left_to_eat = carrots_left - needs_left\n            val needs_left_to_eat = (needs_left / need).toInt\n            val needs_left_to_eat_left = needs_left_to_eat * need\n            val needs_left_to_eat_left_to_eat = (needs_left_to_eat_left / carrot).toInt\n            val needs_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat * carrot\n            val needs_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left / need).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat * need\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left_to_eat / carrot).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat_left * carrot\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left_to_eat_left / need).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left * need\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left / carrot).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat_left_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp05w0s9n0.scala:64:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp05w0s9n0.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05w0s9n0.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05w0s9n0.scala:52:101 -----------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\u001b[0m = needs_left_to_eat_left_to_eat_left_to_eat_left_to_\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: needs_left_to_eat_left_to_eat_left_to_eat_left_to_\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp05w0s9n0.scala:63:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp05w0s9n0.scala:54:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m54 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36marg",
      "stdout": "",
      "timestamp": 1660010273
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val result: List[Long] = new Array[Long](meals)\n        val carrots_left = new Array[Long](meals)\n        val carrots_left2 = new Array[Long](meals)\n        val carrots_left3 = new Array[Long](meals)\n        val carrots_left4 = new Array[Long](meals)\n        val carrots_left5 = new Array[Long](meals)\n        val carrots_left6 = new Array[Long](meals)\n        val carrots_left7 = new Array[Long](meals)\n        val carrots_left8 = new Array[Long](meals)\n        val carrots_left9 = new Array[Long](meals)\n        val carrots_left10 = new Array[Long](meals)\n        val carrots_left11 = new Array[Long](meals)\n        val carrots_left12 = new Array[Long](meals)\n        val carrots_left13 = new Array[Long](meals)\n        val carrots_left14 = new Array[Long](meals)\n        val carrots_left15 = new Array[Long](meals)\n        val carrots_left16 = new Array[Long](meals)\n        val carrots_left17 = new Array[Long](meals)\n        val carrots_left18 = new Array[Long](meals)\n        val carrots_left19 = new Array[Long](meals)\n        val carrots_left20 = new Array[Long](meals)\n        val carrots_left21 = new Array[Long](meals)\n        val carrots_left22 = new Array[Long](meals)\n        val carrots_left23 = new Array[Long](meals)\n        val carrots_left24 = new Array[Long](meals)\n        val carrots_left25 = new Array[Long](meals)\n        val carrots_left26 = new Array[Long](meals)\n        val carrots_left27 = new Array[Long](meals)\n        val carrots_left28 = new Array[Long](meals)\n        val carrots_left29 = new Array[Long](meals)\n        val carrots_left\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8ie2xnb1.scala:65:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8ie2xnb1.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8ie2xnb1.scala:34:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](meals)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    \u001b[1m\u001b[31mArray\u001b[0m[Long]\n\u001b[31m   |\u001b[0m                                 Required: \u001b[1m\u001b[32mList\u001b[0m[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8ie2xnb1.scala:65:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010273
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val totalEaten = carrots - needToEat\n        val remainingCarrots = carrots - totalEaten\n        val carrotLeftToEat = remainingToEat - remainingCarrots\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatListWithZero = carrotLeftToEatList.map(_(0l))\n        val carrotLeftToEatListWithZeroList = carrotLeftToEatListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZero = carrotLeftToEatListWithZeroList.map(_(0l))\n        val carrotLeftToEatListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZero = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqb3m110h.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqb3m110h.scala:38:66 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZero\u001b[0m = carrotLeftToEatList.map(_(\u001b[31m0l\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  \u001b[33mparameter\u001b[0m \u001b[35m_$1\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqb3m110h.scala:40:90 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZeroListWithZero\u001b[0m = carrotLeftToEatListWithZeroList.map(_(\u001b[31m0l\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  \u001b[33mparameter\u001b[0m \u001b[35m_$2\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpqb3m110h.scala:42:66 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZeroListWithZeroListWithZero\u001b[0m = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrotLeftToEatListWithZeroListWithZeroListWithZero\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqb3m110h.scala:46:90 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero\u001b[0m = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWit",
      "stdout": "",
      "timestamp": 1660010272
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining < needs) {\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n            val carrots = number.toInt\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzgri60pv.scala:95:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpzgri60pv.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzgri60pv.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzgri60pv.scala:40:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcarrots\u001b[0m = number.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzgri60pv.scala:41:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mneeds\u001b[0m = need.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzgri60pv.scala:42:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0",
      "stdout": "",
      "timestamp": 1660010286
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val meals_left = meals - carrots_left\n        val carrots_left_to_eat = (carrots_left * meals).toLong\n        val meals_left_to_eat = (meals_left * carrots).toLong\n        val carrots_left_to_eat_and_meals = (carrots_left_to_eat * meals_left).toLong\n        val meals_left_to_eat_and_carrots = (meals_left_to_eat * carrots_left).toLong\n        val carrots_left_to_eat_and_meals_and_carrots = (carrots_left_to_eat_and_meals * meals_left_to_carrots).toLong\n        val meals_left_to_eat_and_carrots_and_meals = meals_left_to_eat_and_carrots + carrots_left_to_eat_and_meals_and_carrots\n        val carrots_left_to_eat_and_meals_and_carrots_and_meals = carrots_left_to_eat_and_meals_and_carrots + meals_left_to_eat_and_carrots_and_meals\n        val meals_left_to_eat_and_carrots_and_carrots_and_meals = meals_left_to_eat_and_carrots_and_carrots + carrots_left_to_eat_and_meals_and_carrots_and_meals\n        val carrots_left_to_eat_and_carrots_and_carrots_and_meals = carrots_left_to_eat_and_carrots_and_carrots_and_meals + meals_left_to_eat_and_carrots_and_carrots_and_meals\n        val carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_meals = carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_meals + carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_meals\n        val carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_carrots_and_meals = carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_carrots_and_meals + carrots_left_to_eat_and_carrots_and_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp60n1u47g.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp60n1u47g.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp60n1u47g.scala:44:66 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmeals_left_to_eat_and_carrots_and_carrots_and_meals\u001b[0m = meals_left_to_eat_and_carrots_and_carrots + carrots_left_to_eat_and_meals_and_carrots_and_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: meals_left_to_eat_and_carrots_and_carrots\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp60n1u47g.scala:45:68 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_and_carrots_and_carrots_and_meals\u001b[0m = carrots_left_to_eat_and_carrots_and_carrots_and_meals + meals_left_to_eat_and_carrots_and_carrots_and_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_and_carrots_and_carrots_and_meals\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp60n1u47g.scala",
      "stdout": "",
      "timestamp": 1660010282
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val leftCarrots = remaining - carrots\n        val result = new ArrayList[Long]()\n        if (leftCarrots > 0) {\n            result += carrots\n            result += leftCarrots\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0hzy2xod.scala:33:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010276
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val meals_left = meals - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list_2 = List(carrots_left.toLong)\n        val meals_left_list_2 = List(meals_left.toLong)\n        val carrots_left_list_3 = List(carrots_left.toLong)\n        val meals_left_list_3 = List(meals_left.toLong)\n        val carrots_left_list_4 = List(carrots_left.toLong)\n        val meals_left_list_4 = List(meals_left.toLong)\n        val carrots_left_list_5 = List(carrots_left.toLong)\n        val meals_left_list_5 = List(meals_left.toLong)\n        val carrots_left_list_6 = List(carrots_left.toLong)\n        val meals_left_list_6 = List(meals_left.toLong)\n        val carrots_left_list_7 = List(carrots_left.toLong)\n        val meals_left_list_7 = List(meals_left.toLong)\n        val carrots_left_list_8 = List(carrots_left.toLong)\n        val meals_left_list_8 = List(meals_left.toLong)\n        val carrots_left_list_9 = List(carrots_left.toLong)\n        val meals_left_list_9 = List(meals_left.toLong)\n        val carrots_left_list_10 = List(carrots_left.toLong)\n        val meals_left_list_10 = List(meals_left.toLong)\n        val carrots_left_list_11 = List(carrots_left.toLong)\n        val meals_left_list_11 = List(meals_left.toLong)\n        val carrots_left_list_12 = List(carrots_left.toLong)\n        val meals_left_list_12 = List(meals_left.toLong)\n        val carrots_left_list_13 = List(carrots_left.toLong)\n        val meals_left_list_13 = List(meals_left.toLong)\n        val carrots_left_list_14\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2otkw9bo.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2otkw9bo.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2otkw9bo.scala:63:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010269
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val meals_left = meals - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list2 = List(carrots_left.toLong)\n        val meals_left_list2 = List(meals_left.toLong)\n        val carrots_left_list3 = List(carrots_left.toLong)\n        val meals_left_list3 = List(meals_left.toLong)\n        val carrots_left_list4 = List(carrots_left.toLong)\n        val meals_left_list4 = List(meals_left.toLong)\n        val carrots_left_list5 = List(carrots_left.toLong)\n        val meals_left_list5 = List(meals_left.toLong)\n        val carrots_left_list6 = List(carrots_left.toLong)\n        val meals_left_list6 = List(meals_left.toLong)\n        val carrots_left_list7 = List(carrots_left.toLong)\n        val meals_left_list7 = List(meals_left.toLong)\n        val carrots_left_list8 = List(carrots_left.toLong)\n        val meals_left_list8 = List(meals_left.toLong)\n        val carrots_left_list9 = List(carrots_left.toLong)\n        val meals_left_list9 = List(meals_left.toLong)\n        val carrots_left_list10 = List(carrots_left.toLong)\n        val meals_left_list10 = List(meals_left.toLong)\n        val carrots_left_list11 = List(carrots_left.toLong)\n        val meals_left_list11 = List(meals_left.toLong)\n        val carrots_left_list12 = List(carrots_left.toLong)\n        val meals_left_list12 = List(meals_left.toLong)\n        val carrots_left_list13 = List(carrots_left.toLong)\n        val meals_left_list13 = List(meals_left.toLong)\n        val carrots_left_list14\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9r27vnmr.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9r27vnmr.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9r27vnmr.scala:63:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010282
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsLeft = carrots - remaining\n        val needLeft = needs - remaining\n        val result = List(carrotsLeft.toLong, needLeft.toLong)\n        if (needLeft <= 0) {\n            val needs = need.toInt\n            val remaining = remaining.toInt\n            val carrotsLeft = carrots - remaining\n            val needLeft = needs - remaining\n            val result = List(carrotsLeft.toLong, needLeft.toLong)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmmfdoslk.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmmfdoslk.scala:39:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010277
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val needs = need - carrots\n        val carrotsLeft = (1000 - number).toLong\n        val carrotsLeftNeeds = (1000 - need).toLong\n        val carrotsLeftNeedsRemaining = (1000 - remaining).toLong\n        val carrotsLeftNeedsRemainingNeeds = (1000 - needs - remaining).toLong\n        val carrotsLeftNeedsRemainingNeedsRemaining = (1000 - needs - remaining - carrots).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeeds = (1000 - needs - remaining - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemaining = (1000 - needs - remaining - carrots - needs - carrots).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeeds = (1000 - needs - remaining - carrots - needs - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots - needs - carrots).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots - needs - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots - needs - carrots - needs - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphgi2fiua.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphgi2fiua.scala:47:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010283
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        val meals = List(carrots.toLong)\n        val hungry = true\n        if (remaining <= 0) {\n            hungry = false\n        }\n        if (hungry) {\n            meals ::: List(need.toLong)\n        } else {\n            meals ::: List(need.toLong, remaining.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk0rfg021.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk0rfg021.scala:36:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            hungry = \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val hungry\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010281
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val hungry = carrots - meals\n        val left = (carrots - needs).toLong\n        val hungryLeft = (carrots - needs - meals).toLong\n        val hungryLeft2 = (carrots - needs - meals).toLong\n        val hungryLeft3 = (carrots - needs - meals).toLong\n        val hungryLeft4 = (carrots - needs - meals).toLong\n        val hungryLeft5 = (carrots - needs - meals).toLong\n        val hungryLeft6 = (carrots - needs - meals).toLong\n        val hungryLeft7 = (carrots - needs - meals).toLong\n        val hungryLeft8 = (carrots - needs - meals).toLong\n        val hungryLeft9 = (carrots - needs - meals).toLong\n        val hungryLeft10 = (carrots - needs - meals).toLong\n        val hungryLeft11 = (carrots - needs - meals).toLong\n        val hungryLeft12 = (carrots - needs - meals).toLong\n        val hungryLeft13 = (carrots - needs - meals).toLong\n        val hungryLeft14 = (carrots - needs - meals).toLong\n        val hungryLeft15 = (carrots - needs - meals).toLong\n        val hungryLeft16 = (carrots - needs - meals).toLong\n        val hungryLeft17 = (carrots - needs - meals).toLong\n        val hungryLeft18 = (carrots - needs - meals).toLong\n        val hungryLeft19 = (carrots - needs - meals).toLong\n        val hungryLeft20 = (carrots - needs - meals).toLong\n        val hungryLeft21 = (carrots - needs - meals).toLong\n        val hungryLeft22 = (carrots - needs - meals).toLong\n        val hungryLeft23 = (carrots - \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp_ibsuouu.scala:59:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryLeft23\u001b[0m = (carrots - \n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp_ibsuouu.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_ibsuouu.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010289
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val carrots_left = remaining - carrots\n        val carrots_left_to_eat = (carrots_left / 2).toInt\n        val carrots_left_to_eat2 = (carrots_left / 2).toInt\n        val carrots_left_to_eat3 = (carrots_left / 2).toInt\n        val carrots_left_to_eat4 = (carrots_left / 2).toInt\n        val carrots_left_to_eat5 = (carrots_left / 2).toInt\n        val carrots_left_to_eat6 = (carrots_left / 2).toInt\n        val carrots_left_to_eat7 = (carrots_left / 2).toInt\n        val carrots_left_to_eat8 = (carrots_left / 2).toInt\n        val carrots_left_to_eat9 = (carrots_left / 2).toInt\n        val carrots_left_to_eat10 = (carrots_left / 2).toInt\n        val carrots_left_to_eat11 = (carrots_left / 2).toInt\n        val carrots_left_to_eat12 = (carrots_left / 2).toInt\n        val carrots_left_to_eat13 = (carrots_left / 2).toInt\n        val carrots_left_to_eat14 = (carrots_left / 2).toInt\n        val carrots_left_to_eat15 = (carrots_left / 2).toInt\n        val carrots_left_to_eat16 = (carrots_left / 2).toInt\n        val carrots_left_to_eat17 = (carrots_left / 2).toInt\n        val carrots_left_to_eat18 = (carrots_left / 2).toInt\n        val carrots_left_to_eat19 = (carrots_left / 2).toInt\n        val carrots_left_to_eat20 = (carrots_left / 2).toInt\n        val carrots_left_to_eat21 = (carrots_left / 2).toInt\n        val carrots_left_to_eat22 = (carrots_left / 2).toInt\n        val carrots_left_to_eat23 = (carrots_left / 2).toInt\n        val carrots_left_to_eat24 = (carrots_left / 2).toInt\n        val carrots_left_to_eat25 = (carrots_left / 2).toInt\n        val carrots_left_to_eat26 = (carrots_left / 2\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptrksxycs.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptrksxycs.scala:59:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010288
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals = carrots_left % needs_left\n        val carrots_after_meals = carrots_left_after_meals / needs_left\n        val carrots_after_meals_remaining = carrots_left_after_meals % needs_left\n        val carrots_after_meals_remaining_remaining = carrots_after_meals_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining = carrots_after_meals_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining = car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvpwetrk3.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\u001b[0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\u001b[31m   |\u001b[0m\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvpwetrk3.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\u001b[0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\u001b[31m   |\u001b[0m\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpvpwetrk3.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[",
      "stdout": "",
      "timestamp": 1660010288
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n        val left  = need.toInt\n        val total = hungry + left\n        val remaining = total - hungry\n        val carrots = List(number.toLong, left.toLong)\n        val result = if (remaining <= 0) carrots else carrots.take(remaining)\n        result :+ total\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_zs4els.scala:40)\n\tat Problem.main(tmp7_zs4els.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010293
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val mealsLeft = meals - carrots\n        val carrotsLeft = carrots - remaining\n        val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n        if (meals == 0) {\n            result\n        } else {\n            eat(number, remaining - meals, mealsLeft)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjboii_bx.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010284
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining == 0) {\n            result.add(carrots)\n            result.add(0)\n        } else {\n            val carrots_left = carrots - remaining\n            val need_left = needs - remaining\n            if (carrots_left == 0) {\n                result.add(carrots)\n                result.add(0)\n            } else if (need_left == 0) {\n                result.add(carrots)\n                result.add(0)\n            } else {\n                val carrots_left_2 = carrots_left / 2\n                val need_left_2 = need_left / 2\n                val carrots_left_3 = carrots_left - carrots_left_2\n                val need_left_3 = need_left - need_left_2\n                val carrots_left_4 = carrots_left - carrots_left_3\n                val need_left_4 = need_left - need_left_3\n                val carrots_left_5 = carrots_left - carrots_left_4\n                val need_left_5 = need_left - need_left_4\n                val carrots_left_6 = carrots_left - carrots_left_5\n                val need_left_6 = need_left - need_left_5\n                val carrots_left_7 = carrots_left - carrots_left_6\n                val need_left_7 = need_left - need_left_6\n                val carrots_left_8 = carrots_left - carrots_left_7\n                val need_left_8 = need_left - need_left_7\n                val carrots_left_9 = carrots_left - carrots_left_8\n                val need_left_9 = need_left - need_left_8\n                val carrots_left_10 = carrots_left - carrots_left_9\n                val need_left_10 = need_left - need_left_9\n                val carrots_left_11 = carrots_left - carrots_left_10\n                val need_left_11 = need_left - need_left_10\n                val carrots_left_12 = carrots_left - carrots_left_11\n                val need_left_12 = need_left - need_left_11\n                val carrots_left_13 = carrots_left - carrots_left_12\n                val need_left_13 = need_left - need_left_12\n                val carrots_left_14 = carrots_left - carrots_left_13\n                val need_left_14 = need_left - need_left_13\n                val carrots_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp22mdt0cz.scala:75:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp22mdt0cz.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp22mdt0cz.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp22mdt0cz.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp22mdt0cz.scala:85:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp22mdt0cz.scala:76:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660010292
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left * needs_left).toInt\n        val needs_left_to_eat = (needs_left * carrots_left).toInt\n        val carrots_left_to_eat = carrots_left_to_eat.toLong\n        val needs_left_to_eat = needs_left_to_eat.toLong\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat + needs_left_to_eat\n        val needs_left_to_eat_with_needs = needs_left_to_eat + carrots_left_to_eat\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toInt\n        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toInt\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n        val carrots_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3oslscf4.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3oslscf4.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat\u001b[0m = carrots_left_to_eat.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3oslscf4.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat\u001b[0m = needs_left_to_eat.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3oslscf4.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_with_needs\u001b[0m = carrots_left_to_eat_with_needs.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_with_needs is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_with_needs\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3oslscf4.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat_with_needs\u001b[0m = needs_left_to_eat_with_needs.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_",
      "stdout": "",
      "timestamp": 1660010289
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = math.min(needs, carrots)\n        val leftOver = math.max(0, carrots - meals)\n        val mealsLeft = math.max(0, leftOver - remaining)\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toInt\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3nzx05yx.scala:74:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nzx05yx.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nzx05yx.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nzx05yx.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nzx05yx.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmealsLeft\u001b[0m = mealsLeft.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmealsLeft is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmealsLeft\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming E",
      "stdout": "",
      "timestamp": 1660010291
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result: List[Long] = new ArrayList[Long]()\n        if (remaining == 0) {\n            result.add(0)\n            result.add(0)\n        } else {\n            val carrots_left = carrots - remaining\n            val needs_left = needs - remaining\n            if (needs_left == 0) {\n                result.add(carrots)\n                result.add(0)\n            } else {\n                val carrots_left_new = carrots_left / needs_left\n                val needs_left_new = needs_left % needs_left\n                result.add(carrots_left_new)\n                result.add(needs_left_new)\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv283rkxh.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv283rkxh.scala:34:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv283rkxh.scala:36:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            result.add(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value add is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv283rkxh.scala:37:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            result.add(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue add is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv283rkxh.scala:42:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                result.add(carrots)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m ",
      "stdout": "",
      "timestamp": 1660010295
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val hungry = carrots - remaining\n        val left = (carrots - meals).toInt\n        val result = List(hungry, left)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuwzkvibo.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuwzkvibo.scala:37:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : List[Int])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010292
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_le",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining <= 0) {\n            result.add(carrots)\n            result.add(0)\n        } else {\n            val carrots_left = remaining - carrots\n            val needs_left = carrots_left - needs\n            if (needs_left <= 0) {\n                result.add(carrots)\n                result.add(0)\n            } else {\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n                val carrots_left_int = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpq_8ob7le.scala:76:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mcarrots_left_int\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq_8ob7le.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpq_8ob7le.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq_8ob7le.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_8ob7le.scala:47:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mneeds_left_int\u001b[0m = needs_left.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_int is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_int\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_8ob7le.scala:48:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mcarrots_left_int\u001b[0m = carrots_left.toInt\n\u001b[3",
      "stdout": "",
      "timestamp": 1660010294
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        if (needs_left <= 0) {\n            result(0) = carrots_left\n            result(1) = needs_left\n        } else {\n            result(0) = carrots_left\n            result(1) = needs_left\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnys9ijo_.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnys9ijo_.scala:44:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010292
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = remaining - carrots\n        val meals = carrots - need\n        val carrots_left_after_meals = carrots - meals\n        val carrots_left_after_meals_after_meals = carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals - carrots_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcb8ndobn.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcb8ndobn.scala:42:111 --------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcb8ndobn.scala:43:135 --------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[3",
      "stdout": "",
      "timestamp": 1660010293
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingCarrots = remaining.toInt\n        val totalCarrots = carrots - needToEat\n        val remainingCarrotsToEat = totalCarrots - needToEat\n        val carrotsToEat = remainingCarrots - remainingCarrotsToEat\n        val carrotsToEatList = List(carrotsToEat.toLong)\n        val carrotsToEatList2 = List(carrotsToEat.toLong)\n        val carrotsToEatList3 = List(carrotsToEat.toLong)\n        val carrotsToEatList4 = List(carrotsToEat.toLong)\n        val carrotsToEatList5 = List(carrotsToEat.toLong)\n        val carrotsToEatList6 = List(carrotsToEat.toLong)\n        val carrotsToEatList7 = List(carrotsToEat.toLong)\n        val carrotsToEatList8 = List(carrotsToEat.toLong)\n        val carrotsToEatList9 = List(carrotsToEat.toLong)\n        val carrotsToEatList10 = List(carrotsToEat.toLong)\n        val carrotsToEatList11 = List(carrotsToEat.toLong)\n        val carrotsToEatList12 = List(carrotsToEat.toLong)\n        val carrotsToEatList13 = List(carrotsToEat.toLong)\n        val carrotsToEatList14 = List(carrotsToEat.toLong)\n        val carrotsToEatList15 = List(carrotsToEat.toLong)\n        val carrotsToEatList16 = List(carrotsToEat.toLong)\n        val carrotsToEatList17 = List(carrotsToEat.toLong)\n        val carrotsToEatList18 = List(carrotsToEat.toLong)\n        val carrotsToEatList19 = List(carrotsToEat.toLong)\n        val carrotsTo\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmph2dwy1vk.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph2dwy1vk.scala:57:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010293
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left % needs_left).toInt\n        val needs_to_eat = (needs_left % carrots_left).toInt\n        val carrots_to_eat_left = carrots_to_eat * needs_to_eat\n        val needs_to_eat_left = needs_to_eat * carrots_to_eat\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat = (needs_to_eat_left / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat * needs_to_eat_left\n        val needs_to_eat_left_to_eat_left = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left\n        val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat * carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat / carrots_to_eat_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0wrei1y4.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0wrei1y4.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wrei1y4.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0wrei1y4.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010294
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n        val left  = remaining - need\n        val result = new mutable.ListBuffer[Long]()\n        val carrots = mutable.ListBuffer[Long]()\n        val hungryCarrots = mutable.ListBuffer[Long]()\n        val leftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptlm0vt7m.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptlm0vt7m.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryLeftCarrots\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryLeftCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryLeftCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptlm0vt7m.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryLeftCarrots\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryLeftCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryLeftCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptlm0vt7m.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryLeftCarrots\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryLeftCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryLeftCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptlm0vt7m.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryLeftCarrots\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryLeftCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryLeftCarrots\u001b[0m\n\u001b[31m  ",
      "stdout": "",
      "timestamp": 1660010295
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n        val hungryList = List(hungry.toLong)\n        val needList = List(need.toLong)\n        val needlessList = List(need.toLong)\n        val hungryNeedlessList = List(hungry.toLong)\n        val needlessList = List(need.toLong)\n        val hungryNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungr\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplbydzz6s.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplbydzz6s.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneedlessList\u001b[0m = List(need.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneedlessList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneedlessList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplbydzz6s.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryNeedlessNeedlessNeedlessNeedlessList\u001b[0m = List(hungry.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryNeedlessNeedlessNeedlessNeedlessList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryNeedlessNeedlessNeedlessNeedlessList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplbydzz6s.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneedlessNeedlessNeedlessNeedlessList\u001b[0m = List(need.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneedlessNeedlessNeedlessNeedlessList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneedlessNeedlessNeedlessNeedlessList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplbydzz6s.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList\u001b[0m = List(hungry.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660010298
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        var i = 0\n        var j = 0\n        var k = 0\n        while (i < carrots && j < needs) {\n            if (remaining > 0) {\n                k += 1\n                remaining -= 1\n            }\n            i += 1\n            j += 1\n        }\n        if (remaining > 0) {\n            k += 1\n        }\n        result(0) = k\n        result(1) = remaining\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpqj5tcuwb.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqj5tcuwb.scala:51:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010298
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val totalEaten = carrots - needToEat\n        val remainingCarrots = remainingToEat - needToEat\n        val hungry = remainingCarrots > 0\n        val eatenCarrots = totalEaten + remainingCarrots\n        val hungryCarrots = hungry ? eatenCarrots : 0\n        val hungryCarrotsList = List(hungryCarrots)\n        val hungryCarrotsListWithRemaining = hungryCarrotsList :+ remainingCarrots\n        hungryCarrotsListWithRemaining\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzdilffj2.scala:38:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryCarrots\u001b[0m = hungry ? eatenCarrots : \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzdilffj2.scala:41:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        hungryCarrotsListWithRemaining\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (hungryCarrotsListWithRemaining : List[Int])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010303
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n        if (remaining <= 0) result\n        else eat(number, need, remaining - meals)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9caexnc6.scala:38)\n\tat Problem.main(tmp9caexnc6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010306
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        val carrots_left = remaining - carrots\n        val needs_left = needs - carrots\n        if (needs_left <= 0) {\n            result(0) = carrots_left\n            result(1) = 0\n        } else {\n            result(0) = carrots_left\n            result(1) = needs_left\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9zpn4t5n.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9zpn4t5n.scala:44:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010304
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number - remaining\n        val hungryCarrotsToEat = need - remaining\n        val hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList2 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList3 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList4 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList5 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList6 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList7 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList8 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList9 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList10 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList11 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList12 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList13 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList14 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList15 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList16 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList17 = List\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5oyttxwu.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010303
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val carrots_left_to_eat = (carrots_left * need).toInt\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat + needs\n        val carrots_left_to_eat_with_needs_with_remaining = carrots_left_to_eat_with_needs + remaining\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs = carrots_left_to_eat_with_needs_with_remaining + needs\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining = carrots_left_to_eat_with_needs_with_remaining_with_needs + remaining\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining + needs\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs + remaining\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining + needs\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs + remaining\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining + needs\n        val carrots_left_to_eat_with_need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0nxcdujt.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0nxcdujt.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0nxcdujt.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010305
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_after_meals = carrots_left - needs_left\n        val needs_left_after_meals = needs_left - carrots_left\n        val meals = List(needs_left_after_meals, carrots_left_after_meals)\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1vuekxfy.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010300
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = needs - carrots\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val needs_left_to_eat = (needs_left - carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left_to_eat * 2).toInt\n        val needs_left_to_eat_2 = (needs_left_to_eat * 2).toInt\n        val carrots_left_to_eat_3 = (carrots_left_to_eat_2 * 3).toInt\n        val needs_left_to_eat_3 = (needs_left_to_eat_2 * 3).toInt\n        val carrots_left_to_eat_4 = (carrots_left_to_eat_3 * 4).toInt\n        val needs_left_to_eat_4 = (needs_left_to_eat_3 * 4).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4 * 5).toInt\n        val needs_left_to_eat_5 = (needs_left_to_eat_4 * 5).toInt\n        val carrots_left_to_eat_6 = (carrots_left_to_eat_5 * 6).toInt\n        val needs_left_to_eat_6 = (needs_left_to_eat_5 * 6).toInt\n        val carrots_left_to_eat_7 = (carrots_left_to_eat_6 * 7).toInt\n        val needs_left_to_eat_7 = (needs_left_to_eat_6 * 7).toInt\n        val carrots_left_to_eat_8 = (carrots_left_to_eat_7 * 8).toInt\n        val needs_left_to_eat_8 = (needs_left_to_eat_7 * 8).toInt\n        val carrots_left_to_eat_9 = (carrots_left_to_eat_8 * 9).toInt\n        val needs_left_to_eat_9 = (needs_left_to_eat_8 * 9).toInt\n        val carrots_left_to_eat_10 = (carrots_left_to_eat_9 * 10).toInt\n        val needs_left_to_eat_10 = (needs_left_to_eat_9 * 10).toInt\n        val carrots_left_to_eat_11 = (carrots_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsuimxfrz.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsuimxfrz.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsuimxfrz.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsuimxfrz.scala:57:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_11\u001b[0m = (carrots_\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: carrots_\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsuimxfrz.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660010308
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = remaining - carrots\n        val carrots_needed = needs - carrots\n        val carrots_left_needed = carrots_needed - carrots_left\n        val carrots_left_needed_to_eat = carrots_left_needed + carrots\n        val carrots_left_needed_to_eat2 = carrots_left_needed + carrots_left\n        val carrots_left_needed_to_eat3 = carrots_left_needed + carrots_left + carrots\n        val carrots_left_needed_to_eat4 = carrots_left_needed + carrots_left + carrots + carrots\n        val carrots_left_needed_to_eat5 = carrots_left_needed + carrots_left + carrots + carrots + carrots\n        val carrots_left_needed_to_eat6 = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat7 = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat8 = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat9 = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat10 = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat11 = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat12 = carrots_left_needed \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp_p391zna.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_p391zna.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010308
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val totalCarrots = carrots - remaining\n        val carrotsLeft = meals - totalCarrots\n        val carrotsLeftList = List(carrotsLeft.toLong)\n        val carrotsLeftListWithZero = carrotsLeftList.map(_ -> 0l)\n        val carrotsLeftListWithZeroAndOne = carrotsLeftListWithZero.zipWithIndex.map { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZero = carrotsLeftListWithZeroAndOne.zipWithIndex.map { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOne = carrotsLeftListWithZeroAndOneWithZero.zipWithIndex.map { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZero = carrotsLeftListWithZeroAndOneWithZeroAndOne.zipWithIndex.map { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOne = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZero.zipWithIndex.map { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZero = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOne.zipWithIndex.map { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZeroAndOne = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZero.zipWithIndex.map { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZero = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZeroAndOne.zipWithIndex.map \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmnnsin91.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmnnsin91.scala:37:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsLeftListWithZero\u001b[0m = carrotsLeftList.map(_ -> \u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value -> is not a member of Nothing\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmnnsin91.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010311
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val carrots_left = carrots - meals\n        val carrots_left_after = carrots - needs - meals\n        val carrots_left_after_meals = carrots - needs - remaining\n        val carrots_left_after_meals_after = carrots - needs - remaining - meals\n        val carrots_left_after_meals_after_meals = carrots - needs - remaining - meals - meals\n        val carrots_left_after_meals_after_meals_after = carrots - needs - remaining - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots - needs - remaining - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after = carrots - needs - remaining - meals - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots - needs - remaining - meals - meals - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after = carrots - needs - remaining - meals - meals - meals - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots - needs - remaining - meals - meals - meals - meals - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after = carrots - needs - remaining - meals - meals - meals - meals - meals - meals - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots - needs - remaining - meals - meals - meals - meals - me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpn0vkyzb7.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn0vkyzb7.scala:48:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010310
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n        val hungryRemaining = remaining.toInt\n        val needToEat = need.toInt\n        val needToEatRemaining = needToEat - hungryRemaining\n        val hungryToEat = hungry - needToEat\n        val hungryToEatRemaining = hungryToEat - hungryRemaining\n        val hungryToEatRemainingList = List(hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList2 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList3 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList4 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList5 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList6 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList7 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgjrfs9j2.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgjrfs9j2.scala:44:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010311
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        val result = List(number - carrots, carrots)\n        if (remaining <= 0) result\n        else eat(number, need, remaining)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpz5tk3y7_.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010306
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val totalCarrots = carrots + remaining\n        val needCarrots = needs - remaining\n        val carrots = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l, 16l, 17l, 18l, 19l, 20l, 21l, 22l, 23l, 24l, 25l, 26l, 27l, 28l, 29l, 30l, 31l, 32l, 33l, 34l, 35l, 36l, 37l, 38l, 39l, 40l, 41l, 42l, 43l, 44l, 45l, 46l, 47l, 48l, 49l, 50l, 51l, 52l, 53l, 54l, 55l, 56l, 57l, 58l, 59l, 60l, 61l, 62l, 63l, 64l, 65l, 66l, 67l, 68l, 69l, 70l, 71l, 72l, 73l, 74l, 75l, 76l, 77l, 78l, 79l, 80l, 81l, 82l, 83l, 84l, 85l, 86l, 87l, 88l, 89l, 90l, 91l, 92l, 93l, 94l, 95l, 96l, 97l, 98l, 99l, 100l, 101l, 102l, 103l, 104l, 105l, 106l, 107l, 108l, 109l, 110l, 111l, 112l, 113l, 114l, 115l, 116l, 117l, 118l, 119l, 120l, 121l, 122l, 123l, 124l, 125l, 126l, 127l, 128l, 129l, 130l, 131l, 132l, 133l, 134l, 135l, 136l, 137l, 138l, 139l, 140l, 141l, 142l, 143l, 144l, 145l, 146l, 147l, 148l, 149l, 150l, 151l, 152l, 153l, 154l, 155l, 156l, 157l, 158l, 159l, 160l, 161l, 162l, 163l, 164l, 165l, 166l, 167l, 168l, 169l, 170l, 171l, 172l, 173l, 174l, 175l, 176l, 177l, 178l, 179l, 180l, 181l, 182l, 183l, 184l, 185l, 186l, 187l, 188l, 189l, 190l, 191l, 192l, 193l, 194l, 195l, 196l, 197l, 198l, 199l, 200l, 201l, 202l, 203l, 204l, 205l, 206l, 207l, 208l, 209l, 210l, 211l, 212l, 213l, 214l, 215l, 216l, 217l, 218l, 219l, 220l, \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_3bo1une.scala:37:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_3bo1une.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots\u001b[0m = List(\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m14l\u001b[0m, \u001b[31m15l\u001b[0m, \u001b[31m16l\u001b[0m, \u001b[31m17l\u001b[0m, \u001b[31m18l\u001b[0m, \u001b[31m19l\u001b[0m, \u001b[31m20l\u001b[0m, \u001b[31m21l\u001b[0m, \u001b[31m22l\u001b[0m, \u001b[31m23l\u001b[0m, \u001b[31m24l\u001b[0m, \u001b[31m25l\u001b[0m, \u001b[31m26l\u001b[0m, \u001b[31m27l\u001b[0m, \u001b[31m28l\u001b[0m, \u001b[31m29l\u001b[0m, \u001b[31m30l\u001b[0m, \u001b[31m31l\u001b[0m, \u001b[31m32l\u001b[0m, \u001b[31m33l\u001b[0m, \u001b[31m34l\u001b[0m, \u001b[31m35l\u001b[0m, \u001b[31m36l\u001b[0m, \u001b[31m37l\u001b[0m, \u001b[31m38l\u001b[0m, \u001b[31m39l\u001b[0m, \u001b[31m40l\u001b[0m, \u001b[31m41l\u001b[0m, \u001b[31m42l\u001b[0m, \u001b[31m43l\u001b[0m, \u001b[31m44l\u001b[0m, \u001b[31m45l\u001b[0m, \u001b[31m46l\u001b[0m, \u001b[31m47l\u001b[0m, \u001b[31m48l\u001b[0m, \u001b[31m49l\u001b[0m, \u001b[31m50l\u001b[0m, \u001b[31m51l\u001b[0m, \u001b[31m52l\u001b[0m, \u001b[31m53l\u001b[0m, \u001b[31m54l\u001b[0m, \u001b[31m55l\u001b[0m, \u001b[31m56l\u001b[0m, \u001b[31m57l\u001b[0m, \u001b[31m58l\u001b[0m, \u001b[31m59l\u001b[0m, \u001b[31m60l\u001b[0m, \u001b[31m61l\u001b[0m, \u001b[31m62l\u001b[0m, \u001b[31m63l\u001b[0m, \u001b[31m64l\u001b[0m, \u001b[31m65l\u001b[0m, \u001b[31m66l\u001b[0m, \u001b[31m67l\u001b[0m, \u001b[31m68l\u001b[0m, \u001b[31m69l\u001b[0m, \u001b[31m70l\u001b[0m, \u001b[31m71l\u001b[0m, \u001b[31m72l\u001b[0m, \u001b[31m73l\u001b[0m, \u001b[31m74l\u001b[0m, \u001b[31m75l\u001b[0m, \u001b[31m76l\u001b[0m, \u001b[31m77l\u001b[0m, \u001b[31m78l\u001b[0m, \u001b[31m79l\u001b[0m, \u001b[31m80l\u001b[0m, \u001b[31m81l\u001b[0m, \u001b[31m82l\u001b[0m, \u001b[31m83l\u001b[0m, \u001b[31m84l\u001b[0m, \u001b[31m85l\u001b[0m, \u001b[31m86l\u001b[0m, \u001b[31m87l\u001b[0m, \u001b[31m88l\u001b[0m, \u001b[31m89l\u001b[0m, \u001b[31m90l\u001b[0m, \u001b[31m91l\u001b[0m, \u001b[31m92l\u001b[0m, \u001b[31m93l\u001b[0m, \u001b[31m94l\u001b[0m, \u001b[31m95l\u001b[0m, \u001b[31m96l\u001b[0m, \u001b[31m97l\u001b[0m, \u001b[31m98l\u001b[0m, \u001b[31m99l\u001b[0m, \u001b[31m100l\u001b[0m, \u001b[31m101l\u001b[0m, \u001b[31m102l\u001b[0m, \u001b[31m103l\u001b[0m, \u001b[31m104l\u001b[0m, \u001b[31m105l\u001b[0m, \u001b[31m106l\u001b[0m, \u001b[31m107l\u001b[0m, \u001b[31m108l\u001b[0m, \u001b[31m109l\u001b[0m, \u001b[31m110l\u001b[0m, \u001b[31m111l\u001b[0m, \u001b[31m112l\u001b[0m, \u001b[31m113l\u001b[0m, \u001b[31m114l\u001b[0m, \u001b[31m115l\u001b[0m, \u001b[31m116l\u001b[0m, \u001b[31m117l\u001b[0m, \u001b[31m118l\u001b[0m, \u001b[31m119l\u001b[0m, \u001b[31m120l\u001b[0m, \u001b[31m121",
      "stdout": "",
      "timestamp": 1660010312
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n        if (remaining < 0l) {\n            val carrots = remaining + meals\n            val meals = need - carrots\n            val result = List(meals.toLong, carrots.toLong)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgx87rrw3.scala:36:31 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmeals\u001b[0m = need - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Recursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010306
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining > 0) {\n            val carrots_left = remaining - carrots\n            val needs_left = carrots_left - needs\n            val needs_left_to_eat = (needs_left / needs).toInt\n            val needs_left_to_eat_left = needs_left - needs_left_to_eat * needs\n            val needs_left_to_eat_left_to_eat = (needs_left_to_eat_left / needs).toInt\n            val needs_left_to_eat_left_to_eat_left = needs_left_to_eat_left - needs_left_to_eat_left_to_eat * needs\n            val needs_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat / needs).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left - needs_left_to_eat_left_to_eat_left * needs\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left / needs).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat - needs_left_to_eat_left_to_eat_left * needs\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left_to_eat / needs).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat_left - needs_left_to_eat_left_to_eat_left_to_eat * needs\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left_to_eat_left / needs).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgsqtqoll.scala:61:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgsqtqoll.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgsqtqoll.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgsqtqoll.scala:49:101 -----------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\u001b[0m = needs_left_to_eat_left_\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: needs_left_to_eat_left_\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgsqtqoll.scala:60:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpgsqtqoll.scala:51:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m51 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m",
      "stdout": "",
      "timestamp": 1660010314
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val totalCarrots = carrots + remaining\n        val needCarrots = needs - remaining\n        val carrotList = List(totalCarrots.toLong, needCarrots.toLong)\n        carrotList.sortWith(_ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpzq3zhykr.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzq3zhykr.scala:37:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        carrotList.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue < is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010314
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val remaining = carrots + meals\n        List(meals, remaining)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmphow3yaqb.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = carrots + meals\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010308
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryRemainingCarrots = remainingCarrots - hungry\n        val hungryRemainingMeals = hungryMeals - hungryCarrots\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots = hungryRemainingCarrots.to\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingCarrots\u001b[0m = hungryRemainingCarrots.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingMeals\u001b[0m = hungryRemainingMeals.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingCarrots\u001b[0m = hungryRemainingCarrots.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingMeals\u001b[0m = hungryRemainingMeals.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /t",
      "stdout": "",
      "timestamp": 1660010315
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - meals\n        val meals_left = carrots_left - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list2 = List(carrots_left.toLong)\n        val meals_left_list2 = List(meals_left.toLong)\n        val carrots_left_list3 = List(carrots_left.toLong)\n        val meals_left_list3 = List(meals_left.toLong)\n        val carrots_left_list4 = List(carrots_left.toLong)\n        val meals_left_list4 = List(meals_left.toLong)\n        val carrots_left_list5 = List(carrots_left.toLong)\n        val meals_left_list5 = List(meals_left.toLong)\n        val carrots_left_list6 = List(carrots_left.toLong)\n        val meals_left_list6 = List(meals_left.toLong)\n        val carrots_left_list7 = List(carrots_left.toLong)\n        val meals_left_list7 = List(meals_left.toLong)\n        val carrots_left_list8 = List(carrots_left.toLong)\n        val meals_left_list8 = List(meals_left.toLong)\n        val carrots_left_list9 = List(carrots_left.toLong)\n        val meals_left_list9 = List(meals_left.toLong)\n        val carrots_left_list10 = List(carrots_left.toLong)\n        val meals_left_list10 = List(meals_left.toLong)\n        val carrots_left_list11 = List(carrots_left.toLong)\n        val meals_left_list11 = List(meals_left.toLong)\n        val carrots_left_list12 = List(carrots_left.toLong)\n        val meals_left_list12 = List(meals_left.toLong)\n        val carrots_left_list13 = List(carrots_left.toLong)\n        val meals_left_list13 = List(meals_left.toLong)\n        val carrots_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfb4_y1o1.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpfb4_y1o1.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfb4_y1o1.scala:63:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010314
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val carrots_left_to_eat_left = carrots_left - carrots_left_to_eat * needs_left\n        val carrots_left_to_eat_left_to_eat = (carrots_left_to_eat_left / needs_left).toInt\n        val carrots_left_to_eat_left_to_eat_left = carrots_left_to_eat_left - carrots_left_to_eat_left_to_eat * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat / needs_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat_left / needs_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat_left_to_eat - carrots_left_to_eat_left_to_eat_left_to_eat * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat_left_to_eat / needs_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left_to_eat_left * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat_left_to_eat_left / needs_left).toInt\n        val carrots_left_to_eat_left_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6v4qj87c.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6v4qj87c.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6v4qj87c.scala:48:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010314
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val carrots_left_after_meals = carrots - carrots_left\n        val carrots_left_after_meals_after_meals = carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals - carrots_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1nr7_2xy.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1nr7_2xy.scala:41:111 --------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1nr7_2xy.scala:42:135 --------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_me\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m   |\u001b[0m\u001b[0m ne",
      "stdout": "",
      "timestamp": 1660010315
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals = carrots_left % needs_left\n        val needs_left_after_meals = needs_left % carrots_left\n        val meals_after_meals = carrots_left_after_meals / needs_left_after_meals\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals % needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals % carrots_left_after_meals\n        val meals_after_meals_after_meals = carrots_left_after_meals_after_meals / needs_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals % needs_left_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals % carrots_left_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals % needs_left_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals % carrots_left_after_meals_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals_after_me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdmzyd31e.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdmzyd31e.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010317
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n        val hungryList = List(hungry.toLong)\n        val hungryRemaining = remaining - hungry\n        val hungryRemainingList = List(hungryRemaining.toLong)\n        val hungryRemainingList2 = List(hungryRemaining.toLong)\n        if (hungryRemaining == 0) {\n            hungryList\n        } else {\n            hungryList2 ++= eat(hungry, need, remaining)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnoc_ygpx.scala:39:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            hungryList2 ++= eat(hungry, need, remaining)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: hungryList2\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010314
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatListWithZero = carrotLeftToEatList.map(_(0l))\n        val carrotLeftToEatListWithZeroList = carrotLeftToEatListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZero = carrotLeftToEatListWithZeroList.map(_(0l))\n        val carrotLeftToEatListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZero = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero = carrotLeftToEat\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplhdzsnd2.scala:37:66 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZero\u001b[0m = carrotLeftToEatList.map(_(\u001b[31m0l\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  \u001b[33mparameter\u001b[0m \u001b[35m_$1\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplhdzsnd2.scala:39:90 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZeroListWithZero\u001b[0m = carrotLeftToEatListWithZeroList.map(_(\u001b[31m0l\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  \u001b[33mparameter\u001b[0m \u001b[35m_$2\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplhdzsnd2.scala:41:66 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZeroListWithZeroListWithZero\u001b[0m = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrotLeftToEatListWithZeroListWithZeroListWithZero\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplhdzsnd2.scala:45:178 -----------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero\u001b[0m = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660010322
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val hungry = carrots - meals\n        val left = (meals - needs).toInt\n        val result = List(hungry, left)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpratfcva5.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010317
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        if (remaining <= 0) {\n            result(0) = carrots.toLong\n            result(1) = 0l.toLong\n        } else {\n            val need = needs.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n            val need = need.toInt\n            val remaining = remaining.toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpku8cssk7.scala:98:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m98 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpku8cssk7.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpku8cssk7.scala:42:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mneed\u001b[0m = need.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneed is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneed\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpku8cssk7.scala:43:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpku8cssk7.scala:44:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcarrots\u001b[0m = carrots.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpku8cssk7.scala:45:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mneed\u001b[0m = need.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660010326
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val remaining = remaining - needs\n        val hungry = remaining > 0\n        val eaten = meals + needs\n        val left = (carrots - eaten).toLong\n        val result = List(left.toLong, eaten.toLong)\n        if (hungry) {\n            val hungryEaten = meals + needs - 1\n            val hungryLeft = carrots - hungryEaten\n            val hungryResult = List(hungryLeft.toLong, hungryEaten.toLong)\n            result ::: hungryResult\n        } else {\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv20hzopk.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - needs\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv20hzopk.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010317
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number.toLong\n        val hungryRabbitNeed = need.toLong\n        val hungryRabbitRemaining = remaining.toLong\n        val hungryRabbitEaten = hungryRabbit\n        val hungryRabbitLeft = hungryRabbit\n        val hungryRabbitEatenNeed = hungryRabbitNeed\n        val hungryRabbitLeftNeed = hungryRabbitNeed\n        val hungryRabbitLeftRemaining = hungryRabbitRemaining\n        val hungryRabbitLeftEaten = hungryRabbitLeft\n        val hungryRabbitLeftLeft = hungryRabbitLeft\n        val hungryRabbitLeftEatenNeed = hungryRabbitLeftNeed\n        val hungryRabbitLeftLeftNeed = hungryRabbitLeftNeed\n        val hungryRabbitLeftLeftRemaining = hungryRabbitLeftRemaining\n        val hungryRabbitLeftLeftEaten = hungryRabbitLeftLeft\n        val hungryRabbitLeftLeftLeft = hungryRabbitLeftLeft\n        val hungryRabbitLeftLeftEatenNeed = hungryRabbitLeftLeftNeed\n        val hungryRabbitLeftLeftLeftNeed = hungryRabbitLeftLeftNeed\n        val hungryRabbitLeftLeftLeftRemaining = hungryRabbitLeftLeftRemaining\n        val hungryRabbitLeftLeftLeftEaten = hungryRabbitLeftLeftLeft\n        val hungryRabbitLeftLeftLeftLeft = hungryRabbitLeftLeftLeftLeft\n        val hungryRabbitLeftLeftLeftEatenNeed = hungryRabbitLeftLeftLeftNeed\n        val hungryRabbitLeftLeftLeftLeftNeed = hungryRabbitLeftLeftLeftNeed\n        val hungryRabbitLeftLeftLeftLeftRemaining = hungr\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4hfz6phs.scala:50:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRabbitLeftLeftLeftLeft\u001b[0m = hungryRabbitLeftLeftLeftLeft\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35mhungryRabbitLeftLeftLeftLeft\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4hfz6phs.scala:53:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRabbitLeftLeftLeftLeftRemaining\u001b[0m = hungr\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: hungr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4hfz6phs.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010326
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsLeft = carrots - remaining\n        val needsLeft  = needs - remaining\n        val carrotEaten = carrots - carrotsLeft\n        val needEaten  = needs - needsLeft\n        val carrotEatenList = List(carrotEaten)\n        val needEatenList = List(needEaten)\n        val carrotEatenList2 = List(carrotEaten)\n        val needEatenList2 = List(needEaten)\n        val carrotEatenList3 = List(carrotEaten)\n        val needEatenList3 = List(needEaten)\n        val carrotEatenList4 = List(carrotEaten)\n        val needEatenList4 = List(needEaten)\n        val carrotEatenList5 = List(carrotEaten)\n        val needEatenList5 = List(needEaten)\n        val carrotEatenList6 = List(carrotEaten)\n        val needEatenList6 = List(needEaten)\n        val carrotEatenList7 = List(carrotEaten)\n        val needEatenList7 = List(needEaten)\n        val carrotEatenList8 = List(carrotEaten)\n        val needEatenList8 = List(needEaten)\n        val carrotEatenList9 = List(carrotEaten)\n        val needEatenList9 = List(needEaten)\n        val carrotEatenList10 = List(carrotEaten)\n        val needEatenList10 = List(needEaten)\n        val carrotEatenList11 = List(carrotEaten)\n        val needEatenList11 = List(needEaten)\n        val carrotEatenList12 = List(carrotEaten)\n        val needEatenList12 = List(needEaten)\n        val carrotEatenList13 = List(carrotEaten)\n        val needEatenList13 = List(needEaten)\n        val carrotEatenList14\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsz_ehbih.scala:65:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsz_ehbih.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsz_ehbih.scala:65:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010326
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left / needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n        val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n        val needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val carrots_left_to_eat_4 = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4 = (needs_left / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left / needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n        val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7 = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n        val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10 = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphwmzperf.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmphwmzperf.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphwmzperf.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphwmzperf.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left % needs_left).toInt\n        val needs_to_eat = (needs_left % carrots_left).toInt\n        val carrots_to_eat_left = carrots_to_eat * needs_to_eat\n        val needs_to_eat_left = needs_to_eat * carrots_to_eat\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat = (needs_to_eat_left / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat * needs_to_eat_left\n        val needs_to_eat_left_to_eat_left = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left\n        val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat * carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat / carrots_to_eat_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0wrei1y4.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0wrei1y4.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wrei1y4.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0wrei1y4.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010294
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val leftCarrots = remaining - carrots\n        val totalCarrots = carrots + leftCarrots\n        val leftCarrotsList = List(leftCarrots.toLong)\n        val totalCarrotsList = List(totalCarrots.toLong)\n        val totalCarrotsListWithLeftCarrots = totalCarrotsList ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsList = totalCarrotsListWithLeftCarrots :: Nil\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrots = totalCarrotsListWithLeftCarrotsList ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsList = totalCarrotsListWithLeftCarrotsListWithLeftCarrots :: Nil\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsList ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots :: Nil\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots :: Nil\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi9eotre2.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi9eotre2.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010326
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list2 = List(carrots_left.toLong)\n        val needs_left_list2 = List(needs_left.toLong)\n        val carrots_left_list3 = List(carrots_left.toLong)\n        val needs_left_list3 = List(needs_left.toLong)\n        val carrots_left_list4 = List(carrots_left.toLong)\n        val needs_left_list4 = List(needs_left.toLong)\n        val carrots_left_list5 = List(carrots_left.toLong)\n        val needs_left_list5 = List(needs_left.toLong)\n        val carrots_left_list6 = List(carrots_left.toLong)\n        val needs_left_list6 = List(needs_left.toLong)\n        val carrots_left_list7 = List(carrots_left.toLong)\n        val needs_left_list7 = List(needs_left.toLong)\n        val carrots_left_list8 = List(carrots_left.toLong)\n        val needs_left_list8 = List(needs_left.toLong)\n        val carrots_left_list9 = List(carrots_left.toLong)\n        val needs_left_list9 = List(needs_left.toLong)\n        val carrots_left_list10 = List(carrots_left.toLong)\n        val needs_left_list10 = List(needs_left.toLong)\n        val carrots_left_list11 = List(carrots_left.toLong)\n        val needs_left_list11 = List(needs_left.toLong)\n        val carrots_left_list12 = List(carrots_left.toLong)\n        val needs_left_list12 = List(needs_left.toLong)\n        val carrots_left_list13 = List(carrots_left.toLong)\n        val needs_left_list13 = List(needs_left.toLong)\n        val carrots_left_list14 = List(carrots_left.toLong)\n        val needs_left_list14 = List(needs_left.toLong)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp9u1c4t33.scala:64:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9u1c4t33.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9u1c4t33.scala:65:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010327
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val carrotsLeft = remaining - carrots\n        val carrotsLeftToEat = carrotsLeft - carrots.toLong\n        val carrotsToEat = carrotsLeft + carrots.toLong\n        val carrotsToEatList = List(carrotsToEat.toLong)\n        val carrotsToEatList2 = List(carrotsToEat.toLong)\n        val carrotsToEatList3 = List(carrotsToEat.toLong)\n        val carrotsToEatList4 = List(carrotsToEat.toLong)\n        val carrotsToEatList5 = List(carrotsToEat.toLong)\n        val carrotsToEatList6 = List(carrotsToEat.toLong)\n        val carrotsToEatList7 = List(carrotsToEat.toLong)\n        val carrotsToEatList8 = List(carrotsToEat.toLong)\n        val carrotsToEatList9 = List(carrotsToEat.toLong)\n        val carrotsToEatList10 = List(carrotsToEat.toLong)\n        val carrotsToEatList11 = List(carrotsToEat.toLong)\n        val carrotsToEatList12 = List(carrotsToEat.toLong)\n        val carrotsToEatList13 = List(carrotsToEat.toLong)\n        val carrotsToEatList14 = List(carrotsToEat.toLong)\n        val carrotsToEatList15 = List(carrotsToEat.toLong)\n        val carrotsToEatList16 = List(carrotsToEat.toLong)\n        val carrotsToEatList17 = List(carrotsToEat.toLong)\n        val carrotsToEatList18 = List(carrotsToEat.toLong)\n        val carrotsToEatList19 = List(carrotsToEat.toLong)\n        val carrotsToEatList20 = List(carrotsToEat.toLong)\n        val carrots\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8f0kpfxf.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8f0kpfxf.scala:56:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010328
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val carrots_left_to_eat = (carrots_left * need).toInt\n        val carrots_to_eat = (carrots_left_to_eat * need).toInt\n        val carrots_to_eat_left = carrots_to_eat - carrots_left\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left * need).toInt\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - carrots_left\n        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left * need).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat - carrots_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left * need).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left * need).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left * need).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppjuzungr.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmppjuzungr.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppjuzungr.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010327
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals = carrots_left % needs_left\n        val needs_left_after_meals = needs_left % carrots_left\n        val meals_after_meals = carrots_left_after_meals / needs_left_after_meals\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals % needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals % carrots_left_after_meals\n        val meals_after_meals_after_meals = carrots_left_after_meals_after_meals / needs_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals % needs_left_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals % carrots_left_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals % needs_left_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals % carrots_left_after_meals_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals_after_me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdmzyd31e.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdmzyd31e.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010317
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n        if (remaining > 0) result ::: eat(number, need, remaining - meals)\n        else result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpipn0uq4z.scala:38)\n\tat Problem.main(tmpipn0uq4z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010331
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val remaining = remaining - need\n        val hungry = remaining > 0\n        val eaten = needs - remaining\n        val hungryEaten = eaten > 0\n        if (hungry) {\n            val hungryEaten = eaten - need\n            val hungryEatenList = List(hungryEaten.toLong)\n            val hungryEatenList2 = List(hungryEaten.toLong)\n            val hungryEatenList3 = List(hungryEaten.toLong)\n            val hungryEatenList4 = List(hungryEaten.toLong)\n            val hungryEatenList5 = List(hungryEaten.toLong)\n            val hungryEatenList6 = List(hungryEaten.toLong)\n            val hungryEatenList7 = List(hungryEaten.toLong)\n            val hungryEatenList8 = List(hungryEaten.toLong)\n            val hungryEatenList9 = List(hungryEaten.toLong)\n            val hungryEatenList10 = List(hungryEaten.toLong)\n            val hungryEatenList11 = List(hungryEaten.toLong)\n            val hungryEatenList12 = List(hungryEaten.toLong)\n            val hungryEatenList13 = List(hungryEaten.toLong)\n            val hungryEatenList14 = List(hungryEaten.toLong)\n            val hungryEatenList15 = List(hungryEaten.toLong)\n            val hungryEatenList16 = List(hungryEaten.toLong)\n            val hungryEatenList17 = List(hungryEaten.toLong)\n            val hungryEatenList18 = List(hungryEaten\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcozrlz47.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcozrlz47.scala:70:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcozrlz47.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - need\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcozrlz47.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcozrlz47.scala:69:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpcozrlz47.scala:60:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m60 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660010333
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList, carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjd074aux.scala:38:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        (carrotEatenList, carrotLeftToEatList)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0mList[Long\u001b[1m\u001b[31m]\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0m\u001b[1m\u001b[31mLong\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals = carrots_left % needs_left\n        val carrots_after_meals = carrots_left_after_meals / needs_left\n        val carrots_after_meals_remaining = carrots_left_after_meals % needs_left\n        val carrots_after_meals_remaining_remaining = carrots_after_meals_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining = carrots_after_meals_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining = car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvpwetrk3.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\u001b[0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\u001b[31m   |\u001b[0m\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvpwetrk3.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\u001b[0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining / needs_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\u001b[31m   |\u001b[0m\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpvpwetrk3.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[",
      "stdout": "",
      "timestamp": 1660010288
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining\n        val carrots_needed = carrots - carrots_left\n        val carrots_needed_to_eat = carrots_needed - carrots_left\n        val carrots_left_to_eat = (carrots_needed - carrots_needed).toInt\n        val carrots_left_to_eat_needed = carrots_left_to_eat - carrots_needed\n        val carrots_left_to_eat_needed_to_eat = carrots_left_to_eat_needed - carrots_needed\n        val carrots_left_to_eat_needed_to_eat = (carrots_left_to_eat_needed - carrots_needed).toInt\n        val carrots_left_to_eat_needed_to_eat_needed = carrots_left_to_eat_needed_to_eat - carrots_needed\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat = carrots_left_to_eat_needed_to_eat_needed - carrots_needed\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat = (carrots_left_to_eat_needed_to_eat_needed - carrots_needed).toInt\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat = carrots_left_to_eat_needed_to_eat_needed_to_eat - carrots_needed\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat = (carrots_left_to_eat_needed_to_eat_needed_to_eat_needed - carrots_needed).toInt\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat = carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat - carrots_needed\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat = carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8z2pdavq.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_needed_to_eat\u001b[0m = (carrots_left_to_eat_needed - carrots_needed).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_needed_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_needed_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8z2pdavq.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_needed_to_eat_needed_to_eat\u001b[0m = (carrots_left_to_eat_needed_to_eat_needed - carrots_needed).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_needed_to_eat_needed_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_needed_to_eat_needed_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8z2pdavq.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\u001b[0m = (carrots_left_to_eat_needed_to_eat_needed_to_eat_needed - carrots_needed).toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m",
      "stdout": "",
      "timestamp": 1660010331
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        val carrots_left = remaining\n        val carrots_eaten = carrots - carrots_left\n        val carrots_left = carrots - carrots_eaten\n        result(0) = carrots_eaten\n        result(1) = carrots_left\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjur9zt2y.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left\u001b[0m = carrots - carrots_eaten\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjur9zt2y.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjur9zt2y.scala:40:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010331
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val leftCarrots = carrots - meals\n        val leftNeeds = needs - meals\n        val leftRemaining = remaining - meals\n        val leftMeals = meals - leftRemaining\n        val leftNeedsLeft = leftNeeds - leftMeals\n        val leftRemainingLeft = leftRemaining - leftMeals\n        val leftMealsLeft = leftMeals - leftRemainingLeft\n        val leftNeedsLeftLeft = leftNeedsLeft - leftMealsLeft\n        val leftRemainingLeftLeft = leftRemainingLeft - leftMealsLeft\n        val leftMealsLeftLeft = leftMeals - leftRemainingLeftLeft\n        val leftNeedsLeftLeftLeft = leftNeedsLeftLeft - leftMealsLeftLeft\n        val leftRemainingLeftLeftLeft = leftRemainingLeftLeft - leftMealsLeftLeft\n        val leftMealsLeftLeftLeft = leftMealsLeftLeft - leftRemainingLeftLeftLeft\n        val leftNeedsLeftLeftLeftLeft = leftNeedsLeftLeftLeft - leftMealsLeftLeftLeft\n        val leftRemainingLeftLeftLeftLeft = leftRemainingLeftLeftLeft - leftMealsLeftLeftLeft\n        val leftMealsLeftLeftLeftLeft = leftMealsLeftLeftLeft - leftRemainingLeftLeftLeftLeft\n        val leftNeedsLeftLeftLeftLeftLeft = leftNeedsLeftLeftLeftLeft - leftMealsLeftLeftLeftLeft\n        val leftRemainingLeftLeftLeftLeftLeft = leftRemainingLeftLeftLeftLeft - leftMealsLeftLeftLeftLeftLeft\n        val leftMealsLeftLeftLeftLeftLeft = leftMealsLeftLeftLeftLeft - leftRemainingLeftLeftLeftLeftLeft\n        val leftNeedsLeftLeftLeftLeftLeftLeft = leftNeedsLeftLeftLeftLeftLeft - leftMealsLeftLeftLeftLeftLeft\n        val leftRemainingLeftLeftLeftLeftLeftLeft = leftRemainingLeftLeftLeftLeftLeft - leftMealsLeftLeftLeftLeftLeft\n        val leftMealsLeftLeftLeftLeftLeftLeft = leftMealsLeftLeftLeftLeftLeft - leftRemainingLeftLeftLeftLeftLeftLeft\n        val leftNeedsLeftLeftLeftLeftLeftLeftLeft = leftNeedsLeftLeftLeftLeftLeftLeft - leftMealsLeftLeftLeftLeftLeftLeft\n        val leftRemainingLeftLeftLeftLeftLeftLeftLeft = leftRemainingLeftLeftLeft\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpksowja1s.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpksowja1s.scala:59:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010333
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val leftCarrots = remaining - carrots\n        val result = List(carrots, leftCarrots)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbdmgvelh.scala:37)\n\tat Problem.main(tmpbdmgvelh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010336
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpa2dedca_.scala:98:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m98 |\u001b[0m        \u001b[33mvar\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa2dedca_.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcarrots_left\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left is already defined as \u001b[33mvariable\u001b[0m \u001b[35mcarrots_left\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa2dedca_.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcarrots_eaten\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_eaten is already defined as \u001b[33mvariable\u001b[0m \u001b[35mcarrots_eaten\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa2dedca_.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcarrots_left\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left is already defined as \u001b[33mvariable\u001b[0m \u001b[35mcarrots_left\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa2dedca_.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcarrots_eaten\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_eaten is already defined as \u001b[33mvariable\u001b[0m \u001b[35mcarrots_eaten\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp",
      "stdout": "",
      "timestamp": 1660010335
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n        val left = (remaining - need).toLong\n        val meals = hungry + left\n        val hungryList = List(hungry.toLong)\n        val leftList = List(left.toLong)\n        if (meals < 0) {\n            hungryList :+ meals.toLong\n        } else {\n            leftList :+ meals.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkef7b3iw.scala:43)\n\tat Problem.main(tmpkef7b3iw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010337
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = remaining - carrots\n        val carrots_left_to_eat = (carrots_left / needs).toInt\n        val carrots_left_to_eat_with_extra = carrots_left % needs\n        val carrots_to_eat = carrots_left_to_eat + carrots_left_to_eat_with_extra\n        val carrots_to_eat_with_extra = carrots_to_eat.toLong\n        val carrots_to_eat_with_extra_with_extra = carrots_to_eat_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf6eoy9d7.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf6eoy9d7.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\u001b[0m = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra is already defined as \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\n\u001b[31m   |\u001b[0m\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpf6eoy9d7.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf6eoy9d7.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010334
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining > carrots) {\n            val carrots = carrots - remaining\n            val needs = needs - remaining\n            val remaining = remaining - carrots\n            result += carrots\n            result += needs\n        }\n        if (remaining > needs) {\n            val carrots = carrots - needs\n            val needs = needs - carrots\n            val remaining = remaining - needs\n            result += carrots\n            result += needs\n        }\n        if (remaining > 0) {\n            val carrots = carrots - remaining\n            val needs = needs - carrots\n            val remaining = remaining - carrots\n            result += carrots\n            result += needs\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpopgpu_ha.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpopgpu_ha.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpopgpu_ha.scala:36:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcarrots\u001b[0m = carrots - remaining\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpopgpu_ha.scala:37:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mneeds\u001b[0m = needs - remaining\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mneeds\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpopgpu_ha.scala:38:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: ",
      "stdout": "",
      "timestamp": 1660010328
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsNeeded = carrots - remaining\n        val carrotsNeededToEat = carrotsNeeded - needs\n        val carrotsNeededToEatList = List(carrotsNeededToEat.toLong)\n        val carrotsNeededToEatListArray = carrotsNeededToEatList.toArray\n        val carrotsNeededToEatArray = carrotsNeededToEatListArray.toList\n        val carrotsNeededToEatArrayArray = carrotsNeededToEatArray.toArray\n        val carrotsNeededToEatArrayArrayArray = carrotsNeededToEatArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArray = carrotsNeededToEatArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray.toArray\n        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArray\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3lngozka.scala:47:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray\u001b[0m = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3lngozka.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3lngozka.scala:37:72 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsNeededToEatListArray\u001b[0m = carrotsNeededToEatList.toArray\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3lngozka.scala:44:68 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArray\u001b[0m = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray.toArray\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrotsNeededToE",
      "stdout": "",
      "timestamp": 1660010336
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat = (needs_left / need).toInt\n        val needs_left_to_eat = (carrots_left / carrots).toInt\n        val needs_left_to_eat = if (needs_left_to_eat == 0) 0 else needs_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat == 0) 0 else carrots_left_to_eat\n        val carrots_to_eat = if (carrots_left_to_eat == 0) 0 else carrots_left_to_eat\n        val needs_to_eat = if (needs_left_to_eat == 0) 0 else needs_left_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_xco7z8_.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_xco7z8_.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (needs_left_to_eat == \u001b[31m0\u001b[0m) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m needs_left_to_eat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_xco7z8_.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (carrots_left_to_eat == \u001b[31m0\u001b[0m) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m carrots_left_to_eat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_xco7z8_.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_to_eat\u001b[0m = \u001b[33mif\u001b[0m (carrots_to_eat == \u001b[31m0\u001b[0m) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m carrots_to_eat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_xco7z8_.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_to_eat\u001b[",
      "stdout": "",
      "timestamp": 1660010336
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left / needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n        val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n        val needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val carrots_left_to_eat_4 = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4 = (needs_left / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left / needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n        val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7 = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n        val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10 = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11 = (carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1hgddzsc.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1hgddzsc.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1hgddzsc.scala:57:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_11\u001b[0m = (carrot\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: carrot\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1hgddzsc.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010337
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val remaining = remaining - carrots\n        val needs = needs - carrots\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.to\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds\u001b[0m = needs - carrots\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds\u001b[0m = needs.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds\u001b[0m = needs.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds\u001b[0m = needs.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of topl",
      "stdout": "",
      "timestamp": 1660010339
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left) \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyigbboj4.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyigbboj4.scala:37:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010339
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat = (needs_left / need).toInt\n        val needs_left_to_eat = (carrots_left / carrots).toInt\n        val carrots_left_to_eat_2 = (carrots_left_to_eat * carrots).toInt\n        val needs_left_to_eat_2 = (needs_left_to_eat * need).toInt\n        val carrots_left_to_eat_3 = (carrots_left_to_eat_2 * carrots).toInt\n        val needs_left_to_eat_3 = (needs_left_to_eat_2 * need).toInt\n        val carrots_left_to_eat_4 = (carrots_left_to_eat_3 * carrots).toInt\n        val needs_left_to_eat_4 = (needs_left_to_eat_3 * need).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4 * carrots).toInt\n        val needs_left_to_eat_5 = (needs_left_to_eat_4 * need).toInt\n        val carrots_left_to_eat_6 = (carrots_left_to_eat_5 * carrots).toInt\n        val needs_left_to_eat_6 = (needs_left_to_eat_5 * need).toInt\n        val carrots_left_to_eat_7 = (carrots_left_to_eat_6 * carrots).toInt\n        val needs_left_to_eat_7 = (needs_left_to_eat_6 * need).toInt\n        val carrots_left_to_eat_8 = (carrots_left_to_eat_7 * carrots).toInt\n        val needs_left_to_eat_8 = (needs_left_to_eat_7 * need).toInt\n        val carrots_left_to_eat_9 = (carrots_left_to_eat_8 * carrots).toInt\n        val needs_left_to_eat_9 = (needs_left_to_eat_8 * need).toInt\n        val carrots_left_to_eat_10 = (carrots_left_to_eat_9 * carrots).toInt\n        val needs_left_to_eat_10 = (needs_left_to_eat_9 * need).toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8vt3xjr0.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8vt3xjr0.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8vt3xjr0.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010342
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = carrots_left % needs_left\n        val needs_left_to_eat_2 = needs_left % carrots_left\n        val carrots_left_to_eat_3 = carrots_left % needs_left_2\n        val needs_left_to_eat_3 = needs_left % carrots_left_2\n        val carrots_left_to_eat_4 = carrots_left % needs_left_3\n        val needs_left_to_eat_4 = needs_left % carrots_left_3\n        val carrots_left_to_eat_5 = carrots_left % needs_left_4\n        val needs_left_to_eat_5 = needs_left % carrots_left_4\n        val carrots_left_to_eat_6 = carrots_left % needs_left_5\n        val needs_left_to_eat_6 = needs_left % carrots_left_5\n        val carrots_left_to_eat_7 = carrots_left % needs_left_6\n        val needs_left_to_eat_7 = needs_left % carrots_left_6\n        val carrots_left_to_eat_8 = carrots_left % needs_left_7\n        val needs_left_to_eat_8 = needs_left % carrots_left_7\n        val carrots_left_to_eat_9 = carrots_left % needs_left_8\n        val needs_left_to_eat_9 = needs_left % carrots_left_8\n        val carrots_left_to_eat_10 = carrots_left % needs_left_9\n        val needs_left_to_eat_10 = needs_left % carrots_left_9\n        val carrots_left_to_eat_11 = carrots_left % needs_left_10\n        val needs_left_to_eat_11 = needs_left % carrots_left_10\n        val carrots_left_to_eat_12 = carrots_left % needs_left_11\n        val needs_left_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpibyc9950.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpibyc9950.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpibyc9950.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpibyc9950.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010343
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = remaining - carrots\n        val carrots_left_to_eat = (carrots_left - needs).toInt\n        val carrots_to_eat = (carrots_left_to_eat + needs).toInt\n        val carrots_to_eat_list = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_2 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_3 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_4 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_5 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_6 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_7 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_8 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_9 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_10 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_11 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_12 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_13 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_14 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_15 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_16 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_17 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_18 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_19 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_20 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_21 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_22 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_23\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjpp8ued6.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjpp8ued6.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjpp8ued6.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010344
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val hungry = carrots - meals\n        val left = (meals + needs).toInt\n        val result = (List(meals, left))\n        if (hungry > 0) {\n            val hungryResult = eat(hungry, need, remaining)\n            val hungryResult2 = eat(hungry, need, remaining)\n            val hungryResult3 = eat(hungry, need, remaining)\n            val hungryResult4 = eat(hungry, need, remaining)\n            val hungryResult5 = eat(hungry, need, remaining)\n            val hungryResult6 = eat(hungry, need, remaining)\n            val hungryResult7 = eat(hungry, need, remaining)\n            val hungryResult8 = eat(hungry, need, remaining)\n            val hungryResult9 = eat(hungry, need, remaining)\n            val hungryResult10 = eat(hungry, need, remaining)\n            val hungryResult11 = eat(hungry, need, remaining)\n            val hungryResult12 = eat(hungry, need, remaining)\n            val hungryResult13 = eat(hungry, need, remaining)\n            val hungryResult14 = eat(hungry, need, remaining)\n            val hungryResult15 = eat(hungry, need, remaining)\n            val hungryResult16 = eat(hungry, need, remaining)\n            val hungryResult17 = eat(hungry, need, remaining)\n            val hungryResult18 = eat(hungry, need, remaining)\n            val hungryResult19 = eat(hungry, need, remaining)\n            val hungryResult20 = eat(hungry, need, remaining)\n            val hungryResult21 = eat(hungry, need, remaining)\n            val hungryResult22 = eat(hungry, need, remaining)\n            val hungryResult23 = eat(hungry, need, remaining)\n            val hungryResult24 = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp8dqwm_3n.scala:62:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mhungryResult24\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8dqwm_3n.scala:74:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8dqwm_3n.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8dqwm_3n.scala:73:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp8dqwm_3n.scala:64:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m64 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        if (remaining <= 0) {\n            result.add(carrots)\n            result.add(carrots)\n        } else {\n            val carrots_left = carrots - remaining\n            if (carrots_left <= needs) {\n                result.add(carrots)\n                result.add(carrots_left)\n            } else {\n                result.add(carrots)\n                result.add(needs)\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7vl7v7mu.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7vl7v7mu.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010340
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        val meals = List(carrots, remaining)\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3hw8_s0d.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010339
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList, carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjd074aux.scala:38:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        (carrotEatenList, carrotLeftToEatList)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0mList[Long\u001b[1m\u001b[31m]\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0m\u001b[1m\u001b[31mLong\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n        val rest = remaining - need\n        val hungryCarrots = hungry.toLong\n        val restCarrots = rest.toLong\n        val hungryCarrotsList = List(hungryCarrots)\n        val restCarrotsList = List(restCarrots)\n        val hungryCarrotsList2 = hungryCarrotsList.zipWithIndex.filter(_._2 % 2 == 0).map(_._1)\n        val restCarrotsList2 = restCarrotsList.zipWithIndex.filter(_._2 % 2 == 0).map(_._1)\n        val hungryCarrotsList3 = hungryCarrotsList2.zipWithIndex.filter(_._2 % 2 == 1).map(_._1)\n        val restCarrotsList3 = restCarrotsList2.zipWithIndex.filter(_._2 % 2 == 1).map(_._1)\n        val hungryCarrotsList4 = hungryCarrotsList3.zipWithIndex.filter(_._2 % 2 == 2).map(_._1)\n        val restCarrotsList4 = restCarrotsList3.zipWithIndex.filter(_._2 % 2 == 2).map(_._1)\n        val hungryCarrotsList5 = hungryCarrotsList4.zipWithIndex.filter(_._2 % 2 == 3).map(_._1)\n        val restCarrotsList5 = restCarrotsList4.zipWithIndex.filter(_._2 % 2 == 3).map(_._1)\n        val hungryCarrotsList6 = hungryCarrotsList5.zipWithIndex.filter(_._2 % 2 == 4).map(_._1)\n        val restCarrotsList6 = restCarrotsList5.zipWithIndex.filter(_._2 % 2 == 4).map(_._1)\n        val hungryCarrotsList7 = hungryCarrotsList6.zipWithIndex.filter(_._2 % 2 == 5).map(_._1)\n        val restCarrotsList7 = restCarrotsList6.zipWithIndex.filter(_._2 % 2 == 5).map(_._1)\n        val hungryCarrotsList8 = hungryCarrotsList7.zipWithIndex.filter(_._2 % 2 == 6).map(_._1)\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi2ic4eyl.scala:51:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010347
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals = carrots_left % needs_left\n        val needs_left_after_meals = needs_left % needs_left\n        val meals_after_meals = carrots_left_after_meals / needs_left_after_meals\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals % needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals % needs_left_after_meals\n        val meals_after_meals_after_meals = carrots_left_after_meals_after_meals / needs_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals % needs_left_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals % needs_left_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals % needs_left_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals % needs_left_after_meals_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals_after_meals\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmph8ow6s0h.scala:49:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmph8ow6s0h.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph8ow6s0h.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010349
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val needs_left_to_eat = (needs_left - carrots_left).toInt\n        val carrots_to_eat = (carrots_left_to_eat + needs_left_to_eat).toInt\n        val needs_to_eat = (needs_left_to_eat + carrots_left_to_eat).toInt\n        val carrots_to_eat_left = carrots_to_eat - needs_to_eat\n        val needs_to_eat_left = needs_to_eat - carrots_to_eat\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left - needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat = (needs_to_eat_left - carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - needs_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left = needs_to_eat_left_to_eat - carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left - needs_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left - carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat - needs_to_eat_left_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat - needs_to_eat_left_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoujn5l4f.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpoujn5l4f.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoujn5l4f.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoujn5l4f.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010348
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val mealsLeft = carrots - remaining\n        val mealsLeftList = List(mealsLeft.toLong)\n        val carrotsLeft = carrots - meals\n        val carrotsLeftList = List(carrotsLeft.toLong)\n        val carrotsLeftList2 = List(carrotsLeft.toLong)\n        val carrotsLeftList3 = List(carrotsLeft.toLong)\n        val carrotsLeftList4 = List(carrotsLeft.toLong)\n        val carrotsLeftList5 = List(carrotsLeft.toLong)\n        val carrotsLeftList6 = List(carrotsLeft.toLong)\n        val carrotsLeftList7 = List(carrotsLeft.toLong)\n        val carrotsLeftList8 = List(carrotsLeft.toLong)\n        val carrotsLeftList9 = List(carrotsLeft.toLong)\n        val carrotsLeftList10 = List(carrotsLeft.toLong)\n        val carrotsLeftList11 = List(carrotsLeft.toLong)\n        val carrotsLeftList12 = List(carrotsLeft.toLong)\n        val carrotsLeftList13 = List(carrotsLeft.toLong)\n        val carrotsLeftList14 = List(carrotsLeft.toLong)\n        val carrotsLeftList15 = List(carrotsLeft.toLong)\n        val carrotsLeftList16 = List(carrotsLeft.toLong)\n        val carrotsLeftList17 = List(carrotsLeft.toLong)\n        val carrotsLeftList18 = List(carrotsLeft.toLong)\n        val carrotsLeftList19 = List(carrotsLeft.toLong)\n        val carrotsLeftList20 = List(carrotsLeft.toLong)\n        val carrotsLeftList21 = List(carrotsLeft.toLong)\n        val carrotsLeftList22 = List(carrotsLeft.toLong)\n        val carrotsLeftList23 = List(carrotsLeft.toLong)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpqgnxqulv.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqgnxqulv.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010350
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val hungry = remaining - carrots\n        val hungryCarrots = if (hungry <= 0) 0 else hungry\n        val hungryCarrotsList = List(hungryCarrots.toLong)\n        val hungryCarrotsList2 = List(hungryCarrots.toLong)\n        val hungryCarrotsList3 = List(hungryCarrots.toLong)\n        val hungryCarrotsList4 = List(hungryCarrots.toLong)\n        val hungryCarrotsList5 = List(hungryCarrots.toLong)\n        val hungryCarrotsList6 = List(hungryCarrots.toLong)\n        val hungryCarrotsList7 = List(hungryCarrots.toLong)\n        val hungryCarrotsList8 = List(hungryCarrots.toLong)\n        val hungryCarrotsList9 = List(hungryCarrots.toLong)\n        val hungryCarrotsList10 = List(hungryCarrots.toLong)\n        val hungryCarrotsList11 = List(hungryCarrots.toLong)\n        val hungryCarrotsList12 = List(hungryCarrots.toLong)\n        val hungryCarrotsList13 = List(hungryCarrots.toLong)\n        val hungryCarrotsList14 = List(hungryCarrots.toLong)\n        val hungryCarrotsList15 = List(hungryCarrots.toLong)\n        val hungryCarrotsList16 = List(hungryCarrots.toLong)\n        val hungryCarrotsList17 = List(hungryCarrots.toLong)\n        val hungryCarrotsList18 = List(hungryCarrots.toLong)\n        val hungryCarrotsList19 = List(hungryCarrots.toLong)\n        val hungryCarrotsList20 = List(hungryCarrots.toLong)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2p3_d631.scala:54:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2p3_d631.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010350
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val hungry = remaining > 0\n        val meals = if (hungry) List(need) else List(remaining)\n        val carrots_left = if (hungry) remaining - need else 0\n        val result = if (hungry) List(meals.sum, carrots_left) else List(meals.sum)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7h968doh.scala:39)\n\tat Problem.main(tmp7h968doh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010354
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val meals_left = meals - remaining\n        val carrots_left_after_meals = carrots_left - meals\n        val meals_left_after_meals = meals_left - carrots_left\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals - meals_left\n        val meals_left_after_meals_after_meals = meals_left_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals - meals_left_after_meals\n        val meals_left_after_meals_after_meals_after_meals = meals_left_after_meals_after_meals - carrots_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals - meals_left_after_meals_after_meals_after_meals\n        val meals_left_after_meals_after_meals_after_meals_after_meals = meals_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals - meals_left_after_meals_after_meals_after_meals_after_meals\n        val meals_left_after_meals_after_meals_after_meals_after_meals_after_meals = meals_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpazaxlaur.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpazaxlaur.scala:46:99 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_me\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: carrots_left_after_meals_after_me\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpazaxlaur.scala:47:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010352
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots % number > 0\n        val hungryMeals = meals > 0\n        val hungryMealCarrots = meals % need > 0\n        val hungryRemainingCarrots = remainingCarrots > 0\n        val hungryRemainingCarrotsMeals = remainingCarrots % number > 0\n        val hungryRemainingMeals = remainingMeals > 0\n        val hungryRemainingMealCarrots = remainingMeals % need > 0\n        val hungryRemainingRemainingCarrots = remainingRemainingCarrots > 0\n        val hungryRemainingRemainingCarrotsMeals = remainingRemainingCarrots % number > 0\n        val hungryRemainingRemainingMeals = remainingRemainingMeals > 0\n        val hungryRemainingRemainingMealCarrots = remainingRemainingMeals % need > 0\n        val hungryRemainingRemainingRemainingCarrots = remainingRemainingRemainingCarrots > 0\n        val hungryRemainingRemainingRemainingCarrotsMeals = remainingRemainingRemainingCarrots % number > 0\n        val hungryRemainingRemainingRemainingMeals = remainingRemainingRemainingMeals > 0\n        val hungryRemainingRemainingRemainingMealCarrots = remainingRemainingRemainingMeals % need > 0\n        val hungryRemainingRemainingRemainingRemainingCarrots = remainingRemainingRemainingRemainingCarrots > 0\n        val hungryRemainingRemainingRemainingRemainingCarrotsMeals = remainingRemainingRemainingRemainingCarrots % number > 0\n        val hungryRemainingRemainingRemainingMeals = remainingRemainingRemainingMeals > 0\n        val hungryRemainingRemainingRemainingMealCarrots = remainingRemainingRemainingMeals % need > 0\n        val hungryRemainingRemainingRemainingMeals = remainingRemainingRemainingMeals > 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz31rl4fi.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingRemainingRemainingMeals\u001b[0m = remainingRemainingRemainingMeals > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingRemainingRemainingMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingRemainingRemainingMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz31rl4fi.scala:53:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingRemainingRemainingMealCarrots\u001b[0m = remainingRemainingRemainingMeals % need > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingRemainingRemainingMealCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingRemainingRemainingMealCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz31rl4fi.scala:54:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingRemainingRemainingMeals\u001b[0m = remainingRemainingRemainingMeals > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemainingRemainingRemainingMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemainingRemainingRemainingMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz31rl4fi.scala:40:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingMeals\u001b[0m = remainingMeals > \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ",
      "stdout": "",
      "timestamp": 1660010354
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_after_meals = carrots_left - needs_left\n        val needs_left_after_meals = needs_left - carrots_left\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals - needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals - needs_left_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meal\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsn65h1to.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:44:87 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:45:85 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /t",
      "stdout": "",
      "timestamp": 1659804749
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrotsLeft = carrots - remaining\n        val mealsLeft = meals - remaining\n        val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n        if (meals > 0) {\n            val mealsLeft = meals - remaining\n            val carrotsLeft = carrots - remaining\n            val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpd455f19r.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010348
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left * needs_left).toInt\n        val carrots_to_eat = (carrots_left * needs_left).toInt\n        val carrots_to_eat_left = carrots_to_eat - carrots_left_to_eat\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjtq9kmtd.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjtq9kmtd.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjtq9kmtd.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010355
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val carrots_needed = needs - carrots\n        val carrots_left_needed = carrots_left - carrots_needed\n        val carrots_left_needed_to_eat = carrots_needed - carrots_left\n        val carrots_left_needed_to_eat2 = carrots_left_needed + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat3 = carrots_left_needed_to_eat2 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat4 = carrots_left_needed_to_eat3 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat5 = carrots_left_needed_to_eat4 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat6 = carrots_left_needed_to_eat5 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat7 = carrots_left_needed_to_eat6 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat8 = carrots_left_needed_to_eat7 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat9 = carrots_left_needed_to_eat8 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat10 = carrots_left_needed_to_eat9 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat11 = carrots_left_needed_to_eat10 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat12 = carrots_left_needed_to_eat11 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat13 = carrots_left_needed_to_eat12 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat14 = carrots_left_needed_to_eat13 + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat15 = carrots_left_needed_to_eat14 + carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp703scmyd.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp703scmyd.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp703scmyd.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010355
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val meals = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val meals_left = meals - remaining\n        val meals_left_carrots = meals_left.toLong\n        val carrots_left_carrots = carrots_left.toLong\n        val meals_left_carrots_left = meals_left_carrots - carrots_left_carrots\n        val carrots_left_carrots_left = carrots_left_carrots - meals_left_carrots_left\n        val meals_left_carrots_left_carrots = meals_left_carrots_left.toLong\n        val carrots_left_carrots_left_carrots = carrots_left_carrots_left.toLong\n        val meals_left_carrots_left_carrots_left = meals_left_carrots_left_carrots - carrots_left_carrots_left_carrots\n        val carrots_left_carrots_left_carrots_left = carrots_left_carrots_left_carrots - meals_left_carrots_left_carrots_left\n        val meals_left_carrots_left_carrots_left_carrots = meals_left_carrots_left_carrots_left.toLong\n        val carrots_left_carrots_left_carrots_left_carrots = carrots_left_carrots_left_carrots_left.toLong\n        val meals_left_carrots_left_carrots_left_carrots_left = meals_left_carrots_left_carrots_left_carrots - carrots_left_carrots_left_carrots_left_carrots\n        val carrots_left_carrots_left_carrots_left_carrots_left = carrots_left_carrots_left_carrots_left_carrots - meals_left_carrots_left_carrots_left_carrots_left\n        val meals_left_carrots_left_carrots_left_carrots_left_carrots = meals_left_carrots_left_carrots_left_carrots_left.toLong\n        val carrots_left_carrots_left_carrots_left_carrots_left_carrots = carrots_left_carrots_left_carrots_left_carrots - meals_left_carrots_left_carrots_left_carrots_left_carro\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmphkc87ixc.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphkc87ixc.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010356
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        if (remaining <= 0) {\n            List(number.toLong)\n        } else {\n            List(number.toLong, remaining.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxw2lq17q.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010351
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - need\n        val remaining = remaining - meals\n        if (remaining <= 0) {\n            List(meals)\n        } else {\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - meals\n            val meals = carrots - need\n            val remaining = remaining - me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo2gnn6_m.scala:98:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m98 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo2gnn6_m.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - meals\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpo2gnn6_m.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo2gnn6_m.scala:41:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmeals\u001b[0m = carrots - need\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo2gnn6_m.scala:42:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - meals\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo2gnn6_m.scala:43:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmeals\u001b[0m = carrots - need\n\u001b[31m\u001b[31m",
      "stdout": "",
      "timestamp": 1660010359
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = carrots - needToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        if (carrotLeftToEat < 0)\n            carrotEatenList :+ carrotLeftToEat\n        else\n            carrotEatenList :+ carrotLeftToEat\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp57vco8z_.scala:44)\n\tat Problem.main(tmp57vco8z_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010361
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining\n        val carrots_needed = carrots - carrots_left\n        val carrots_needed_to_eat = carrots_needed - carrots_left\n        val carrots_left_to_eat = carrots_needed - carrots_left\n        val carrots_left_to_eat2 = carrots_needed - carrots_left\n        val carrots_left_to_eat3 = carrots_needed - carrots_left\n        val carrots_left_to_eat4 = carrots_needed - carrots_left\n        val carrots_left_to_eat5 = carrots_needed - carrots_left\n        val carrots_left_to_eat6 = carrots_needed - carrots_left\n        val carrots_left_to_eat7 = carrots_needed - carrots_left\n        val carrots_left_to_eat8 = carrots_needed - carrots_left\n        val carrots_left_to_eat9 = carrots_needed - carrots_left\n        val carrots_left_to_eat10 = carrots_needed - carrots_left\n        val carrots_left_to_eat11 = carrots_needed - carrots_left\n        val carrots_left_to_eat12 = carrots_needed - carrots_left\n        val carrots_left_to_eat13 = carrots_needed - carrots_left\n        val carrots_left_to_eat14 = carrots_needed - carrots_left\n        val carrots_left_to_eat15 = carrots_needed - carrots_left\n        val carrots_left_to_eat16 = carrots_needed - carrots_left\n        val carrots_left_to_eat17 = carrots_needed - carrots_left\n        val carrots_left_to_eat18 = carrots_needed - carrots_left\n        val carrots_left_to_eat19 = carrots_needed - carrots_left\n        val carrots_left_to_eat20 = carrots_needed - carrots_left\n        val carrots_left_to_eat21 = carrots_needed - carrots_left\n        val carrots_left_to_eat22 = carrots_needed - carrots_left\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp4tu6a67a.scala:60:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4tu6a67a.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4tu6a67a.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4tu6a67a.scala:61:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010360
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new Array[Long](2)\n        val carrots_left = remaining - carrots\n        val carrots_left_to_eat = (needs - carrots).toInt\n        val carrots_left_to_eat2 = carrots_left_to_eat * carrots_left_to_eat\n        val carrots_left_to_eat3 = carrots_left_to_eat2 * carrots_left_to_eat\n        val carrots_left_to_eat4 = carrots_left_to_eat3 * carrots_left_to_eat\n        val carrots_left_to_eat5 = carrots_left_to_eat4 * carrots_left_to_eat\n        val carrots_left_to_eat6 = carrots_left_to_eat5 * carrots_left_to_eat\n        val carrots_left_to_eat7 = carrots_left_to_eat6 * carrots_left_to_eat\n        val carrots_left_to_eat8 = carrots_left_to_eat7 * carrots_left_to_eat\n        val carrots_left_to_eat9 = carrots_left_to_eat8 * carrots_left_to_eat\n        val carrots_left_to_eat10 = carrots_left_to_eat9 * carrots_left_to_eat\n        val carrots_left_to_eat11 = carrots_left_to_eat10 * carrots_left_to_eat\n        val carrots_left_to_eat12 = carrots_left_to_eat11 * carrots_left_to_eat\n        val carrots_left_to_eat13 = carrots_left_to_eat12 * carrots_left_to_eat\n        val carrots_left_to_eat14 = carrots_left_to_eat13 * carrots_left_to_eat\n        val carrots_left_to_eat15 = carrots_left_to_eat14 * carrots_left_to_eat\n        val carrots_left_to_eat16 = carrots_left_to_eat15 * carrots_left_to_eat\n        val carrots_left_to_eat17 = carrots_left_to_eat16 * carrots_left_to_eat\n        val carrots_left_to_eat18 = carrots_left_to_eat17 * carrots_left_to_eat\n        val carrots_left_to_eat19 = carrots_left_to_eat18 * carrots_left_to_eat\n        val carrots_left_to_eat20 = carrots_left_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7g68jum0.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7g68jum0.scala:55:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat20\u001b[0m = carrots_left_to_\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: carrots_left_to_\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7g68jum0.scala:56:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n        val need_left = needs - remaining\n        val carrots_left_to_eat = (carrots_left - need_left).toInt\n        val need_left_to_eat = (need_left - carrots_left).toInt\n        val carrots_to_eat = (carrots_left_to_eat + need_left_to_eat).toInt\n        val need_to_eat = (need_left_to_eat + carrots_left_to_eat).toInt\n        val carrots_to_eat_left = carrots_to_eat - need_to_eat\n        val need_to_eat_left = need_to_eat - carrots_to_eat\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left - need_to_eat_left).toInt\n        val need_to_eat_left_to_eat = (need_to_eat_left - carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat + need_to_eat_left_to_eat\n        val need_to_eat_left_to_eat_left = need_to_eat_left_to_eat + carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left - need_to_eat_left_to_eat_left).toInt\n        val need_to_eat_left_to_eat_left_to_eat = (need_to_eat_left_to_eat_left - carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat + need_to_eat_left_to_eat_left_to_eat\n        val need_to_eat_left_to_eat_left_to_eat_left = need_to_eat_left_to_eat_left_to_eat + carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left - need_to_eat_left_to_eat_left_to_eat_left).toInt\n        val need_to_eat_left_to_eat_left_to_eat_left = need_to_eat_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz2b6sgle.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneed_to_eat_left_to_eat_left_to_eat_left\u001b[0m = need_to_eat_left_to_e\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneed_to_eat_left_to_eat_left_to_eat_left is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneed_to_eat_left_to_eat_left_to_eat_left\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpz2b6sgle.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2b6sgle.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz2b6sgle.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010359
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n        val hungryRemaining = remaining - need\n        val hungryEaten = if (hungryRemaining > 0) hungryRemaining else 0\n        val hungryEatenList = List(hungryEaten.toLong)\n        val hungryEatenList2 = List(hungryEaten.toLong)\n        val hungryEatenList3 = List(hungryEaten.toLong)\n        val hungryEatenList4 = List(hungryEaten.toLong)\n        val hungryEatenList5 = List(hungryEaten.toLong)\n        val hungryEatenList6 = List(hungryEaten.toLong)\n        val hungryEatenList7 = List(hungryEaten.toLong)\n        val hungryEatenList8 = List(hungryEaten.toLong)\n        val hungryEatenList9 = List(hungryEaten.toLong)\n        val hungryEatenList10 = List(hungryEaten.toLong)\n        val hungryEatenList11 = List(hungryEaten.toLong)\n        val hungryEatenList12 = List(hungryEaten.toLong)\n        val hungryEatenList13 = List(hungryEaten.toLong)\n        val hungryEatenList14 = List(hungryEaten.toLong)\n        val hungryEatenList15 = List(hungryEaten.toLong)\n        val hungryEatenList16 = List(hungryEaten.toLong)\n        val hungryEatenList17 = List(hungryEaten.toLong)\n        val hungryEatenList18 = List(hungryEaten.toLong)\n        val hungryEatenList19 = List(hungryEaten.toLong)\n        val hungryEatenList20 = List(hungryEat\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8sqf3szk.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8sqf3szk.scala:53:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryEatenList20\u001b[0m = List(hungryEat\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: hungryEat\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8sqf3szk.scala:54:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010362
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList2 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList3 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList4 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList5 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList6 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList7 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList8 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList9 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList10 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList11 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList12 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList13 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList14 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList15 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList16 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList17 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList18 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList19 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList20 = List(carrotLeftToEat.toLong)\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzxe5r0ar.scala:57:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010362
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrotsRemaining = carrots - remaining\n        val needsToEat = needs - carrotsRemaining\n        val carrotsToEat = carrotsRemaining + needsToEat\n        val carrotsToEatList = List(carrotsToEat.toLong)\n        val carrotsToEatList2 = List(carrotsToEat.toLong)\n        val carrotsToEatList3 = List(carrotsToEat.toLong)\n        val carrotsToEatList4 = List(carrotsToEat.toLong)\n        val carrotsToEatList5 = List(carrotsToEat.toLong)\n        val carrotsToEatList6 = List(carrotsToEat.toLong)\n        val carrotsToEatList7 = List(carrotsToEat.toLong)\n        val carrotsToEatList8 = List(carrotsToEat.toLong)\n        val carrotsToEatList9 = List(carrotsToEat.toLong)\n        val carrotsToEatList10 = List(carrotsToEat.toLong)\n        val carrotsToEatList11 = List(carrotsToEat.toLong)\n        val carrotsToEatList12 = List(carrotsToEat.toLong)\n        val carrotsToEatList13 = List(carrotsToEat.toLong)\n        val carrotsToEatList14 = List(carrotsToEat.toLong)\n        val carrotsToEatList15 = List(carrotsToEat.toLong)\n        val carrotsToEatList16 = List(carrotsToEat.toLong)\n        val carrotsToEatList17 = List(carrotsToEat.toLong)\n        val carrotsToEatList18 = List(carrotsToEat.toLong)\n        val carrotsToEatList19 = List(carrotsToEat.toLong)\n        val carrotsToEatList20 = List(carrotsTo\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv1zky6bi.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv1zky6bi.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv1zky6bi.scala:56:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrotsToEatList20\u001b[0m = List(carrotsTo\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: carrotsTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv1zky6bi.scala:57:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010364
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number - remaining\n        val hungryCarrotsToEat = need - hungryCarrots\n        val hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList2 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList3 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList4 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList5 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList6 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList7 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList8 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList9 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList10 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList11 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList12 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList13 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList14 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList15 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList16 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsTo\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp19l2xe5l.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp19l2xe5l.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010364
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n        while (carrots_left > 0) {\n            val carrots_needed = carrots_left / needs.toDouble\n            val carrots_left_to_eat = (carrots_left - carrots_needed).toInt\n            val carrots_left_to_eat_doubled = (carrots_left_to_eat * 2).toInt\n            val carrots_left_to_eat_doubled_doubled = (carrots_left_to_eat_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled_doubled_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo1pqpwv7.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo1pqpwv7.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpo1pqpwv7.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo1pqpwv7.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpo1pqpwv7.scala:42:71 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_doubled_doubled_doubled_doubled\u001b[0m = (carrots_left_to_eat_doubled_doubled_doubled_doubled * \u001b[31m2\u001b[0m).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_doubled_doubled_doubled_doubled\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo1pqpwv7.scala:48:119 -----------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\u001b[0m = (carrots_left_to_eat_doubled_\n\u001b[31m\u001b[31m   |\u001b[0m                   ",
      "stdout": "",
      "timestamp": 1660010369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n        val hungryRemaining = remaining - need\n        val hungryEaten = math.min(hungry, hungryRemaining)\n        val hungryEatenRemaining = math.max(hungry, hungryRemaining)\n        val hungryEatenList = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList2 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList3 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList4 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList5 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList6 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList7 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList8 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList9 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList10 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList11 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList12 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        val hungryEatenList13 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2lgp4j00.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n        val left  = remaining - need\n        val meals = List(need)\n        val hungryMeals = List(need)\n        val leftMeals  = List(left)\n        val hungryLeftMeals = List(left)\n        val hungryLeftMeals2 = List(left)\n        val hungryLeftMeals3 = List(left)\n        val hungryLeftMeals4 = List(left)\n        val hungryLeftMeals5 = List(left)\n        val hungryLeftMeals6 = List(left)\n        val hungryLeftMeals7 = List(left)\n        val hungryLeftMeals8 = List(left)\n        val hungryLeftMeals9 = List(left)\n        val hungryLeftMeals10 = List(left)\n        val hungryLeftMeals11 = List(left)\n        val hungryLeftMeals12 = List(left)\n        val hungryLeftMeals13 = List(left)\n        val hungryLeftMeals14 = List(left)\n        val hungryLeftMeals15 = List(left)\n        val hungryLeftMeals16 = List(left)\n        val hungryLeftMeals17 = List(left)\n        val hungryLeftMeals18 = List(left)\n        val hungryLeftMeals19 = List(left)\n        val hungryLeftMeals20 = List(left)\n        val hungryLeftMeals21 = List(left)\n        val hungryLeftMeals22 = List(left)\n        val hungryLeftMeals23 = List(left)\n        val hungryLeftMeals24 = List(left)\n        val hungryLeftMeals25 = List(left)\n        val hungryLeftMeals26 = List(left)\n        val hungryLeftMeals27 = List(left)\n        val hungryLeftMeals28 = List(left)\n        val hungryLeftMeals29 = List(left)\n        val hungryLeftMeals30 = List(left)\n        val hungryLeftMeals31 = List(left)\n        val hungryLeftMeals32 = List(left)\n        val hungryLeftMeals33 = List(left)\n        val hungryLeftMeals34 = List(left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplsuix2lv.scala:70:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010368
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val carrots_needed = needs - carrots_left\n        val carrots_left_after_meals = carrots_left - carrots_needed\n        val carrots_needed_after_meals = carrots_needed - carrots_left\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals - carrots_needed_after_meals\n        val carrots_needed_after_meals_after_meals = carrots_needed_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals - carrots_needed_after_meals_after_meals\n        val carrots_needed_after_meals_after_meals_after_meals = carrots_needed_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals - carrots_needed_after_meals_after_meals_after_meals_after_meals\n        val carrots_needed_after_meals_after_meals_after_meals_after_meals = carrots_needed_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n        val carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpn6fl6s3g.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpn6fl6s3g.scala:43:77 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_needed_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_needed_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots_needed_after_meals_after_meals_after_meals_after_meals\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpn6fl6s3g.scala:44:87 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn6fl6s3g.scala:45:101 -----------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = carrots_needed_after_meals_after_meals_after_meals_afte",
      "stdout": "",
      "timestamp": 1660010367
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n        val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryRemainingCarrots = remainingCarrots - hungry\n        val hungryRemainingMeals = hungryMeals - hungryCarrots\n        val hungryRemainingHungryCarrots = hungryRemainingCarrots - hungryRemainingMeals\n        val hungryRemainingHungryMeals = hungryRemainingMeals - hungryRemainingHungryCarrots\n        val hungryRemainingHungryHungryCarrots = hungryRemainingHungryCarrots - hungryRemainingHungryMeals\n        val hungryRemainingHungryHungryMeals = hungryRemainingHungryMeals - hungryRemainingHungryHungryCarrots\n        val hungryRemainingHungryHungryHungryCarrots = hungryRemainingHungryHungryCarrots - hungryRemainingHungryHungryMeals\n        val hungryRemainingHungryHungryHungryMeals = hungryRemainingHungryHungryMeals - hungryRemainingHungryHungryHungryCarrots\n        val hungryRemainingHungryHungryHungryHungryCarrots = hungryRemainingHungryHungryHungryMeals - hungryRemainingHungryHungryHungryHungryMeals\n        val hungryRemainingHungryHungryHungryHungryMeals = hungry\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpk265wrpw.scala:35:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryCarrots\u001b[0m = carrots - hungry\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((hungry : Boolean))\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpk265wrpw.scala:36:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryMeals\u001b[0m = meals - hungry\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((hungry : Boolean))\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpk265wrpw.scala:37:54 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemainingCarrots\u001b[0m = remainingCarrots - hungry\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((hungry : Boolean))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk265wrpw.scala:47:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1660010369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining - carrots\n        val meals = List(need)\n        val hungry = true\n        val hungryCarrots = List(number)\n        val hungryCarrotsRemaining = remaining\n        while (hungry) {\n            val hungryMeals = meals.takeWhile(_ < need)\n            val hungryCarrotsRemaining = hungryCarrotsRemaining - hungryMeals.head\n            val hungryCarrots = hungryCarrots.takeWhile(_ < hungryCarrotsRemaining)\n            val hungryMealsRemaining = hungryMeals.takeWhile(_ < need)\n            val hungryMealsRemainingCarrots = hungryMealsRemaining.takeWhile(_ < carrots)\n            hungry = hungryMealsRemainingCarrots.isEmpty\n            meals = hungryMeals\n            hungryCarrots = hungryCarrotsRemaining\n            hungryCarrotsRemaining = hungryMealsRemainingCarrots\n        }\n        meals.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnrcii1g8.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnrcii1g8.scala:39:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mhungryCarrotsRemaining\u001b[0m = hungryCarrotsRemaining - hungryMeals.head\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Recursive \u001b[33mvalue\u001b[0m \u001b[35mhungryCarrotsRemaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnrcii1g8.scala:40:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mhungryCarrots\u001b[0m = hungryCarrots.takeWhile(_ < hungryCarrotsRemaining)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Recursive \u001b[33mvalue\u001b[0m \u001b[35mhungryCarrots\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpnrcii1g8.scala:43:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            hungry = hungryMealsRemainingCarrots.isEmpty\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val hungry\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpnrcii1g8.scala:44:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            meals = hungryMeals\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val meals\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with ",
      "stdout": "",
      "timestamp": 1660010365
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_le",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val carrots_left_to_eat = (needs - carrots).toInt\n        val carrots_left_to_eat_max = carrots_left - carrots_left_to_eat\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuy2avr98.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_min\u001b[0m = carrots_left_to_eat - carrots_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_min is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_min\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_max\u001b[0m = carrots_left_to_eat - carrots_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_max is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_max\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_min\u001b[0m = carrots_left_to_eat - carrots_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat_min is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat_min\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat_max\u001b[0m = carrots_left_to_eat - carrots_left\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660010369
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val result = carrots_left_list ++ needs_left_list\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgy4j_fr9.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010365
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = carrots - remaining\n        val hungry = carrots - meals\n        val eaten = meals - need\n        val left = (carrots - eaten) - hungry\n        List(meals.toLong, left.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsdlmwzvj.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010367
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n        val needs_left = needs - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_list\u001b[0m = List(carrots_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_list\u001b[0m = List(needs_left.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_le",
      "stdout": "",
      "timestamp": 1660010250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - needs\n        val needs_left_to_eat = (needs_left / needs).toInt\n        val carrots_left_to_eat = (carrots_left / needs).toInt\n        val carrots_left_to_eat = if (carrots_left_to_eat > 0) carrots_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat > 0) needs_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (carrots_left_to_eat > \u001b[31m0\u001b[0m) carrots_left_to_eat \u001b[33melse\u001b[0m \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcarrots_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcarrots_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (needs_left_to_eat > \u001b[31m0\u001b[0m) needs_left_to_eat \u001b[33melse\u001b[0m \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (needs_left_to_eat > \u001b[31m0\u001b[0m) needs_left_to_eat \u001b[33melse\u001b[0m \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mneeds_left_to_eat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mneeds_left_to_eat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_to_eat\u001b[0m = \u001b[33mif\u001b[0m (needs_left_to_eat > \u001b[31m0\u001b[0m) needs_left_to_eat \u001b[33melse\u001b[0m \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660010371
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        if (carrotLeftToEatList == List(0l)) {\n            carrotLeftToEatList\n        } else {\n            carrotLeftToEatList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgrsg988_.scala:44)\n\tat Problem.main(tmpgrsg988_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010372
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n        val hungryRemaining = remaining.toInt\n        val needToEat = need.toInt\n        val needToEatRemaining = hungryRemaining - needToEat\n        val hungryEaten = hungry - needToEat\n        val hungryEatenRemaining = hungryRemaining - hungryEaten\n        val hungryEatenRemainingToEat = hungryEatenRemaining.toInt\n        val hungryEatenRemainingToEatRemaining = hungryEatenRemainingToEat.toInt\n        val hungryEatenRemainingToEatRemainingToEat = hungryEatenRemainingToEatRemaining.toInt\n        val hungryEatenRemainingToEatRemainingToEatRemaining = hungryEatenRemainingToEatRemainingToEat.toInt\n        val hungryEatenRemainingToEatRemainingToEatRemainingToEat = hungryEatenRemainingToEatRemainingToEatRemainingToEat.toInt\n        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemaining = hungryEatenRemainingToEatRemainingToEatRemainingToEat.toInt\n        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat.toInt\n        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining.toInt\n        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemainingToEat = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingTo\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpd2thzhwg.scala:41:68 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryEatenRemainingToEatRemainingToEatRemainingToEat\u001b[0m = hungryEatenRemainingToEatRemainingToEatRemainingToEat.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mhungryEatenRemainingToEatRemainingToEatRemainingToEat\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpd2thzhwg.scala:43:82 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat\u001b[0m = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpd2thzhwg.scala:44:91 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\u001b[0m = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd2thzhwg.scala:45:96 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemainingToEat\u001b",
      "stdout": "",
      "timestamp": 1660010371
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining = remaining + carrots\n        val meals = List(need)\n        val hungry = true\n        val hungryCarrots = List(number)\n        val hungryRemaining = remaining\n        val hungryMeals = List(need)\n        while (hungry) {\n            val hungryMeals = List(need - hungryRemaining)\n            val hungryRemaining = remaining - hungryMeals.last\n            val hungryCarrots = List(number - hungryRemaining)\n            val hungryMeals = List(need - hungryRemaining)\n            hungry = false\n            val hungryMeals = List(need - hungryRemaining)\n            val hungryRemaining = remaining - hungryMeals.last\n            val hungryCarrots = List(number - hungryRemaining)\n            val hungryMeals = List(need - hungryRemaining)\n            hungry = true\n        }\n        val hungryMeals = List(need - hungryRemaining)\n        val hungryRemaining = remaining - hungryMeals.last\n        val hungryCarrots = List(number - hungryRemaining)\n        val hungryMeals = List(need - hungryRemaining)\n        List(number - hungryRemaining, hungryRemaining)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyynk095p.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryMeals\u001b[0m = List(need - hungryRemaining)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyynk095p.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryRemaining\u001b[0m = remaining - hungryMeals.last\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryRemaining is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryRemaining\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyynk095p.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryCarrots\u001b[0m = List(number - hungryRemaining)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryCarrots is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryCarrots\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyynk095p.scala:53:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhungryMeals\u001b[0m = List(need - hungryRemaining)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mhungryMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mhungryMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpyynk095p.scala:32:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining + ca",
      "stdout": "",
      "timestamp": 1660010369
    },
    {
      "exit_code": -1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n        val leftCarrots = remaining - carrots\n        val result = List(carrots.toLong, leftCarrots.toLong)\n        if (leftCarrots == 0) result\n        else eat(number, need, remaining - carrots)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "Timeout",
      "stderr": "None",
      "stdout": "None",
      "timestamp": 1660010377
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = math.min(needs, carrots)\n        val carrots_left = math.max(0, carrots - meals)\n        val carrots_left_after_meals = math.max(0, carrots_left - remaining)\n        val carrots_left_after_meals_after_meals = math.max(0, carrots_left_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals = math.max(0, carrots_left_after_meals_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals = math.max(0, carrots_left_after_meals_after_meals_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpr08ta49r.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpr08ta49r.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpr08ta49r.scala:43:135 --------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = math.max(\u001b[31m0\u001b[0m, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals - meals)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr08ta49r.scala:44:147 -----------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\u001b[0m = math.max(\u001b[31m0\u001b[0m, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1660010373
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat = needs - carrots_left\n        val carrots_left_to_eat2 = carrots_left_to_eat.toInt\n        val needs_left_to_eat2 = needs_left_to_eat.toInt\n        val carrots_left_to_eat3 = carrots_left_to_eat2.toInt\n        val needs_left_to_eat3 = needs_left_to_eat2.toInt\n        val carrots_left_to_eat4 = carrots_left_to_eat3.toInt\n        val needs_left_to_eat4 = needs_left_to_eat3.toInt\n        val carrots_left_to_eat5 = carrots_left_to_eat4.toInt\n        val needs_left_to_eat5 = needs_left_to_eat4.toInt\n        val carrots_left_to_eat6 = carrots_left_to_eat5.toInt\n        val needs_left_to_eat6 = needs_left_to_eat5.toInt\n        val carrots_left_to_eat7 = carrots_left_to_eat6.toInt\n        val needs_left_to_eat7 = needs_left_to_eat6.toInt\n        val carrots_left_to_eat8 = carrots_left_to_eat7.toInt\n        val needs_left_to_eat8 = needs_left_to_eat7.toInt\n        val carrots_left_to_eat9 = carrots_left_to_eat8.toInt\n        val needs_left_to_eat9 = needs_left_to_eat8.toInt\n        val carrots_left_to_eat10 = carrots_left_to_eat9.toInt\n        val needs_left_to_eat10 = needs_left_to_eat9.toInt\n        val carrots_left_to_eat11 = carrots_left_to_eat10.toInt\n        val needs_left_to_eat11 = needs_left_to_eat10.toInt\n        val carrots_left_to_eat12 = carrots_left_to_eat11.toInt\n        val needs_left_to_eat12 = needs_left_to_eat11.toInt\n        val carrots_left_to_eat13 = carrots_left_to_eat12.toInt\n        val needs_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplyhwc7pp.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplyhwc7pp.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplyhwc7pp.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplyhwc7pp.scala:63:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010374
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val result = new mutable.ListBuffer[Long]()\n        val carrots_left = remaining - carrots\n        val needs_left = carrots - needs\n        val needs_left_carrots = needs_left * carrots\n        val needs_left_carrots_left = needs_left_carrots - carrots\n        val needs_left_carrots_left_carrots = needs_left_carrots_left * carrots\n        val needs_left_carrots_left_carrots_left = needs_left_carrots_left_carrots - carrots\n        val needs_left_carrots_left_carrots_left_carrots = needs_left_carrots_left_carrots_left * carrots\n        val needs_left_carrots_left_carrots_left_carrots_left = needs_left_carrots_left_carrots_left_carrots - carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots = needs_left_carrots_left_carrots_left_carrots_left * carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left = needs_left_carrots_left_carrots_left_carrots_left_carrots - carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots = needs_left_carrots_left_carrots_left_carrots_left_carrots_left * carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left - carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left * carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots - carrots\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp28swsuj2.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp28swsuj2.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp28swsuj2.scala:46:90 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mneeds_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\u001b[0m = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left - carrots\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp28swsuj2.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010374
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val totalCarrots = carrots + remaining\n        val totalNeeds = needs + remaining\n        val totalNeedsAfterMeals = totalNeeds - carrots\n        val totalCarrotsAfterMeals = totalCarrots - need\n        val totalCarrotsLeftAfterMeals = totalCarrots - totalNeedsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMeals = totalCarrotsLeftAfterMeals - totalCarrotsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMeals = totalCarrotsLeftAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals = totalCarrotsLeftAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n        val totalCarrotsLeftAfterMe\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwld1zd_n.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwld1zd_n.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\u001b[0m = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals is already defined as \u001b[33mvalue\u001b[0m \u001b[35mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwld1zd_n.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwld1zd_n.scala:44:91 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\u001b[0m = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  totalCarrotsLeftAfterMe",
      "stdout": "",
      "timestamp": 1660010373
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    // but now you need to eat more carrots to complete the day's meals.\n    // you should return an array of [ total number of eaten carrots after your meals,\n    // the number of carrots left after your meals ]\n    // if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number : integer\n    // the number of carrots that you have eaten.\n    // @need : integer\n    // the number of carrots that you need to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n        val needs = need.toInt\n        val remaining = remaining.toInt\n        val meals = math.min(needs, carrots)\n        val leftCarrots = math.max(0, carrots - meals)\n        val leftNeeds = math.max(0, needs - meals)\n        val leftRemaining = math.max(0, remaining - meals)\n        val leftMeals = math.min(leftNeeds, leftCarrots)\n        val leftLeftCarrots = math.max(0, leftCarrots - leftMeals)\n        val leftLeftNeeds = math.max(0, leftNeeds - leftMeals)\n        val leftLeftRemaining = math.max(0, leftRemaining - leftMeals)\n        val leftLeftMeals = math.min(leftLeftNeeds, leftLeftCarrots)\n        val leftLeftLeftCarrots = math.max(0, leftLeftCarrots - leftLeftMeals)\n        val leftLeftLeftNeeds = math.max(0, leftLeftNeeds - leftLeftMeals)\n        val leftLeftLeftRemaining = math.max(0, leftLeftRemaining - leftLeftMeals)\n        val leftLeftLeftMeals = math.min(leftLeftLeftNeeds, leftLeftLeftCarrots)\n        val leftLeftLeftLeftCarrots = math.max(0, leftLeftLeftCarrots - leftLeftLeftMeals)\n        val leftLeftLeftLeftNeeds = math.max(0, leftLeftLeftNeeds - leftLeftLeftMeals)\n        val leftLeftLeftLeftRemaining = math.max(0, leftLeftLeftRemaining - leftLeftLeftMeals)\n        val leftLeftLeftLeftMeals = math.min(leftLeftLeftLeftNeeds, leftLeftLeftLeftCarrots)\n        val leftLeftLeftLeftLeftCarrots = math.max(0, leftLeftLeftLeftCarrots - leftLeftLeftLeftMeals)\n        val leftLeftLeftLeftLeftNeeds = math.max(0, leftLeftLeftLeftNeeds - leftLeftLeftLeftMeals)\n        val leftLeftLeftLeftLeftRemaining = math.max(0, leftLeftLeftLeftRemaining - leftLeftLeftLeftMeals)\n        val leftLeftLeftLeftLeftMeals = math.min(leftLeftLeftLeftLeftNeeds, leftLeftLeftLeftLeftCarrots)\n        val leftLeftLeftLeftLeftLeftCarrots = math.max(0, leftLeftLeftLeftLeftCarrots - leftLeftLeftLeftLeftMeals)\n        val leftLeftLeftLeftLeftLeftNeeds = math.max(0, leftLeftLeftLeftLeftNeeds - leftLeftLeftLeftLeftMeals)\n        val leftLeftLeftLeft\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6luofs0o.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6luofs0o.scala:33:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremaining\u001b[0m = remaining.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mremaining\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6luofs0o.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010374
    }
  ]
}