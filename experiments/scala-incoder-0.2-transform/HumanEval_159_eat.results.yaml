language: scala
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsLeft = carrots - remaining\n        val needsLeft  = needs -\
    \ remaining\n        val carrotEaten = carrots - carrotsLeft\n        val needEaten\
    \  = needs - needsLeft\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val needEatenList = List(needEaten.toLong)\n        val carrotLeftList\
    \ = List(carrotsLeft.toLong)\n        val needLeftList = List(needLeft.toLong)\n\
    \        (carrotEatenList, needEatenList, carrotLeftList, needLeftList)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp07yjvwpq.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp07yjvwpq.scala:41:32\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mneedLeftList\e[0m = List(needLeft.toLong)\n\e[31m\e[31m   |\e[0m         \
    \                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \         Not found: needLeft\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp07yjvwpq.scala:42:8 ---------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        (carrotEatenList, needEatenList, carrotLeftList, needLeftList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  Found:    (List[Nothing], List[Nothing], List[Nothing],\
    \ List[Nothing])\n\e[31m   |\e[0m  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left, carrots_left)\n        meals.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaud8b0bi.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = remaining - carrots\n        val meals = carrots - need\n\
    \        val meals_left = carrots_left - meals\n        val meals_left_to_eat\
    \ = (meals_left / meals).toInt\n        val meals_left_to_eat_2 = meals_left %\
    \ meals\n        val meals_left_to_eat_3 = meals_left_to_eat + meals_left_to_eat_2\n\
    \        val meals_left_to_eat_4 = meals_left_to_eat_3 + meals_left_to_eat_3\n\
    \        val meals_left_to_eat_5 = meals_left_to_eat_4 + meals_left_to_eat_4\n\
    \        val meals_left_to_eat_6 = meals_left_to_eat_5 + meals_left_to_eat_5\n\
    \        val meals_left_to_eat_7 = meals_left_to_eat_6 + meals_left_to_eat_6\n\
    \        val meals_left_to_eat_8 = meals_left_to_eat_7 + meals_left_to_eat_7\n\
    \        val meals_left_to_eat_9 = meals_left_to_eat_8 + meals_left_to_eat_8\n\
    \        val meals_left_to_eat_10 = meals_left_to_eat_9 + meals_left_to_eat_9\n\
    \        val meals_left_to_eat_11 = meals_left_to_eat_10 + meals_left_to_eat_10\n\
    \        val meals_left_to_eat_12 = meals_left_to_eat_11 + meals_left_to_eat_11\n\
    \        val meals_left_to_eat_13 = meals_left_to_eat_12 + meals_left_to_eat_12\n\
    \        val meals_left_to_eat_14 = meals_left_to_eat_13 + meals_left_to_eat_13\n\
    \        val meals_left_to_eat_15 = meals_left_to_eat_14 + meals_left_to_eat_14\n\
    \        val meals_left_to_eat_16 = meals_left_to_eat_15 + meals_left_to_eat_15\n\
    \        val meals_left_to_eat_17 = meals_left_to_eat_16\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7ruyym17.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ruyym17.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_needed = needs\
    \ - carrots_left\n        val carrots_needed_to_eat = (carrots_needed / carrots).toInt\n\
    \        val carrots_left_to_eat = (carrots_needed % carrots).toInt\n        val\
    \ carrots_to_eat = (carrots_left_to_eat + carrots_needed_to_eat).toInt\n     \
    \   val carrots_to_eat_left = carrots_to_eat - carrots_needed\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed\
    \ = (carrots_to_eat_left_to_eat / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat\
    \ = (carrots_to_eat_left_to_eat_needed / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat_left\
    \ = carrots_to_eat_left_to_eat_needed - carrots_to_eat_left_to_eat\n        val\
    \ carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_needed_to_eat\
    \ / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed\
    \ = (carrots_to_eat_left_to_eat_needed_to_eat_left / carrots).toInt\n        val\
    \ carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed_to_eat = (carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat\
    \ / carrots).toInt\n        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed_to_eat_left\
    \ = carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat - carrots_to_eat_left_to_eat_needed\n\
    \        val carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed\
    \ = (carrots_to_eat_left_to_eat_needed_to_eat_left_to_eat_needed / carrots).toInt\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6s373wsl.scala:49:11 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6s373wsl.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6s373wsl.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val left  = need - remaining\n        if(hungry <= 0) List(number.toLong)\n\
    \        else List(number.toLong, hungry.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnw6bkohe.scala:37)\n\tat Problem.main(tmpnw6bkohe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remaining = remaining + meals\n\
    \        val mealsLeft = meals + carrots\n        val mealsRight = meals - carrots\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsRight = mealsRight.toString.toLong\n\
    \        List(mealsLeft, mealsRight)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm3yflj9u.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toString.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm3yflj9u.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmealsRight\e[0m = mealsRight.toString.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmealsRight is already defined as \e[33mvalue\e[0m \e[35mmealsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpm3yflj9u.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining + meals\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ / needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n   \
    \     val needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val\
    \ carrots_left_to_eat_4 = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4\
    \ = (needs_left / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left\
    \ / needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n   \
    \     val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val\
    \ carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7\
    \ = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n   \
    \     val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val\
    \ carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10\
    \ = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphwmzperf.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphwmzperf.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphwmzperf.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphwmzperf.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots.toLong\n        val hungryMeals = meals.toLong\n\
    \        val hungryRemaining = remaining.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemaining - hungryCarrots\n        val hungryRemainingMeals = hungryRemaining\
    \ - hungryMeals\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n\
    \        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val\
    \ hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val\
    \ hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val\
    \ hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrot\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingCarrots\e\
    [0m = hungryRemainingCarrots.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingCarrots is already defined as \e[33mvalue\e\
    [0m \e[35mhungryRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingMeals\e[0m\
    \ = hungryRemainingMeals.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingMeals is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryRemainingMeals\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingCarrots\e\
    [0m = hungryRemainingCarrots.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingCarrots is already defined as \e[33mvalue\e\
    [0m \e[35mhungryRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt10dzcb0.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingMeals\e[0m\
    \ = hungryRemainingMeals.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingMeals is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryRemainingMeals\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /t"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_minus_1\
    \ = (carrots_left - carrots_left_to_eat).toInt\n        val needs_left_to_eat_minus_1\
    \ = (needs_left - needs_left_to_eat).toInt\n        val carrots_left_to_eat_minus_2\
    \ = (carrots_left - carrots_left_to_eat_minus_1).toInt\n        val needs_left_to_eat_minus_2\
    \ = (needs_left - needs_left_to_eat_minus_1).toInt\n        val carrots_left_to_eat_minus_3\
    \ = (carrots_left - carrots_left_to_eat_minus_2).toInt\n        val needs_left_to_eat_minus_3\
    \ = (needs_left - needs_left_to_eat_minus_2).toInt\n        val carrots_left_to_eat_minus_4\
    \ = (carrots_left - carrots_left_to_eat_minus_3).toInt\n        val needs_left_to_eat_minus_4\
    \ = (needs_left - needs_left_to_eat_minus_3).toInt\n        val carrots_left_to_eat_minus_5\
    \ = (carrots_left - carrots_left_to_eat_minus_4).toInt\n        val needs_left_to_eat_minus_5\
    \ = (needs_left - needs_left_to_eat_minus_4).toInt\n        val carrots_left_to_eat_minus_6\
    \ = (carrots_left - carrots_left_to_eat_minus_5).toInt\n        val needs_left_to_eat_minus_6\
    \ = (needs_left - needs_left_to_eat_minus_5).toInt\n        val carrots_left_to_eat_minus_7\
    \ = (carrots_left - carrots_left_to_eat_minus_6).toInt\n        val needs_left_to_eat_minus_7\
    \ = (needs_left - needs_left_to_eat_minus_6).toInt\n        val carrots_left_to_eat_min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5y5anzbf.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5y5anzbf.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5y5anzbf.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5y5anzbf.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - hungry\n        if (hungryRemaining\
    \ < 0l) {\n            val hungryRemainingList = List(hungryRemaining.toLong)\n\
    \            hungryRemainingList :+ 0l.toLong\n        } else {\n            val\
    \ hungryRemainingList = List(hungryRemaining.toLong)\n            hungryRemainingList\
    \ :+ hungry.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7uap1al4.scala:42)\n\tat Problem.main(tmp7uap1al4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_after_meals = carrots_left - needs_left\n\
    \        val needs_left_after_meals = needs_left - carrots_left\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left_after_meals - needs_left_after_meals\n        val needs_left_after_meals_after_meals\
    \ = needs_left_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - needs_left_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsn65h1to.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpsn65h1to.scala:44:87 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:45:85\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /t"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ArrayList[Long]()\n        var carrots_left\
    \ = remaining\n        var carrots_eaten = 0\n        var carrots_left_after_meals\
    \ = 0\n        var carrots_eaten_after_meals = 0\n        var carrots_left_after_meals_after_meals\
    \ = 0\n        var carrots_eaten_after_meals_after_meals = 0\n        var carrots_left_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_eaten_after_meals_after_meals_after_meals = 0\n   \
    \     var carrots_left_after_meals_after_meals_after_meals_after_meals = 0\n \
    \       var carrots_eaten_after_meals_after_meals_after_meals_after_meals = 0\n\
    \        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = 0\n        var carrots_eaten_after_meals_after_meals_after_meals_after_meals_after_me\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcp0juv87.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcp0juv87.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpcp0juv87.scala:34:37 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]\
    \ = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                               Not found: type ArrayList\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcp0juv87.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ArrayList[Long]()\n        val carrots_remaining\
    \ = remaining - carrots\n        val needs_remaining = carrots_remaining - needs\n\
    \        val carrots_needs = carrots - needs\n        val needs_carrots = needs\
    \ - carrots\n        val carrots_remaining_needs = carrots_remaining - needs_remaining\n\
    \        val needs_remaining_carrots = needs_remaining - carrots_remaining\n \
    \       val needs_carrots_remaining = needs_carrots - carrots_remaining\n    \
    \    val needs_carrots_needs = needs_carrots - needs_carrots\n        val needs_carrots_remaining_needs\
    \ = needs_carrots_remaining - needs_remaining_carrots\n        val needs_carrots_needs_remaining\
    \ = needs_carrots_needs - needs_carrots_remaining\n        val needs_carrots_needs_remaining_needs\
    \ = needs_carrots_needs_remaining - needs_needs_remaining_carrots\n        val\
    \ needs_carrots_needs_needs_remaining = needs_carrots_needs_needs_remaining -\
    \ needs_needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_needs_remaining\
    \ = needs_carrots_needs_needs_needs_remaining - needs_needs_needs_needs_needs_remaining_carrots\n\
    \        val needs_carrots_needs_needs_needs_needs_remaining = needs_carrots_needs_needs_needs_needs_remaining\
    \ - needs_needs_needs_needs_needs_needs_remaining_carrots\n        val needs_carrots_needs_needs_needs_needs_remaining\
    \ = needs_carrots_needs_needs_needs_needs_needs_remaining - needs_needs_needs_needs_needs_needs_needs_remaining_carrots\n\
    \        val needs_carrots_needs_needs_needs_needs_needs_remaining = needs_carrots_needs_needs_needs_needs_needs_needs_needs_remaining\
    \ - needs_needs_needs_needs_needs_needs_needs_needs_needs_remaining_carrots\n\
    \        val needs_carrots_needs_needs_needs_needs_need\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpohs0tcke.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpohs0tcke.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneeds_carrots_needs_needs_needs_needs_remaining\e[0m = needs_carrots_needs_needs_needs_needs_needs_remaining\
    \ - needs_needs_needs_needs_needs_needs_needs_remaining_carrots\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_carrots_needs_needs_needs_needs_remaining is already\
    \ defined as \e[33mvalue\e[0m \e[35mneeds_carrots_needs_needs_needs_needs_remaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpohs0tcke.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpohs0tcke.scala:34:37 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: type ArrayList\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpohs0tcke.scala:46:50 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mneeds_carrots_needs_needs_remaining\e\
    [0m = needs_carrots_needs_needs_remaining"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat\
    \ = (needs_left / carrots).toInt\n        val needs_left_to_eat = (carrots_left\
    \ / needs).toInt\n        val carrots_left_to_eat_left = carrots_left - carrots_left_to_eat\
    \ * carrots\n        val needs_left_to_eat_left = carrots_left - needs_left_to_eat\
    \ * needs\n        val carrots_left_to_eat_left_to_eat = (needs_left_to_eat_left\
    \ / carrots).toInt\n        val needs_left_to_eat_left_to_eat = (carrots_left_to_eat_left\
    \ / needs).toInt\n        val carrots_left_to_eat_left_to_eat_left = carrots_left_to_eat_left\
    \ - carrots_left_to_eat_left_to_eat * carrots\n        val needs_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left - needs_left_to_eat_left_to_eat * needs\n       \
    \ val carrots_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat_left\
    \ / carrots).toInt\n        val needs_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat_left\
    \ / needs).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left\
    \ * carrots\n        val needs_left_to_eat_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat_left\
    \ - needs_left_to_eat_left_to_eat_left * needs\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left_to_eat / carrots).toInt\n        val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left_to_eat / needs)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0lxfhjjz.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0lxfhjjz.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0lxfhjjz.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining <= 0)\
    \ {\n            result ++= List(number.toLong)\n        } else {\n          \
    \  val carrots_left = carrots - remaining\n            val needs_left = needs\
    \ - remaining\n            result ++= List(needs_left.toLong, carrots_left.toLong)\n\
    \        }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp4yey2_4.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp4yey2_4.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsNeeded = needs - remaining\n        val carrotsNeededList = List(carrotsNeeded)\n\
    \        val carrotsNeededList2 = List(carrotsNeeded)\n        val carrotsNeededList3\
    \ = List(carrotsNeeded)\n        val carrotsNeededList4 = List(carrotsNeeded)\n\
    \        val carrotsNeededList5 = List(carrotsNeeded)\n        val carrotsNeededList6\
    \ = List(carrotsNeeded)\n        val carrotsNeededList7 = List(carrotsNeeded)\n\
    \        val carrotsNeededList8 = List(carrotsNeeded)\n        val carrotsNeededList9\
    \ = List(carrotsNeeded)\n        val carrotsNeededList10 = List(carrotsNeeded)\n\
    \        val carrotsNeededList11 = List(carrotsNeeded)\n        val carrotsNeededList12\
    \ = List(carrotsNeeded)\n        val carrotsNeededList13 = List(carrotsNeeded)\n\
    \        val carrotsNeededList14 = List(carrotsNeeded)\n        val carrotsNeededList15\
    \ = List(carrotsNeeded)\n        val carrotsNeededList16 = List(carrotsNeeded)\n\
    \        val carrotsNeededList17 = List(carrotsNeeded)\n        val carrotsNeededList18\
    \ = List(carrotsNeeded)\n        val carrotsNeededList19 = List(carrotsNeeded)\n\
    \        val carrotsNeededList20 = List(carrotsNeeded)\n        val carrotsNeededList21\
    \ = List(carrotsNeeded)\n        val carrotsNeededList22 = List(carrotsNeeded)\n\
    \        val carrotsNeededList23 = List(carrotsNeeded)\n        val carrotsNeededList24\
    \ = List(carrotsNeeded)\n        val carrotsNeededList25 = List(carrotsNeeded)\n\
    \        val carrotsNeededList26 = List(c\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1v4xd11x.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1v4xd11x.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1v4xd11x.scala:60:39 ------------------------\e[0m\e[0m\n\e[31m60 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrotsNeededList26\e[0m = List(c\n\e[31m\e[31m\
    \   |\e[0m                                       ^\e[0m\n\e[31m   |\e[0m     \
    \                                  Not found: c\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp1v4xd11x.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        var carrots_left = 0\n        var\
    \ meals_left = 0\n        var i = 0\n        while (i < carrots && carrots_left\
    \ < meals) {\n            carrots_left += number\n            meals_left += need\n\
    \            i += 1\n        }\n        if (meals_left > carrots) {\n        \
    \    carrots_left = carrots - meals_left\n        }\n        result(0) = carrots_left\n\
    \        result(1) = meals_left\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppixurz3f.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppixurz3f.scala:39:25\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            carrots_left\
    \ += number\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value += is not a member of Int - did you mean Int.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppixurz3f.scala:40:23 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            meals_left += need\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a\
    \ member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmppixurz3f.scala:48:8 ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m\
    \        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    (result : Array[Long])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat\
    \ = needs_left - carrots_left\n        val carrots_to_eat = carrots_left_to_eat\
    \ + needs_left_to_eat\n        val needs_to_eat = needs_left_to_eat + carrots_left_to_eat\n\
    \        val carrots_to_eat2 = carrots_to_eat.toInt\n        val needs_to_eat2\
    \ = needs_to_eat.toInt\n        val carrots_to_eat3 = carrots_to_eat2 * carrots_to_eat2\n\
    \        val needs_to_eat3 = needs_to_eat2 * needs_to_eat2\n        val carrots_to_eat4\
    \ = carrots_to_eat3 * carrots_to_eat3\n        val needs_to_eat4 = needs_to_eat3\
    \ * needs_to_eat3\n        val carrots_to_eat5 = carrots_to_eat4 * carrots_to_eat4\n\
    \        val needs_to_eat5 = needs_to_eat4 * needs_to_eat4\n        val carrots_to_eat6\
    \ = carrots_to_eat5 * carrots_to_eat5\n        val needs_to_eat6 = needs_to_eat5\
    \ * needs_to_eat5\n        val carrots_to_eat7 = carrots_to_eat6 * carrots_to_eat6\n\
    \        val needs_to_eat7 = needs_to_eat6 * needs_to_eat6\n        val carrots_to_eat8\
    \ = carrots_to_eat7 * carrots_to_eat7\n        val needs_to_eat8 = needs_to_eat7\
    \ * needs_to_eat7\n        val carrots_to_eat9 = carrots_to_eat8 * carrots_to_eat8\n\
    \        val needs_to_eat9 = needs_to_eat8 * needs_to_eat8\n        val carrots_to_eat10\
    \ = carrots_to_eat9 * carrots_to_eat9\n        val needs_to_eat10 = needs_to_eat9\
    \ * needs_to_eat9\n        val carrots_to_eat11 = carrots_to_eat10 * carrots_to_eat10\n\
    \        val needs_to_eat11 = needs_to_eat10 * needs_to_eat10\n        val carrots_to_eat12\
    \ = carrots_to_eat11 * carrots_to_eat11\n        val needs_to_eat12 = needs_to_eat11\
    \ * needs_to_eat11\n        val carrots_to_eat13 = carrots_to_eat12\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp66c3oov.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp66c3oov.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp66c3oov.scala:64:5 ---------------------\e[0m\e[0m\n\e[31m64\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ArrayList[Long]()\n        if (remaining <\
    \ needs) {\n            val carrots_left = carrots - remaining\n            val\
    \ carrots_left_to_eat = (needs - remaining).toInt\n            val carrots_to_eat\
    \ = (carrots_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left\
    \ = carrots_to_eat - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left - carrots_left_to_eat).toInt\n            val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n          \
    \  val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat\
    \ - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n\
    \            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ - carrots_left_to_eat\n            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n\
    \            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat\n\
    \            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat).toInt\n\
    \            val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp2l_1mla.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp2l_1mla.scala:61:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpp2l_1mla.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp2l_1mla.scala:34:37 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: type ArrayList\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp2l_1mla.scala:60:1 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpp2l_1mla.scala:51:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m51 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = needToEat - remainingToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n\
    \        if (carrotLeftToEatList.size < needToEat) {\n            carrotLeftToEatList.take(needToEat.toInt)\n\
    \        } else {\n            carrotLeftToEatList\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpktuud_ii.scala:44)\n\tat Problem.main(tmpktuud_ii.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = List(need +\
    \ carrots)\n        val hungry = List(need + carrots, remaining + carrots)\n \
    \       if (remaining <= 0) {\n            hungry\n        } else {\n        \
    \    meals :: eat(number, need, remaining)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoq9h8b59.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoq9h8b59.scala:38:12\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m            meals :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e\
    [0m            Found:    (meals : List[Long])\n\e[31m   |\e[0m            Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val meals_left = carrots - meals\n        val carrots_left_to_eat\
    \ = (carrots_left - meals_left).toInt\n        val meals_left_to_eat = (meals_left\
    \ - carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left - meals_left_to_eat).toInt\n\
    \        val meals_left_to_eat_2 = (meals_left_to_eat - carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left_to_eat_2 - meals_left_to_eat_2).toInt\n\
    \        val meals_left_to_eat_3 = (meals_left_to_eat_2 - carrots_left_to_eat_2).toInt\n\
    \        val carrots_left_to_eat_4 = (carrots_left_to_eat_3 - meals_left_to_eat_3).toInt\n\
    \        val meals_left_to_eat_4 = (meals_left_to_eat_3 - carrots_left_to_eat_3).toInt\n\
    \        val carrots_left_to_eat_5 = (carrots_left_to_eat_4 - meals_left_to_eat_4).toInt\n\
    \        val meals_left_to_eat_5 = (meals_left_to_eat_4 - carrots_left_to_eat_4).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left_to_eat_5 - meals_left_to_eat_5).toInt\n\
    \        val meals_left_to_eat_6 = (meals_left_to_eat_5 - carrots_left_to_eat_5).toInt\n\
    \        val carrots_left_to_eat_7 = (carrots_left_to_eat_6 - meals_left_to_eat_6).toInt\n\
    \        val meals_left_to_eat_7 = (meals_left_to_eat_6 - carrots_left_to_eat_6).toInt\n\
    \        val carrots_left_to_eat_8 = (carrots_left_to_eat_7 - meals_left_to_eat_7).toInt\n\
    \        val meals_left_to_eat_8 = (meals_left_to_eat_7\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyzavuf0p.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyzavuf0p.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpyzavuf0p.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyzavuf0p.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = carrots_left\
    \ - carrots_left_to_eat * needs_left\n        val needs_left_to_eat_2 = needs_left\
    \ - needs_left_to_eat * carrots_left\n        val carrots_left_to_eat_3 = carrots_left\
    \ - carrots_left_to_eat * needs_left_2\n        val needs_left_to_eat_3 = needs_left\
    \ - needs_left_to_eat * carrots_left_2\n        val carrots_left_to_eat_4 = carrots_left\
    \ - carrots_left_to_eat * needs_left_3\n        val needs_left_to_eat_4 = needs_left\
    \ - needs_left_to_eat * carrots_left_3\n        val carrots_left_to_eat_5 = carrots_left\
    \ - carrots_left_to_eat * needs_left_4\n        val needs_left_to_eat_5 = needs_left\
    \ - needs_left_to_eat * carrots_left_4\n        val carrots_left_to_eat_6 = carrots_left\
    \ - carrots_left_to_eat * needs_left_5\n        val needs_left_to_eat_6 = needs_left\
    \ - needs_left_to_eat * carrots_left_5\n        val carrots_left_to_eat_7 = carrots_left\
    \ - carrots_left_to_eat * needs_left_6\n        val needs_left_to_eat_7 = needs_left\
    \ - needs_left_to_eat * carrots_left_6\n        val carrots_left_to_eat_8 = carrots_left\
    \ - carrots_left_to_eat * needs_left_7\n        val needs_left_to_eat_8 = needs_left\
    \ - needs_left_to_eat * carrots_left_7\n        val carrots_left_to_eat_9 = carrots_left\
    \ - carrots_left_to_eat * needs_left_8\n        val needs_left_to_eat_9 = needs_left\
    \ - needs_left_to_eat * carrots_left_8\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmlcy308r.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmlcy308r.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpmlcy308r.scala:56:5 ---------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010248
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n\
    \        val left  = need.toInt\n        val total = hungry + left\n        val\
    \ remaining = total - hungry\n        val result = if (remaining <= 0) List(number.toLong)\
    \ else List(number.toLong, remaining.toLong)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp305pvalz.scala:39)\n\tat Problem.main(tmp305pvalz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val lefts = remaining - needs\n\
    \        if (meals > 0) {\n            List(meals.toLong, lefts.toLong)\n    \
    \    } else {\n            List(meals.toLong, 0l.toLong)\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprxs0kwox.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - need\n        val remaining = remaining - meals\n\
    \        val mealsLeft = meals - remaining\n        val mealsLeft = mealsLeft.toLong\n\
    \        val carrotsLeft = carrots - mealsLeft\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0jivfgmz.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0jivfgmz.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - meals\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0jivfgmz.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0jivfgmz.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeft\e[0m = carrotsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mcarrotsLeft is already defined as \e[33mvalue\e[0m \e[35mcarrotsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0jivfgmz.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m--"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - need\n        val carrots_left_to_eat\
    \ = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n\
    \        val carrots_to_eat = carrots_left_to_eat + needs_left_to_eat\n      \
    \  val needs_to_eat = needs_left_to_eat + carrots_left_to_eat\n        val carrots_to_eat2\
    \ = carrots_to_eat.toInt\n        val needs_to_eat2 = needs_to_eat.toInt\n   \
    \     val carrots_to_eat3 = carrots_to_eat2 * carrots_to_eat2\n        val needs_to_eat3\
    \ = needs_to_eat2 * needs_to_eat2\n        val carrots_to_eat4 = carrots_to_eat3\
    \ * carrots_to_eat3\n        val needs_to_eat4 = needs_to_eat3 * needs_to_eat3\n\
    \        val carrots_to_eat5 = carrots_to_eat4 * carrots_to_eat4\n        val\
    \ needs_to_eat5 = needs_to_eat4 * needs_to_eat4\n        val carrots_to_eat6 =\
    \ carrots_to_eat5 * carrots_to_eat5\n        val needs_to_eat6 = needs_to_eat5\
    \ * needs_to_eat5\n        val carrots_to_eat7 = carrots_to_eat6 * carrots_to_eat6\n\
    \        val needs_to_eat7 = needs_to_eat6 * needs_to_eat6\n        val carrots_to_eat8\
    \ = carrots_to_eat7 * carrots_to_eat7\n        val needs_to_eat8 = needs_to_eat7\
    \ * needs_to_eat7\n        val carrots_to_eat9 = carrots_to_eat8 * carrots_to_eat8\n\
    \        val needs_to_eat9 = needs_to_eat8 * needs_to_eat8\n        val carrots_to_eat10\
    \ = carrots_to_eat9 * carrots_to_eat9\n        val needs_to_eat10 = needs_to_eat9\
    \ * needs_to_eat9\n        val carrots_to_eat11 = carrots_to_eat10 * carrots_to_eat10\n\
    \        val needs_to_eat11 = needs_to_eat10 * needs_to_eat10\n        val carrots_to_eat12\
    \ = carrots_to_eat11 * carrots_to_eat11\n        val needs_to_eat12 = needs_to_eat11\
    \ * needs_to_eat11\n        val carrots_to_eat13 = carrots_to_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp87h4ede_.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp87h4ede_.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp87h4ede_.scala:63:31 ------------------------\e[0m\e[0m\n\e[31m63 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_to_eat13\e[0m = carrots_to_\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                               Not found: carrots_to_\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp87h4ede_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjd074aux.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n\
    \        result :: eat(remaining, need, carrots)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2cpzuzp1.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result :: eat(remaining,\
    \ need, carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = meals > 0\n      \
    \  val left = (meals - needs).toInt\n        val result = if (hungry) List(meals,\
    \ left) else List(meals)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpchdb6jvj.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val result = List(carrots,\
    \ remaining)\n        result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu3khxp34.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_left_to_eat\
    \ = (carrots_left - needs).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ + needs).toInt\n        val carrots_to_eat_left = carrots_to_eat - carrots_left\n\
    \        val carrots_to_eat_left_to_eat = (carrots_to_eat_left + carrots_left_to_eat).toInt\n\
    \        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - carrots_to_eat_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left\
    \ + carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left\
    \ + carrots_to_eat_left_to_eat_left_to_eat).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat =\
    \ (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat + carrots_to_eat_left_to_eat_left_to_eat_left_to_eat).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left + carrots_to_eat_left_to_eat_left_to_eat_left_to_e\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfynk11bn.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfynk11bn.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfynk11bn.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val rest = remaining - need\n        val hungryList = List(hungry.toLong)\n\
    \        val restList = List(rest.toLong)\n        if (hungry > 0) {\n       \
    \     hungryList :+ hungry\n        }\n        if (rest > 0) {\n            restList\
    \ :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList\
    \ :+ 0\n        }\n        if (hungry == 0 && rest > 0) {\n            restList\
    \ :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList\
    \ :+ 0\n            restList :+ 0\n        }\n        if (hungry > 0 && rest ==\
    \ 0) {\n            hungryList :+ hungry\n        }\n        if (hungry == 0 &&\
    \ rest > 0) {\n            restList :+ rest\n        }\n        if (hungry ==\
    \ 0 && rest == 0) {\n            hungryList :+ 0\n        }\n        if (hungry\
    \ > 0 && rest > 0) {\n            hungryList :+ hungry\n            restList :+\
    \ rest\n        }\n        if (hungry > 0 && rest == 0) {\n            hungryList\
    \ :+ hungry\n        }\n        if (hungry == 0 && rest > 0) {\n            restList\
    \ :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList\
    \ :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList\
    \ :+ hungry\n            restList :+ rest\n        }\n        if (hungry > 0 &&\
    \ rest == 0) {\n            hungryList :+ hungry\n        }\n        if (hungry\
    \ == 0 && rest > 0) {\n            restList :+ rest\n        }\n        if (hungry\
    \ == 0 && rest == 0) {\n            hungryList :+ 0\n        }\n        if (hungry\
    \ > 0 && rest > 0) {\n            hungryList :+ hungry\n            restList :+\
    \ rest\n        }\n        if (hungry > 0 && rest == 0) {\n            hungryList\
    \ :+ hungry\n        }\n        if (hungry == 0 && rest > 0) {\n            restList\
    \ :+ rest\n        }\n        if (hungry == 0 && rest == 0) {\n            hungryList\
    \ :+ 0\n        }\n        if (hungry > 0 && rest > 0) {\n            hungryList\
    \ :+ \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb6ahia6h.scala:100:25 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m            hungryList :+ \n\e[31m\e[31m    |\e[0m \
    \                        ^\e[0m\n\e[31m    |\e[0m                         expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpb6ahia6h.scala:112:0 ---------------------------\e[0m\e\
    [0m\n\e[31m112 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb6ahia6h.scala:111:1\
    \ --------------------\e[0m\e[0m\n\e[31m111 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: List[Long]\n\e\
    [31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpb6ahia6h.scala:102:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m102 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        if (hungry < 0) left else hungry\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9u7b_sjl.scala:33:24\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (hungry\
    \ < \e[31m0\e[0m) left \e[33melse\e[0m hungry\n\e[31m\e[31m   |\e[0m         \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                        Found:    (left\
    \ : Long)\n\e[31m   |\e[0m                        Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9u7b_sjl.scala:33:34 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (hungry < \e[31m0\e[0m) left \e\
    [33melse\e[0m hungry\n\e[31m\e[31m   |\e[0m                                  ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (hungry : Long)\n\
    \e[31m   |\e[0m                                  Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val need_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / need_left).toInt\n        val need_left_to_eat\
    \ = (need_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ / need_left_to_eat).toInt\n        val need_left_to_eat_2 = (need_left / carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left / need_left_to_eat_2).toInt\n\
    \        val need_left_to_eat_3 = (need_left / carrots_left_to_eat_2).toInt\n\
    \        val carrots_left_to_eat_4 = (carrots_left / need_left_to_eat_3).toInt\n\
    \        val need_left_to_eat_4 = (need_left / carrots_left_to_eat_3).toInt\n\
    \        val carrots_left_to_eat_5 = (carrots_left / need_left_to_eat_4).toInt\n\
    \        val need_left_to_eat_5 = (need_left / carrots_left_to_eat_4).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left / need_left_to_eat_5).toInt\n\
    \        val need_left_to_eat_6 = (need_left / carrots_left_to_eat_5).toInt\n\
    \        val carrots_left_to_eat_7 = (carrots_left / need_left_to_eat_6).toInt\n\
    \        val need_left_to_eat_7 = (need_left / carrots_left_to_eat_6).toInt\n\
    \        val carrots_left_to_eat_8 = (carrots_left / need_left_to_eat_7).toInt\n\
    \        val need_left_to_eat_8 = (need_left / carrots_left_to_eat_7).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left / need_left_to_eat_8).toInt\n\
    \        val need_left_to_eat_9 = (need_left / carrots_left_to_eat_8).toInt\n\
    \        val carrots_left_to_eat_10 = (carrots_left / need_left_to_eat_9).toInt\n\
    \        val need_left_to_eat_10 = (need_left / carrot\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp465tpa5z.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp465tpa5z.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp465tpa5z.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp465tpa5z.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots,\
    \ leftCarrots)\n        if (leftCarrots > 0) {\n            val newRemaining =\
    \ remaining - carrots\n            val newNumber = number + need\n           \
    \ val newNeed = newNumber - newRemaining\n            val newResult = eat(newNumber,\
    \ newNeed, remaining)\n            result ::: newResult\n        } else {\n  \
    \          result\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjcq583eq.scala:45)\n\tat Problem.main(tmpjcq583eq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = List(number\
    \ - carrots, carrots)\n        if (remaining <= 0) meals :: Nil\n        else\
    \ meals :: eat(remaining, need, carrots)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1uk4set7.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1uk4set7.scala:34:28\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (remaining\
    \ <= \e[31m0\e[0m) meals :: Nil\n\e[31m\e[31m   |\e[0m                       \
    \     ^^^^^\e[0m\n\e[31m   |\e[0m                            Found:    (meals\
    \ : List[Long])\n\e[31m   |\e[0m                            Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1uk4set7.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m meals\
    \ :: eat(remaining, need, carrots)\n\e[31m\e[31m   |\e[0m             ^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    (meals : List[Long])\n\e[31m   |\e\
    [0m             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsLeft = carrots - remaining\n        val needsToEat = needs -\
    \ remaining\n        val meals = List(needsToEat.toLong, carrotsLeft.toLong)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt63otimn.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val result: List[Long] = new ArrayList[Long]()\n        val carrotEaten\
    \ = remainingToEat\n        val carrotLeftToEat = carrots - carrotEaten\n    \
    \    val carrotLeftToEat2 = carrots - carrotEaten - carrotLeftToEat\n        val\
    \ carrotLeftToEat3 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2\n\
    \        val carrotLeftToEat4 = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2\
    \ - carrotLeftToEat3\n        val carrotLeftToEat5 = carrots - carrotEaten - carrotLeftToEat\
    \ - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4\n        val carrotLeftToEat6\
    \ = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3\
    \ - carrotLeftToEat4 - carrotLeftToEat5\n        val carrotLeftToEat7 = carrots\
    \ - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4\
    \ - carrotLeftToEat5 - carrotLeftToEat6\n        val carrotLeftToEat8 = carrots\
    \ - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3 - carrotLeftToEat4\
    \ - carrotLeftToEat5 - carrotLeftToEat6 - carrotLeftToEat7\n        val carrotLeftToEat9\
    \ = carrots - carrotEaten - carrotLeftToEat - carrotLeftToEat2 - carrotLeftToEat3\
    \ - carrotLeftToEat4 - carrotLeftToEat5 - carrotLeftToEat6 - carrotLeftToEat7\
    \ - carrotLeftToEat8\n        val carrotLeftToEat10 = carrots - carrotEaten -\
    \ carrotLeftToEat - carrotLeftToE\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiyzu7h7k.scala:34:37 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: type ArrayList\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiyzu7h7k.scala:45:74 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeftToEat10\e[0m =\
    \ carrots - carrotEaten - carrotLeftToEat - carrotLeftToE\n\e[31m\e[31m   |\e\
    [0m                                                                          ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                Not found:\
    \ carrotLeftToE\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiyzu7h7k.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val lefts = carrots - meals\n \
    \       if (meals > 0) {\n            List(meals.toLong, lefts.toLong)\n     \
    \   } else {\n            List(meals.toLong, needs.toLong)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd2isuo1v.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m =\
    \ List(carrots_left.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m = List(carrots_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_le"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat\
    \ = needs_left - carrots_left\n        val carrots_left_to_eat2 = carrots_left_to_eat\
    \ * carrots_left_to_eat\n        val needs_left_to_eat2 = needs_left_to_eat *\
    \ needs_left_to_eat\n        val carrots_left_to_eat3 = carrots_left_to_eat2 *\
    \ carrots_left_to_eat\n        val needs_left_to_eat3 = needs_left_to_eat2 * needs_left_to_eat\n\
    \        val carrots_left_to_eat4 = carrots_left_to_eat3 * carrots_left_to_eat\n\
    \        val needs_left_to_eat4 = needs_left_to_eat3 * needs_left_to_eat\n   \
    \     val carrots_left_to_eat5 = carrots_left_to_eat4 * carrots_left_to_eat\n\
    \        val needs_left_to_eat5 = needs_left_to_eat4 * needs_left_to_eat\n   \
    \     val carrots_left_to_eat6 = carrots_left_to_eat5 * carrots_left_to_eat\n\
    \        val needs_left_to_eat6 = needs_left_to_eat5 * needs_left_to_eat\n   \
    \     val carrots_left_to_eat7 = carrots_left_to_eat6 * carrots_left_to_eat\n\
    \        val needs_left_to_eat7 = needs_left_to_eat6 * needs_left_to_eat\n   \
    \     val carrots_left_to_eat8 = carrots_left_to_eat7 * carrots_left_to_eat\n\
    \        val needs_left_to_eat8 = needs_left_to_eat7 * needs_left_to_eat\n   \
    \     val carrots_left_to_eat9 = carrots_left_to_eat8 * carrots_left_to_eat\n\
    \        val needs_left_to_eat9 = needs_left_to_eat8 * needs_left_to_eat\n   \
    \     val carrots_left_to_eat10 = carrots_left_to_eat9 * carrots_left_to_eat\n\
    \        val needs_left_to_eat10 = needs_left_to_eat9 * needs_left_to_eat\n  \
    \      val carrots_left_to_eat11 = carrots_left_to_eat10 * carrots_left_to_eat\n\
    \        val need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppdimsarf.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppdimsarf.scala:32:25\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds\e[0m = need.toInt\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toInt is not a member of Null, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.javaBigInteger2bigInt\n\e[31m   |\e[0m  import\
    \ math.Numeric.BigDecimalAsIfIntegral.mkNumericOps\n\e[31m   |\e[0m  import math.Numeric.BigDecimalIsFractional.mkNumericOps\n\
    \e[31m   |\e[0m  import math.Numeric.BigIntIsIntegral.mkNumericOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppdimsarf.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppdimsarf.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppdimsarf.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 "
  stdout: ''
  timestamp: 1660010251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left - carrots_left).toInt\n        val carrots_to_eat = if (carrots_left_to_eat\
    \ > 0) carrots_left_to_eat else 0\n        val needs_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 0\n        val carrots_to_eat = (carrots_to_eat\
    \ * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n\
    \        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val\
    \ needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat\
    \ = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat\
    \ * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n\
    \        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val\
    \ carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat\
    \ = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat\
    \ * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n\
    \        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val\
    \ needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat\
    \ = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat = (needs_to_eat\
    \ * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n\
    \        val needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val\
    \ carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val needs_to_eat\
    \ = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat = (carrots_to_eat\
    \ * need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp61dkk2ic.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp61dkk2ic.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_to_eat\e[0m = (carrots_to_eat * needs_to_eat).toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_to_eat is already defined as \e[33mvalue\e[0m \e[35mcarrots_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp61dkk2ic.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat\e[0m = (needs_to_eat *\
    \ carrots_to_eat).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_to_eat is already defined as \e[33mvalue\e[0m \e[35mneeds_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp61dkk2ic.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mcarrots_to_eat\e[0m = (carrots_to_eat\
    \ * needs_to_eat).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_to_eat is already defined as \e[33mvalue\e[0m \e[35mcarrots_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp61dkk2ic.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat\e[0m = (needs_to_eat *\
    \ carrots_to_eat).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_to_eat is already defined as \e[33mvalue\e[0m \e[35mneeds_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n\
    \        val meals_left = List(needs_left.toLong, carrots_left.toLong)\n     \
    \   val meals_right = List(needs_left.toLong, carrots_left.toLong)\n        val\
    \ meals_left_right = List(needs_left.toLong, carrots_left.toLong)\n        val\
    \ meals_right_left = List(needs_left.toLong, carrots_left.toLong)\n        val\
    \ meals_left_right_left = List(needs_left.toLong, carrots_left.toLong)\n     \
    \   val meals_right_left_left = List(needs_left.toLong, carrots_left.toLong)\n\
    \        val meals_left_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n\
    \        val meals_right_left_right_left = List(needs_left.toLong, carrots_left.toLong)\n\
    \        val meals_left_right_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n\
    \        val meals_right_left_right_right_left = List(needs_left.toLong, carrots_left.toLong)\n\
    \        val meals_left_right_right_right_right_left = List(needs_left.toLong,\
    \ carrots_left.toLong)\n        val meals_right_left_right_right_right_left =\
    \ List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_right_right_left\
    \ = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_right_right_right_left\
    \ = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_right_right_right_right_left\
    \ = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_right_right_right_right_right_left\
    \ = List(needs_left.toLong, carrots_left.toLong)\n        val meals_left_right_right_right_right_right_right_right_right_right_left\
    \ = List(needs_left.toLong, carrots_left.toLong)\n        val meals_right_left_right_right_right_right_right_right_right_right_right_left\
    \ = List(need\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9fcoumk_.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9fcoumk_.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9fcoumk_.scala:55:5 ---------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left_to_eat\
    \ * carrots_left_to_eat).toInt\n        val needs_left_to_eat_2 = (needs_left_to_eat\
    \ * needs_left_to_eat).toInt\n        val carrots_left_to_eat_3 = (carrots_left_to_eat_2\
    \ * carrots_left_to_eat_2).toInt\n        val needs_left_to_eat_3 = (needs_left_to_eat_2\
    \ * needs_left_to_eat_2).toInt\n        val carrots_left_to_eat_4 = (carrots_left_to_eat_3\
    \ * carrots_left_to_eat_3).toInt\n        val needs_left_to_eat_4 = (needs_left_to_eat_3\
    \ * needs_left_to_eat_3).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4\
    \ * carrots_left_to_eat_4).toInt\n        val needs_left_to_eat_5 = (needs_left_to_eat_4\
    \ * needs_left_to_eat_4).toInt\n        val carrots_left_to_eat_6 = (carrots_left_to_eat_5\
    \ * carrots_left_to_eat_5).toInt\n        val needs_left_to_eat_6 = (needs_left_to_eat_5\
    \ * needs_left_to_eat_5).toInt\n        val carrots_left_to_eat_7 = (carrots_left_to_eat_6\
    \ * carrots_left_to_eat_6).toInt\n        val needs_left_to_eat_7 = (needs_left_to_eat_6\
    \ * needs_left_to_eat_6).toInt\n        val carrots_left_to_eat_8 = (carrots_left_to_eat_7\
    \ * carrots_left_to_eat_7).toInt\n        val needs_left_to_eat_8 = (needs_left_to_eat_7\
    \ * needs_left_to_eat_7).toInt\n        val carrots_left_to_eat_9 = (carrots_left_to_eat_8\
    \ * car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnwva9ivg.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnwva9ivg.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpnwva9ivg.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwva9ivg.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - needs\n        val needs_left_carrots\
    \ = needs_left.toInt\n        val needs_left_carrots_left = needs_left_carrots\
    \ - 1\n        val needs_left_carrots_left_carrots = needs_left_carrots_left.toInt\n\
    \        val needs_left_carrots_left_carrots_left = needs_left_carrots_left_carrots\
    \ - 1\n        val needs_left_carrots_left_carrots_left_carrots = needs_left_carrots_left_carrots_left.toInt\n\
    \        val needs_left_carrots_left_carrots_left_carrots_carrots = needs_left_carrots_left_carrots_left_carrots_left.toInt\n\
    \        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots\
    \ - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots\
    \ - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots\
    \ - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots\
    \ - 1\n        val needs_left_carrots_left_carrots_left_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrots_carrot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpphwbf_9k.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpphwbf_9k.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpphwbf_9k.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpphwbf_9k.scala:42:67 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_carrots_left_carrots_left_carrots_carrots\e\
    [0m = needs_left_carrots_left_carrots_left_carrots_left.toInt\n\e[31m\e[31m  \
    \ |\e[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: needs_left_carrots_left_carrots_left_carrots_left\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpphwbf_9k.scala:43:75\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds_left_carrots_left_carrots_left_carrots_carrots_carrots\e[0m = needs_left_carrots_left_carrots_left_carrots_left_carrots_carrots\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: needs_left_carrots_lef"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_in_stock = carrots_left.toLong\n       \
    \ val needs_left_in_stock = needs_left.toLong\n        val carrots_left_in_stock2\
    \ = carrots_left_in_stock * carrots_left_in_stock\n        val needs_left_in_stock2\
    \ = needs_left_in_stock * needs_left_in_stock\n        val carrots_left_in_stock3\
    \ = carrots_left_in_stock2 * carrots_left_in_stock\n        val needs_left_in_stock3\
    \ = needs_left_in_stock2 * needs_left_in_stock\n        val carrots_left_in_stock4\
    \ = carrots_left_in_stock3 * carrots_left_in_stock\n        val needs_left_in_stock4\
    \ = needs_left_in_stock3 * needs_left_in_stock\n        val carrots_left_in_stock5\
    \ = carrots_left_in_stock4 * carrots_left_in_stock\n        val needs_left_in_stock5\
    \ = needs_left_in_stock4 * needs_left_in_stock\n        val carrots_left_in_stock6\
    \ = carrots_left_in_stock5 * carrots_left_in_stock\n        val needs_left_in_stock6\
    \ = needs_left_in_stock5 * needs_left_in_stock\n        val carrots_left_in_stock7\
    \ = carrots_left_in_stock6 * carrots_left_in_stock\n        val needs_left_in_stock7\
    \ = needs_left_in_stock6 * needs_left_in_stock\n        val carrots_left_in_stock8\
    \ = carrots_left_in_stock7 * carrots_left_in_stock\n        val needs_left_in_stock8\
    \ = needs_left_in_stock7 * needs_left_in_stock\n        val carrots_left_in_stock9\
    \ = carrots_left_in_stock8 * carrots_left_in_stock\n        val needs_left_in_stock9\
    \ = needs_left_in_stock8 * needs_left_in_stock\n        val carrots_left_in_stock10\
    \ = carrots_left_in_stock9 * carrots_left_in_stock\n        val needs_left_in_stock10\
    \ = needs_left_in_stock9 * needs_left_in_stock\n        val carrots_left_in_stock11\
    \ = carrots_left_in_stock10 * carrots_left_in_stock\n        val needs_left_in_stock11\
    \ = needs_left_in_stock10 * needs_left_in_stock\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcbjemg8n.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcbjemg8n.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val carrots_left_to_eat = (needs - carrots).toInt\n\
    \        val carrots_left_to_eat_max = carrots_left - carrots_left_to_eat\n  \
    \      val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left_to_eat_max\n\
    \        val carrots_left_to_eat_max_index = carrots_left_to_eat - 1\n       \
    \ val carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n        val\
    \ carrots_left_to_eat_max_value = carrots_left_to_eat_max\n        val carrots_left_to_eat_min_value\
    \ = carrots_left_to_eat_min\n        val carrots_left_to_eat_max_index = carrots_left_to_eat_max\
    \ + 1\n        val carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n\
    \        val carrots_left_to_eat_max_value = carrots_left_to_eat_max\n       \
    \ val carrots_left_to_eat_min_value = carrots_left_to_eat_min\n        val carrots_left_to_eat_max_index\
    \ = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_min_index = carrots_left_to_eat_max\
    \ + 1\n        val carrots_left_to_eat_max_value = carrots_left_to_eat_max\n \
    \       val carrots_left_to_eat_min_value = carrots_left_to_eat_min\n        val\
    \ carrots_left_to_eat_max_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_min_index\
    \ = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_max_value = carrots_left_to_eat_max\n\
    \        val carrots_left_to_eat_min_value = carrots_left_to_eat_min\n       \
    \ val carrots_left_to_eat_max_index = carrots_left_to_eat_max + 1\n        val\
    \ carrots_left_to_eat_min_index = carrots_left_to_eat_max + 1\n        val carrots_left_to_eat_max_value\
    \ = carrots_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_max_index\e\
    [0m = carrots_left_to_eat_max + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_max_index is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_max_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_min_index\e\
    [0m = carrots_left_to_eat_max + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_min_index is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_min_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_max_value\e\
    [0m = carrots_left_to_eat_max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_max_value is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_max_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnmhfgjla.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_min_value\e\
    [0m = carrots_left_to_eat_min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_min_value is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_min_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote "
  stdout: ''
  timestamp: 1660010262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val meals_left = meals -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list_2\
    \ = List(carrots_left.toLong)\n        val meals_left_list_2 = List(meals_left.toLong)\n\
    \        val carrots_left_list_3 = List(carrots_left.toLong)\n        val meals_left_list_3\
    \ = List(meals_left.toLong)\n        val carrots_left_list_4 = List(carrots_left.toLong)\n\
    \        val meals_left_list_4 = List(meals_left.toLong)\n        val carrots_left_list_5\
    \ = List(carrots_left.toLong)\n        val meals_left_list_5 = List(meals_left.toLong)\n\
    \        val carrots_left_list_6 = List(carrots_left.toLong)\n        val meals_left_list_6\
    \ = List(meals_left.toLong)\n        val carrots_left_list_7 = List(carrots_left.toLong)\n\
    \        val meals_left_list_7 = List(meals_left.toLong)\n        val carrots_left_list_8\
    \ = List(carrots_left.toLong)\n        val meals_left_list_8 = List(meals_left.toLong)\n\
    \        val carrots_left_list_9 = List(carrots_left.toLong)\n        val meals_left_list_9\
    \ = List(meals_left.toLong)\n        val carrots_left_list_10 = List(carrots_left.toLong)\n\
    \        val meals_left_list_10 = List(meals_left.toLong)\n        val carrots_left_list_11\
    \ = List(carrots_left.toLong)\n        val meals_left_list_11 = List(meals_left.toLong)\n\
    \        val carrots_left_list_12 = List(carrots_left.toLong)\n        val meals_left_list_12\
    \ = List(meals_left.toLong)\n        val carrots_left_list_13 = List(carrots_left.toLong)\n\
    \        val meals_left_list_13 = List(meals_left.toLong)\n        val carrots_left_list_14\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2otkw9bo.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2otkw9bo.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2otkw9bo.scala:63:5 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010269
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n\
    \        if (meals.toLong > 0) {\n            val newRemaining = remaining + meals\n\
    \            val newNumber = number - newRemaining\n            val newNeed =\
    \ need - newRemaining\n            val newResult = eat(newNumber, newNeed, newRemaining)\n\
    \            result ::: newResult\n        } else {\n            result\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp85y2228y.scala:45)\n\tat Problem.main(tmp85y2228y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n\
    \        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat * 2).toInt\n\
    \        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_left_to_eat_with_hunger = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n        val carrots_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpls5fthf4.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat_with_hunger\e[0m = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_with_hunger is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_with_hunger\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat_with_hunger\e[0m = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_with_hunger is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_with_hunger\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat_with_hunger\e[0m = (carrots_left_to_eat_with_hunger\
    \ + needs_left).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_with_hunger is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_with_hunger\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpls5fthf4.scala:41:12\
    \ ---------------------"
  stdout: ''
  timestamp: 1660010269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        if (remaining == 0) {\n       \
    \     result(0) = carrots.toLong\n            result(1) = 0l.toLong\n        }\
    \ else {\n            val carrots_left = carrots - remaining\n            val\
    \ needs_left = needs - remaining\n            if (carrots_left == 0) {\n     \
    \           result(0) = carrots.toLong\n                result(1) = needs.toLong\n\
    \            } else {\n                result(0) = carrots_left.toLong\n     \
    \           result(1) = needs_left.toLong\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcs0uzeju.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcs0uzeju.scala:49:8\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val meals_left = carrots_left_after_meals\
    \ / needs_left\n        val carrots_left_after_meals_left = carrots_left_after_meals\
    \ % needs_left\n        val meals_left_left = carrots_left_after_meals_left /\
    \ needs_left\n        val carrots_left_after_meals_left_left = carrots_left_after_meals_left\
    \ % needs_left\n        val meals_left_left_left = carrots_left_after_meals_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left = carrots_left_after_meals_left_left\
    \ % needs_left\n        val meals_left_left_left_left = carrots_left_after_meals_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left = carrots_left_after_meals_left_left_left\
    \ % needs_left\n        val meals_left_left_left_left_left = carrots_left_after_meals_left_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left_left\
    \ = carrots_left_after_meals_left_left_left_left % needs_left\n        val meals_left_left_left_left_left_left\
    \ = carrots_left_after_meals_left_left_left_left_left / needs_left\n        val\
    \ carrots_left_after_meals_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left\
    \ % needs_left\n        val meals_left_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left_left_left_left\
    \ = carrots_left_after_meals_left_left_left_left_left_left % needs_left\n    \
    \    val meals_left_left_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left_left_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8si_t4ht.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8si_t4ht.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8si_t4ht.scala:54:5 ---------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list_sorted\
    \ = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_\
    \ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_ <\
    \ _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n \
    \       val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n   \
    \     val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val\
    \ carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted\
    \ = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_\
    \ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n\
    \        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n  \
    \      val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val\
    \ carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted\
    \ = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_\
    \ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n\
    \        val carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n  \
    \      val needs_left_list_sorted = needs_left_list.sortWith(_ < _)\n        val\
    \ carrots_left_list_sorted = carrots_left_list.sortWith(_ < _)\n        val needs_left_list_sorted\
    \ = needs_left_list.sortWith(_ < _)\n        val carrots_left_list_sorted = carrots_left_list.sortWith(_\
    \ < _)\n        val needs_left_list_sorted = needs_left_list.sortWith\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list_sorted\e\
    [0m = carrots_left_list.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list_sorted\e\
    [0m = needs_left_list.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mneeds_left_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list_sorted\e\
    [0m = carrots_left_list.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq_mfx0s2.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list_sorted\e\
    [0m = needs_left_list.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mneeds_left_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same gr"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n\
    \        val needs_left_to_eat = (needs_left - carrots_left).toInt\n        val\
    \ carrots_left_to_eat = carrots_left_to_eat.toLong\n        val needs_left_to_eat\
    \ = needs_left_to_eat.toLong\n        val carrots_left_to_eat_2 = carrots_left_to_eat\
    \ * 2\n        val needs_left_to_eat_2 = needs_left_to_eat * 2\n        val carrots_left_to_eat_3\
    \ = carrots_left_to_eat * 3\n        val needs_left_to_eat_3 = needs_left_to_eat\
    \ * 3\n        val carrots_left_to_eat_4 = carrots_left_to_eat * 4\n        val\
    \ needs_left_to_eat_4 = needs_left_to_eat * 4\n        val carrots_left_to_eat_5\
    \ = carrots_left_to_eat * 5\n        val needs_left_to_eat_5 = needs_left_to_eat\
    \ * 5\n        val carrots_left_to_eat_6 = carrots_left_to_eat * 6\n        val\
    \ needs_left_to_eat_6 = needs_left_to_eat * 6\n        val carrots_left_to_eat_7\
    \ = carrots_left_to_eat * 7\n        val needs_left_to_eat_7 = needs_left_to_eat\
    \ * 7\n        val carrots_left_to_eat_8 = carrots_left_to_eat * 8\n        val\
    \ needs_left_to_eat_8 = needs_left_to_eat * 8\n        val carrots_left_to_eat_9\
    \ = carrots_left_to_eat * 9\n        val needs_left_to_eat_9 = needs_left_to_eat\
    \ * 9\n        val carrots_left_to_eat_10 = carrots_left_to_eat * 10\n       \
    \ val needs_left_to_eat_10 = needs_left_to_eat * 10\n        val carrots_left_to_eat_11\
    \ = carrots_left_to_eat * 11\n        val needs_left_to_eat_11 = needs_left_to_eat\
    \ * 11\n        val carrots_left_to_eat_12 = carrots_left_to_eat * 12\n      \
    \  val needs_left_to_eat_12 = needs_left_to_eat * 12\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40134o8s.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat\e[0m\
    \ = carrots_left_to_eat.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat is already defined as \e[33mvalue\e[0m\
    \ \e[35mcarrots_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp40134o8s.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_to_eat\e[0m =\
    \ needs_left_to_eat.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_to_eat is already defined as \e[33mvalue\e[0m \e\
    [35mneeds_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp40134o8s.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp40134o8s.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010269
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots,\
    \ leftCarrots)\n        if (leftCarrots == 0) {\n            List(number * need)\n\
    \        } else {\n            List(number * need, leftCarrots)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplvrlnnny.scala:41)\n\tat Problem.main(tmplvrlnnny.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsLeft = carrots - remaining\n        val needLeft = needs - remaining\n\
    \        val meals = carrotsLeft + needLeft\n        val mealsLeft = meals - needLeft\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val needLeft = needLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val needLeft = needLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppkp3k573.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppkp3k573.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeft\e[0m = carrotsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mcarrotsLeft is already defined as \e[33mvalue\e[0m \e[35mcarrotsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppkp3k573.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mneedLeft\e[0m = needLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneedLeft\
    \ is already defined as \e[33mvalue\e[0m \e[35mneedLeft\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppkp3k573.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppkp3k573.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeft\e[0m = carrotsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcarrotsLeft is already defined as \e[33mvalue\e[0m \e[35mcarrotsLe"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val carrots_left_to_eat = (carrots_left / meals).toInt\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 0) 1 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 1) 1 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 2) 2 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 3) 3 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 4) 4 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 5) 5 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 6) 6 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 7) 7 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 8) 8 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 9) 9 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 10) 10 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 11) 11 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 12) 12 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 13) 13 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 14) 14 else carrots_left_to_eat\n\
    \        val carrots_left_to_eat = if (carrots_left_to_eat == 15\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn_qymhgt.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat\e[0m = \e[33mif\e[0m (carrots_left_to_eat == \e[31m0\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m carrots_left_to_eat\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat is already defined as \e[33mvalue\e[0m\
    \ \e[35mcarrots_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat\e[0m\
    \ = \e[33mif\e[0m (carrots_left_to_eat == \e[31m1\e[0m) \e[31m1\e[0m \e[33melse\e\
    [0m carrots_left_to_eat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat is already defined as \e[33mvalue\e[0m\
    \ \e[35mcarrots_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat\e[0m\
    \ = \e[33mif\e[0m (carrots_left_to_eat == \e[31m2\e[0m) \e[31m2\e[0m \e[33melse\e\
    [0m carrots_left_to_eat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat is already defined as \e[33mvalue\e[0m\
    \ \e[35mcarrots_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn_qymhgt.scala:40:12 ---------------------------\e\
    [0m\e["
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val carrots_needed = needs - carrots\n        val\
    \ carrots_left_needed = carrots_left - carrots_needed\n        val carrots_left_needed_to_eat\
    \ = carrots_left_needed + carrots\n        val carrots_left_needed_to_eat2 = carrots_left_needed\
    \ + carrots_needed\n        val carrots_left_needed_to_eat3 = carrots_left_needed\
    \ + carrots_needed + carrots\n        val carrots_left_needed_to_eat4 = carrots_left_needed\
    \ + carrots_needed + carrots + carrots\n        val carrots_left_needed_to_eat5\
    \ = carrots_left_needed + carrots_needed + carrots + carrots + carrots\n     \
    \   val carrots_left_needed_to_eat6 = carrots_left_needed + carrots_needed + carrots\
    \ + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat7\
    \ = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots\n        val carrots_left_needed_to_eat8 = carrots_left_needed\
    \ + carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots\n        val carrots_left_needed_to_eat9 = carrots_left_needed\
    \ + carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat10\
    \ = carrots_left_needed + carrots_needed + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\
    \ + carrots\n        val carrots_left_needed_to_eat11 = carrots_left_needed +\
    \ carrots_needed + carrots + carrots + carrots + carrots + carrots + carrots +\
    \ carrots + carrots + carrots + car\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkxefl1t4.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkxefl1t4.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkxefl1t4.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new ArrayList[Long]()\n        val carrots_left = remaining\n\
    \        val carrots_needed = carrots - carrots_left\n        val carrots_left_needed\
    \ = carrots_needed - carrots_left\n        val carrots_left_needed_2 = carrots_left_needed\
    \ - carrots_left\n        val carrots_left_needed_3 = carrots_left_needed_2 -\
    \ carrots_left\n        val carrots_left_needed_4 = carrots_left_needed_3 - carrots_left\n\
    \        val carrots_left_needed_5 = carrots_left_needed_4 - carrots_left\n  \
    \      val carrots_left_needed_6 = carrots_left_needed_5 - carrots_left\n    \
    \    val carrots_left_needed_7 = carrots_left_needed_6 - carrots_left\n      \
    \  val carrots_left_needed_8 = carrots_left_needed_7 - carrots_left\n        val\
    \ carrots_left_needed_9 = carrots_left_needed_8 - carrots_left\n        val carrots_left_needed_10\
    \ = carrots_left_needed_9 - carrots_left\n        val carrots_left_needed_11 =\
    \ carrots_left_needed_10 - carrots_left\n        val carrots_left_needed_12 =\
    \ carrots_left_needed_11 - carrots_left\n        val carrots_left_needed_13 =\
    \ carrots_left_needed_12 - carrots_left\n        val carrots_left_needed_14 =\
    \ carrots_left_needed_13 - carrots_left\n        val carrots_left_needed_15 =\
    \ carrots_left_needed_14 - carrots_left\n        val carrots_left_needed_16 =\
    \ carrots_left_needed_15 - carrots_left\n        val carrots_left_needed_17 =\
    \ carrots_left_needed_16 - carrots_left\n        val carrots_left_needed_18 =\
    \ carrots_left_needed_17 - carrots_left\n        val carrots_left_needed_19 =\
    \ carrots_left_needed_18 - carrots_left\n        val carrots_left_needed_20 =\
    \ carrots_left_needed_19 - carrots_left\n        val carrots_left_needed_21 =\
    \ carrots_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4_680sok.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4_680sok.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                 Not found: type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp4_680sok.scala:57:37 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_needed_21\e\
    [0m = carrots_left_\n\e[31m\e[31m   |\e[0m                                   \
    \  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Not\
    \ found: carrots_left_\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4_680sok.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftOver = remaining - carrots\n        val result = List(number.toLong,\
    \ leftOver.toLong)\n        if (leftOver > 0) result :+ eat(leftOver, need, remaining)\n\
    \        else result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxr0dv8fw.scala:34:39\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (leftOver\
    \ > \e[31m0\e[0m) result :+ eat(leftOver, need, remaining)\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    Found:    \e[1m\e[31mList\e[0m\e\
    [1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                        \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - meals\n        val carrots_left_after_meals\
    \ = carrots_left - remaining\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - remaining\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - remaining\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - remaining\n        val carrot\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpktz97id0.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpktz97id0.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpktz97id0.scala:41:111 --------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - remaining\n\e[31m\e[31m   |\e[0m                                         \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpktz97id0.scala:42:123 -----------------------\e[0m\e[0m\n\e[31m42 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - remaining\n\e[31m\e[31m   |\e[0m                                         \
    \                                                                            \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: carrots_left_after_meals_"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining == 0)\
    \ {\n            result ++= List(number.toLong)\n        } else {\n          \
    \  val carrots_left = carrots - remaining\n            val needs_left = needs\
    \ - remaining\n            val carrots_left_to_eat = carrots_left - needs_left\n\
    \            val needs_left_to_eat = (needs_left / need).toInt\n            val\
    \ needs_left_to_eat_left = needs_left_to_eat * need\n            val needs_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left / carrot).toInt\n            val needs_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_to_eat * carrot\n            val needs_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left / need).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_to_eat_left_to_eat * need\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left_to_eat / carrot).toInt\n            val\
    \ needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat_left\
    \ * carrot\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left_to_eat_left / need).toInt\n          \
    \  val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left * need\n      \
    \      val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left / carrot).toInt\n\
    \            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_to_eat_left_to_eat_left_to_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp05w0s9n0.scala:64:0 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp05w0s9n0.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp05w0s9n0.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp05w0s9n0.scala:52:101 -----------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            \e[33mval\e[0m \e[36mneeds_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\e\
    [0m = needs_left_to_eat_left_to_eat_left_to_eat_left_to_\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           Not found: needs_left_to_eat_left_to_eat_left_to_eat_left_to_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp05w0s9n0.scala:63:1\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp05w0s9n0.scala:54:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m54 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36marg"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new Array[Long](meals)\n        val carrots_left\
    \ = new Array[Long](meals)\n        val carrots_left2 = new Array[Long](meals)\n\
    \        val carrots_left3 = new Array[Long](meals)\n        val carrots_left4\
    \ = new Array[Long](meals)\n        val carrots_left5 = new Array[Long](meals)\n\
    \        val carrots_left6 = new Array[Long](meals)\n        val carrots_left7\
    \ = new Array[Long](meals)\n        val carrots_left8 = new Array[Long](meals)\n\
    \        val carrots_left9 = new Array[Long](meals)\n        val carrots_left10\
    \ = new Array[Long](meals)\n        val carrots_left11 = new Array[Long](meals)\n\
    \        val carrots_left12 = new Array[Long](meals)\n        val carrots_left13\
    \ = new Array[Long](meals)\n        val carrots_left14 = new Array[Long](meals)\n\
    \        val carrots_left15 = new Array[Long](meals)\n        val carrots_left16\
    \ = new Array[Long](meals)\n        val carrots_left17 = new Array[Long](meals)\n\
    \        val carrots_left18 = new Array[Long](meals)\n        val carrots_left19\
    \ = new Array[Long](meals)\n        val carrots_left20 = new Array[Long](meals)\n\
    \        val carrots_left21 = new Array[Long](meals)\n        val carrots_left22\
    \ = new Array[Long](meals)\n        val carrots_left23 = new Array[Long](meals)\n\
    \        val carrots_left24 = new Array[Long](meals)\n        val carrots_left25\
    \ = new Array[Long](meals)\n        val carrots_left26 = new Array[Long](meals)\n\
    \        val carrots_left27 = new Array[Long](meals)\n        val carrots_left28\
    \ = new Array[Long](meals)\n        val carrots_left29 = new Array[Long](meals)\n\
    \        val carrots_left\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8ie2xnb1.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8ie2xnb1.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8ie2xnb1.scala:34:33 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e\
    [0m] = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](meals)\n\e[31m\e[31m \
    \  |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Found:    \e[1m\e[31mArray\e[0m[Long]\n\
    \e[31m   |\e[0m                                 Required: \e[1m\e[32mList\e[0m[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ie2xnb1.scala:65:5\
    \ ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val totalEaten = carrots - needToEat\n        val remainingCarrots =\
    \ carrots - totalEaten\n        val carrotLeftToEat = remainingToEat - remainingCarrots\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatListWithZero\
    \ = carrotLeftToEatList.map(_(0l))\n        val carrotLeftToEatListWithZeroList\
    \ = carrotLeftToEatListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZero\
    \ = carrotLeftToEatListWithZeroList.map(_(0l))\n        val carrotLeftToEatListWithZeroListWithZeroList\
    \ = carrotLeftToEatListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZero\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n        val carrotLeftToEatListWithZeroListWithZeroListWithZeroList\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero.toList\n \
    \       val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero =\
    \ carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroList\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroList\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqb3m110h.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpqb3m110h.scala:38:66\
    \ -----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e\
    [0m \e[36mcarrotLeftToEatListWithZero\e[0m = carrotLeftToEatList.map(_(\e[31m0l\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                                 \
    \                 ^\e[0m\n\e[31m   |\e[0m                                  \e\
    [33mparameter\e[0m \e[35m_$1\e[0m does not take parameters\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmpqb3m110h.scala:40:90 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeftToEatListWithZeroListWithZero\e\
    [0m = carrotLeftToEatListWithZeroList.map(_(\e[31m0l\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                ^\e[0m\n\e[31m   |\e[0m                                  \e[33mparameter\e\
    [0m \e[35m_$2\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpqb3m110h.scala:42:66 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeftToEatListWithZeroListWithZeroListWithZero\e\
    [0m = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n\e[31m\e[31m\
    \   |\e[0m                                                                  ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mcarrotLeftToEatListWithZeroListWithZeroListWithZero\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqb3m110h.scala:46:90\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero\e\
    [0m = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWit"
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining < needs)\
    \ {\n            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \            val carrots = number.toInt\n            val needs = need.toInt\n\
    \            val remaining = remaining.toInt\n            val result = new mutable.ListBuffer[Long]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzgri60pv.scala:95:0 ----------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzgri60pv.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzgri60pv.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpzgri60pv.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = number.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzgri60pv.scala:41:16 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m            \e[33mval\e[0m \e[36mneeds\e[0m = need.toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneeds is already\
    \ defined as \e[33mvalue\e[0m \e[35mneeds\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzgri60pv.scala:42:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e\
    [0m \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0"
  stdout: ''
  timestamp: 1660010286
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val meals_left = meals - carrots_left\n       \
    \ val carrots_left_to_eat = (carrots_left * meals).toLong\n        val meals_left_to_eat\
    \ = (meals_left * carrots).toLong\n        val carrots_left_to_eat_and_meals =\
    \ (carrots_left_to_eat * meals_left).toLong\n        val meals_left_to_eat_and_carrots\
    \ = (meals_left_to_eat * carrots_left).toLong\n        val carrots_left_to_eat_and_meals_and_carrots\
    \ = (carrots_left_to_eat_and_meals * meals_left_to_carrots).toLong\n        val\
    \ meals_left_to_eat_and_carrots_and_meals = meals_left_to_eat_and_carrots + carrots_left_to_eat_and_meals_and_carrots\n\
    \        val carrots_left_to_eat_and_meals_and_carrots_and_meals = carrots_left_to_eat_and_meals_and_carrots\
    \ + meals_left_to_eat_and_carrots_and_meals\n        val meals_left_to_eat_and_carrots_and_carrots_and_meals\
    \ = meals_left_to_eat_and_carrots_and_carrots + carrots_left_to_eat_and_meals_and_carrots_and_meals\n\
    \        val carrots_left_to_eat_and_carrots_and_carrots_and_meals = carrots_left_to_eat_and_carrots_and_carrots_and_meals\
    \ + meals_left_to_eat_and_carrots_and_carrots_and_meals\n        val carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_meals\
    \ = carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_meals + carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_meals\n\
    \        val carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_carrots_and_meals\
    \ = carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_carrots_and_meals\
    \ + carrots_left_to_eat_and_carrots_and_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp60n1u47g.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp60n1u47g.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp60n1u47g.scala:44:66 ------------------------\e[0m\e[0m\n\e[31m44 |\e\
    [0m        \e[33mval\e[0m \e[36mmeals_left_to_eat_and_carrots_and_carrots_and_meals\e\
    [0m = meals_left_to_eat_and_carrots_and_carrots + carrots_left_to_eat_and_meals_and_carrots_and_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 Not found: meals_left_to_eat_and_carrots_and_carrots\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp60n1u47g.scala:45:68 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_and_carrots_and_carrots_and_meals\e\
    [0m = carrots_left_to_eat_and_carrots_and_carrots_and_meals + meals_left_to_eat_and_carrots_and_carrots_and_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mcarrots_left_to_eat_and_carrots_and_carrots_and_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp60n1u47g.scala"
  stdout: ''
  timestamp: 1660010282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = new ArrayList[Long]()\n\
    \        if (leftCarrots > 0) {\n            result += carrots\n            result\
    \ += leftCarrots\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0hzy2xod.scala:33:25 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val meals_left = meals -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list_2\
    \ = List(carrots_left.toLong)\n        val meals_left_list_2 = List(meals_left.toLong)\n\
    \        val carrots_left_list_3 = List(carrots_left.toLong)\n        val meals_left_list_3\
    \ = List(meals_left.toLong)\n        val carrots_left_list_4 = List(carrots_left.toLong)\n\
    \        val meals_left_list_4 = List(meals_left.toLong)\n        val carrots_left_list_5\
    \ = List(carrots_left.toLong)\n        val meals_left_list_5 = List(meals_left.toLong)\n\
    \        val carrots_left_list_6 = List(carrots_left.toLong)\n        val meals_left_list_6\
    \ = List(meals_left.toLong)\n        val carrots_left_list_7 = List(carrots_left.toLong)\n\
    \        val meals_left_list_7 = List(meals_left.toLong)\n        val carrots_left_list_8\
    \ = List(carrots_left.toLong)\n        val meals_left_list_8 = List(meals_left.toLong)\n\
    \        val carrots_left_list_9 = List(carrots_left.toLong)\n        val meals_left_list_9\
    \ = List(meals_left.toLong)\n        val carrots_left_list_10 = List(carrots_left.toLong)\n\
    \        val meals_left_list_10 = List(meals_left.toLong)\n        val carrots_left_list_11\
    \ = List(carrots_left.toLong)\n        val meals_left_list_11 = List(meals_left.toLong)\n\
    \        val carrots_left_list_12 = List(carrots_left.toLong)\n        val meals_left_list_12\
    \ = List(meals_left.toLong)\n        val carrots_left_list_13 = List(carrots_left.toLong)\n\
    \        val meals_left_list_13 = List(meals_left.toLong)\n        val carrots_left_list_14\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2otkw9bo.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2otkw9bo.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2otkw9bo.scala:63:5 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val meals_left = meals -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list2\
    \ = List(carrots_left.toLong)\n        val meals_left_list2 = List(meals_left.toLong)\n\
    \        val carrots_left_list3 = List(carrots_left.toLong)\n        val meals_left_list3\
    \ = List(meals_left.toLong)\n        val carrots_left_list4 = List(carrots_left.toLong)\n\
    \        val meals_left_list4 = List(meals_left.toLong)\n        val carrots_left_list5\
    \ = List(carrots_left.toLong)\n        val meals_left_list5 = List(meals_left.toLong)\n\
    \        val carrots_left_list6 = List(carrots_left.toLong)\n        val meals_left_list6\
    \ = List(meals_left.toLong)\n        val carrots_left_list7 = List(carrots_left.toLong)\n\
    \        val meals_left_list7 = List(meals_left.toLong)\n        val carrots_left_list8\
    \ = List(carrots_left.toLong)\n        val meals_left_list8 = List(meals_left.toLong)\n\
    \        val carrots_left_list9 = List(carrots_left.toLong)\n        val meals_left_list9\
    \ = List(meals_left.toLong)\n        val carrots_left_list10 = List(carrots_left.toLong)\n\
    \        val meals_left_list10 = List(meals_left.toLong)\n        val carrots_left_list11\
    \ = List(carrots_left.toLong)\n        val meals_left_list11 = List(meals_left.toLong)\n\
    \        val carrots_left_list12 = List(carrots_left.toLong)\n        val meals_left_list12\
    \ = List(meals_left.toLong)\n        val carrots_left_list13 = List(carrots_left.toLong)\n\
    \        val meals_left_list13 = List(meals_left.toLong)\n        val carrots_left_list14\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9r27vnmr.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9r27vnmr.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9r27vnmr.scala:63:5 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsLeft = carrots - remaining\n        val needLeft = needs - remaining\n\
    \        val result = List(carrotsLeft.toLong, needLeft.toLong)\n        if (needLeft\
    \ <= 0) {\n            val needs = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrotsLeft = carrots - remaining\n            val needLeft =\
    \ needs - remaining\n            val result = List(carrotsLeft.toLong, needLeft.toLong)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmmfdoslk.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmmfdoslk.scala:39:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e\
    [0m \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m            \
    \                ^\e[0m\n\e[31m   |\e[0m                            Recursive\
    \ \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val needs = need - carrots\n        val carrotsLeft = (1000 - number).toLong\n\
    \        val carrotsLeftNeeds = (1000 - need).toLong\n        val carrotsLeftNeedsRemaining\
    \ = (1000 - remaining).toLong\n        val carrotsLeftNeedsRemainingNeeds = (1000\
    \ - needs - remaining).toLong\n        val carrotsLeftNeedsRemainingNeedsRemaining\
    \ = (1000 - needs - remaining - carrots).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeeds\
    \ = (1000 - needs - remaining - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = (1000 - needs - remaining - carrots - needs - carrots).toLong\n        val\
    \ carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeeds = (1000 - needs -\
    \ remaining - carrots - needs - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots).toLong\n\
    \        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots -\
    \ needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots -\
    \ needs - carrots).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots -\
    \ needs - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = (1000 - needs - remaining - carrots - needs - carrots - needs - carrots -\
    \ needs - carrots - needs - carrots - needs).toLong\n        val carrotsLeftNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphgi2fiua.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmphgi2fiua.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = List(carrots.toLong)\n\
    \        val hungry = true\n        if (remaining <= 0) {\n            hungry\
    \ = false\n        }\n        if (hungry) {\n            meals ::: List(need.toLong)\n\
    \        } else {\n            meals ::: List(need.toLong, remaining.toLong)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk0rfg021.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk0rfg021.scala:36:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            hungry =\
    \ \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Reassignment to val hungry\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val left = (carrots - needs).toLong\n        val hungryLeft = (carrots\
    \ - needs - meals).toLong\n        val hungryLeft2 = (carrots - needs - meals).toLong\n\
    \        val hungryLeft3 = (carrots - needs - meals).toLong\n        val hungryLeft4\
    \ = (carrots - needs - meals).toLong\n        val hungryLeft5 = (carrots - needs\
    \ - meals).toLong\n        val hungryLeft6 = (carrots - needs - meals).toLong\n\
    \        val hungryLeft7 = (carrots - needs - meals).toLong\n        val hungryLeft8\
    \ = (carrots - needs - meals).toLong\n        val hungryLeft9 = (carrots - needs\
    \ - meals).toLong\n        val hungryLeft10 = (carrots - needs - meals).toLong\n\
    \        val hungryLeft11 = (carrots - needs - meals).toLong\n        val hungryLeft12\
    \ = (carrots - needs - meals).toLong\n        val hungryLeft13 = (carrots - needs\
    \ - meals).toLong\n        val hungryLeft14 = (carrots - needs - meals).toLong\n\
    \        val hungryLeft15 = (carrots - needs - meals).toLong\n        val hungryLeft16\
    \ = (carrots - needs - meals).toLong\n        val hungryLeft17 = (carrots - needs\
    \ - meals).toLong\n        val hungryLeft18 = (carrots - needs - meals).toLong\n\
    \        val hungryLeft19 = (carrots - needs - meals).toLong\n        val hungryLeft20\
    \ = (carrots - needs - meals).toLong\n        val hungryLeft21 = (carrots - needs\
    \ - meals).toLong\n        val hungryLeft22 = (carrots - needs - meals).toLong\n\
    \        val hungryLeft23 = (carrots - \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_ibsuouu.scala:59:37 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mhungryLeft23\e[0m = (carrots\
    \ - \n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_ibsuouu.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_ibsuouu.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val carrots_left_to_eat\
    \ = (carrots_left / 2).toInt\n        val carrots_left_to_eat2 = (carrots_left\
    \ / 2).toInt\n        val carrots_left_to_eat3 = (carrots_left / 2).toInt\n  \
    \      val carrots_left_to_eat4 = (carrots_left / 2).toInt\n        val carrots_left_to_eat5\
    \ = (carrots_left / 2).toInt\n        val carrots_left_to_eat6 = (carrots_left\
    \ / 2).toInt\n        val carrots_left_to_eat7 = (carrots_left / 2).toInt\n  \
    \      val carrots_left_to_eat8 = (carrots_left / 2).toInt\n        val carrots_left_to_eat9\
    \ = (carrots_left / 2).toInt\n        val carrots_left_to_eat10 = (carrots_left\
    \ / 2).toInt\n        val carrots_left_to_eat11 = (carrots_left / 2).toInt\n \
    \       val carrots_left_to_eat12 = (carrots_left / 2).toInt\n        val carrots_left_to_eat13\
    \ = (carrots_left / 2).toInt\n        val carrots_left_to_eat14 = (carrots_left\
    \ / 2).toInt\n        val carrots_left_to_eat15 = (carrots_left / 2).toInt\n \
    \       val carrots_left_to_eat16 = (carrots_left / 2).toInt\n        val carrots_left_to_eat17\
    \ = (carrots_left / 2).toInt\n        val carrots_left_to_eat18 = (carrots_left\
    \ / 2).toInt\n        val carrots_left_to_eat19 = (carrots_left / 2).toInt\n \
    \       val carrots_left_to_eat20 = (carrots_left / 2).toInt\n        val carrots_left_to_eat21\
    \ = (carrots_left / 2).toInt\n        val carrots_left_to_eat22 = (carrots_left\
    \ / 2).toInt\n        val carrots_left_to_eat23 = (carrots_left / 2).toInt\n \
    \       val carrots_left_to_eat24 = (carrots_left / 2).toInt\n        val carrots_left_to_eat25\
    \ = (carrots_left / 2).toInt\n        val carrots_left_to_eat26 = (carrots_left\
    \ / 2\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptrksxycs.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptrksxycs.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val carrots_after_meals = carrots_left_after_meals\
    \ / needs_left\n        val carrots_after_meals_remaining = carrots_left_after_meals\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining = carrots_after_meals_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining / needs_left\n        val\
    \ carrots_after_meals_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining / needs_left\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining % needs_left\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvpwetrk3.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpvpwetrk3.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpvpwetrk3.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e["
  stdout: ''
  timestamp: 1660010288
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n\
    \        val left  = need.toInt\n        val total = hungry + left\n        val\
    \ remaining = total - hungry\n        val carrots = List(number.toLong, left.toLong)\n\
    \        val result = if (remaining <= 0) carrots else carrots.take(remaining)\n\
    \        result :+ total\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7_zs4els.scala:40)\n\tat Problem.main(tmp7_zs4els.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val mealsLeft = meals - carrots\n        val carrotsLeft = carrots - remaining\n\
    \        val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n        if (meals\
    \ == 0) {\n            result\n        } else {\n            eat(number, remaining\
    \ - meals, mealsLeft)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjboii_bx.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining == 0)\
    \ {\n            result.add(carrots)\n            result.add(0)\n        } else\
    \ {\n            val carrots_left = carrots - remaining\n            val need_left\
    \ = needs - remaining\n            if (carrots_left == 0) {\n                result.add(carrots)\n\
    \                result.add(0)\n            } else if (need_left == 0) {\n   \
    \             result.add(carrots)\n                result.add(0)\n           \
    \ } else {\n                val carrots_left_2 = carrots_left / 2\n          \
    \      val need_left_2 = need_left / 2\n                val carrots_left_3 = carrots_left\
    \ - carrots_left_2\n                val need_left_3 = need_left - need_left_2\n\
    \                val carrots_left_4 = carrots_left - carrots_left_3\n        \
    \        val need_left_4 = need_left - need_left_3\n                val carrots_left_5\
    \ = carrots_left - carrots_left_4\n                val need_left_5 = need_left\
    \ - need_left_4\n                val carrots_left_6 = carrots_left - carrots_left_5\n\
    \                val need_left_6 = need_left - need_left_5\n                val\
    \ carrots_left_7 = carrots_left - carrots_left_6\n                val need_left_7\
    \ = need_left - need_left_6\n                val carrots_left_8 = carrots_left\
    \ - carrots_left_7\n                val need_left_8 = need_left - need_left_7\n\
    \                val carrots_left_9 = carrots_left - carrots_left_8\n        \
    \        val need_left_9 = need_left - need_left_8\n                val carrots_left_10\
    \ = carrots_left - carrots_left_9\n                val need_left_10 = need_left\
    \ - need_left_9\n                val carrots_left_11 = carrots_left - carrots_left_10\n\
    \                val need_left_11 = need_left - need_left_10\n               \
    \ val carrots_left_12 = carrots_left - carrots_left_11\n                val need_left_12\
    \ = need_left - need_left_11\n                val carrots_left_13 = carrots_left\
    \ - carrots_left_12\n                val need_left_13 = need_left - need_left_12\n\
    \                val carrots_left_14 = carrots_left - carrots_left_13\n      \
    \          val need_left_14 = need_left - need_left_13\n                val carrots_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp22mdt0cz.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp22mdt0cz.scala:86:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m86 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp22mdt0cz.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp22mdt0cz.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp22mdt0cz.scala:85:1\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp22mdt0cz.scala:76:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left * needs_left).toInt\n\
    \        val needs_left_to_eat = (needs_left * carrots_left).toInt\n        val\
    \ carrots_left_to_eat = carrots_left_to_eat.toLong\n        val needs_left_to_eat\
    \ = needs_left_to_eat.toLong\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat\
    \ + needs_left_to_eat\n        val needs_left_to_eat_with_needs = needs_left_to_eat\
    \ + carrots_left_to_eat\n        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toInt\n\
    \        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toInt\n\
    \        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n\
    \        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n\
    \        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n\
    \        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n\
    \        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n\
    \        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n\
    \        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n\
    \        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n\
    \        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n\
    \        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n\
    \        val carrots_left_to_eat_with_needs = carrots_left_to_eat_with_needs.toLong\n\
    \        val needs_left_to_eat_with_needs = needs_left_to_eat_with_needs.toLong\n\
    \        val carrots_left_\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3oslscf4.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3oslscf4.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat\e[0m = carrots_left_to_eat.toLong\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mcarrots_left_to_eat is already defined as \e[33mvalue\e[0m \e[35mcarrots_left_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3oslscf4.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_to_eat\e[0m = needs_left_to_eat.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_to_eat is already defined as \e[33mvalue\e[0m \e\
    [35mneeds_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3oslscf4.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_with_needs\e\
    [0m = carrots_left_to_eat_with_needs.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_with_needs is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_with_needs\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3oslscf4.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_to_eat_with_needs\e\
    [0m = needs_left_to_eat_with_needs.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_"
  stdout: ''
  timestamp: 1660010289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = math.min(needs, carrots)\n        val leftOver = math.max(0,\
    \ carrots - meals)\n        val mealsLeft = math.max(0, leftOver - remaining)\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toInt\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val mealsLeft = mealsLeft.toLong\n\
    \        val mealsLeft = mealsLeft.toLong\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp3nzx05yx.scala:74:11 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp3nzx05yx.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3nzx05yx.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft\
    \ is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3nzx05yx.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3nzx05yx.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming E"
  stdout: ''
  timestamp: 1660010291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ArrayList[Long]()\n        if (remaining ==\
    \ 0) {\n            result.add(0)\n            result.add(0)\n        } else {\n\
    \            val carrots_left = carrots - remaining\n            val needs_left\
    \ = needs - remaining\n            if (needs_left == 0) {\n                result.add(carrots)\n\
    \                result.add(0)\n            } else {\n                val carrots_left_new\
    \ = carrots_left / needs_left\n                val needs_left_new = needs_left\
    \ % needs_left\n                result.add(carrots_left_new)\n               \
    \ result.add(needs_left_new)\n            }\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv283rkxh.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv283rkxh.scala:34:37\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e\
    [0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Not\
    \ found: type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv283rkxh.scala:36:19\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            result.add(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value add is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpv283rkxh.scala:37:19 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m            result.add(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv283rkxh.scala:42:23\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                result.add(carrots)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660010295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val hungry = carrots - remaining\n        val left = (carrots - meals).toInt\n\
    \        val result = List(hungry, left)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuwzkvibo.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuwzkvibo.scala:37:8\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m =\
    \ List(carrots_left.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m = List(carrots_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_le"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining <= 0)\
    \ {\n            result.add(carrots)\n            result.add(0)\n        } else\
    \ {\n            val carrots_left = remaining - carrots\n            val needs_left\
    \ = carrots_left - needs\n            if (needs_left <= 0) {\n               \
    \ result.add(carrots)\n                result.add(0)\n            } else {\n \
    \               val needs_left_int = needs_left.toInt\n                val carrots_left_int\
    \ = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n\
    \                val carrots_left_int = carrots_left.toInt\n                val\
    \ needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n\
    \                val needs_left_int = needs_left.toInt\n                val carrots_left_int\
    \ = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n\
    \                val carrots_left_int = carrots_left.toInt\n                val\
    \ needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n\
    \                val needs_left_int = needs_left.toInt\n                val carrots_left_int\
    \ = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n\
    \                val carrots_left_int = carrots_left.toInt\n                val\
    \ needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n\
    \                val needs_left_int = needs_left.toInt\n                val carrots_left_int\
    \ = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n\
    \                val carrots_left_int = carrots_left.toInt\n                val\
    \ needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n\
    \                val needs_left_int = needs_left.toInt\n                val carrots_left_int\
    \ = carrots_left.toInt\n                val needs_left_int = needs_left.toInt\n\
    \                val carrots_left_int = carrots_left.toInt\n                val\
    \ needs_left_int = needs_left.toInt\n                val carrots_left_int = carrots_left.toInt\n\
    \                val needs_left_int = needs_left.toInt\n                val carrots_left_int\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq_8ob7le.scala:76:38 ---------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m                \e[33mval\e[0m \e[36mcarrots_left_int\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e\
    [31m   |\e[0m                                      expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq_8ob7le.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpq_8ob7le.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq_8ob7le.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq_8ob7le.scala:47:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                \e[33mval\e\
    [0m \e[36mneeds_left_int\e[0m = needs_left.toInt\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneeds_left_int\
    \ is already defined as \e[33mvalue\e[0m \e[35mneeds_left_int\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq_8ob7le.scala:48:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m                \e[33mval\e\
    [0m \e[36mcarrots_left_int\e[0m = carrots_left.toInt\n\e[3"
  stdout: ''
  timestamp: 1660010294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        val carrots_left = carrots - remaining\n\
    \        val needs_left = needs - remaining\n        if (needs_left <= 0) {\n\
    \            result(0) = carrots_left\n            result(1) = needs_left\n  \
    \      } else {\n            result(0) = carrots_left\n            result(1) =\
    \ needs_left\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnys9ijo_.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnys9ijo_.scala:44:8\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = remaining - carrots\n        val meals = carrots - need\n\
    \        val carrots_left_after_meals = carrots - meals\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals - carrots_left_after_meals_after_meals\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n \
    \       val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcb8ndobn.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcb8ndobn.scala:42:111\
    \ --------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                       ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpcb8ndobn.scala:43:135 --------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_\n\e[31m\e[31m   |\e[0m                   \
    \                                                                            \
    \                                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660010293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingCarrots = remaining.toInt\n\
    \        val totalCarrots = carrots - needToEat\n        val remainingCarrotsToEat\
    \ = totalCarrots - needToEat\n        val carrotsToEat = remainingCarrots - remainingCarrotsToEat\n\
    \        val carrotsToEatList = List(carrotsToEat.toLong)\n        val carrotsToEatList2\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList3 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList4 = List(carrotsToEat.toLong)\n        val carrotsToEatList5\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList6 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList7 = List(carrotsToEat.toLong)\n        val carrotsToEatList8\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList9 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList10 = List(carrotsToEat.toLong)\n        val carrotsToEatList11\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList12 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList13 = List(carrotsToEat.toLong)\n        val carrotsToEatList14\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList15 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList16 = List(carrotsToEat.toLong)\n        val carrotsToEatList17\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList18 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList19 = List(carrotsToEat.toLong)\n        val carrotsTo\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph2dwy1vk.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmph2dwy1vk.scala:57:5 ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left\
    \ % needs_left).toInt\n        val needs_to_eat = (needs_left % carrots_left).toInt\n\
    \        val carrots_to_eat_left = carrots_to_eat * needs_to_eat\n        val\
    \ needs_to_eat_left = needs_to_eat * carrots_to_eat\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat\
    \ = (needs_to_eat_left / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat * needs_to_eat_left\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left\n \
    \       val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat\
    \ * carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat\
    \ / carrots_to_eat_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0wrei1y4.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0wrei1y4.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0wrei1y4.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0wrei1y4.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val carrots = mutable.ListBuffer[Long]()\n        val hungryCarrots =\
    \ mutable.ListBuffer[Long]()\n        val leftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryLeftCarrots = mutable.ListBuffer[Long]()\n        val hungryLeftCarrots\
    \ = mutable.ListBuffer[Long\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptlm0vt7m.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptlm0vt7m.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryLeftCarrots\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mhungryLeftCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryLeftCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptlm0vt7m.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftCarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mhungryLeftCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptlm0vt7m.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftCarrots\e[0m =\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mhungryLeftCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptlm0vt7m.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftCarrots\e[0m =\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mhungryLeftCarrots\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1660010295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val needList = List(need.toLong)\n\
    \        val needlessList = List(need.toLong)\n        val hungryNeedlessList\
    \ = List(hungry.toLong)\n        val needlessList = List(need.toLong)\n      \
    \  val hungryNeedlessNeedlessList = List(hungry.toLong)\n        val needlessNeedlessList\
    \ = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessList = List(hungry.toLong)\n\
    \        val needlessNeedlessNeedlessList = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessList\
    \ = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessList = List(need.toLong)\n\
    \        val hungryNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n\
    \        val needlessNeedlessNeedlessNeedlessList = List(need.toLong)\n      \
    \  val hungryNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n\
    \        val needlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n\
    \        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n\
    \        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n\
    \        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(hungry.toLong)\n\
    \        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessList = List(need.toLong)\n\
    \        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList\
    \ = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList\
    \ = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList\
    \ = List(hungry.toLong)\n        val needlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList\
    \ = List(need.toLong)\n        val hungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList\
    \ = List(hungr\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplbydzz6s.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplbydzz6s.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneedlessList\e[0m = List(need.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneedlessList is already defined as \e[33mvalue\e[0m \e[35mneedlessList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplbydzz6s.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedlessNeedlessNeedlessNeedlessList\e\
    [0m = List(hungry.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedlessNeedlessNeedlessNeedlessList is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryNeedlessNeedlessNeedlessNeedlessList\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmplbydzz6s.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mneedlessNeedlessNeedlessNeedlessList\e[0m\
    \ = List(need.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneedlessNeedlessNeedlessNeedlessList is already defined as\
    \ \e[33mvalue\e[0m \e[35mneedlessNeedlessNeedlessNeedlessList\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplbydzz6s.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryNeedlessNeedlessNeedlessNeedlessNeedlessNeedlessList\e[0m = List(hungry.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        while (i < carrots && j < needs) {\n            if\
    \ (remaining > 0) {\n                k += 1\n                remaining -= 1\n\
    \            }\n            i += 1\n            j += 1\n        }\n        if\
    \ (remaining > 0) {\n            k += 1\n        }\n        result(0) = k\n  \
    \      result(1) = remaining\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqj5tcuwb.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqj5tcuwb.scala:51:8\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val totalEaten = carrots - needToEat\n        val remainingCarrots =\
    \ remainingToEat - needToEat\n        val hungry = remainingCarrots > 0\n    \
    \    val eatenCarrots = totalEaten + remainingCarrots\n        val hungryCarrots\
    \ = hungry ? eatenCarrots : 0\n        val hungryCarrotsList = List(hungryCarrots)\n\
    \        val hungryCarrotsListWithRemaining = hungryCarrotsList :+ remainingCarrots\n\
    \        hungryCarrotsListWithRemaining\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzdilffj2.scala:38:35 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungry\
    \ ? eatenCarrots : \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                            value ? is not\
    \ a member of Boolean\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzdilffj2.scala:41:8\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m        hungryCarrotsListWithRemaining\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    (hungryCarrotsListWithRemaining : List[Int])\n\e[31m   |\e\
    [0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010303
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n\
    \        if (remaining <= 0) result\n        else eat(number, need, remaining\
    \ - meals)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9caexnc6.scala:38)\n\tat Problem.main(tmp9caexnc6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        val carrots_left = remaining -\
    \ carrots\n        val needs_left = needs - carrots\n        if (needs_left <=\
    \ 0) {\n            result(0) = carrots_left\n            result(1) = 0\n    \
    \    } else {\n            result(0) = carrots_left\n            result(1) = needs_left\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9zpn4t5n.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zpn4t5n.scala:44:8\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number\
    \ - remaining\n        val hungryCarrotsToEat = need - remaining\n        val\
    \ hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList2\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList3 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList4 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList5 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList6 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList7\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList8 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList9 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList10 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList11 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList12\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList13 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList14 = List(hungryCarrotsToEat.toLong)\n    \
    \    val hungryCarrotsToEatList15 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList16 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList17\
    \ = List\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5oyttxwu.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_left_to_eat\
    \ = (carrots_left * need).toInt\n        val carrots_left_to_eat_with_needs =\
    \ carrots_left_to_eat + needs\n        val carrots_left_to_eat_with_needs_with_remaining\
    \ = carrots_left_to_eat_with_needs + remaining\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs\
    \ = carrots_left_to_eat_with_needs_with_remaining + needs\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining\
    \ = carrots_left_to_eat_with_needs_with_remaining_with_needs + remaining\n   \
    \     val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs\
    \ = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining +\
    \ needs\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining\
    \ = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs\
    \ + remaining\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs\
    \ = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining\
    \ + needs\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining\
    \ = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs\
    \ + remaining\n        val carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs\
    \ = carrots_left_to_eat_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining_with_needs_with_remaining\
    \ + needs\n        val carrots_left_to_eat_with_need\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0nxcdujt.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0nxcdujt.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0nxcdujt.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_after_meals = carrots_left - needs_left\n\
    \        val needs_left_after_meals = needs_left - carrots_left\n        val meals\
    \ = List(needs_left_after_meals, carrots_left_after_meals)\n        meals\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1vuekxfy.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = needs - carrots\n        val carrots_left_to_eat\
    \ = (carrots_left - needs_left).toInt\n        val needs_left_to_eat = (needs_left\
    \ - carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left_to_eat\
    \ * 2).toInt\n        val needs_left_to_eat_2 = (needs_left_to_eat * 2).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left_to_eat_2 * 3).toInt\n     \
    \   val needs_left_to_eat_3 = (needs_left_to_eat_2 * 3).toInt\n        val carrots_left_to_eat_4\
    \ = (carrots_left_to_eat_3 * 4).toInt\n        val needs_left_to_eat_4 = (needs_left_to_eat_3\
    \ * 4).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4 * 5).toInt\n\
    \        val needs_left_to_eat_5 = (needs_left_to_eat_4 * 5).toInt\n        val\
    \ carrots_left_to_eat_6 = (carrots_left_to_eat_5 * 6).toInt\n        val needs_left_to_eat_6\
    \ = (needs_left_to_eat_5 * 6).toInt\n        val carrots_left_to_eat_7 = (carrots_left_to_eat_6\
    \ * 7).toInt\n        val needs_left_to_eat_7 = (needs_left_to_eat_6 * 7).toInt\n\
    \        val carrots_left_to_eat_8 = (carrots_left_to_eat_7 * 8).toInt\n     \
    \   val needs_left_to_eat_8 = (needs_left_to_eat_7 * 8).toInt\n        val carrots_left_to_eat_9\
    \ = (carrots_left_to_eat_8 * 9).toInt\n        val needs_left_to_eat_9 = (needs_left_to_eat_8\
    \ * 9).toInt\n        val carrots_left_to_eat_10 = (carrots_left_to_eat_9 * 10).toInt\n\
    \        val needs_left_to_eat_10 = (needs_left_to_eat_9 * 10).toInt\n       \
    \ val carrots_left_to_eat_11 = (carrots_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsuimxfrz.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsuimxfrz.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsuimxfrz.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsuimxfrz.scala:57:38 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_11\e\
    [0m = (carrots_\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: carrots_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsuimxfrz.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = remaining - carrots\n        val carrots_needed = needs\
    \ - carrots\n        val carrots_left_needed = carrots_needed - carrots_left\n\
    \        val carrots_left_needed_to_eat = carrots_left_needed + carrots\n    \
    \    val carrots_left_needed_to_eat2 = carrots_left_needed + carrots_left\n  \
    \      val carrots_left_needed_to_eat3 = carrots_left_needed + carrots_left +\
    \ carrots\n        val carrots_left_needed_to_eat4 = carrots_left_needed + carrots_left\
    \ + carrots + carrots\n        val carrots_left_needed_to_eat5 = carrots_left_needed\
    \ + carrots_left + carrots + carrots + carrots\n        val carrots_left_needed_to_eat6\
    \ = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots\n\
    \        val carrots_left_needed_to_eat7 = carrots_left_needed + carrots_left\
    \ + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat8\
    \ = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat9\
    \ = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots + carrots + carrots + carrots\n        val carrots_left_needed_to_eat10\
    \ = carrots_left_needed + carrots_left + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\
    \ + carrots\n        val carrots_left_needed_to_eat11 = carrots_left_needed +\
    \ carrots_left + carrots + carrots + carrots + carrots + carrots + carrots + carrots\
    \ + carrots + carrots + carrots + carrots + carrots + carrots + carrots + carrots\n\
    \        val carrots_left_needed_to_eat12 = carrots_left_needed \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_p391zna.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_p391zna.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val totalCarrots = carrots - remaining\n        val carrotsLeft = meals\
    \ - totalCarrots\n        val carrotsLeftList = List(carrotsLeft.toLong)\n   \
    \     val carrotsLeftListWithZero = carrotsLeftList.map(_ -> 0l)\n        val\
    \ carrotsLeftListWithZeroAndOne = carrotsLeftListWithZero.zipWithIndex.map { case\
    \ (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZero\
    \ = carrotsLeftListWithZeroAndOne.zipWithIndex.map { case (l, i) => if (i == 0)\
    \ 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOne = carrotsLeftListWithZeroAndOneWithZero.zipWithIndex.map\
    \ { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZero\
    \ = carrotsLeftListWithZeroAndOneWithZeroAndOne.zipWithIndex.map { case (l, i)\
    \ => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOne\
    \ = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZero.zipWithIndex.map { case\
    \ (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZero\
    \ = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOne.zipWithIndex.map\
    \ { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZeroAndOne\
    \ = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZero.zipWithIndex.map\
    \ { case (l, i) => if (i == 0) 0l else l }\n        val carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZero\
    \ = carrotsLeftListWithZeroAndOneWithZeroAndOneWithZeroAndOneWithZeroAndOne.zipWithIndex.map\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmnnsin91.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmnnsin91.scala:37:60\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotsLeftListWithZero\e[0m = carrotsLeftList.map(_ -> \e[31m0l\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                                          ^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value -> is not a member\
    \ of Nothing\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmnnsin91.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val carrots_left = carrots - meals\n\
    \        val carrots_left_after = carrots - needs - meals\n        val carrots_left_after_meals\
    \ = carrots - needs - remaining\n        val carrots_left_after_meals_after =\
    \ carrots - needs - remaining - meals\n        val carrots_left_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals\n        val carrots_left_after_meals_after_meals_after\
    \ = carrots - needs - remaining - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after\
    \ = carrots - needs - remaining - meals - meals - meals - meals - meals\n    \
    \    val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots\
    \ - needs - remaining - meals - meals - meals - meals - meals - meals\n      \
    \  val carrots_left_after_meals_after_meals_after_meals_after_meals_after = carrots\
    \ - needs - remaining - meals - meals - meals - meals - meals - meals - meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals - meals - meals - meals - meals\
    \ - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after\
    \ = carrots - needs - remaining - meals - meals - meals - meals - meals - meals\
    \ - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals - meals - meals - me\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpn0vkyzb7.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0vkyzb7.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n\
    \        val hungryRemaining = remaining.toInt\n        val needToEat = need.toInt\n\
    \        val needToEatRemaining = needToEat - hungryRemaining\n        val hungryToEat\
    \ = hungry - needToEat\n        val hungryToEatRemaining = hungryToEat - hungryRemaining\n\
    \        val hungryToEatRemainingList = List(hungryToEatRemaining.toLong)\n  \
    \      val hungryToEatRemainingList2 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong)\n\
    \        val hungryToEatRemainingList3 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList4 = List(hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong)\n\
    \        val hungryToEatRemainingList5 = List(hungryToEatRemaining.toLong, hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList6 = List(hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong)\n        val hungryToEatRemainingList7 = List(hungryToEatRemaining.toLong,\
    \ hungryToEatRemaining.toLong, hungryToEatRemaining.toLong, hungryToEatRemaining.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgjrfs9j2.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgjrfs9j2.scala:44:5 ---------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val result = List(number\
    \ - carrots, carrots)\n        if (remaining <= 0) result\n        else eat(number,\
    \ need, remaining)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz5tk3y7_.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val totalCarrots = carrots + remaining\n        val needCarrots = needs\
    \ - remaining\n        val carrots = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l,\
    \ 10l, 11l, 12l, 13l, 14l, 15l, 16l, 17l, 18l, 19l, 20l, 21l, 22l, 23l, 24l, 25l,\
    \ 26l, 27l, 28l, 29l, 30l, 31l, 32l, 33l, 34l, 35l, 36l, 37l, 38l, 39l, 40l, 41l,\
    \ 42l, 43l, 44l, 45l, 46l, 47l, 48l, 49l, 50l, 51l, 52l, 53l, 54l, 55l, 56l, 57l,\
    \ 58l, 59l, 60l, 61l, 62l, 63l, 64l, 65l, 66l, 67l, 68l, 69l, 70l, 71l, 72l, 73l,\
    \ 74l, 75l, 76l, 77l, 78l, 79l, 80l, 81l, 82l, 83l, 84l, 85l, 86l, 87l, 88l, 89l,\
    \ 90l, 91l, 92l, 93l, 94l, 95l, 96l, 97l, 98l, 99l, 100l, 101l, 102l, 103l, 104l,\
    \ 105l, 106l, 107l, 108l, 109l, 110l, 111l, 112l, 113l, 114l, 115l, 116l, 117l,\
    \ 118l, 119l, 120l, 121l, 122l, 123l, 124l, 125l, 126l, 127l, 128l, 129l, 130l,\
    \ 131l, 132l, 133l, 134l, 135l, 136l, 137l, 138l, 139l, 140l, 141l, 142l, 143l,\
    \ 144l, 145l, 146l, 147l, 148l, 149l, 150l, 151l, 152l, 153l, 154l, 155l, 156l,\
    \ 157l, 158l, 159l, 160l, 161l, 162l, 163l, 164l, 165l, 166l, 167l, 168l, 169l,\
    \ 170l, 171l, 172l, 173l, 174l, 175l, 176l, 177l, 178l, 179l, 180l, 181l, 182l,\
    \ 183l, 184l, 185l, 186l, 187l, 188l, 189l, 190l, 191l, 192l, 193l, 194l, 195l,\
    \ 196l, 197l, 198l, 199l, 200l, 201l, 202l, 203l, 204l, 205l, 206l, 207l, 208l,\
    \ 209l, 210l, 211l, 212l, 213l, 214l, 215l, 216l, 217l, 218l, 219l, 220l, \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_3bo1une.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_3bo1une.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots\e[0m = List(\e[31m1l\e[0m, \e[31m2l\e[0m, \e[31m3l\e[0m, \e[31m4l\e\
    [0m, \e[31m5l\e[0m, \e[31m6l\e[0m, \e[31m7l\e[0m, \e[31m8l\e[0m, \e[31m9l\e[0m,\
    \ \e[31m10l\e[0m, \e[31m11l\e[0m, \e[31m12l\e[0m, \e[31m13l\e[0m, \e[31m14l\e\
    [0m, \e[31m15l\e[0m, \e[31m16l\e[0m, \e[31m17l\e[0m, \e[31m18l\e[0m, \e[31m19l\e\
    [0m, \e[31m20l\e[0m, \e[31m21l\e[0m, \e[31m22l\e[0m, \e[31m23l\e[0m, \e[31m24l\e\
    [0m, \e[31m25l\e[0m, \e[31m26l\e[0m, \e[31m27l\e[0m, \e[31m28l\e[0m, \e[31m29l\e\
    [0m, \e[31m30l\e[0m, \e[31m31l\e[0m, \e[31m32l\e[0m, \e[31m33l\e[0m, \e[31m34l\e\
    [0m, \e[31m35l\e[0m, \e[31m36l\e[0m, \e[31m37l\e[0m, \e[31m38l\e[0m, \e[31m39l\e\
    [0m, \e[31m40l\e[0m, \e[31m41l\e[0m, \e[31m42l\e[0m, \e[31m43l\e[0m, \e[31m44l\e\
    [0m, \e[31m45l\e[0m, \e[31m46l\e[0m, \e[31m47l\e[0m, \e[31m48l\e[0m, \e[31m49l\e\
    [0m, \e[31m50l\e[0m, \e[31m51l\e[0m, \e[31m52l\e[0m, \e[31m53l\e[0m, \e[31m54l\e\
    [0m, \e[31m55l\e[0m, \e[31m56l\e[0m, \e[31m57l\e[0m, \e[31m58l\e[0m, \e[31m59l\e\
    [0m, \e[31m60l\e[0m, \e[31m61l\e[0m, \e[31m62l\e[0m, \e[31m63l\e[0m, \e[31m64l\e\
    [0m, \e[31m65l\e[0m, \e[31m66l\e[0m, \e[31m67l\e[0m, \e[31m68l\e[0m, \e[31m69l\e\
    [0m, \e[31m70l\e[0m, \e[31m71l\e[0m, \e[31m72l\e[0m, \e[31m73l\e[0m, \e[31m74l\e\
    [0m, \e[31m75l\e[0m, \e[31m76l\e[0m, \e[31m77l\e[0m, \e[31m78l\e[0m, \e[31m79l\e\
    [0m, \e[31m80l\e[0m, \e[31m81l\e[0m, \e[31m82l\e[0m, \e[31m83l\e[0m, \e[31m84l\e\
    [0m, \e[31m85l\e[0m, \e[31m86l\e[0m, \e[31m87l\e[0m, \e[31m88l\e[0m, \e[31m89l\e\
    [0m, \e[31m90l\e[0m, \e[31m91l\e[0m, \e[31m92l\e[0m, \e[31m93l\e[0m, \e[31m94l\e\
    [0m, \e[31m95l\e[0m, \e[31m96l\e[0m, \e[31m97l\e[0m, \e[31m98l\e[0m, \e[31m99l\e\
    [0m, \e[31m100l\e[0m, \e[31m101l\e[0m, \e[31m102l\e[0m, \e[31m103l\e[0m, \e[31m104l\e\
    [0m, \e[31m105l\e[0m, \e[31m106l\e[0m, \e[31m107l\e[0m, \e[31m108l\e[0m, \e[31m109l\e\
    [0m, \e[31m110l\e[0m, \e[31m111l\e[0m, \e[31m112l\e[0m, \e[31m113l\e[0m, \e[31m114l\e\
    [0m, \e[31m115l\e[0m, \e[31m116l\e[0m, \e[31m117l\e[0m, \e[31m118l\e[0m, \e[31m119l\e\
    [0m, \e[31m120l\e[0m, \e[31m121"
  stdout: ''
  timestamp: 1660010312
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n\
    \        if (remaining < 0l) {\n            val carrots = remaining + meals\n\
    \            val meals = need - carrots\n            val result = List(meals.toLong,\
    \ carrots.toLong)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgx87rrw3.scala:36:31 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mmeals\e[0m = need -\
    \ carrots\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m\
    \   |\e[0m                               Recursive \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining > 0)\
    \ {\n            val carrots_left = remaining - carrots\n            val needs_left\
    \ = carrots_left - needs\n            val needs_left_to_eat = (needs_left / needs).toInt\n\
    \            val needs_left_to_eat_left = needs_left - needs_left_to_eat * needs\n\
    \            val needs_left_to_eat_left_to_eat = (needs_left_to_eat_left / needs).toInt\n\
    \            val needs_left_to_eat_left_to_eat_left = needs_left_to_eat_left -\
    \ needs_left_to_eat_left_to_eat * needs\n            val needs_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat / needs).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_to_eat_left - needs_left_to_eat_left_to_eat_left *\
    \ needs\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left / needs).toInt\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_to_eat_left_to_eat - needs_left_to_eat_left_to_eat_left\
    \ * needs\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left_to_eat / needs).toInt\n            val\
    \ needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = needs_left_to_eat_left_to_eat_left_to_eat_left\
    \ - needs_left_to_eat_left_to_eat_left_to_eat * needs\n            val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left_to_eat_left_to_eat_left / needs).toInt\n         \
    \   val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgsqtqoll.scala:61:0 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgsqtqoll.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpgsqtqoll.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpgsqtqoll.scala:49:101 -----------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e[0m \e[36mneeds_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\e\
    [0m = needs_left_to_eat_left_\n\e[31m\e[31m   |\e[0m                         \
    \                                                                            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: needs_left_to_eat_left_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgsqtqoll.scala:60:1\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpgsqtqoll.scala:51:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m51 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m"
  stdout: ''
  timestamp: 1660010314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val totalCarrots = carrots + remaining\n        val needCarrots = needs\
    \ - remaining\n        val carrotList = List(totalCarrots.toLong, needCarrots.toLong)\n\
    \        carrotList.sortWith(_ < _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzq3zhykr.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzq3zhykr.scala:37:30\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        carrotList.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                            ^^^\e[0m\n\e[31m   |\e\
    [0mvalue < is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remaining = carrots + meals\n\
    \        List(meals, remaining)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphow3yaqb.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = carrots\
    \ + meals\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remainingCarrots = remaining\
    \ - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots\
    \ - hungry\n        val hungryMeals = meals - hungry\n        val hungryRemainingCarrots\
    \ = remainingCarrots - hungry\n        val hungryRemainingMeals = hungryMeals\
    \ - hungryCarrots\n        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n\
    \        val hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val\
    \ hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val\
    \ hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrots.toLong\n        val\
    \ hungryRemainingMeals = hungryRemainingMeals.toLong\n        val hungryRemainingCarrots\
    \ = hungryRemainingCarrots.toLong\n        val hungryRemainingMeals = hungryRemainingMeals.toLong\n\
    \        val hungryRemainingCarrots = hungryRemainingCarrots.to\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingCarrots\e\
    [0m = hungryRemainingCarrots.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingCarrots is already defined as \e[33mvalue\e\
    [0m \e[35mhungryRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingMeals\e[0m\
    \ = hungryRemainingMeals.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingMeals is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryRemainingMeals\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingCarrots\e\
    [0m = hungryRemainingCarrots.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingCarrots is already defined as \e[33mvalue\e\
    [0m \e[35mhungryRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpldhg9v83.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingMeals\e[0m\
    \ = hungryRemainingMeals.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingMeals is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryRemainingMeals\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /t"
  stdout: ''
  timestamp: 1660010315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - meals\n        val meals_left = carrots_left\
    \ - remaining\n        val carrots_left_list = List(carrots_left.toLong)\n   \
    \     val meals_left_list = List(meals_left.toLong)\n        val carrots_left_list2\
    \ = List(carrots_left.toLong)\n        val meals_left_list2 = List(meals_left.toLong)\n\
    \        val carrots_left_list3 = List(carrots_left.toLong)\n        val meals_left_list3\
    \ = List(meals_left.toLong)\n        val carrots_left_list4 = List(carrots_left.toLong)\n\
    \        val meals_left_list4 = List(meals_left.toLong)\n        val carrots_left_list5\
    \ = List(carrots_left.toLong)\n        val meals_left_list5 = List(meals_left.toLong)\n\
    \        val carrots_left_list6 = List(carrots_left.toLong)\n        val meals_left_list6\
    \ = List(meals_left.toLong)\n        val carrots_left_list7 = List(carrots_left.toLong)\n\
    \        val meals_left_list7 = List(meals_left.toLong)\n        val carrots_left_list8\
    \ = List(carrots_left.toLong)\n        val meals_left_list8 = List(meals_left.toLong)\n\
    \        val carrots_left_list9 = List(carrots_left.toLong)\n        val meals_left_list9\
    \ = List(meals_left.toLong)\n        val carrots_left_list10 = List(carrots_left.toLong)\n\
    \        val meals_left_list10 = List(meals_left.toLong)\n        val carrots_left_list11\
    \ = List(carrots_left.toLong)\n        val meals_left_list11 = List(meals_left.toLong)\n\
    \        val carrots_left_list12 = List(carrots_left.toLong)\n        val meals_left_list12\
    \ = List(meals_left.toLong)\n        val carrots_left_list13 = List(carrots_left.toLong)\n\
    \        val meals_left_list13 = List(meals_left.toLong)\n        val carrots_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfb4_y1o1.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfb4_y1o1.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfb4_y1o1.scala:63:5 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n\
    \        val carrots_left_to_eat_left = carrots_left - carrots_left_to_eat * needs_left\n\
    \        val carrots_left_to_eat_left_to_eat = (carrots_left_to_eat_left / needs_left).toInt\n\
    \        val carrots_left_to_eat_left_to_eat_left = carrots_left_to_eat_left -\
    \ carrots_left_to_eat_left_to_eat * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat / needs_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left\
    \ * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left / needs_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left_to_eat_left_to_eat - carrots_left_to_eat_left_to_eat_left_to_eat\
    \ * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left_to_eat / needs_left).toInt\n       \
    \ val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left_to_eat_left\
    \ * needs_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left_to_eat_left / needs_left).toInt\n  \
    \      val carrots_left_to_eat_left_to_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6v4qj87c.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6v4qj87c.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6v4qj87c.scala:48:5 ---------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_left_after_meals\
    \ = carrots - carrots_left\n        val carrots_left_after_meals_after_meals =\
    \ carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals - carrots_left_after_meals_after_meals\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n \
    \       val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_me\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1nr7_2xy.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1nr7_2xy.scala:41:111\
    \ --------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                       ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp1nr7_2xy.scala:42:135 --------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_me\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                                                  ^\e[0m\n\e\
    [31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m ne"
  stdout: ''
  timestamp: 1660010315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val needs_left_after_meals = needs_left\
    \ % carrots_left\n        val meals_after_meals = carrots_left_after_meals / needs_left_after_meals\n\
    \        val carrots_left_after_meals_after_meals = carrots_left_after_meals %\
    \ needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals\
    \ % carrots_left_after_meals\n        val meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ / needs_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals % needs_left_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals\
    \ % carrots_left_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals\
    \ % needs_left_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals\
    \ = needs_left_after_meals_after_meals_after_meals % carrots_left_after_meals_after_meals_after_meals\n\
    \        val meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ / needs_left_after_meals_after_meals_after_meals_after_me\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdmzyd31e.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdmzyd31e.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val hungryRemaining = remaining\
    \ - hungry\n        val hungryRemainingList = List(hungryRemaining.toLong)\n \
    \       val hungryRemainingList2 = List(hungryRemaining.toLong)\n        if (hungryRemaining\
    \ == 0) {\n            hungryList\n        } else {\n            hungryList2 ++=\
    \ eat(hungry, need, remaining)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnoc_ygpx.scala:39:12 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            hungryList2 ++= eat(hungry, need, remaining)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Not found: hungryList2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n\
    \        val carrotLeftToEatListWithZero = carrotLeftToEatList.map(_(0l))\n  \
    \      val carrotLeftToEatListWithZeroList = carrotLeftToEatListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZero = carrotLeftToEatListWithZeroList.map(_(0l))\n\
    \        val carrotLeftToEatListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZero = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroList = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZero =\
    \ carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroList\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroList\
    \ = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \        val carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero\
    \ = carrotLeftToEat\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmplhdzsnd2.scala:37:66 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeftToEatListWithZero\e\
    [0m = carrotLeftToEatList.map(_(\e[31m0l\e[0m))\n\e[31m\e[31m   |\e[0m       \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                  \e[33mparameter\e[0m \e[35m_$1\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmplhdzsnd2.scala:39:90\
    \ -----------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e\
    [0m \e[36mcarrotLeftToEatListWithZeroListWithZero\e[0m = carrotLeftToEatListWithZeroList.map(_(\e\
    [31m0l\e[0m))\n\e[31m\e[31m   |\e[0m                                         \
    \                                                 ^\e[0m\n\e[31m   |\e[0m    \
    \                              \e[33mparameter\e[0m \e[35m_$2\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplhdzsnd2.scala:41:66\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotLeftToEatListWithZeroListWithZeroListWithZero\e[0m = carrotLeftToEatListWithZeroListWithZeroListWithZero.toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mcarrotLeftToEatListWithZeroListWithZeroListWithZero\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplhdzsnd2.scala:45:178\
    \ -----------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZero\e\
    [0m = carrotLeftToEatListWithZeroListWithZeroListWithZeroListWithZeroListWithZeroListWithZero.toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val left = (meals - needs).toInt\n        val result = List(hungry, left)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpratfcva5.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        if (remaining <= 0) {\n       \
    \     result(0) = carrots.toLong\n            result(1) = 0l.toLong\n        }\
    \ else {\n            val need = needs.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n\
    \            val need = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n\
    \            val need = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n\
    \            val need = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n\
    \            val need = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n\
    \            val need = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n\
    \            val need = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n            val carrots = carrots.toInt\n\
    \            val need = need.toInt\n            val remaining = remaining.toInt\n\
    \            val carrots = carrots.toInt\n            val need = need.toInt\n\
    \            val remaining = remaining.toInt\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpku8cssk7.scala:98:0 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpku8cssk7.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpku8cssk7.scala:42:16 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            \e[33mval\e[0m \e[36mneed\e[0m = need.toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneed is already\
    \ defined as \e[33mvalue\e[0m \e[35mneed\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpku8cssk7.scala:43:16 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpku8cssk7.scala:44:16 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = carrots.toInt\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpku8cssk7.scala:45:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e\
    [0m \e[36mneed\e[0m = need.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^"
  stdout: ''
  timestamp: 1660010326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val remaining = remaining - needs\n\
    \        val hungry = remaining > 0\n        val eaten = meals + needs\n     \
    \   val left = (carrots - eaten).toLong\n        val result = List(left.toLong,\
    \ eaten.toLong)\n        if (hungry) {\n            val hungryEaten = meals +\
    \ needs - 1\n            val hungryLeft = carrots - hungryEaten\n            val\
    \ hungryResult = List(hungryLeft.toLong, hungryEaten.toLong)\n            result\
    \ ::: hungryResult\n        } else {\n            result\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv20hzopk.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - needs\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpv20hzopk.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number.toLong\n\
    \        val hungryRabbitNeed = need.toLong\n        val hungryRabbitRemaining\
    \ = remaining.toLong\n        val hungryRabbitEaten = hungryRabbit\n        val\
    \ hungryRabbitLeft = hungryRabbit\n        val hungryRabbitEatenNeed = hungryRabbitNeed\n\
    \        val hungryRabbitLeftNeed = hungryRabbitNeed\n        val hungryRabbitLeftRemaining\
    \ = hungryRabbitRemaining\n        val hungryRabbitLeftEaten = hungryRabbitLeft\n\
    \        val hungryRabbitLeftLeft = hungryRabbitLeft\n        val hungryRabbitLeftEatenNeed\
    \ = hungryRabbitLeftNeed\n        val hungryRabbitLeftLeftNeed = hungryRabbitLeftNeed\n\
    \        val hungryRabbitLeftLeftRemaining = hungryRabbitLeftRemaining\n     \
    \   val hungryRabbitLeftLeftEaten = hungryRabbitLeftLeft\n        val hungryRabbitLeftLeftLeft\
    \ = hungryRabbitLeftLeft\n        val hungryRabbitLeftLeftEatenNeed = hungryRabbitLeftLeftNeed\n\
    \        val hungryRabbitLeftLeftLeftNeed = hungryRabbitLeftLeftNeed\n       \
    \ val hungryRabbitLeftLeftLeftRemaining = hungryRabbitLeftLeftRemaining\n    \
    \    val hungryRabbitLeftLeftLeftEaten = hungryRabbitLeftLeftLeft\n        val\
    \ hungryRabbitLeftLeftLeftLeft = hungryRabbitLeftLeftLeftLeft\n        val hungryRabbitLeftLeftLeftEatenNeed\
    \ = hungryRabbitLeftLeftLeftNeed\n        val hungryRabbitLeftLeftLeftLeftNeed\
    \ = hungryRabbitLeftLeftLeftNeed\n        val hungryRabbitLeftLeftLeftLeftRemaining\
    \ = hungr\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4hfz6phs.scala:50:43 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitLeftLeftLeftLeft\e\
    [0m = hungryRabbitLeftLeftLeftLeft\n\e[31m\e[31m   |\e[0m                    \
    \                       ^\e[0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e\
    [0m \e[35mhungryRabbitLeftLeftLeftLeft\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4hfz6phs.scala:53:52 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitLeftLeftLeftLeftRemaining\e\
    [0m = hungr\n\e[31m\e[31m   |\e[0m                                           \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \            Not found: hungr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4hfz6phs.scala:54:5 ---------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsLeft = carrots - remaining\n        val needsLeft  = needs -\
    \ remaining\n        val carrotEaten = carrots - carrotsLeft\n        val needEaten\
    \  = needs - needsLeft\n        val carrotEatenList = List(carrotEaten)\n    \
    \    val needEatenList = List(needEaten)\n        val carrotEatenList2 = List(carrotEaten)\n\
    \        val needEatenList2 = List(needEaten)\n        val carrotEatenList3 =\
    \ List(carrotEaten)\n        val needEatenList3 = List(needEaten)\n        val\
    \ carrotEatenList4 = List(carrotEaten)\n        val needEatenList4 = List(needEaten)\n\
    \        val carrotEatenList5 = List(carrotEaten)\n        val needEatenList5\
    \ = List(needEaten)\n        val carrotEatenList6 = List(carrotEaten)\n      \
    \  val needEatenList6 = List(needEaten)\n        val carrotEatenList7 = List(carrotEaten)\n\
    \        val needEatenList7 = List(needEaten)\n        val carrotEatenList8 =\
    \ List(carrotEaten)\n        val needEatenList8 = List(needEaten)\n        val\
    \ carrotEatenList9 = List(carrotEaten)\n        val needEatenList9 = List(needEaten)\n\
    \        val carrotEatenList10 = List(carrotEaten)\n        val needEatenList10\
    \ = List(needEaten)\n        val carrotEatenList11 = List(carrotEaten)\n     \
    \   val needEatenList11 = List(needEaten)\n        val carrotEatenList12 = List(carrotEaten)\n\
    \        val needEatenList12 = List(needEaten)\n        val carrotEatenList13\
    \ = List(carrotEaten)\n        val needEatenList13 = List(needEaten)\n       \
    \ val carrotEatenList14\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsz_ehbih.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsz_ehbih.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsz_ehbih.scala:65:5 ---------------------\e[0m\e[0m\n\e[31m65\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ / needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n   \
    \     val needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val\
    \ carrots_left_to_eat_4 = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4\
    \ = (needs_left / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left\
    \ / needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n   \
    \     val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val\
    \ carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7\
    \ = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n   \
    \     val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val\
    \ carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10\
    \ = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphwmzperf.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphwmzperf.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphwmzperf.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphwmzperf.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left\
    \ % needs_left).toInt\n        val needs_to_eat = (needs_left % carrots_left).toInt\n\
    \        val carrots_to_eat_left = carrots_to_eat * needs_to_eat\n        val\
    \ needs_to_eat_left = needs_to_eat * carrots_to_eat\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat\
    \ = (needs_to_eat_left / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat * needs_to_eat_left\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left\n \
    \       val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat\
    \ * carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat\
    \ / carrots_to_eat_left_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0wrei1y4.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0wrei1y4.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0wrei1y4.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0wrei1y4.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val totalCarrots = carrots\
    \ + leftCarrots\n        val leftCarrotsList = List(leftCarrots.toLong)\n    \
    \    val totalCarrotsList = List(totalCarrots.toLong)\n        val totalCarrotsListWithLeftCarrots\
    \ = totalCarrotsList ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsList\
    \ = totalCarrotsListWithLeftCarrots :: Nil\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrots\
    \ = totalCarrotsListWithLeftCarrotsList ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsList\
    \ = totalCarrotsListWithLeftCarrotsListWithLeftCarrots :: Nil\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots\
    \ = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsList ++ leftCarrotsList\n\
    \        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList\
    \ = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots :: Nil\n\
    \        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots\
    \ = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList\
    \ ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList\
    \ = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots\
    \ :: Nil\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrots\
    \ = totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList\
    \ ++ leftCarrotsList\n        val totalCarrotsListWithLeftCarrotsListWithLeftCarrotsListWithLeftCarrotsList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi9eotre2.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpi9eotre2.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list2\
    \ = List(carrots_left.toLong)\n        val needs_left_list2 = List(needs_left.toLong)\n\
    \        val carrots_left_list3 = List(carrots_left.toLong)\n        val needs_left_list3\
    \ = List(needs_left.toLong)\n        val carrots_left_list4 = List(carrots_left.toLong)\n\
    \        val needs_left_list4 = List(needs_left.toLong)\n        val carrots_left_list5\
    \ = List(carrots_left.toLong)\n        val needs_left_list5 = List(needs_left.toLong)\n\
    \        val carrots_left_list6 = List(carrots_left.toLong)\n        val needs_left_list6\
    \ = List(needs_left.toLong)\n        val carrots_left_list7 = List(carrots_left.toLong)\n\
    \        val needs_left_list7 = List(needs_left.toLong)\n        val carrots_left_list8\
    \ = List(carrots_left.toLong)\n        val needs_left_list8 = List(needs_left.toLong)\n\
    \        val carrots_left_list9 = List(carrots_left.toLong)\n        val needs_left_list9\
    \ = List(needs_left.toLong)\n        val carrots_left_list10 = List(carrots_left.toLong)\n\
    \        val needs_left_list10 = List(needs_left.toLong)\n        val carrots_left_list11\
    \ = List(carrots_left.toLong)\n        val needs_left_list11 = List(needs_left.toLong)\n\
    \        val carrots_left_list12 = List(carrots_left.toLong)\n        val needs_left_list12\
    \ = List(needs_left.toLong)\n        val carrots_left_list13 = List(carrots_left.toLong)\n\
    \        val needs_left_list13 = List(needs_left.toLong)\n        val carrots_left_list14\
    \ = List(carrots_left.toLong)\n        val needs_left_list14 = List(needs_left.toLong)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9u1c4t33.scala:64:11 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9u1c4t33.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9u1c4t33.scala:65:5\
    \ ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val carrotsLeftToEat =\
    \ carrotsLeft - carrots.toLong\n        val carrotsToEat = carrotsLeft + carrots.toLong\n\
    \        val carrotsToEatList = List(carrotsToEat.toLong)\n        val carrotsToEatList2\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList3 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList4 = List(carrotsToEat.toLong)\n        val carrotsToEatList5\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList6 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList7 = List(carrotsToEat.toLong)\n        val carrotsToEatList8\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList9 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList10 = List(carrotsToEat.toLong)\n        val carrotsToEatList11\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList12 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList13 = List(carrotsToEat.toLong)\n        val carrotsToEatList14\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList15 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList16 = List(carrotsToEat.toLong)\n        val carrotsToEatList17\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList18 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList19 = List(carrotsToEat.toLong)\n        val carrotsToEatList20\
    \ = List(carrotsToEat.toLong)\n        val carrots\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8f0kpfxf.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp8f0kpfxf.scala:56:5 ---------------------\e[0m\e[0m\n\e[31m56 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_left_to_eat\
    \ = (carrots_left * need).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ * need).toInt\n        val carrots_to_eat_left = carrots_to_eat - carrots_left\n\
    \        val carrots_to_eat_left_to_eat = (carrots_to_eat_left * need).toInt\n\
    \        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - carrots_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left\
    \ * need).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat\
    \ - carrots_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left * need).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left\n      \
    \  val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ * need).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left * need).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_e\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppjuzungr.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppjuzungr.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppjuzungr.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val needs_left_after_meals = needs_left\
    \ % carrots_left\n        val meals_after_meals = carrots_left_after_meals / needs_left_after_meals\n\
    \        val carrots_left_after_meals_after_meals = carrots_left_after_meals %\
    \ needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals\
    \ % carrots_left_after_meals\n        val meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ / needs_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals % needs_left_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals\
    \ % carrots_left_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals\
    \ % needs_left_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals\
    \ = needs_left_after_meals_after_meals_after_meals % carrots_left_after_meals_after_meals_after_meals\n\
    \        val meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ / needs_left_after_meals_after_meals_after_meals_after_me\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdmzyd31e.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdmzyd31e.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010317
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals.toLong, carrots.toLong)\n\
    \        if (remaining > 0) result ::: eat(number, need, remaining - meals)\n\
    \        else result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpipn0uq4z.scala:38)\n\tat Problem.main(tmpipn0uq4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010331
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val remaining = remaining - need\n\
    \        val hungry = remaining > 0\n        val eaten = needs - remaining\n \
    \       val hungryEaten = eaten > 0\n        if (hungry) {\n            val hungryEaten\
    \ = eaten - need\n            val hungryEatenList = List(hungryEaten.toLong)\n\
    \            val hungryEatenList2 = List(hungryEaten.toLong)\n            val\
    \ hungryEatenList3 = List(hungryEaten.toLong)\n            val hungryEatenList4\
    \ = List(hungryEaten.toLong)\n            val hungryEatenList5 = List(hungryEaten.toLong)\n\
    \            val hungryEatenList6 = List(hungryEaten.toLong)\n            val\
    \ hungryEatenList7 = List(hungryEaten.toLong)\n            val hungryEatenList8\
    \ = List(hungryEaten.toLong)\n            val hungryEatenList9 = List(hungryEaten.toLong)\n\
    \            val hungryEatenList10 = List(hungryEaten.toLong)\n            val\
    \ hungryEatenList11 = List(hungryEaten.toLong)\n            val hungryEatenList12\
    \ = List(hungryEaten.toLong)\n            val hungryEatenList13 = List(hungryEaten.toLong)\n\
    \            val hungryEatenList14 = List(hungryEaten.toLong)\n            val\
    \ hungryEatenList15 = List(hungryEaten.toLong)\n            val hungryEatenList16\
    \ = List(hungryEaten.toLong)\n            val hungryEatenList17 = List(hungryEaten.toLong)\n\
    \            val hungryEatenList18 = List(hungryEaten\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcozrlz47.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcozrlz47.scala:70:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcozrlz47.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining - need\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpcozrlz47.scala:33:24 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcozrlz47.scala:69:1 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpcozrlz47.scala:60:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m60 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1660010333
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjd074aux.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val carrots_after_meals = carrots_left_after_meals\
    \ / needs_left\n        val carrots_after_meals_remaining = carrots_left_after_meals\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining = carrots_after_meals_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining / needs_left\n        val\
    \ carrots_after_meals_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining / needs_left\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining % needs_left\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvpwetrk3.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpvpwetrk3.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpvpwetrk3.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e["
  stdout: ''
  timestamp: 1660010288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining\n        val carrots_needed = carrots - carrots_left\n        val\
    \ carrots_needed_to_eat = carrots_needed - carrots_left\n        val carrots_left_to_eat\
    \ = (carrots_needed - carrots_needed).toInt\n        val carrots_left_to_eat_needed\
    \ = carrots_left_to_eat - carrots_needed\n        val carrots_left_to_eat_needed_to_eat\
    \ = carrots_left_to_eat_needed - carrots_needed\n        val carrots_left_to_eat_needed_to_eat\
    \ = (carrots_left_to_eat_needed - carrots_needed).toInt\n        val carrots_left_to_eat_needed_to_eat_needed\
    \ = carrots_left_to_eat_needed_to_eat - carrots_needed\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat\
    \ = carrots_left_to_eat_needed_to_eat_needed - carrots_needed\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat\
    \ = (carrots_left_to_eat_needed_to_eat_needed - carrots_needed).toInt\n      \
    \  val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat = carrots_left_to_eat_needed_to_eat_needed_to_eat\
    \ - carrots_needed\n        val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\
    \ = (carrots_left_to_eat_needed_to_eat_needed_to_eat_needed - carrots_needed).toInt\n\
    \        val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\
    \ = carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat - carrots_needed\n\
    \        val carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\
    \ = carrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8z2pdavq.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_needed_to_eat\e\
    [0m = (carrots_left_to_eat_needed - carrots_needed).toInt\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_needed_to_eat is already defined as \e\
    [33mvalue\e[0m \e[35mcarrots_left_to_eat_needed_to_eat\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8z2pdavq.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat_needed_to_eat_needed_to_eat\e[0m = (carrots_left_to_eat_needed_to_eat_needed\
    \ - carrots_needed).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_needed_to_eat_needed_to_eat is already\
    \ defined as \e[33mvalue\e[0m \e[35mcarrots_left_to_eat_needed_to_eat_needed_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8z2pdavq.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\e\
    [0m = (carrots_left_to_eat_needed_to_eat_needed_to_eat_needed - carrots_needed).toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrots_left_to_eat_needed_to_eat_needed_to_eat_needed_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m"
  stdout: ''
  timestamp: 1660010331
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        val carrots_left = remaining\n\
    \        val carrots_eaten = carrots - carrots_left\n        val carrots_left\
    \ = carrots - carrots_eaten\n        result(0) = carrots_eaten\n        result(1)\
    \ = carrots_left\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjur9zt2y.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots\
    \ - carrots_eaten\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpjur9zt2y.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjur9zt2y.scala:40:8 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010331
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val leftCarrots = carrots - meals\n\
    \        val leftNeeds = needs - meals\n        val leftRemaining = remaining\
    \ - meals\n        val leftMeals = meals - leftRemaining\n        val leftNeedsLeft\
    \ = leftNeeds - leftMeals\n        val leftRemainingLeft = leftRemaining - leftMeals\n\
    \        val leftMealsLeft = leftMeals - leftRemainingLeft\n        val leftNeedsLeftLeft\
    \ = leftNeedsLeft - leftMealsLeft\n        val leftRemainingLeftLeft = leftRemainingLeft\
    \ - leftMealsLeft\n        val leftMealsLeftLeft = leftMeals - leftRemainingLeftLeft\n\
    \        val leftNeedsLeftLeftLeft = leftNeedsLeftLeft - leftMealsLeftLeft\n \
    \       val leftRemainingLeftLeftLeft = leftRemainingLeftLeft - leftMealsLeftLeft\n\
    \        val leftMealsLeftLeftLeft = leftMealsLeftLeft - leftRemainingLeftLeftLeft\n\
    \        val leftNeedsLeftLeftLeftLeft = leftNeedsLeftLeftLeft - leftMealsLeftLeftLeft\n\
    \        val leftRemainingLeftLeftLeftLeft = leftRemainingLeftLeftLeft - leftMealsLeftLeftLeft\n\
    \        val leftMealsLeftLeftLeftLeft = leftMealsLeftLeftLeft - leftRemainingLeftLeftLeftLeft\n\
    \        val leftNeedsLeftLeftLeftLeftLeft = leftNeedsLeftLeftLeftLeft - leftMealsLeftLeftLeftLeft\n\
    \        val leftRemainingLeftLeftLeftLeftLeft = leftRemainingLeftLeftLeftLeft\
    \ - leftMealsLeftLeftLeftLeftLeft\n        val leftMealsLeftLeftLeftLeftLeft =\
    \ leftMealsLeftLeftLeftLeft - leftRemainingLeftLeftLeftLeftLeft\n        val leftNeedsLeftLeftLeftLeftLeftLeft\
    \ = leftNeedsLeftLeftLeftLeftLeft - leftMealsLeftLeftLeftLeftLeft\n        val\
    \ leftRemainingLeftLeftLeftLeftLeftLeft = leftRemainingLeftLeftLeftLeftLeft -\
    \ leftMealsLeftLeftLeftLeftLeft\n        val leftMealsLeftLeftLeftLeftLeftLeft\
    \ = leftMealsLeftLeftLeftLeftLeft - leftRemainingLeftLeftLeftLeftLeftLeft\n  \
    \      val leftNeedsLeftLeftLeftLeftLeftLeftLeft = leftNeedsLeftLeftLeftLeftLeftLeft\
    \ - leftMealsLeftLeftLeftLeftLeftLeft\n        val leftRemainingLeftLeftLeftLeftLeftLeftLeft\
    \ = leftRemainingLeftLeftLeft\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpksowja1s.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpksowja1s.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010333
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots,\
    \ leftCarrots)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbdmgvelh.scala:37)\n\tat Problem.main(tmpbdmgvelh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010336
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        var carrots_eaten = 0\n        var carrots_left = 0\n   \
    \     var carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten\
    \ = 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var\
    \ carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left =\
    \ 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var\
    \ carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten =\
    \ 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var\
    \ carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left =\
    \ 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var\
    \ carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten =\
    \ 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var\
    \ carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left =\
    \ 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var\
    \ carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten =\
    \ 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var\
    \ carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left =\
    \ 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var\
    \ carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten =\
    \ 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var\
    \ carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left =\
    \ 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var\
    \ carrots_eaten = 0\n        var carrots_left = 0\n        var carrots_eaten =\
    \ 0\n        var carrots_left = 0\n        var carrots_eaten = 0\n        var\
    \ carrots_left = 0\n        var carrots_eaten = 0\n        var carrots_left =\
    \ 0\n        var carrots_eaten = 0\n        var carrots_left = 0\n        var\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpa2dedca_.scala:98:11 ---------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpa2dedca_.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m \e[36mcarrots_left\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left\
    \ is already defined as \e[33mvariable\e[0m \e[35mcarrots_left\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa2dedca_.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mcarrots_eaten\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_eaten is already defined as \e[33mvariable\e[0m \e\
    [35mcarrots_eaten\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpa2dedca_.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mvar\e[0m \e[36mcarrots_left\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left\
    \ is already defined as \e[33mvariable\e[0m \e[35mcarrots_left\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa2dedca_.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mcarrots_eaten\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_eaten is already defined as \e[33mvariable\e[0m \e\
    [35mcarrots_eaten\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp"
  stdout: ''
  timestamp: 1660010335
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left = (remaining - need).toLong\n        val meals = hungry + left\n\
    \        val hungryList = List(hungry.toLong)\n        val leftList = List(left.toLong)\n\
    \        if (meals < 0) {\n            hungryList :+ meals.toLong\n        } else\
    \ {\n            leftList :+ meals.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkef7b3iw.scala:43)\n\tat Problem.main(tmpkef7b3iw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = remaining - carrots\n        val carrots_left_to_eat\
    \ = (carrots_left / needs).toInt\n        val carrots_left_to_eat_with_extra =\
    \ carrots_left % needs\n        val carrots_to_eat = carrots_left_to_eat + carrots_left_to_eat_with_extra\n\
    \        val carrots_to_eat_with_extra = carrots_to_eat.toLong\n        val carrots_to_eat_with_extra_with_extra\
    \ = carrots_to_eat_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra.toLong\n        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra_with_extra.toLong\n      \
    \  val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\
    \        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\
    \        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\
    \        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\
    \        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\
    \        val carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\
    \        val carrots_to_eat_with_extra_with_extra_with_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf6eoy9d7.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf6eoy9d7.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\e\
    [0m = carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpf6eoy9d7.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf6eoy9d7.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010334
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining > carrots)\
    \ {\n            val carrots = carrots - remaining\n            val needs = needs\
    \ - remaining\n            val remaining = remaining - carrots\n            result\
    \ += carrots\n            result += needs\n        }\n        if (remaining >\
    \ needs) {\n            val carrots = carrots - needs\n            val needs =\
    \ needs - carrots\n            val remaining = remaining - needs\n           \
    \ result += carrots\n            result += needs\n        }\n        if (remaining\
    \ > 0) {\n            val carrots = carrots - remaining\n            val needs\
    \ = needs - carrots\n            val remaining = remaining - carrots\n       \
    \     result += carrots\n            result += needs\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpopgpu_ha.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpopgpu_ha.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpopgpu_ha.scala:36:26 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = carrots - remaining\n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpopgpu_ha.scala:37:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mneeds\e[0m = needs - remaining\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mneeds\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpopgpu_ha.scala:38:28 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining - carrots\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: "
  stdout: ''
  timestamp: 1660010328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsNeeded = carrots - remaining\n        val carrotsNeededToEat\
    \ = carrotsNeeded - needs\n        val carrotsNeededToEatList = List(carrotsNeededToEat.toLong)\n\
    \        val carrotsNeededToEatListArray = carrotsNeededToEatList.toArray\n  \
    \      val carrotsNeededToEatArray = carrotsNeededToEatListArray.toList\n    \
    \    val carrotsNeededToEatArrayArray = carrotsNeededToEatArray.toArray\n    \
    \    val carrotsNeededToEatArrayArrayArray = carrotsNeededToEatArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArray = carrotsNeededToEatArrayArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray =\
    \ carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArray.toArray\n       \
    \ val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray.toArray\n\
    \        val carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArray\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3lngozka.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray\e\
    [0m = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArrayArrayArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp3lngozka.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp3lngozka.scala:37:72 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrotsNeededToEatListArray\e\
    [0m = carrotsNeededToEatList.toArray\n\e[31m\e[31m   |\e[0m                  \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                                          No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                          where:  \
    \  B is a type variable\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3lngozka.scala:44:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsNeededToEatArrayArrayArrayArrayArrayArrayArray\e[0m = carrotsNeededToEatArrayArrayArrayArrayArrayArrayArray.toArray\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mcarrotsNeededToE"
  stdout: ''
  timestamp: 1660010336
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat\
    \ = (needs_left / need).toInt\n        val needs_left_to_eat = (carrots_left /\
    \ carrots).toInt\n        val needs_left_to_eat = if (needs_left_to_eat == 0)\
    \ 0 else needs_left_to_eat\n        val carrots_left_to_eat = if (carrots_left_to_eat\
    \ == 0) 0 else carrots_left_to_eat\n        val carrots_to_eat = if (carrots_left_to_eat\
    \ == 0) 0 else carrots_left_to_eat\n        val needs_to_eat = if (needs_left_to_eat\
    \ == 0) 0 else needs_left_to_eat\n        val carrots_to_eat = if (carrots_to_eat\
    \ == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat ==\
    \ 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0)\
    \ 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0) 0 else\
    \ needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n\
    \        val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n     \
    \   val carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n    \
    \    val needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val\
    \ carrots_to_eat = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val\
    \ needs_to_eat = if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat\
    \ = if (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat =\
    \ if (needs_to_eat == 0) 0 else needs_to_eat\n        val carrots_to_eat = if\
    \ (carrots_to_eat == 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat\
    \ == 0) 0 else needs_to_eat\n        val carrots_to_eat = if (carrots_to_eat ==\
    \ 0) 0 else carrots_to_eat\n        val needs_to_eat = if (needs_to_eat == 0)\
    \ 0 else needs_to_eat\n        val carrots_to_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_xco7z8_.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_xco7z8_.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneeds_left_to_eat\e[0m = \e[33mif\e[0m (needs_left_to_eat == \e[31m0\e\
    [0m) \e[31m0\e[0m \e[33melse\e[0m needs_left_to_eat\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_to_eat is already defined as \e[33mvalue\e[0m \e\
    [35mneeds_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_xco7z8_.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat\e[0m\
    \ = \e[33mif\e[0m (carrots_left_to_eat == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e\
    [0m carrots_left_to_eat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat is already defined as \e[33mvalue\e[0m\
    \ \e[35mcarrots_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_xco7z8_.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mcarrots_to_eat\e[0m = \e\
    [33mif\e[0m (carrots_to_eat == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m carrots_to_eat\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_to_eat is already defined as \e[33mvalue\e[0m \e[35mcarrots_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_xco7z8_.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat\e["
  stdout: ''
  timestamp: 1660010336
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n\
    \        val needs_left = needs - remaining\n        val carrots_left_to_eat =\
    \ (carrots_left / needs_left).toInt\n        val needs_left_to_eat = (needs_left\
    \ / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left / needs_left_2).toInt\n\
    \        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n     \
    \   val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n        val\
    \ needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val carrots_left_to_eat_4\
    \ = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4 = (needs_left\
    \ / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left /\
    \ needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n   \
    \     val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val\
    \ carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7\
    \ = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n   \
    \     val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val\
    \ carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10\
    \ = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11 =\
    \ (carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1hgddzsc.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1hgddzsc.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1hgddzsc.scala:57:38 ------------------------\e[0m\e[0m\n\e[31m57 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_11\e[0m = (carrot\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Not found: carrot\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1hgddzsc.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val remaining = remaining - carrots\n        val needs = needs - carrots\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.toInt\n        val\
    \ needs = needs.toInt\n        val needs = needs.toInt\n        val needs = needs.toInt\n\
    \        val needs = needs.toInt\n        val needs = needs.to\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpalbi1_9b.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mneeds\e[0m = needs - carrots\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneeds is\
    \ already defined as \e[33mvalue\e[0m \e[35mneeds\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneeds\e[0m = needs.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds is already defined as \e[33mvalue\e[0m \e[35mneeds\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpalbi1_9b.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mneeds\e[0m = needs.toInt\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneeds is already\
    \ defined as \e[33mvalue\e[0m \e[35mneeds\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpalbi1_9b.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneeds\e[0m = needs.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds is already defined as \e[33mvalue\e[0m \e[35mneeds\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of topl"
  stdout: ''
  timestamp: 1660010339
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) :: List(needs_left) :: List(needs_left)\
    \ :: List(needs_left) :: List(needs_left) \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyigbboj4.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyigbboj4.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010339
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat\
    \ = (needs_left / need).toInt\n        val needs_left_to_eat = (carrots_left /\
    \ carrots).toInt\n        val carrots_left_to_eat_2 = (carrots_left_to_eat * carrots).toInt\n\
    \        val needs_left_to_eat_2 = (needs_left_to_eat * need).toInt\n        val\
    \ carrots_left_to_eat_3 = (carrots_left_to_eat_2 * carrots).toInt\n        val\
    \ needs_left_to_eat_3 = (needs_left_to_eat_2 * need).toInt\n        val carrots_left_to_eat_4\
    \ = (carrots_left_to_eat_3 * carrots).toInt\n        val needs_left_to_eat_4 =\
    \ (needs_left_to_eat_3 * need).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4\
    \ * carrots).toInt\n        val needs_left_to_eat_5 = (needs_left_to_eat_4 * need).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left_to_eat_5 * carrots).toInt\n\
    \        val needs_left_to_eat_6 = (needs_left_to_eat_5 * need).toInt\n      \
    \  val carrots_left_to_eat_7 = (carrots_left_to_eat_6 * carrots).toInt\n     \
    \   val needs_left_to_eat_7 = (needs_left_to_eat_6 * need).toInt\n        val\
    \ carrots_left_to_eat_8 = (carrots_left_to_eat_7 * carrots).toInt\n        val\
    \ needs_left_to_eat_8 = (needs_left_to_eat_7 * need).toInt\n        val carrots_left_to_eat_9\
    \ = (carrots_left_to_eat_8 * carrots).toInt\n        val needs_left_to_eat_9 =\
    \ (needs_left_to_eat_8 * need).toInt\n        val carrots_left_to_eat_10 = (carrots_left_to_eat_9\
    \ * carrots).toInt\n        val needs_left_to_eat_10 = (needs_left_to_eat_9 *\
    \ need).toInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8vt3xjr0.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8vt3xjr0.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8vt3xjr0.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = carrots_left\
    \ % needs_left\n        val needs_left_to_eat_2 = needs_left % carrots_left\n\
    \        val carrots_left_to_eat_3 = carrots_left % needs_left_2\n        val\
    \ needs_left_to_eat_3 = needs_left % carrots_left_2\n        val carrots_left_to_eat_4\
    \ = carrots_left % needs_left_3\n        val needs_left_to_eat_4 = needs_left\
    \ % carrots_left_3\n        val carrots_left_to_eat_5 = carrots_left % needs_left_4\n\
    \        val needs_left_to_eat_5 = needs_left % carrots_left_4\n        val carrots_left_to_eat_6\
    \ = carrots_left % needs_left_5\n        val needs_left_to_eat_6 = needs_left\
    \ % carrots_left_5\n        val carrots_left_to_eat_7 = carrots_left % needs_left_6\n\
    \        val needs_left_to_eat_7 = needs_left % carrots_left_6\n        val carrots_left_to_eat_8\
    \ = carrots_left % needs_left_7\n        val needs_left_to_eat_8 = needs_left\
    \ % carrots_left_7\n        val carrots_left_to_eat_9 = carrots_left % needs_left_8\n\
    \        val needs_left_to_eat_9 = needs_left % carrots_left_8\n        val carrots_left_to_eat_10\
    \ = carrots_left % needs_left_9\n        val needs_left_to_eat_10 = needs_left\
    \ % carrots_left_9\n        val carrots_left_to_eat_11 = carrots_left % needs_left_10\n\
    \        val needs_left_to_eat_11 = needs_left % carrots_left_10\n        val\
    \ carrots_left_to_eat_12 = carrots_left % needs_left_11\n        val needs_left_to_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpibyc9950.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpibyc9950.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpibyc9950.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpibyc9950.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = remaining - carrots\n        val carrots_left_to_eat\
    \ = (carrots_left - needs).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ + needs).toInt\n        val carrots_to_eat_list = List(carrots_to_eat.toLong)\n\
    \        val carrots_to_eat_list_2 = List(carrots_to_eat.toLong)\n        val\
    \ carrots_to_eat_list_3 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_4\
    \ = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_5 = List(carrots_to_eat.toLong)\n\
    \        val carrots_to_eat_list_6 = List(carrots_to_eat.toLong)\n        val\
    \ carrots_to_eat_list_7 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_8\
    \ = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_9 = List(carrots_to_eat.toLong)\n\
    \        val carrots_to_eat_list_10 = List(carrots_to_eat.toLong)\n        val\
    \ carrots_to_eat_list_11 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_12\
    \ = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_13 = List(carrots_to_eat.toLong)\n\
    \        val carrots_to_eat_list_14 = List(carrots_to_eat.toLong)\n        val\
    \ carrots_to_eat_list_15 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_16\
    \ = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_17 = List(carrots_to_eat.toLong)\n\
    \        val carrots_to_eat_list_18 = List(carrots_to_eat.toLong)\n        val\
    \ carrots_to_eat_list_19 = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_20\
    \ = List(carrots_to_eat.toLong)\n        val carrots_to_eat_list_21 = List(carrots_to_eat.toLong)\n\
    \        val carrots_to_eat_list_22 = List(carrots_to_eat.toLong)\n        val\
    \ carrots_to_eat_list_23\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjpp8ued6.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjpp8ued6.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjpp8ued6.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val left = (meals + needs).toInt\n        val result = (List(meals, left))\n\
    \        if (hungry > 0) {\n            val hungryResult = eat(hungry, need, remaining)\n\
    \            val hungryResult2 = eat(hungry, need, remaining)\n            val\
    \ hungryResult3 = eat(hungry, need, remaining)\n            val hungryResult4\
    \ = eat(hungry, need, remaining)\n            val hungryResult5 = eat(hungry,\
    \ need, remaining)\n            val hungryResult6 = eat(hungry, need, remaining)\n\
    \            val hungryResult7 = eat(hungry, need, remaining)\n            val\
    \ hungryResult8 = eat(hungry, need, remaining)\n            val hungryResult9\
    \ = eat(hungry, need, remaining)\n            val hungryResult10 = eat(hungry,\
    \ need, remaining)\n            val hungryResult11 = eat(hungry, need, remaining)\n\
    \            val hungryResult12 = eat(hungry, need, remaining)\n            val\
    \ hungryResult13 = eat(hungry, need, remaining)\n            val hungryResult14\
    \ = eat(hungry, need, remaining)\n            val hungryResult15 = eat(hungry,\
    \ need, remaining)\n            val hungryResult16 = eat(hungry, need, remaining)\n\
    \            val hungryResult17 = eat(hungry, need, remaining)\n            val\
    \ hungryResult18 = eat(hungry, need, remaining)\n            val hungryResult19\
    \ = eat(hungry, need, remaining)\n            val hungryResult20 = eat(hungry,\
    \ need, remaining)\n            val hungryResult21 = eat(hungry, need, remaining)\n\
    \            val hungryResult22 = eat(hungry, need, remaining)\n            val\
    \ hungryResult23 = eat(hungry, need, remaining)\n            val hungryResult24\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8dqwm_3n.scala:62:32 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m            \e[33mval\e[0m \e[36mhungryResult24\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dqwm_3n.scala:74:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp8dqwm_3n.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8dqwm_3n.scala:73:1 ---------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp8dqwm_3n.scala:64:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m64 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010347
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining <= 0)\
    \ {\n            result.add(carrots)\n            result.add(carrots)\n      \
    \  } else {\n            val carrots_left = carrots - remaining\n            if\
    \ (carrots_left <= needs) {\n                result.add(carrots)\n           \
    \     result.add(carrots_left)\n            } else {\n                result.add(carrots)\n\
    \                result.add(needs)\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7vl7v7mu.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7vl7v7mu.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = List(carrots,\
    \ remaining)\n        meals\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3hw8_s0d.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010339
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjd074aux.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val rest = remaining - need\n        val hungryCarrots = hungry.toLong\n\
    \        val restCarrots = rest.toLong\n        val hungryCarrotsList = List(hungryCarrots)\n\
    \        val restCarrotsList = List(restCarrots)\n        val hungryCarrotsList2\
    \ = hungryCarrotsList.zipWithIndex.filter(_._2 % 2 == 0).map(_._1)\n        val\
    \ restCarrotsList2 = restCarrotsList.zipWithIndex.filter(_._2 % 2 == 0).map(_._1)\n\
    \        val hungryCarrotsList3 = hungryCarrotsList2.zipWithIndex.filter(_._2\
    \ % 2 == 1).map(_._1)\n        val restCarrotsList3 = restCarrotsList2.zipWithIndex.filter(_._2\
    \ % 2 == 1).map(_._1)\n        val hungryCarrotsList4 = hungryCarrotsList3.zipWithIndex.filter(_._2\
    \ % 2 == 2).map(_._1)\n        val restCarrotsList4 = restCarrotsList3.zipWithIndex.filter(_._2\
    \ % 2 == 2).map(_._1)\n        val hungryCarrotsList5 = hungryCarrotsList4.zipWithIndex.filter(_._2\
    \ % 2 == 3).map(_._1)\n        val restCarrotsList5 = restCarrotsList4.zipWithIndex.filter(_._2\
    \ % 2 == 3).map(_._1)\n        val hungryCarrotsList6 = hungryCarrotsList5.zipWithIndex.filter(_._2\
    \ % 2 == 4).map(_._1)\n        val restCarrotsList6 = restCarrotsList5.zipWithIndex.filter(_._2\
    \ % 2 == 4).map(_._1)\n        val hungryCarrotsList7 = hungryCarrotsList6.zipWithIndex.filter(_._2\
    \ % 2 == 5).map(_._1)\n        val restCarrotsList7 = restCarrotsList6.zipWithIndex.filter(_._2\
    \ % 2 == 5).map(_._1)\n        val hungryCarrotsList8 = hungryCarrotsList7.zipWithIndex.filter(_._2\
    \ % 2 == 6).map(_._1)\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi2ic4eyl.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010347
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val needs_left_after_meals = needs_left\
    \ % needs_left\n        val meals_after_meals = carrots_left_after_meals / needs_left_after_meals\n\
    \        val carrots_left_after_meals_after_meals = carrots_left_after_meals %\
    \ needs_left_after_meals\n        val needs_left_after_meals_after_meals = needs_left_after_meals\
    \ % needs_left_after_meals\n        val meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ / needs_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals % needs_left_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals\
    \ % needs_left_after_meals_after_meals\n        val meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals / needs_left_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals\
    \ % needs_left_after_meals_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals_after_meals\
    \ = needs_left_after_meals_after_meals_after_meals % needs_left_after_meals_after_meals_after_meals\n\
    \        val meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ / needs_left_after_meals_after_meals_after_meals_after_meals\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmph8ow6s0h.scala:49:11 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmph8ow6s0h.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph8ow6s0h.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010349
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left - carrots_left).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ + needs_left_to_eat).toInt\n        val needs_to_eat = (needs_left_to_eat +\
    \ carrots_left_to_eat).toInt\n        val carrots_to_eat_left = carrots_to_eat\
    \ - needs_to_eat\n        val needs_to_eat_left = needs_to_eat - carrots_to_eat\n\
    \        val carrots_to_eat_left_to_eat = (carrots_to_eat_left - needs_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat = (needs_to_eat_left - carrots_to_eat_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - needs_to_eat_left_to_eat\n\
    \        val needs_to_eat_left_to_eat_left = needs_to_eat_left_to_eat - carrots_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left\
    \ - needs_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat\
    \ = (needs_to_eat_left_to_eat_left - carrots_to_eat_left_to_eat_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat\
    \ - needs_to_eat_left_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat\
    \ - needs_to_eat_left_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoujn5l4f.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoujn5l4f.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpoujn5l4f.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoujn5l4f.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010348
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val mealsLeft = carrots - remaining\n        val mealsLeftList = List(mealsLeft.toLong)\n\
    \        val carrotsLeft = carrots - meals\n        val carrotsLeftList = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList2 = List(carrotsLeft.toLong)\n        val carrotsLeftList3\
    \ = List(carrotsLeft.toLong)\n        val carrotsLeftList4 = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList5 = List(carrotsLeft.toLong)\n        val carrotsLeftList6\
    \ = List(carrotsLeft.toLong)\n        val carrotsLeftList7 = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList8 = List(carrotsLeft.toLong)\n        val carrotsLeftList9\
    \ = List(carrotsLeft.toLong)\n        val carrotsLeftList10 = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList11 = List(carrotsLeft.toLong)\n        val carrotsLeftList12\
    \ = List(carrotsLeft.toLong)\n        val carrotsLeftList13 = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList14 = List(carrotsLeft.toLong)\n        val carrotsLeftList15\
    \ = List(carrotsLeft.toLong)\n        val carrotsLeftList16 = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList17 = List(carrotsLeft.toLong)\n        val carrotsLeftList18\
    \ = List(carrotsLeft.toLong)\n        val carrotsLeftList19 = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList20 = List(carrotsLeft.toLong)\n        val carrotsLeftList21\
    \ = List(carrotsLeft.toLong)\n        val carrotsLeftList22 = List(carrotsLeft.toLong)\n\
    \        val carrotsLeftList23 = List(carrotsLeft.toLong)\n        \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqgnxqulv.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqgnxqulv.scala:61:5\
    \ ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010350
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val hungry = remaining - carrots\n        val hungryCarrots = if (hungry\
    \ <= 0) 0 else hungry\n        val hungryCarrotsList = List(hungryCarrots.toLong)\n\
    \        val hungryCarrotsList2 = List(hungryCarrots.toLong)\n        val hungryCarrotsList3\
    \ = List(hungryCarrots.toLong)\n        val hungryCarrotsList4 = List(hungryCarrots.toLong)\n\
    \        val hungryCarrotsList5 = List(hungryCarrots.toLong)\n        val hungryCarrotsList6\
    \ = List(hungryCarrots.toLong)\n        val hungryCarrotsList7 = List(hungryCarrots.toLong)\n\
    \        val hungryCarrotsList8 = List(hungryCarrots.toLong)\n        val hungryCarrotsList9\
    \ = List(hungryCarrots.toLong)\n        val hungryCarrotsList10 = List(hungryCarrots.toLong)\n\
    \        val hungryCarrotsList11 = List(hungryCarrots.toLong)\n        val hungryCarrotsList12\
    \ = List(hungryCarrots.toLong)\n        val hungryCarrotsList13 = List(hungryCarrots.toLong)\n\
    \        val hungryCarrotsList14 = List(hungryCarrots.toLong)\n        val hungryCarrotsList15\
    \ = List(hungryCarrots.toLong)\n        val hungryCarrotsList16 = List(hungryCarrots.toLong)\n\
    \        val hungryCarrotsList17 = List(hungryCarrots.toLong)\n        val hungryCarrotsList18\
    \ = List(hungryCarrots.toLong)\n        val hungryCarrotsList19 = List(hungryCarrots.toLong)\n\
    \        val hungryCarrotsList20 = List(hungryCarrots.toLong)\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp2p3_d631.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2p3_d631.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010350
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val hungry = remaining > 0\n        val meals = if (hungry) List(need)\
    \ else List(remaining)\n        val carrots_left = if (hungry) remaining - need\
    \ else 0\n        val result = if (hungry) List(meals.sum, carrots_left) else\
    \ List(meals.sum)\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7h968doh.scala:39)\n\tat Problem.main(tmp7h968doh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val meals_left = meals -\
    \ remaining\n        val carrots_left_after_meals = carrots_left - meals\n   \
    \     val meals_left_after_meals = meals_left - carrots_left\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left_after_meals - meals_left\n        val meals_left_after_meals_after_meals\
    \ = meals_left_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - meals_left_after_meals\n        val\
    \ meals_left_after_meals_after_meals_after_meals = meals_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - meals_left_after_meals_after_meals_after_meals\n\
    \        val meals_left_after_meals_after_meals_after_meals_after_meals = meals_left_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ - meals_left_after_meals_after_meals_after_meals_after_meals\n        val meals_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = meals_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_me\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpazaxlaur.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpazaxlaur.scala:46:99\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_me\n\e[31m\e[31m   |\e[0m               \
    \                                                                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \               Not found: carrots_left_after_meals_after_me\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpazaxlaur.scala:47:5 ---------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remainingCarrots = remaining\
    \ - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots\
    \ % number > 0\n        val hungryMeals = meals > 0\n        val hungryMealCarrots\
    \ = meals % need > 0\n        val hungryRemainingCarrots = remainingCarrots >\
    \ 0\n        val hungryRemainingCarrotsMeals = remainingCarrots % number > 0\n\
    \        val hungryRemainingMeals = remainingMeals > 0\n        val hungryRemainingMealCarrots\
    \ = remainingMeals % need > 0\n        val hungryRemainingRemainingCarrots = remainingRemainingCarrots\
    \ > 0\n        val hungryRemainingRemainingCarrotsMeals = remainingRemainingCarrots\
    \ % number > 0\n        val hungryRemainingRemainingMeals = remainingRemainingMeals\
    \ > 0\n        val hungryRemainingRemainingMealCarrots = remainingRemainingMeals\
    \ % need > 0\n        val hungryRemainingRemainingRemainingCarrots = remainingRemainingRemainingCarrots\
    \ > 0\n        val hungryRemainingRemainingRemainingCarrotsMeals = remainingRemainingRemainingCarrots\
    \ % number > 0\n        val hungryRemainingRemainingRemainingMeals = remainingRemainingRemainingMeals\
    \ > 0\n        val hungryRemainingRemainingRemainingMealCarrots = remainingRemainingRemainingMeals\
    \ % need > 0\n        val hungryRemainingRemainingRemainingRemainingCarrots =\
    \ remainingRemainingRemainingRemainingCarrots > 0\n        val hungryRemainingRemainingRemainingRemainingCarrotsMeals\
    \ = remainingRemainingRemainingRemainingCarrots % number > 0\n        val hungryRemainingRemainingRemainingMeals\
    \ = remainingRemainingRemainingMeals > 0\n        val hungryRemainingRemainingRemainingMealCarrots\
    \ = remainingRemainingRemainingMeals % need > 0\n        val hungryRemainingRemainingRemainingMeals\
    \ = remainingRemainingRemainingMeals > 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz31rl4fi.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingRemainingRemainingMeals\e\
    [0m = remainingRemainingRemainingMeals > \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingRemainingRemainingMeals is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryRemainingRemainingRemainingMeals\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpz31rl4fi.scala:53:12 ---------------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingRemainingRemainingMealCarrots\e\
    [0m = remainingRemainingRemainingMeals % need > \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingRemainingRemainingMealCarrots is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryRemainingRemainingRemainingMealCarrots\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpz31rl4fi.scala:54:12 ---------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingRemainingRemainingMeals\e\
    [0m = remainingRemainingRemainingMeals > \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingRemainingRemainingMeals is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryRemainingRemainingRemainingMeals\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpz31rl4fi.scala:40:35 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemainingMeals\e[0m = remainingMeals > \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1660010354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_after_meals = carrots_left - needs_left\n\
    \        val needs_left_after_meals = needs_left - carrots_left\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left_after_meals - needs_left_after_meals\n        val needs_left_after_meals_after_meals\
    \ = needs_left_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - needs_left_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsn65h1to.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpsn65h1to.scala:44:87 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - needs_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsn65h1to.scala:45:85\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = needs_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35mneeds_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /t"
  stdout: ''
  timestamp: 1659804749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsLeft = carrots - remaining\n        val mealsLeft = meals - remaining\n\
    \        val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n        if (meals\
    \ > 0) {\n            val mealsLeft = meals - remaining\n            val carrotsLeft\
    \ = carrots - remaining\n            val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd455f19r.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010348
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left * needs_left).toInt\n\
    \        val carrots_to_eat = (carrots_left * needs_left).toInt\n        val carrots_to_eat_left\
    \ = carrots_to_eat - carrots_left_to_eat\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat - carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat_left\
    \ * needs_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat =\
    \ (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left * needs_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left * needs_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjtq9kmtd.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjtq9kmtd.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjtq9kmtd.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val carrots_needed = needs - carrots\n        val\
    \ carrots_left_needed = carrots_left - carrots_needed\n        val carrots_left_needed_to_eat\
    \ = carrots_needed - carrots_left\n        val carrots_left_needed_to_eat2 = carrots_left_needed\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat3 = carrots_left_needed_to_eat2\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat4 = carrots_left_needed_to_eat3\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat5 = carrots_left_needed_to_eat4\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat6 = carrots_left_needed_to_eat5\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat7 = carrots_left_needed_to_eat6\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat8 = carrots_left_needed_to_eat7\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat9 = carrots_left_needed_to_eat8\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat10 = carrots_left_needed_to_eat9\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat11 = carrots_left_needed_to_eat10\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat12 = carrots_left_needed_to_eat11\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat13 = carrots_left_needed_to_eat12\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat14 = carrots_left_needed_to_eat13\
    \ + carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat15 = carrots_left_needed_to_eat14\
    \ + carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp703scmyd.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp703scmyd.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp703scmyd.scala:53:5 ---------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val meals_left = meals -\
    \ remaining\n        val meals_left_carrots = meals_left.toLong\n        val carrots_left_carrots\
    \ = carrots_left.toLong\n        val meals_left_carrots_left = meals_left_carrots\
    \ - carrots_left_carrots\n        val carrots_left_carrots_left = carrots_left_carrots\
    \ - meals_left_carrots_left\n        val meals_left_carrots_left_carrots = meals_left_carrots_left.toLong\n\
    \        val carrots_left_carrots_left_carrots = carrots_left_carrots_left.toLong\n\
    \        val meals_left_carrots_left_carrots_left = meals_left_carrots_left_carrots\
    \ - carrots_left_carrots_left_carrots\n        val carrots_left_carrots_left_carrots_left\
    \ = carrots_left_carrots_left_carrots - meals_left_carrots_left_carrots_left\n\
    \        val meals_left_carrots_left_carrots_left_carrots = meals_left_carrots_left_carrots_left.toLong\n\
    \        val carrots_left_carrots_left_carrots_left_carrots = carrots_left_carrots_left_carrots_left.toLong\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left = meals_left_carrots_left_carrots_left_carrots\
    \ - carrots_left_carrots_left_carrots_left_carrots\n        val carrots_left_carrots_left_carrots_left_carrots_left\
    \ = carrots_left_carrots_left_carrots_left_carrots - meals_left_carrots_left_carrots_left_carrots_left\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left_carrots = meals_left_carrots_left_carrots_left_carrots_left.toLong\n\
    \        val carrots_left_carrots_left_carrots_left_carrots_left_carrots = carrots_left_carrots_left_carrots_left_carrots\
    \ - meals_left_carrots_left_carrots_left_carrots_left_carro\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphkc87ixc.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphkc87ixc.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        if (remaining <= 0) {\n\
    \            List(number.toLong)\n        } else {\n            List(number.toLong,\
    \ remaining.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxw2lq17q.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010351
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - need\n        val remaining = remaining - meals\n\
    \        if (remaining <= 0) {\n            List(meals)\n        } else {\n  \
    \          val meals = carrots - need\n            val remaining = remaining -\
    \ meals\n            val meals = carrots - need\n            val remaining = remaining\
    \ - meals\n            val meals = carrots - need\n            val remaining =\
    \ remaining - meals\n            val meals = carrots - need\n            val remaining\
    \ = remaining - meals\n            val meals = carrots - need\n            val\
    \ remaining = remaining - meals\n            val meals = carrots - need\n    \
    \        val remaining = remaining - meals\n            val meals = carrots -\
    \ need\n            val remaining = remaining - meals\n            val meals =\
    \ carrots - need\n            val remaining = remaining - meals\n            val\
    \ meals = carrots - need\n            val remaining = remaining - meals\n    \
    \        val meals = carrots - need\n            val remaining = remaining - meals\n\
    \            val meals = carrots - need\n            val remaining = remaining\
    \ - meals\n            val meals = carrots - need\n            val remaining =\
    \ remaining - meals\n            val meals = carrots - need\n            val remaining\
    \ = remaining - meals\n            val meals = carrots - need\n            val\
    \ remaining = remaining - meals\n            val meals = carrots - need\n    \
    \        val remaining = remaining - meals\n            val meals = carrots -\
    \ need\n            val remaining = remaining - meals\n            val meals =\
    \ carrots - need\n            val remaining = remaining - meals\n            val\
    \ meals = carrots - need\n            val remaining = remaining - meals\n    \
    \        val meals = carrots - need\n            val remaining = remaining - meals\n\
    \            val meals = carrots - need\n            val remaining = remaining\
    \ - meals\n            val meals = carrots - need\n            val remaining =\
    \ remaining - meals\n            val meals = carrots - need\n            val remaining\
    \ = remaining - meals\n            val meals = carrots - need\n            val\
    \ remaining = remaining - meals\n            val meals = carrots - need\n    \
    \        val remaining = remaining - me\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo2gnn6_m.scala:98:0 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo2gnn6_m.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining - meals\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpo2gnn6_m.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo2gnn6_m.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mmeals\e[0m = carrots\
    \ - need\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmeals is already defined as \e[33mvalue\e[0m \e[35mmeals\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpo2gnn6_m.scala:42:16 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining - meals\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpo2gnn6_m.scala:43:16 ---------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m            \e[33mval\e[0m \e[36mmeals\e[0m = carrots - need\n\e[31m\e\
    [31m"
  stdout: ''
  timestamp: 1660010359
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - needToEat\n        val carrotLeftToEat =\
    \ carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        if (carrotLeftToEat\
    \ < 0)\n            carrotEatenList :+ carrotLeftToEat\n        else\n       \
    \     carrotEatenList :+ carrotLeftToEat\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp57vco8z_.scala:44)\n\tat Problem.main(tmp57vco8z_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining\n        val carrots_needed = carrots - carrots_left\n        val\
    \ carrots_needed_to_eat = carrots_needed - carrots_left\n        val carrots_left_to_eat\
    \ = carrots_needed - carrots_left\n        val carrots_left_to_eat2 = carrots_needed\
    \ - carrots_left\n        val carrots_left_to_eat3 = carrots_needed - carrots_left\n\
    \        val carrots_left_to_eat4 = carrots_needed - carrots_left\n        val\
    \ carrots_left_to_eat5 = carrots_needed - carrots_left\n        val carrots_left_to_eat6\
    \ = carrots_needed - carrots_left\n        val carrots_left_to_eat7 = carrots_needed\
    \ - carrots_left\n        val carrots_left_to_eat8 = carrots_needed - carrots_left\n\
    \        val carrots_left_to_eat9 = carrots_needed - carrots_left\n        val\
    \ carrots_left_to_eat10 = carrots_needed - carrots_left\n        val carrots_left_to_eat11\
    \ = carrots_needed - carrots_left\n        val carrots_left_to_eat12 = carrots_needed\
    \ - carrots_left\n        val carrots_left_to_eat13 = carrots_needed - carrots_left\n\
    \        val carrots_left_to_eat14 = carrots_needed - carrots_left\n        val\
    \ carrots_left_to_eat15 = carrots_needed - carrots_left\n        val carrots_left_to_eat16\
    \ = carrots_needed - carrots_left\n        val carrots_left_to_eat17 = carrots_needed\
    \ - carrots_left\n        val carrots_left_to_eat18 = carrots_needed - carrots_left\n\
    \        val carrots_left_to_eat19 = carrots_needed - carrots_left\n        val\
    \ carrots_left_to_eat20 = carrots_needed - carrots_left\n        val carrots_left_to_eat21\
    \ = carrots_needed - carrots_left\n        val carrots_left_to_eat22 = carrots_needed\
    \ - carrots_left\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp4tu6a67a.scala:60:11 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4tu6a67a.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4tu6a67a.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4tu6a67a.scala:61:5 ---------------------\e[0m\e[0m\n\e[31m61\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new Array[Long](2)\n        val carrots_left = remaining -\
    \ carrots\n        val carrots_left_to_eat = (needs - carrots).toInt\n       \
    \ val carrots_left_to_eat2 = carrots_left_to_eat * carrots_left_to_eat\n     \
    \   val carrots_left_to_eat3 = carrots_left_to_eat2 * carrots_left_to_eat\n  \
    \      val carrots_left_to_eat4 = carrots_left_to_eat3 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat5 = carrots_left_to_eat4 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat6 = carrots_left_to_eat5 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat7 = carrots_left_to_eat6 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat8 = carrots_left_to_eat7 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat9 = carrots_left_to_eat8 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat10 = carrots_left_to_eat9 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat11 = carrots_left_to_eat10 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat12 = carrots_left_to_eat11 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat13 = carrots_left_to_eat12 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat14 = carrots_left_to_eat13 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat15 = carrots_left_to_eat14 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat16 = carrots_left_to_eat15 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat17 = carrots_left_to_eat16 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat18 = carrots_left_to_eat17 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat19 = carrots_left_to_eat18 * carrots_left_to_eat\n\
    \        val carrots_left_to_eat20 = carrots_left_to_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7g68jum0.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7g68jum0.scala:55:36\
    \ ------------------------\e[0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left_to_eat20\e[0m = carrots_left_to_\n\e[31m\e[31m   |\e[0m     \
    \                               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                             Not found: carrots_left_to_\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7g68jum0.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val need_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left - need_left).toInt\n        val need_left_to_eat\
    \ = (need_left - carrots_left).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ + need_left_to_eat).toInt\n        val need_to_eat = (need_left_to_eat + carrots_left_to_eat).toInt\n\
    \        val carrots_to_eat_left = carrots_to_eat - need_to_eat\n        val need_to_eat_left\
    \ = need_to_eat - carrots_to_eat\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left\
    \ - need_to_eat_left).toInt\n        val need_to_eat_left_to_eat = (need_to_eat_left\
    \ - carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left =\
    \ carrots_to_eat_left_to_eat + need_to_eat_left_to_eat\n        val need_to_eat_left_to_eat_left\
    \ = need_to_eat_left_to_eat + carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left - need_to_eat_left_to_eat_left).toInt\n \
    \       val need_to_eat_left_to_eat_left_to_eat = (need_to_eat_left_to_eat_left\
    \ - carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat + need_to_eat_left_to_eat_left_to_eat\n\
    \        val need_to_eat_left_to_eat_left_to_eat_left = need_to_eat_left_to_eat_left_to_eat\
    \ + carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left - need_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val need_to_eat_left_to_eat_left_to_eat_left = need_to_eat_left_to_e\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2b6sgle.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mneed_to_eat_left_to_eat_left_to_eat_left\e\
    [0m = need_to_eat_left_to_e\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneed_to_eat_left_to_eat_left_to_eat_left is already defined\
    \ as \e[33mvalue\e[0m \e[35mneed_to_eat_left_to_eat_left_to_eat_left\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpz2b6sgle.scala:33:24 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz2b6sgle.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz2b6sgle.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2np1shd5.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryEaten = if\
    \ (hungryRemaining > 0) hungryRemaining else 0\n        val hungryEatenList =\
    \ List(hungryEaten.toLong)\n        val hungryEatenList2 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList3 = List(hungryEaten.toLong)\n        val hungryEatenList4\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList5 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList6 = List(hungryEaten.toLong)\n        val hungryEatenList7\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList8 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList9 = List(hungryEaten.toLong)\n        val hungryEatenList10\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList11 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList12 = List(hungryEaten.toLong)\n        val hungryEatenList13\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList14 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList15 = List(hungryEaten.toLong)\n        val hungryEatenList16\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList17 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList18 = List(hungryEaten.toLong)\n        val hungryEatenList19\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList20 = List(hungryEat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8sqf3szk.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8sqf3szk.scala:53:37\
    \ ------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryEatenList20\e[0m = List(hungryEat\n\e[31m\e[31m   |\e[0m           \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                  Not found: hungryEat\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8sqf3szk.scala:54:5 ---------------------\e[0m\e\
    [0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010362
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n\
    \        val carrotLeftToEatList2 = List(carrotLeftToEat.toLong)\n        val\
    \ carrotLeftToEatList3 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList4\
    \ = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList5 = List(carrotLeftToEat.toLong)\n\
    \        val carrotLeftToEatList6 = List(carrotLeftToEat.toLong)\n        val\
    \ carrotLeftToEatList7 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList8\
    \ = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList9 = List(carrotLeftToEat.toLong)\n\
    \        val carrotLeftToEatList10 = List(carrotLeftToEat.toLong)\n        val\
    \ carrotLeftToEatList11 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList12\
    \ = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList13 = List(carrotLeftToEat.toLong)\n\
    \        val carrotLeftToEatList14 = List(carrotLeftToEat.toLong)\n        val\
    \ carrotLeftToEatList15 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList16\
    \ = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList17 = List(carrotLeftToEat.toLong)\n\
    \        val carrotLeftToEatList18 = List(carrotLeftToEat.toLong)\n        val\
    \ carrotLeftToEatList19 = List(carrotLeftToEat.toLong)\n        val carrotLeftToEatList20\
    \ = List(carrotLeftToEat.toLong)\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzxe5r0ar.scala:57:5\
    \ ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010362
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsRemaining = carrots - remaining\n        val needsToEat = needs\
    \ - carrotsRemaining\n        val carrotsToEat = carrotsRemaining + needsToEat\n\
    \        val carrotsToEatList = List(carrotsToEat.toLong)\n        val carrotsToEatList2\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList3 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList4 = List(carrotsToEat.toLong)\n        val carrotsToEatList5\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList6 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList7 = List(carrotsToEat.toLong)\n        val carrotsToEatList8\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList9 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList10 = List(carrotsToEat.toLong)\n        val carrotsToEatList11\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList12 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList13 = List(carrotsToEat.toLong)\n        val carrotsToEatList14\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList15 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList16 = List(carrotsToEat.toLong)\n        val carrotsToEatList17\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList18 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList19 = List(carrotsToEat.toLong)\n        val carrotsToEatList20\
    \ = List(carrotsTo\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv1zky6bi.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv1zky6bi.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpv1zky6bi.scala:56:38 ------------------------\e[0m\e[0m\n\e[31m56 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrotsToEatList20\e[0m = List(carrotsTo\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: carrotsTo\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv1zky6bi.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number\
    \ - remaining\n        val hungryCarrotsToEat = need - hungryCarrots\n       \
    \ val hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList2\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList3 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList4 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList5 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList6 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList7\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList8 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList9 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList10 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList11 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList12\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList13 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList14 = List(hungryCarrotsToEat.toLong)\n    \
    \    val hungryCarrotsToEatList15 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList16 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsTo\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp19l2xe5l.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp19l2xe5l.scala:50:5 ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        while (carrots_left > 0) {\n            val carrots_needed\
    \ = carrots_left / needs.toDouble\n            val carrots_left_to_eat = (carrots_left\
    \ - carrots_needed).toInt\n            val carrots_left_to_eat_doubled = (carrots_left_to_eat\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled = (carrots_left_to_eat_doubled\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled\
    \ = (carrots_left_to_eat_doubled_doubled_doubled_doubled * 2).toInt\n        \
    \    val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled\
    \ = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ = (carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ * 2).toInt\n            val carrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\
    \ = (carrots_left_to_eat_doubled_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo1pqpwv7.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo1pqpwv7.scala:60:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpo1pqpwv7.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo1pqpwv7.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo1pqpwv7.scala:42:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e\
    [0m \e[36mcarrots_left_to_eat_doubled_doubled_doubled_doubled\e[0m = (carrots_left_to_eat_doubled_doubled_doubled_doubled\
    \ * \e[31m2\e[0m).toInt\n\e[31m\e[31m   |\e[0m                               \
    \                                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_doubled_doubled_doubled_doubled\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo1pqpwv7.scala:48:119\
    \ -----------------------\e[0m\e[0m\n\e[31m48 |\e[0m            \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled_doubled\e\
    [0m = (carrots_left_to_eat_doubled_\n\e[31m\e[31m   |\e[0m                   "
  stdout: ''
  timestamp: 1660010369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryEaten = math.min(hungry,\
    \ hungryRemaining)\n        val hungryEatenRemaining = math.max(hungry, hungryRemaining)\n\
    \        val hungryEatenList = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList2 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList3 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList4 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList5 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList6 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList7 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList8 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList9 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList10 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList11 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList12 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        val hungryEatenList13 = List(hungryEaten.toLong, hungryEatenRemaining.toLong)\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2lgp4j00.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        val meals = List(need)\n      \
    \  val hungryMeals = List(need)\n        val leftMeals  = List(left)\n       \
    \ val hungryLeftMeals = List(left)\n        val hungryLeftMeals2 = List(left)\n\
    \        val hungryLeftMeals3 = List(left)\n        val hungryLeftMeals4 = List(left)\n\
    \        val hungryLeftMeals5 = List(left)\n        val hungryLeftMeals6 = List(left)\n\
    \        val hungryLeftMeals7 = List(left)\n        val hungryLeftMeals8 = List(left)\n\
    \        val hungryLeftMeals9 = List(left)\n        val hungryLeftMeals10 = List(left)\n\
    \        val hungryLeftMeals11 = List(left)\n        val hungryLeftMeals12 = List(left)\n\
    \        val hungryLeftMeals13 = List(left)\n        val hungryLeftMeals14 = List(left)\n\
    \        val hungryLeftMeals15 = List(left)\n        val hungryLeftMeals16 = List(left)\n\
    \        val hungryLeftMeals17 = List(left)\n        val hungryLeftMeals18 = List(left)\n\
    \        val hungryLeftMeals19 = List(left)\n        val hungryLeftMeals20 = List(left)\n\
    \        val hungryLeftMeals21 = List(left)\n        val hungryLeftMeals22 = List(left)\n\
    \        val hungryLeftMeals23 = List(left)\n        val hungryLeftMeals24 = List(left)\n\
    \        val hungryLeftMeals25 = List(left)\n        val hungryLeftMeals26 = List(left)\n\
    \        val hungryLeftMeals27 = List(left)\n        val hungryLeftMeals28 = List(left)\n\
    \        val hungryLeftMeals29 = List(left)\n        val hungryLeftMeals30 = List(left)\n\
    \        val hungryLeftMeals31 = List(left)\n        val hungryLeftMeals32 = List(left)\n\
    \        val hungryLeftMeals33 = List(left)\n        val hungryLeftMeals34 = List(left)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplsuix2lv.scala:70:5\
    \ ---------------------\e[0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_needed = needs\
    \ - carrots_left\n        val carrots_left_after_meals = carrots_left - carrots_needed\n\
    \        val carrots_needed_after_meals = carrots_needed - carrots_left\n    \
    \    val carrots_left_after_meals_after_meals = carrots_left_after_meals - carrots_needed_after_meals\n\
    \        val carrots_needed_after_meals_after_meals = carrots_needed_after_meals\
    \ - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - carrots_needed_after_meals_after_meals\n\
    \        val carrots_needed_after_meals_after_meals_after_meals = carrots_needed_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - carrots_needed_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_needed_after_meals_after_meals_after_meals_after_meals =\
    \ carrots_needed_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpn6fl6s3g.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpn6fl6s3g.scala:43:77\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_needed_after_meals_after_meals_after_meals_after_meals\e[0m =\
    \ carrots_needed_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mcarrots_needed_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpn6fl6s3g.scala:44:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn6fl6s3g.scala:45:101\
    \ -----------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_needed_after_meals_after_meals_after_meals_afte"
  stdout: ''
  timestamp: 1660010367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remainingCarrots = remaining\
    \ - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots\
    \ - hungry\n        val hungryMeals = meals - hungry\n        val hungryRemainingCarrots\
    \ = remainingCarrots - hungry\n        val hungryRemainingMeals = hungryMeals\
    \ - hungryCarrots\n        val hungryRemainingHungryCarrots = hungryRemainingCarrots\
    \ - hungryRemainingMeals\n        val hungryRemainingHungryMeals = hungryRemainingMeals\
    \ - hungryRemainingHungryCarrots\n        val hungryRemainingHungryHungryCarrots\
    \ = hungryRemainingHungryCarrots - hungryRemainingHungryMeals\n        val hungryRemainingHungryHungryMeals\
    \ = hungryRemainingHungryMeals - hungryRemainingHungryHungryCarrots\n        val\
    \ hungryRemainingHungryHungryHungryCarrots = hungryRemainingHungryHungryCarrots\
    \ - hungryRemainingHungryHungryMeals\n        val hungryRemainingHungryHungryHungryMeals\
    \ = hungryRemainingHungryHungryMeals - hungryRemainingHungryHungryHungryCarrots\n\
    \        val hungryRemainingHungryHungryHungryHungryCarrots = hungryRemainingHungryHungryHungryMeals\
    \ - hungryRemainingHungryHungryHungryHungryMeals\n        val hungryRemainingHungryHungryHungryHungryMeals\
    \ = hungry\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpk265wrpw.scala:35:36 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = carrots\
    \ - hungry\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ ((hungry : Boolean))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpk265wrpw.scala:36:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e\
    [0m \e[36mhungryMeals\e[0m = meals - hungry\n\e[31m\e[31m   |\e[0m           \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpk265wrpw.scala:37:54 -----------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingCarrots\e[0m = remainingCarrots\
    \ - hungry\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((hungry : Boolean))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk265wrpw.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660010369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = List(need)\n\
    \        val hungry = true\n        val hungryCarrots = List(number)\n       \
    \ val hungryCarrotsRemaining = remaining\n        while (hungry) {\n         \
    \   val hungryMeals = meals.takeWhile(_ < need)\n            val hungryCarrotsRemaining\
    \ = hungryCarrotsRemaining - hungryMeals.head\n            val hungryCarrots =\
    \ hungryCarrots.takeWhile(_ < hungryCarrotsRemaining)\n            val hungryMealsRemaining\
    \ = hungryMeals.takeWhile(_ < need)\n            val hungryMealsRemainingCarrots\
    \ = hungryMealsRemaining.takeWhile(_ < carrots)\n            hungry = hungryMealsRemainingCarrots.isEmpty\n\
    \            meals = hungryMeals\n            hungryCarrots = hungryCarrotsRemaining\n\
    \            hungryCarrotsRemaining = hungryMealsRemainingCarrots\n        }\n\
    \        meals.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnrcii1g8.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnrcii1g8.scala:39:41\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e\
    [0m \e[36mhungryCarrotsRemaining\e[0m = hungryCarrotsRemaining - hungryMeals.head\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                       Recursive \e[33mvalue\e[0m \e[35mhungryCarrotsRemaining\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnrcii1g8.scala:40:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e\
    [0m \e[36mhungryCarrots\e[0m = hungryCarrots.takeWhile(_ < hungryCarrotsRemaining)\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               Recursive \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpnrcii1g8.scala:43:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            hungry =\
    \ hungryMealsRemainingCarrots.isEmpty\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val hungry\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpnrcii1g8.scala:44:18 -----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            meals = hungryMeals\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val meals\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with "
  stdout: ''
  timestamp: 1660010365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m =\
    \ List(carrots_left.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m = List(carrots_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_le"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val carrots_left_to_eat = (needs - carrots).toInt\n\
    \        val carrots_left_to_eat_max = carrots_left - carrots_left_to_eat\n  \
    \      val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n    \
    \    val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n      \
    \  val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val\
    \ carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max\
    \ = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min =\
    \ carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat\
    \ - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat -\
    \ carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n\
    \        val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n  \
    \      val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n    \
    \    val carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n      \
    \  val carrots_left_to_eat_max = carrots_left_to_eat - carrots_left\n        val\
    \ carrots_left_to_eat_min = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max\
    \ = carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_min =\
    \ carrots_left_to_eat - carrots_left\n        val carrots_left_to_eat_max = carrots_left_to_eat\
    \ - carrots_left\n        val carrots_left_to_eat_min = carrots_left_to_eat -\
    \ carrots_left\n        val carrots_left_to_e\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuy2avr98.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_to_eat_min\e[0m = carrots_left_to_eat - carrots_left\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_min is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_min\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_max\e\
    [0m = carrots_left_to_eat - carrots_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_max is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_max\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_min\e\
    [0m = carrots_left_to_eat - carrots_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_min is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_to_eat_min\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuy2avr98.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_max\e\
    [0m = carrots_left_to_eat - carrots_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val result = carrots_left_list\
    \ ++ needs_left_list\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgy4j_fr9.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val eaten = meals - need\n        val left = (carrots - eaten) - hungry\n\
    \        List(meals.toLong, left.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsdlmwzvj.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m =\
    \ List(carrots_left.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m = List(carrots_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp50nwp9rx.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp50nwp9rx.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_le"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - needs\n        val needs_left_to_eat\
    \ = (needs_left / needs).toInt\n        val carrots_left_to_eat = (carrots_left\
    \ / needs).toInt\n        val carrots_left_to_eat = if (carrots_left_to_eat >\
    \ 0) carrots_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_eat else 1\n        val needs_left_to_eat = if (needs_left_to_eat\
    \ > 0) needs_left_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat\e[0m\
    \ = \e[33mif\e[0m (carrots_left_to_eat > \e[31m0\e[0m) carrots_left_to_eat \e\
    [33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat is already defined as \e[33mvalue\e[0m\
    \ \e[35mcarrots_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_to_eat\e[0m =\
    \ \e[33mif\e[0m (needs_left_to_eat > \e[31m0\e[0m) needs_left_to_eat \e[33melse\e\
    [0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_to_eat is already defined as \e[33mvalue\e[0m \e\
    [35mneeds_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_to_eat\e[0m =\
    \ \e[33mif\e[0m (needs_left_to_eat > \e[31m0\e[0m) needs_left_to_eat \e[33melse\e\
    [0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left_to_eat is already defined as \e[33mvalue\e[0m \e\
    [35mneeds_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpg4u0el3u.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_to_eat\e[0m =\
    \ \e[33mif\e[0m (needs_left_to_eat > \e[31m0\e[0m) needs_left_to_eat \e[33melse\e\
    [0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010371
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n\
    \        if (carrotLeftToEatList == List(0l)) {\n            carrotLeftToEatList\n\
    \        } else {\n            carrotLeftToEatList\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgrsg988_.scala:44)\n\tat Problem.main(tmpgrsg988_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n\
    \        val hungryRemaining = remaining.toInt\n        val needToEat = need.toInt\n\
    \        val needToEatRemaining = hungryRemaining - needToEat\n        val hungryEaten\
    \ = hungry - needToEat\n        val hungryEatenRemaining = hungryRemaining - hungryEaten\n\
    \        val hungryEatenRemainingToEat = hungryEatenRemaining.toInt\n        val\
    \ hungryEatenRemainingToEatRemaining = hungryEatenRemainingToEat.toInt\n     \
    \   val hungryEatenRemainingToEatRemainingToEat = hungryEatenRemainingToEatRemaining.toInt\n\
    \        val hungryEatenRemainingToEatRemainingToEatRemaining = hungryEatenRemainingToEatRemainingToEat.toInt\n\
    \        val hungryEatenRemainingToEatRemainingToEatRemainingToEat = hungryEatenRemainingToEatRemainingToEatRemainingToEat.toInt\n\
    \        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemaining =\
    \ hungryEatenRemainingToEatRemainingToEatRemainingToEat.toInt\n        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat\
    \ = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat.toInt\n\
    \        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\
    \ = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining.toInt\n\
    \        val hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemainingToEat\
    \ = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingTo\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd2thzhwg.scala:41:68 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemainingToEatRemainingToEatRemainingToEat\e\
    [0m = hungryEatenRemainingToEatRemainingToEatRemainingToEat.toInt\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mhungryEatenRemainingToEatRemainingToEatRemainingToEat\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd2thzhwg.scala:43:82\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat\e\
    [0m = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEat\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd2thzhwg.scala:44:91\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\e\
    [0m = hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  hungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpd2thzhwg.scala:45:96 ------------------------\e[0m\e[0m\n\e[31m45 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryEatenRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemainingToEat\e"
  stdout: ''
  timestamp: 1660010371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining + carrots\n        val meals = List(need)\n\
    \        val hungry = true\n        val hungryCarrots = List(number)\n       \
    \ val hungryRemaining = remaining\n        val hungryMeals = List(need)\n    \
    \    while (hungry) {\n            val hungryMeals = List(need - hungryRemaining)\n\
    \            val hungryRemaining = remaining - hungryMeals.last\n            val\
    \ hungryCarrots = List(number - hungryRemaining)\n            val hungryMeals\
    \ = List(need - hungryRemaining)\n            hungry = false\n            val\
    \ hungryMeals = List(need - hungryRemaining)\n            val hungryRemaining\
    \ = remaining - hungryMeals.last\n            val hungryCarrots = List(number\
    \ - hungryRemaining)\n            val hungryMeals = List(need - hungryRemaining)\n\
    \            hungry = true\n        }\n        val hungryMeals = List(need - hungryRemaining)\n\
    \        val hungryRemaining = remaining - hungryMeals.last\n        val hungryCarrots\
    \ = List(number - hungryRemaining)\n        val hungryMeals = List(need - hungryRemaining)\n\
    \        List(number - hungryRemaining, hungryRemaining)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyynk095p.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = List(need\
    \ - hungryRemaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyynk095p.scala:51:12 ---------------------------\e[0m\e[0m\n\e\
    [31m51 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = remaining - hungryMeals.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemaining is already defined as \e[33mvalue\e[0m \e\
    [35mhungryRemaining\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyynk095p.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = List(number\
    \ - hungryRemaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyynk095p.scala:53:12 ---------------------------\e[0m\e[0m\n\e\
    [31m53 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = List(need - hungryRemaining)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpyynk095p.scala:32:24 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining + ca"
  stdout: ''
  timestamp: 1660010369
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots.toLong,\
    \ leftCarrots.toLong)\n        if (leftCarrots == 0) result\n        else eat(number,\
    \ need, remaining - carrots)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = math.min(needs, carrots)\n        val carrots_left = math.max(0,\
    \ carrots - meals)\n        val carrots_left_after_meals = math.max(0, carrots_left\
    \ - remaining)\n        val carrots_left_after_meals_after_meals = math.max(0,\
    \ carrots_left_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = math.max(0, carrots_left_after_meals_after_meals - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = math.max(0, carrots_left_after_meals_after_meals_after_meals - meals)\n  \
    \      val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals -\
    \ meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - meals)\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = math.max(0, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr08ta49r.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr08ta49r.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpr08ta49r.scala:43:135 --------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = math.max(\e[31m0\e[0m, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - meals)\n\e[31m\e[31m   |\e[0m                                            \
    \                                                                            \
    \               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m\
    \   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpr08ta49r.scala:44:147 -----------------------\e[0m\e[0m\n\e[31m44 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = math.max(\e[31m0\e[0m, carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - needs\n        val carrots_left_to_eat\
    \ = carrots_left - needs_left\n        val needs_left_to_eat = needs - carrots_left\n\
    \        val carrots_left_to_eat2 = carrots_left_to_eat.toInt\n        val needs_left_to_eat2\
    \ = needs_left_to_eat.toInt\n        val carrots_left_to_eat3 = carrots_left_to_eat2.toInt\n\
    \        val needs_left_to_eat3 = needs_left_to_eat2.toInt\n        val carrots_left_to_eat4\
    \ = carrots_left_to_eat3.toInt\n        val needs_left_to_eat4 = needs_left_to_eat3.toInt\n\
    \        val carrots_left_to_eat5 = carrots_left_to_eat4.toInt\n        val needs_left_to_eat5\
    \ = needs_left_to_eat4.toInt\n        val carrots_left_to_eat6 = carrots_left_to_eat5.toInt\n\
    \        val needs_left_to_eat6 = needs_left_to_eat5.toInt\n        val carrots_left_to_eat7\
    \ = carrots_left_to_eat6.toInt\n        val needs_left_to_eat7 = needs_left_to_eat6.toInt\n\
    \        val carrots_left_to_eat8 = carrots_left_to_eat7.toInt\n        val needs_left_to_eat8\
    \ = needs_left_to_eat7.toInt\n        val carrots_left_to_eat9 = carrots_left_to_eat8.toInt\n\
    \        val needs_left_to_eat9 = needs_left_to_eat8.toInt\n        val carrots_left_to_eat10\
    \ = carrots_left_to_eat9.toInt\n        val needs_left_to_eat10 = needs_left_to_eat9.toInt\n\
    \        val carrots_left_to_eat11 = carrots_left_to_eat10.toInt\n        val\
    \ needs_left_to_eat11 = needs_left_to_eat10.toInt\n        val carrots_left_to_eat12\
    \ = carrots_left_to_eat11.toInt\n        val needs_left_to_eat12 = needs_left_to_eat11.toInt\n\
    \        val carrots_left_to_eat13 = carrots_left_to_eat12.toInt\n        val\
    \ needs_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplyhwc7pp.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplyhwc7pp.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmplyhwc7pp.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplyhwc7pp.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - needs\n        val needs_left_carrots\
    \ = needs_left * carrots\n        val needs_left_carrots_left = needs_left_carrots\
    \ - carrots\n        val needs_left_carrots_left_carrots = needs_left_carrots_left\
    \ * carrots\n        val needs_left_carrots_left_carrots_left = needs_left_carrots_left_carrots\
    \ - carrots\n        val needs_left_carrots_left_carrots_left_carrots = needs_left_carrots_left_carrots_left\
    \ * carrots\n        val needs_left_carrots_left_carrots_left_carrots_left = needs_left_carrots_left_carrots_left_carrots\
    \ - carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left * carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots - carrots\n    \
    \    val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_left * carrots\n\
    \        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ - carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ * carrots\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ - carrots\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp28swsuj2.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp28swsuj2.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp28swsuj2.scala:46:90 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36mneeds_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\e\
    [0m = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ - carrots\n\e[31m\e[31m   |\e[0m                                           \
    \                                               ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp28swsuj2.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val totalCarrots = carrots + remaining\n        val totalNeeds = needs +\
    \ remaining\n        val totalNeedsAfterMeals = totalNeeds - carrots\n       \
    \ val totalCarrotsAfterMeals = totalCarrots - need\n        val totalCarrotsLeftAfterMeals\
    \ = totalCarrots - totalNeedsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMeals\
    \ = totalCarrotsLeftAfterMeals - totalCarrotsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMeals\
    \ = totalCarrotsLeftAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMeals\n\
    \        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals = totalCarrotsLeftAfterMealsAfterMealsAfterMeals\
    \ - totalCarrotsAfterMealsAfterMealsAfterMeals\n        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \        val totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \        val totalCarrotsLeftAfterMe\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwld1zd_n.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwld1zd_n.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e[0m\
    \ = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ is already defined as \e[33mvalue\e[0m \e[35mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpwld1zd_n.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwld1zd_n.scala:44:91 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mtotalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m = totalCarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - totalCarrotsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  totalCarrotsLeftAfterMe"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = math.min(needs, carrots)\n        val leftCarrots = math.max(0,\
    \ carrots - meals)\n        val leftNeeds = math.max(0, needs - meals)\n     \
    \   val leftRemaining = math.max(0, remaining - meals)\n        val leftMeals\
    \ = math.min(leftNeeds, leftCarrots)\n        val leftLeftCarrots = math.max(0,\
    \ leftCarrots - leftMeals)\n        val leftLeftNeeds = math.max(0, leftNeeds\
    \ - leftMeals)\n        val leftLeftRemaining = math.max(0, leftRemaining - leftMeals)\n\
    \        val leftLeftMeals = math.min(leftLeftNeeds, leftLeftCarrots)\n      \
    \  val leftLeftLeftCarrots = math.max(0, leftLeftCarrots - leftLeftMeals)\n  \
    \      val leftLeftLeftNeeds = math.max(0, leftLeftNeeds - leftLeftMeals)\n  \
    \      val leftLeftLeftRemaining = math.max(0, leftLeftRemaining - leftLeftMeals)\n\
    \        val leftLeftLeftMeals = math.min(leftLeftLeftNeeds, leftLeftLeftCarrots)\n\
    \        val leftLeftLeftLeftCarrots = math.max(0, leftLeftLeftCarrots - leftLeftLeftMeals)\n\
    \        val leftLeftLeftLeftNeeds = math.max(0, leftLeftLeftNeeds - leftLeftLeftMeals)\n\
    \        val leftLeftLeftLeftRemaining = math.max(0, leftLeftLeftRemaining - leftLeftLeftMeals)\n\
    \        val leftLeftLeftLeftMeals = math.min(leftLeftLeftLeftNeeds, leftLeftLeftLeftCarrots)\n\
    \        val leftLeftLeftLeftLeftCarrots = math.max(0, leftLeftLeftLeftCarrots\
    \ - leftLeftLeftLeftMeals)\n        val leftLeftLeftLeftLeftNeeds = math.max(0,\
    \ leftLeftLeftLeftNeeds - leftLeftLeftLeftMeals)\n        val leftLeftLeftLeftLeftRemaining\
    \ = math.max(0, leftLeftLeftLeftRemaining - leftLeftLeftLeftMeals)\n        val\
    \ leftLeftLeftLeftLeftMeals = math.min(leftLeftLeftLeftLeftNeeds, leftLeftLeftLeftLeftCarrots)\n\
    \        val leftLeftLeftLeftLeftLeftCarrots = math.max(0, leftLeftLeftLeftLeftCarrots\
    \ - leftLeftLeftLeftLeftMeals)\n        val leftLeftLeftLeftLeftLeftNeeds = math.max(0,\
    \ leftLeftLeftLeftLeftNeeds - leftLeftLeftLeftLeftMeals)\n        val leftLeftLeftLeft\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6luofs0o.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6luofs0o.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6luofs0o.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010374
