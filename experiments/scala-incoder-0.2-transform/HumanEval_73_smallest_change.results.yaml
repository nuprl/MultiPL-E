language: scala
name: HumanEval_73_smallest_change
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ r = arr.last\n        val s = arr.init.reverse\n        val a = arr.toList\n\
    \        val b = a.toList\n        val c = b.toList\n        val d = c.toList\n\
    \        val e = d.toList\n        val f = e.toList\n        val g = f.toList\n\
    \        val h = g.toList\n        val i = h.toList\n        val j = i.toList\n\
    \        val k = j.toList\n        val l = k.toList\n        val m = l.toList\n\
    \        val n = m.toList\n        val o = n.toList\n        val p = o.toList\n\
    \        val q = p.toList\n        val r = q.toList\n        val s = r.toList\n\
    \        val t = s.toList\n        val u = t.toList\n        val v = u.toList\n\
    \        val w = v.toList\n        val x = w.toList\n        val y = x.toList\n\
    \        val z = y.toList\n        val a = z.toList\n        val b = a.toList\n\
    \        val c = b.toList\n        val d = c.toList\n        val e = d.toList\n\
    \        val f = e.toList\n        val g = f.toList\n        val h = g.toList\n\
    \        val i = h.toList\n        val j = i.toList\n        val k = j.toList\n\
    \        val l = k.toList\n        val m = l.toList\n        val n = m.toList\n\
    \        val o = n.toList\n        val p = o.toList\n        val q = p.toList\n\
    \        val r = q.toList\n        val s = r.toList\n        val t = s.toList\n\
    \        val u = t.toList\n        val v = u.toList\n        val w = v.toList\n\
    \        val x = w.toList\n        val y = x.toList\n        val z = y.toList\n\
    \        val a = z.toList\n        val b = a.toList\n        val c = b.toList\n\
    \        val d = c.toList\n        val e = d.toList\n        val f = e.toList\n\
    \        val g = f.toList\n        val h = g.toList\n        val i = h.toList\n\
    \        val j = i.toList\n        val k = j.toList\n        val l = k.toList\n\
    \        val m = l.toList\n        val n = m.toList\n        val o = n.toList\n\
    \        val p = o.toList\n        val q = p.toList\n        val r = q\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5h7h7n3.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5h7h7n3.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = m.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5h7h7n3.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = q.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5h7h7n3.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = r.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5h7h7n3.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = z.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ma is already defined\
    \ as \e[33mvalue\e[0m \e[35ma\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5h7h7n3.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m "
  stdout: ''
  timestamp: 1659805576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var min = 0\n        var minIndex = 0\n\
    \        var max = 0\n        var maxIndex = 0\n        while (i < n) {\n    \
    \        while (j < n) {\n                if (arr(i) == arr(j)) {\n          \
    \          temp = 1\n                    j++\n                }\n            \
    \    else {\n                    temp = 0\n                }\n               \
    \ k = j\n                while (k < n) {\n                    if (arr(i) != arr(k))\
    \ {\n                        temp = 0\n                        k++\n         \
    \           }\n                    else {\n                        temp = 1\n\
    \                    }\n                }\n                if (temp == 1) {\n\
    \                    result(i) = arr(i)\n                    i++\n           \
    \         j++\n                }\n                else {\n                   \
    \ result(i) = arr(j)\n                    j++\n                }\n           \
    \ }\n            while (j < n) {\n                k = j\n                while\
    \ (k < n) {\n                    if (arr(i) != arr(k)) {\n                   \
    \     temp = 0\n                        k++\n                    }\n         \
    \           else {\n                        temp = 1\n                    }\n\
    \                }\n                if (temp == 1) {\n                    result(i)\
    \ = arr(i)\n                    i++\n                }\n                else {\n\
    \                    result(i) = arr(j)\n                    j++\n           \
    \     }\n            }\n        }\n        var i = 0\n        while (i < n) {\n\
    \            if (result(i) == arr(i)) {\n                i++\n            }\n\
    \            else {\n                j = 0\n                while (j < n) {\n\
    \                    if (result(i) != arr(j)) {\n                        temp\
    \ = 0\n                        j++\n                    }\n                  \
    \  else {\n                        temp = 1\n                    }\n         \
    \       }\n                if (temp == 1) {\n                    result(i) = arr(i)\n\
    \                    i++\n                }\n                else {\n        \
    \            result(i) = arr(j)\n                    j++\n                }\n\
    \            }\n        }\n        i = 0\n        while (i < n) {\n          \
    \  if (result(i) == arr(i)) {\n                i++\n            }\n          \
    \  else {\n                j = 0\n                while (j < n) {\n          \
    \          if (result(i) != arr(j)) {\n                        temp = 0\n    \
    \                    j++\n                    }\n                    else {\n\
    \                        temp = 1\n                    }\n                }\n\
    \                if (temp == 1) {\n                    result(i) = arr(i)\n  \
    \                  i++\n                }\n                else {\n          \
    \          result(i) = arr(j)\n                    j++\n                }\n  \
    \          }\n        }\n        i = 0\n        while (i < n) {\n            if\
    \ (result(i) == arr(i)) {\n                i++\n            }\n            else\
    \ {\n                j = 0\n                while (j < n) {\n                \
    \    if (result(i) != arr(j)) {\n                        temp = 0\n          \
    \              j++\n                    }\n                    else {\n      \
    \                  temp = 1\n                    }\n                }\n      \
    \          if (temp == 1) {\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfr7nh0vd.scala:30:23 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpfr7nh0vd.scala:39:27 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                        k++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpfr7nh0vd.scala:48:23 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfr7nh0vd.scala:52:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpfr7nh0vd.scala:60:27 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m                        k++\n\e[31m\e[31m   |\e[0m  \
    \                         ^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpfr7nh0vd.scala:68:23 ---------------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m                    i++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659805576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var count = 0\n        var i = 0\n        var j = 0\n        while (i\
    \ < len) {\n            if (arr(i) == arr(len - 1 - j)) {\n                count\
    \ += 1\n                j++\n            } else {\n                j = 0\n   \
    \         }\n            i += 1\n        }\n        count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph0qamcay.scala:23:19 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmph0qamcay.scala:15:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m            \
    \                 ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded\
    \ function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmph0qamcay.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.min\n        val max = arr.max\n        val mid = len/2\n\
    \        val midVal = arr(mid)\n        val leftArr = (arr.take(mid).reverse).reverse\n\
    \        val rightArr = (arr.drop(mid+1).reverse).reverse\n        val leftMin\
    \ = smallestChange(leftArr)\n        val leftMax = smallestChange(leftArr)\n \
    \       val rightMin = smallestChange(rightArr)\n        val rightMax = smallestChange(rightArr)\n\
    \        if (leftMin < leftMax) {\n            if (rightMin < rightMax) {\n  \
    \              if (leftMin < midVal) {\n                    return leftMin\n \
    \               }\n                if (rightMin < midVal) {\n                \
    \    return rightMin\n                }\n            }\n        }\n        if\
    \ (rightMin < rightMax) {\n            if (leftMin < midVal) {\n             \
    \   return leftMin\n            }\n            if (rightMin < midVal) {\n    \
    \            return rightMin\n            }\n        }\n        if (leftMin <\
    \ midVal) {\n            return leftMin\n        }\n        if (rightMin < midVal)\
    \ {\n            return rightMin\n        }\n        if (leftMin < max) {\n  \
    \          return leftMin\n        }\n        if (rightMin < max) {\n        \
    \    return rightMin\n        }\n        if (leftMin < min) {\n            return\
    \ leftMin\n        }\n        if (rightMin < min) {\n            return rightMin\n\
    \        }\n        return 0\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0r036ceb.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = len / 4\n        val maxLen3\
    \ = len / 8\n        val maxLen4 = len / 16\n        val maxLen5 = len / 32\n\
    \        val maxLen6 = len / 64\n        val maxLen7 = len / 128\n        val\
    \ maxLen8 = len / 256\n        val maxLen9 = len / 512\n        val maxLen10 =\
    \ len / 1024\n        val maxLen11 = len / 2048\n        val maxLen12 = len /\
    \ 4096\n        val maxLen13 = len / 8192\n        val maxLen14 = len / 16384\n\
    \        val maxLen15 = len / 32768\n        val maxLen16 = len / 65536\n    \
    \    val maxLen17 = len / 131072\n        val maxLen18 = len / 262144\n      \
    \  val maxLen19 = len / 524288\n        val maxLen20 = len / 1048576\n       \
    \ val maxLen21 = len / 2097152\n        val maxLen22 = len / 4194304\n       \
    \ val maxLen23 = len / 8388608\n        val maxLen24 = len / 16777216\n      \
    \  val maxLen25 = len / 33554432\n        val maxLen26 = len / 67108864\n    \
    \    val maxLen27 = len / 134217728\n        val maxLen28 = len / 268435456\n\
    \        val maxLen29 = len / 536870912\n        val maxLen30 = len / 1073741824\n\
    \        val maxLen31 = len / 2147483648\n        val maxLen32 = len / 4294967296\n\
    \        val maxLen33 = len / 8589934592\n        val maxLen34 = len / 17179869184\n\
    \        val maxLen35 = len / 34359738368\n        val maxLen36 = len / 68719476736\n\
    \        val maxLen37 = len / 137438953472\n        val maxLen38 = len / 274877906944\n\
    \        val maxLen39 = len / 549755813888\n        val maxLen40 = len / 1099511627776\n\
    \        val maxLen41 = len / 2199023255552\n        val maxLen42 = len / 4398046511104\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpre_5zpyz.scala:59:11 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpre_5zpyz.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpre_5zpyz.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        var count = 0\n        while(i < len) {\n     \
    \       while(j < len) {\n                if(arr(i) == arr(j)) {\n           \
    \         temp = arr(i)\n                    arr(i) = arr(j)\n               \
    \     arr(j) = temp\n                    j++\n                }\n            \
    \    else {\n                    j++\n                }\n            }\n     \
    \       i = i + 1\n            j = len\n            k = k + 1\n            while(k\
    \ >= 0) {\n                if(arr(k) == arr(len - k)) {\n                    temp\
    \ = arr(k)\n                    arr(k) = arr(len - k)\n                    arr(len\
    \ - k) = temp\n                    k--\n                }\n                else\
    \ {\n                    k--\n                }\n            }\n            count\
    \ = count + 1\n        }\n        if(count < min) {\n            min = count\n\
    \        }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwovb6a_n.scala:29:23 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpwovb6a_n.scala:32:23 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwovb6a_n.scala:43:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                    k--\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpwovb6a_n.scala:46:23 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    k--\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpwovb6a_n.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpwovb6a_n.scala:52:16 -----------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m            min = count\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val min\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation a"
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ val max = (arr.lastOption.getOrElse(0l) + arr.headOption.getOrElse(0l)).toLong\n\
    \        val min = arr.headOption.getOrElse(0l)\n        val mid = max / 2\n \
    \       val left = arr.take(mid)\n        val right = arr.drop(mid)\n        val\
    \ leftMin = smallestChange(left)\n        val rightMin = smallestChange(right)\n\
    \        val leftMax = smallestChange(left.reverse)\n        val rightMax = smallestChange(right.reverse)\n\
    \        val leftMinMax = smallestChange(left.reverse ++ right)\n        val rightMinMax\
    \ = smallestChange(right ++ left.reverse)\n        val leftMinMaxMax = smallestChange(left.reverse\
    \ ++ right.reverse)\n        val leftMinMaxMaxMax = smallestChange(left.reverse\
    \ ++ right.reverse ++ right)\n        val leftMinMaxMaxMaxMax = smallestChange(left.reverse\
    \ ++ right.reverse ++ right.reverse ++ right)\n        val leftMinMaxMaxMaxMaxMax\
    \ = smallestChange(left.reverse ++ right.reverse ++ right.reverse ++ right.reverse\
    \ ++ right)\n        val leftMinMaxMaxMaxMaxMaxMax = smallestChange(left.reverse\
    \ ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse ++ right)\n\
    \        val leftMinMaxMaxMaxMaxMaxMaxMax = smallestChange(left.reverse ++ right.reverse\
    \ ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse ++ right)\n\
    \        val leftMinMaxMaxMaxMaxMaxMaxMax = smallestChange(left.reverse ++ right.reverse\
    \ ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse\
    \ ++ right)\n        val leftMinMaxMaxMaxMaxMaxMaxMaxMax = smallestChange(left.reverse\
    \ ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse\
    \ ++ right.reverse ++ right.reverse ++ right)\n        val leftMinMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = smallestChange(left.reverse ++ right.reverse ++ right.reverse ++ right.reverse\
    \ ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse\
    \ ++ right)\n        val leftMinMaxMaxMaxMaxMaxMaxMaxMaxMax = smallestChange(left.reverse\
    \ ++ right.reverse ++ right.reverse ++ right.reverse ++ right\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi1gzyheq.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi1gzyheq.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftMinMaxMaxMaxMaxMaxMaxMax\e[0m = smallestChange(left.reverse ++ right.reverse\
    \ ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse ++ right.reverse\
    \ ++ right)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinMaxMaxMaxMaxMaxMaxMax is already defined as \e[33mvalue\e\
    [0m \e[35mleftMinMaxMaxMaxMaxMaxMaxMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi1gzyheq.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mleftMinMaxMaxMaxMaxMaxMaxMaxMaxMax\e\
    [0m = smallestChange(left.reverse ++ right.reverse ++ right.reverse ++ right.reverse\
    \ ++ right\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinMaxMaxMaxMaxMaxMaxMaxMaxMax is already defined as \e\
    [33mvalue\e[0m \e[35mleftMinMaxMaxMaxMaxMaxMaxMaxMaxMax\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi1gzyheq.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi1gzyheq.scal"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.length\n     \
    \   val minChange = arr.take(n/2).foldLeft(0)((acc, x) => acc + x)\n        val\
    \ maxChange = arr.takeRight(n/2).foldLeft(0)((acc, x) => acc + x)\n        minChange\
    \ < maxChange ? minChange : maxChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5au7e5ot.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5au7e5ot.scala:19:44 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        minChange < maxChange ? minChange : \e[35mmaxChange\e\
    [0m\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: type\
    \ maxChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ArrayBuffer(0)\n        val change\
    \ = mutable.ArrayBuffer(0)\n        val changed = mutable.ArrayBuffer(0)\n   \
    \     val changeIndex = mutable.ArrayBuffer(0)\n        val changeIndex2 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex3 = mutable.ArrayBuffer(0)\n        val changeIndex4 =\
    \ mutable.ArrayBuffer(0)\n        val changeIndex5 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex6 = mutable.ArrayBuffer(0)\n        val changeIndex7 =\
    \ mutable.ArrayBuffer(0)\n        val changeIndex8 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex9 = mutable.ArrayBuffer(0)\n        val changeIndex10\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex11 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex12 = mutable.ArrayBuffer(0)\n        val changeIndex13\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex14 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex15 = mutable.ArrayBuffer(0)\n        val changeIndex16\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex17 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex18 = mutable.ArrayBuffer(0)\n        val changeIndex19\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex20 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex21 = mutable.ArrayBuffer(0)\n        val changeIndex22\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex23 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex24 = mutable.ArrayBuffer(0)\n        val changeIndex25\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex26 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex27 = mutable.ArrayBuffer(0)\n        val changeIndex28\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex29 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex30 = mutable.ArrayBuffer(0)\n        val changeIndex31\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex32 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex33 = mutable.ArrayBuffer(0)\n        val changeIndex34\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex35 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex36 = mutable.ArrayBuffer(0)\n        val changeIndex37\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex38 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex39 = mutable.ArrayBuffer(0)\n        val changeIndex40\
    \ = mutable.Array\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9y830xjl.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9y830xjl.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9y830xjl.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9y830xjl.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9y830xjl.scala:21:26 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9y830xjl.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex2\e[0m = mut"
  stdout: ''
  timestamp: 1659805576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n \
    \       val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n        val r = arr.init.reverse\n        val m = arr.last\n\
    \        val d = arr.head\n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtbjtbhw.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtbjtbhw.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtbjtbhw.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtbjtbhw.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdtbjtbhw.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.head\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e\
    [0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpdtbjtbhw.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m     "
  stdout: ''
  timestamp: 1659805576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var min = n\n        var max = 0\n        while(i < n && j < m) {\n   \
    \         if(arr(i) < arr(j)) {\n                min = Math.min(min, k + 1)\n\
    \                k = k + 1\n            }\n            else if(arr(i) > arr(j))\
    \ {\n                max = Math.max(max, k + 1)\n                k = k + 1\n \
    \           }\n            else {\n                i = i + 1\n               \
    \ j = j + 1\n            }\n        }\n        if(min < n) {\n            min\
    \ = n\n        }\n        if(max < m) {\n            max = m\n        }\n    \
    \    if(min == n) {\n            min = 0\n        }\n        if(max == m) {\n\
    \            max = 0\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8p8xog3l.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        var temp = 0\n    \
    \    var count = 0\n        while (i < n) {\n            while (j < n) {\n   \
    \             if (arr(i) == arr(j)) {\n                    p(i) = arr(i)\n   \
    \                 j = j + 1\n                    k = k + 1\n                }\n\
    \                else {\n                    p(i) = arr(j)\n                 \
    \   j = j + 1\n                }\n            }\n            i = i + 1\n     \
    \       j = k\n            k = k + 1\n        }\n        val l = p.length\n  \
    \      val r = p.last\n        while (l > 1) {\n            temp = p.last\n  \
    \          p.last = p(l - 1)\n            p(l - 1) = temp\n            l = l -\
    \ 1\n        }\n        while (l > 0) {\n            temp = p.last\n         \
    \   p.last = p(l - 1)\n            p(l - 1) = temp\n            l = l - 1\n  \
    \      }\n        while (l > 0) {\n            temp = p.last\n            p.last\
    \ = p(l - 1)\n            p(l - 1) = temp\n            l = l - 1\n        }\n\
    \        while (l > 0) {\n            temp = p.last\n            p.last = p(l\
    \ - 1)\n            p(l - 1) = temp\n            l = l - 1\n        }\n      \
    \  while (l > 0) {\n            temp = p.last\n            p.last = p(l - 1)\n\
    \            p(l - 1) = temp\n            l = l - 1\n        }\n        while\
    \ (l > 0) {\n            temp = p.last\n            p.last = p(l - 1)\n      \
    \      p(l - 1) = temp\n            l = l - 1\n        }\n        while (l > 0)\
    \ {\n            temp = p.last\n            p.last = p(l - 1)\n            p(l\
    \ - 1) = temp\n            l = l - 1\n        }\n        while (l > 0) {\n   \
    \         temp = p.last\n            p.last = p(l - 1)\n            p(l - 1) =\
    \ temp\n            l = l - 1\n        }\n        while (l > 0) {\n          \
    \  temp = p.last\n            p.last = p(l - 1)\n            p(l - 1) = temp\n\
    \            l = l - 1\n        }\n        while (l > 0) {\n            temp =\
    \ p.last\n            p.last = p(l - 1)\n            p(l - 1) = temp\n       \
    \     l = l - 1\n        }\n        while (l > 0) {\n            temp = p.last\n\
    \            p.last = p(l - 1)\n            p(l - 1) = temp\n            l = l\
    \ - 1\n        }\n        while (l > 0) {\n            temp = p.last\n       \
    \     p.last = p(l - 1)\n            p(l - 1) = temp\n            \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6aj5gbx3.scala:127:0 ---------------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6aj5gbx3.scala:44:21\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m            temp = p.last\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        Found:    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp6aj5gbx3.scala:45:19 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            p.last = p(l - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6aj5gbx3.scala:47:14\
    \ -----------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            l = l -\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6aj5gbx3.scala:50:21 --------------------\e[0m\e\
    [0m\n\e[31m50 |\e[0m            temp = p.last\n\e[31m\e[31m   |\e[0m         \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Long\n\e[31m\
    \   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp6aj5gbx3.scala:51:19 -----------------------------\e[0m\e\
    [0m\n\e[31m51 |\e[0m            p.last = p(l - \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6aj5gbx3.scala:53:14\
    \ -----------------------------\e[0m\e[0m\n\e[31m53 |\e[0m            l = l"
  stdout: ''
  timestamp: 1659805577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val max = (arr.head + arr.last) / 2\n        val max2\
    \ = max / 2\n        val max3 = max / 3\n        val max4 = max / 4\n        val\
    \ max5 = max / 5\n        val max6 = max / 6\n        val max7 = max / 7\n   \
    \     val max8 = max / 8\n        val max9 = max / 9\n        val max10 = max\
    \ / 10\n        val max11 = max / 11\n        val max12 = max / 12\n        val\
    \ max13 = max / 13\n        val max14 = max / 14\n        val max15 = max / 15\n\
    \        val max16 = max / 16\n        val max17 = max / 17\n        val max18\
    \ = max / 18\n        val max19 = max / 19\n        val max20 = max / 20\n   \
    \     val max21 = max / 21\n        val max22 = max / 22\n        val max23 =\
    \ max / 23\n        val max24 = max / 24\n        val max25 = max / 25\n     \
    \   val max26 = max / 26\n        val max27 = max / 27\n        val max28 = max\
    \ / 28\n        val max29 = max / 29\n        val max30 = max / 30\n        val\
    \ max31 = max / 31\n        val max32 = max / 32\n        val max33 = max / 33\n\
    \        val max34 = max / 34\n        val max35 = max / 35\n        val max36\
    \ = max / 36\n        val max37 = max / 37\n        val max38 = max / 38\n   \
    \     val max39 = max / 39\n        val max40 = max / 40\n        val max41 =\
    \ max / 41\n        val max42 = max / 42\n        val max43 = max / 43\n     \
    \   val max44 = max / 44\n        val max45 = max / 45\n        val max46 = max\
    \ / 46\n        val max47 = max / 47\n        val max48 = max / 48\n        val\
    \ max49 = max / 49\n        val max50 = max / 50\n        val max51 = max / 51\n\
    \        val max52 = max / 52\n        val max53 = max / 53\n        val max54\
    \ = max / 54\n        val max55 = max / 55\n        val max56 = max / 56\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqzx6qxie.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqzx6qxie.scala:74:5 ---------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        var count\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp\
    \ = 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n \
    \       var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var\
    \ temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11\
    \ = 0\n        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n\
    \        var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n    \
    \    var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var\
    \ temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24\
    \ = 0\n        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n\
    \        var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n    \
    \    var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var\
    \ temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37\
    \ = 0\n        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n\
    \        var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n    \
    \    var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var\
    \ temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50\
    \ = 0\n        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n\
    \        var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n    \
    \    var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var\
    \ temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63\
    \ = 0\n        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n\
    \        var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n    \
    \    var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var\
    \ temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76\
    \ = 0\n        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n\
    \        var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n    \
    \    var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var\
    \ temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89\
    \ = 0\n        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n\
    \        var temp93 = 0\n        var temp\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf_92z5gq.scala:117:4 ---------------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf_92z5gq.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf_92z5gq.scala:117:5\
    \ --------------------\e[0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var k = 0\n        var minChange =\
    \ 0\n        while (i < len) {\n            while (j < len) {\n              \
    \  if (arr(i) == arr(j)) {\n                    j++\n                } else {\n\
    \                    k++\n                }\n            }\n            minChange\
    \ = k\n            i = j\n            j = k\n            k = 0\n        }\n  \
    \      minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpej9zsbe8.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpej9zsbe8.scala:26:23 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpej9zsbe8.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val x = arr(i)\n            val y = arr(j)\n\
    \            val z = arr(k)\n            if (x == y && x == z) {\n           \
    \     min = Math.min(min, i - k + 1)\n                i = i + 1\n            \
    \    j = j + 1\n                k = k + 1\n            } else if (x == y || x\
    \ == z) {\n                i = i + 1\n            } else if (y == z) {\n     \
    \           j = j + 1\n            } else {\n                k = k + 1\n     \
    \       }\n        }\n        min\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmplmy_r6vh.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplmy_r6vh.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexArr\
    \ = 0\n        val minChangeIndexArr2 = len\n        val minChangeIndexArr3 =\
    \ len\n        val minChangeIndexArr4 = len\n        val minChangeIndexArr5 =\
    \ len\n        val minChangeIndexArr6 = len\n        val minChangeIndexArr7 =\
    \ len\n        val minChangeIndexArr8 = len\n        val minChangeIndexArr9 =\
    \ len\n        val minChangeIndexArr10 = len\n        val minChangeIndexArr11\
    \ = len\n        val minChangeIndexArr12 = len\n        val minChangeIndexArr13\
    \ = len\n        val minChangeIndexArr14 = len\n        val minChangeIndexArr15\
    \ = len\n        val minChangeIndexArr16 = len\n        val minChangeIndexArr17\
    \ = len\n        val minChangeIndexArr18 = len\n        val minChangeIndexArr19\
    \ = len\n        val minChangeIndexArr20 = len\n        val minChangeIndexArr21\
    \ = len\n        val minChangeIndexArr22 = len\n        val minChangeIndexArr23\
    \ = len\n        val minChangeIndexArr24 = len\n        val minChangeIndexArr25\
    \ = len\n        val minChangeIndexArr26 = len\n        val minChangeIndexArr27\
    \ = len\n        val minChangeIndexArr28 = len\n        val minChangeIndexArr29\
    \ = len\n        val minChangeIndexArr30 = len\n        val minChangeIndexArr31\
    \ = len\n        val minChangeIndexArr32 = len\n        val minChangeIndexArr33\
    \ = len\n        val minChangeIndexArr34 = len\n        val minChangeIndexArr35\
    \ = len\n        val minChangeIndexArr36 = len\n        val minChangeIndexArr37\
    \ = len\n        val minChangeIndexArr38 = len\n        val minChangeIndexArr39\
    \ = len\n        val minChangeIndexArr40 = len\n        val minChangeIndexArr41\
    \ = len\n        val minChangeIndexArr42 = len\n        val minChangeIndexArr43\
    \ = len\n        val minChangeIndexArr44 = len\n        val minChangeIndexArr45\
    \ = len\n        val minChangeIndexArr46 = len\n        val minChangeIndexArr47\
    \ = len\n        val minChangeIndexArr48 = len\n        val minChangeIndexArr49\
    \ = len\n        val minChangeIndexArr50 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp48dyl0is.scala:68:33 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArr50\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp48dyl0is.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48dyl0is.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ r = arr.last\n        val changes = mutable.ArrayBuffer(r.toLong)\n        val\
    \ changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n        val change = mutable.ArrayBuffer(r.toLong)\n\
    \        val changed = mutable.ArrayBuffer(r.toLong)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv8ootsib.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer(r.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv8ootsib.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer(r.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv8ootsib.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer(r.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv8ootsib.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer(r.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv8ootsib.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer(r.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31"
  stdout: ''
  timestamp: 1659805576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ d = arr.last\n        val r = arr.init\n        val s = arr.tail\n        val\
    \ c = arr.init\n        val d = arr.last\n        val r = arr.init\n        val\
    \ s = arr.tail\n        val c = arr.init\n        val d = arr.last\n        val\
    \ r = arr.init\n        val s = arr.tail\n        val c = arr.init\n        val\
    \ d = arr.last\n        val r = arr.init\n        val s = arr.tail\n        val\
    \ c = arr.init\n        val d = arr.last\n        val r = arr.init\n        val\
    \ s = arr.tail\n        val c = arr.init\n        val d = arr.last\n        val\
    \ r = arr.init\n        val s = arr.tail\n        val c = arr.init\n        val\
    \ d = arr.last\n        val r = arr.init\n        val s = arr.tail\n        val\
    \ c = arr.init\n        val d = arr.last\n        val r = arr.init\n        val\
    \ s = arr.tail\n        val c = arr.init\n        val d = arr.last\n        val\
    \ r = arr.init\n        val s = arr.tail\n        val c = arr.init\n        val\
    \ d = arr.last\n        val r = arr.init\n        val s = arr.tail\n        val\
    \ c = arr.init\n        val d = arr.last\n        val r = arr.init\n        val\
    \ s = arr.tail\n        val c = arr.init\n        val d = arr.last\n        val\
    \ r = arr.init\n        val s = arr.tail\n        val c = arr.init\n        val\
    \ d = arr.last\n        val r = arr.init\n        val s = arr.tail\n        val\
    \ c = arr.init\n        val d = arr.last\n        val r = arr.init\n        val\
    \ s = arr.tail\n        val c = arr.init\n        val d = arr.last\n        val\
    \ r = arr.init\n        val s = arr.tail\n        val c = arr.init\n        val\
    \ d = arr.last\n        val r = arr.init\n        val s = arr.tail\n        val\
    \ c = arr.init\n        val d = arr.last\n        val r = arr.init\n        val\
    \ s = arr.tail\n        val c = arr.init\n        val d = arr.last\n        val\
    \ r = arr.init\n        val s = arr.tail\n        val c = arr.init\n        val\
    \ d = arr.last\n        val r = arr.init\n        val s = arr.tail\n        val\
    \ c = arr.init\n        val d = arr.last\n        val r = arr.init\n        val\
    \ s = arr.tail\n        val c = arr.init\n        val d = arr.last\n        val\
    \ r = arr.init\n        val s = arr.tail\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpigx1qtk_.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpigx1qtk_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpigx1qtk_.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpigx1qtk_.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpigx1qtk_.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already defined\
    \ as \e[33mvalue\e[0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpigx1qtk_.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659805576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = (len - 1) * 2\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var count = 0\n        while (i < len)\
    \ {\n            while (j < len) {\n                if (arr(i) == arr(j)) {\n\
    \                    j++\n                    k++\n                } else {\n\
    \                    j++\n                }\n            }\n            while\
    \ (k < len) {\n                if (arr(i) == arr(k)) {\n                    k++\n\
    \                } else {\n                    k++\n                }\n      \
    \      }\n            if (j == len) {\n                count += 1\n          \
    \      j = 0\n            }\n            if (k == len) {\n                count\
    \ += 1\n                k = 0\n            }\n            i += 1\n        }\n\
    \        if (count < min) {\n            min = count\n        }\n        if (count\
    \ > max) {\n            max = count\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1e8qt8v7.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp1e8qt8v7.scala:29:23 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1e8qt8v7.scala:34:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp1e8qt8v7.scala:36:23 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp1e8qt8v7.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp1e8qt8v7.scala:26:21 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m                    j++\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\
    \e[31m   |\e[0m                    value ++ is not a member of Int\n\e[31m\e[31m--\
    \ [E052] Type Error: "
  stdout: ''
  timestamp: 1659805576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n\
    \        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n       \
    \ var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp95 = 0\n        var temp96 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprmzno6b5.scala:118:5\
    \ --------------------\e[0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var minIndex = 0\n        var maxIndex = 0\n        while (i < len) {\n\
    \            while (j < len) {\n                if (arr(i) == arr(j)) {\n    \
    \                j++\n                }\n                else {\n            \
    \        j = 0\n                }\n            }\n            k = i\n        \
    \    while (k >= 0) {\n                if (arr(k) == arr(len - k)) {\n       \
    \             k--\n                }\n                else {\n               \
    \     k = 0\n                }\n            }\n            if (k > 0) {\n    \
    \            min = arr(i)\n                minIndex = i\n                max =\
    \ arr(len - k)\n                maxIndex = len - k\n            }\n          \
    \  i += 1\n        }\n        if (min == 0) {\n            return 0\n        }\n\
    \        if (maxIndex == minIndex) {\n            return minIndex\n        }\n\
    \        if (maxIndex < minIndex) {\n            return minIndex\n        }\n\
    \        return maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpslwu6h3j.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpslwu6h3j.scala:35:23 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                    k--\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpslwu6h3j.scala:15:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m   |\e[0m                    \
    \         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded function:\n\
    \e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpslwu6h3j.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e\
    [33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpslwu6h3j.scala:44:20 -----------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                max = arr(len - k)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val <none>\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n     \
    \   var minChangeIndex3 = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5\
    \ = 0\n        var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n    \
    \    var minChangeIndex8 = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10\
    \ = 0\n        var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n  \
    \      var minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var\
    \ minChangeIndex15 = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17\
    \ = 0\n        var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n  \
    \      var minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var\
    \ minChangeIndex22 = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24\
    \ = 0\n        var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n  \
    \      var minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var\
    \ minChangeIndex29 = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31\
    \ = 0\n        var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n  \
    \      var minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var\
    \ minChangeIndex36 = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38\
    \ = 0\n        var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n  \
    \      var minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var\
    \ minChangeIndex43 = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45\
    \ = 0\n        var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n  \
    \      var minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var\
    \ minChangeIndex50 = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52\
    \ = 0\n        var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n  \
    \      var minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var\
    \ minChangeIndex57 = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59\
    \ = 0\n        var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n  \
    \      var minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var\
    \ minChangeIndex64 = 0\n        var minChangeIndex65 = 0\n        var minChangeIndex66\
    \ = 0\n        var minChangeIndex67 = 0\n        var minChangeIndex68 = 0\n  \
    \      var minChangeIndex69 = 0\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9qrx2pc8.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp9qrx2pc8.scala:90:5 ---------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            while (j < len) {\n                if (arr(i) != arr(j))\
    \ {\n                    minChange = minChange - 1\n                    j++\n\
    \                } else {\n                    j++\n                }\n      \
    \      }\n            i = i + 1\n            j = j + 1\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdlc323sn.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpdlc323sn.scala:26:23 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdlc323sn.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdlc323sn.scala:23:30\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                   \
    \ minChange = minChange - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var min = 0\n        var temp = 0\n\
    \        while (i < len) {\n            while (j < len) {\n                if\
    \ (arr(i) == arr(j)) {\n                    temp = arr(i)\n                  \
    \  arr(i) = arr(j)\n                    arr(j) = temp\n                    j++\n\
    \                }\n                j++\n            }\n            i++\n    \
    \        j = 0\n            min = arr.min\n        }\n        min\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp70c7f9bg.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp70c7f9bg.scala:29:19 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                j++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp70c7f9bg.scala:32:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m \
    \             ^\e[0m\n\e[31m   |\e[0m              end of statement expected but\
    \ '=' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp70c7f9bg.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp70c7f9bg.scala:31:13\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m            value ++ is not\
    \ a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var minChange = 0\n        var minChangeIndex = 0\n        var\
    \ minChangeLen = 0\n        var minChangeIndexLen = 0\n        var minChangeIndexLen2\
    \ = 0\n        var minChangeIndexLen3 = 0\n        var minChangeIndexLen4 = 0\n\
    \        var minChangeIndexLen5 = 0\n        var minChangeIndexLen6 = 0\n    \
    \    var minChangeIndexLen7 = 0\n        var minChangeIndexLen8 = 0\n        var\
    \ minChangeIndexLen9 = 0\n        var minChangeIndexLen10 = 0\n        var minChangeIndexLen11\
    \ = 0\n        var minChangeIndexLen12 = 0\n        var minChangeIndexLen13 =\
    \ 0\n        var minChangeIndexLen14 = 0\n        var minChangeIndexLen15 = 0\n\
    \        var minChangeIndexLen16 = 0\n        var minChangeIndexLen17 = 0\n  \
    \      var minChangeIndexLen18 = 0\n        var minChangeIndexLen19 = 0\n    \
    \    var minChangeIndexLen20 = 0\n        var minChangeIndexLen21 = 0\n      \
    \  var minChangeIndexLen22 = 0\n        var minChangeIndexLen23 = 0\n        var\
    \ minChangeIndexLen24 = 0\n        var minChangeIndexLen25 = 0\n        var minChangeIndexLen26\
    \ = 0\n        var minChangeIndexLen27 = 0\n        var minChangeIndexLen28 =\
    \ 0\n        var minChangeIndexLen29 = 0\n        var minChangeIndexLen30 = 0\n\
    \        var minChangeIndexLen31 = 0\n        var minChangeIndexLen32 = 0\n  \
    \      var minChangeIndexLen33 = 0\n        var minChangeIndexLen34 = 0\n    \
    \    var minChangeIndexLen35 = 0\n        var minChangeIndexLen36 = 0\n      \
    \  var minChangeIndexLen37 = 0\n        var minChangeIndexLen38 = 0\n        var\
    \ minChangeIndexLen39 = 0\n        var minChangeIndexLen40 = 0\n        var minChangeIndexLen41\
    \ = 0\n        var minChangeIndexLen42 = 0\n        var minChangeIndexLen43 =\
    \ 0\n        var minChangeIndexLen44 = 0\n        var minChangeIndexLen45 = 0\n\
    \        var minChangeIndexLen46 = 0\n        var minChangeIndexLen47 = 0\n  \
    \      var minChangeIndexLen48 = 0\n        var minChangeIndexLen49 = 0\n    \
    \    var minChangeIndexLen50 = 0\n        var minChangeIndexLen51 = 0\n      \
    \  var minChangeIndexLen52 = 0\n        var minChangeIndexLen53 = 0\n        var\
    \ minChangeIndexLen54 = 0\n        var minChangeIndexLen55 = 0\n        var minChangeIndexLen56\
    \ = 0\n        var minChangeIndexLen57 = 0\n        var minChangeIndexLen58 =\
    \ 0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi29929ur.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpi29929ur.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val len = arr.length\n        val max = (len / 2) -\
    \ 1\n        val min = (len / 2)\n        val maxI = n - max\n        val minI\
    \ = n - min\n        var i = 0\n        var j = 0\n        var k = 0\n       \
    \ var k1 = n - 1\n        var k2 = n - 1\n        var k3 = n - 1\n        var\
    \ k4 = n - 1\n        var k5 = n - 1\n        var k6 = n - 1\n        var k7 =\
    \ n - 1\n        var k8 = n - 1\n        var k9 = n - 1\n        var k10 = n -\
    \ 1\n        var k11 = n - 1\n        var k12 = n - 1\n        var k13 = n - 1\n\
    \        var k14 = n - 1\n        var k15 = n - 1\n        var k16 = n - 1\n \
    \       var k17 = n - 1\n        var k18 = n - 1\n        var k19 = n - 1\n  \
    \      var k20 = n - 1\n        var k21 = n - 1\n        var k22 = n - 1\n   \
    \     var k23 = n - 1\n        var k24 = n - 1\n        var k25 = n - 1\n    \
    \    var k26 = n - 1\n        var k27 = n - 1\n        var k28 = n - 1\n     \
    \   var k29 = n - 1\n        var k30 = n - 1\n        var k31 = n - 1\n      \
    \  var k32 = n - 1\n        var k33 = n - 1\n        var k34 = n - 1\n       \
    \ var k35 = n - 1\n        var k36 = n - 1\n        var k37 = n - 1\n        var\
    \ k38 = n - 1\n        var k39 = n - 1\n        var k40 = n - 1\n        var k41\
    \ = n - 1\n        var k42 = n - 1\n        var k43 = n - 1\n        var k44 =\
    \ n - 1\n        var k45 = n - 1\n        var k46 = n - 1\n        var k47 = n\
    \ - 1\n        var k48 = n - 1\n        var k49 = n - 1\n        var k50 = n -\
    \ 1\n        var k51 = n - 1\n        var k52 = n - 1\n        var k53 = n - 1\n\
    \        var k54 = n - 1\n        var k55 = n - 1\n        var k56 = n - 1\n \
    \       var k57 = n - 1\n        var k58 = n - 1\n        var k59 = n - 1\n  \
    \      var k60 = n - 1\n        var k61 = n - 1\n        var k62 = n - 1\n   \
    \     var k63 = n - 1\n        var k64 = n - 1\n        var k65 = n - 1\n    \
    \    var k\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4dipzand.scala:92:4 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4dipzand.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4dipzand.scala:92:5\
    \ ---------------------\e[0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var max = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        while(i < len) {\n         \
    \   max = arr(i)\n            while(j < len) {\n                if(arr(j) < max)\
    \ {\n                    max = arr(j)\n                }\n                j++\n\
    \            }\n            min = max\n            while(j < len) {\n        \
    \        if(arr(j) > max) {\n                    max = arr(j)\n              \
    \  }\n                j++\n            }\n            if(max != min) {\n     \
    \           temp = max\n                max = min\n                min = temp\n\
    \            }\n            i++\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp07yqznfc.scala:29:19 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp07yqznfc.scala:36:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                j++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmp07yqznfc.scala:43:15 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            i++\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp07yqznfc.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ var i = 0\n        var j = 0\n        var changes = 0\n        var minChanges\
    \ = Long.MaxValue\n        while (i < n) {\n            while (j < n) {\n    \
    \            if (arr(i) == arr(j)) {\n                    j++\n              \
    \  }\n                else {\n                    changes = changes + 1\n    \
    \                if (changes < minChanges) {\n                        minChanges\
    \ = changes\n                    }\n                    j = 0\n              \
    \  }\n            }\n            i += 1\n            j = 0\n        }\n      \
    \  minChanges\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl0ybjhch.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpl0ybjhch.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ val m = arr.head\n        val max = (n - 1).toLong\n        val min = 0l\n \
    \       var i = 0\n        var j = 0\n        var k = 0\n        var count = 0\n\
    \        var minChange = 0l\n        var maxChange = 0l\n        while (i < n)\
    \ {\n            while (j < n) {\n                if (arr(i) == arr(j)) {\n  \
    \                  count += 1\n                    j += 1\n                }\n\
    \                else {\n                    j = 0\n                }\n      \
    \      }\n            while (k < n) {\n                if (arr(i) == arr(k)) {\n\
    \                    k += 1\n                }\n                else {\n     \
    \               k = 0\n                }\n            }\n            if (count\
    \ < min) {\n                min = count\n                minChange = min\n   \
    \         }\n            if (count > max) {\n                max = count\n   \
    \             maxChange = max\n            }\n            count = 0\n        \
    \    i = 0\n            j = 0\n            k = 0\n        }\n        if (minChange\
    \ == maxChange) {\n            return 0\n        }\n        if (minChange < maxChange)\
    \ {\n            return minChange\n        }\n        return maxChange\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplsg2y9bm.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmplsg2y9bm.scala:45:20 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                min = count\n\e[31m\e[31m   |\e[0m  \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to\
    \ val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmplsg2y9bm.scala:49:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m49 |\e[0m                max\
    \ = count\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmprd98qnmn.scala:63:11 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmprd98qnmn.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprd98qnmn.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var minChangeCount = 0\n        var minChangeIndex\
    \ = 0\n        var minChangeIndex2 = -1\n        var minChangeIndex3 = -1\n  \
    \      var minChangeIndex4 = -1\n        var minChangeIndex5 = -1\n        var\
    \ minChangeIndex6 = -1\n        var minChangeIndex7 = -1\n        var minChangeIndex8\
    \ = -1\n        var minChangeIndex9 = -1\n        var minChangeIndex10 = -1\n\
    \        var minChangeIndex11 = -1\n        var minChangeIndex12 = -1\n      \
    \  var minChangeIndex13 = -1\n        var minChangeIndex14 = -1\n        var minChangeIndex15\
    \ = -1\n        var minChangeIndex16 = -1\n        var minChangeIndex17 = -1\n\
    \        var minChangeIndex18 = -1\n        var minChangeIndex19 = -1\n      \
    \  var minChangeIndex20 = -1\n        var minChangeIndex21 = -1\n        var minChangeIndex22\
    \ = -1\n        var minChangeIndex23 = -1\n        var minChangeIndex24 = -1\n\
    \        var minChangeIndex25 = -1\n        var minChangeIndex26 = -1\n      \
    \  var minChangeIndex27 = -1\n        var minChangeIndex28 = -1\n        var minChangeIndex29\
    \ = -1\n        var minChangeIndex30 = -1\n        var minChangeIndex31 = -1\n\
    \        var minChangeIndex32 = -1\n        var minChangeIndex33 = -1\n      \
    \  var minChangeIndex34 = -1\n        var minChangeIndex35 = -1\n        var minChangeIndex36\
    \ = -1\n        var minChangeIndex37 = -1\n        var minChangeIndex38 = -1\n\
    \        var minChangeIndex39 = -1\n        var minChangeIndex40 = -1\n      \
    \  var minChangeIndex41 = -1\n        var minChangeIndex42 = -1\n        var minChangeIndex43\
    \ = -1\n        var minChangeIndex44 = -1\n        var minChangeIndex45 = -1\n\
    \        var minChangeIndex46 = -1\n        var minChangeIndex47 = -1\n      \
    \  var minChangeIndex48 = -1\n        var minChangeIndex49 = -1\n        var minChangeIndex50\
    \ = -1\n        var minChangeIndex51 = -1\n        var minChangeIndex52 = -1\n\
    \        var minChangeIndex53 = -1\n        var minChangeIndex54 = -1\n      \
    \  var minChangeIndex55 = -1\n        var minChangeIndex56 = -1\n        var minChangeIndex57\
    \ = -1\n        var minChangeIndex58 = -1\n        var minChangeIndex59 = -1\n\
    \        var minChangeIndex60 = -1\n        var minChangeIndex61 = -1\n      \
    \  var minChangeIndex62 = -1\n        var minChangeIndex63 = -1\n        var minChangeIndex64\
    \ = -1\n        var minChangeIndex65 = -1\n        var minChangeIndex66 = -1\n\
    \        var minChangeIndex67 = -1\n        var minChangeIndex68\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps5d2xbp6.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps5d2xbp6.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps5d2xbp6.scala:87:5\
    \ ---------------------\e[0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val len = arr.length\n        val maxLen = len / 2\n\
    \        val maxLen2 = len / 3\n        val maxLen3 = len / 4\n        val maxLen4\
    \ = len / 5\n        val maxLen5 = len / 6\n        val maxLen6 = len / 7\n  \
    \      val maxLen7 = len / 8\n        val maxLen8 = len / 9\n        val maxLen9\
    \ = len / 10\n        val maxLen10 = len / 11\n        val maxLen11 = len / 12\n\
    \        val maxLen12 = len / 13\n        val maxLen13 = len / 14\n        val\
    \ maxLen14 = len / 15\n        val maxLen15 = len / 16\n        val maxLen16 =\
    \ len / 17\n        val maxLen17 = len / 18\n        val maxLen18 = len / 19\n\
    \        val maxLen19 = len / 20\n        val maxLen20 = len / 21\n        val\
    \ maxLen21 = len / 22\n        val maxLen22 = len / 23\n        val maxLen23 =\
    \ len / 24\n        val maxLen24 = len / 25\n        val maxLen25 = len / 26\n\
    \        val maxLen26 = len / 27\n        val maxLen27 = len / 28\n        val\
    \ maxLen28 = len / 29\n        val maxLen29 = len / 30\n        val maxLen30 =\
    \ len / 31\n        val maxLen31 = len / 32\n        val maxLen32 = len / 33\n\
    \        val maxLen33 = len / 34\n        val maxLen34 = len / 35\n        val\
    \ maxLen35 = len / 36\n        val maxLen36 = len / 37\n        val maxLen37 =\
    \ len / 38\n        val maxLen38 = len / 39\n        val maxLen39 = len / 40\n\
    \        val maxLen40 = len / 41\n        val maxLen41 = len / 42\n        val\
    \ maxLen42 = len / 43\n        val maxLen43 = len / 44\n        val maxLen44 =\
    \ len / 45\n        val maxLen45 = len / 46\n        val maxLen46 = len / 47\n\
    \        val maxLen47 = len / 48\n        val maxLen48 = len / 49\n        val\
    \ maxLen49 = len / 50\n        val maxLen50 = len / 51\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsfqd98he.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsfqd98he.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var temp = 0\n        var change = 0\n        while (i < len) {\n\
    \            while (j < len) {\n                if (arr(i) == arr(j)) {\n    \
    \                temp += 1\n                    j += 1\n                } else\
    \ {\n                    temp = 0\n                    j += 1\n              \
    \  }\n            }\n            while (k < len) {\n                if (arr(i)\
    \ == arr(k)) {\n                    temp += 1\n                    k += 1\n  \
    \              } else {\n                    temp = 0\n                    k +=\
    \ 1\n                }\n            }\n            if (temp < minChange) {\n \
    \               minChange = temp\n                change = arr(i)\n          \
    \  }\n            i += 1\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqw4wro23.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpqw4wro23.scala:43:26 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                minChange = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = len\n        var i = 0\n        var j = 0\n        while(i < len)\
    \ {\n            while(j < len && arr(i) == arr(j)) {\n                j++\n \
    \           }\n            if(j == len) {\n                min = Math.min(min,\
    \ len - i)\n                j = 0\n            }\n            i += 1\n       \
    \     j += 1\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8ev8417v.scala:22:19 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8ev8417v.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ val m = arr.last\n        val max = (n to m).foldLeft(0)((acc, x) => acc + (x\
    \ - arr(x)))\n        val min = (m to n).foldLeft(0)((acc, x) => acc + (x - arr(x)))\n\
    \        val diff = max - min\n        diff / 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgnf3fv84.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.takeWhile(_ < 0).length\n\
    \        val max = (arr.takeWhile(_ < 0).reverse).length\n        val min = (arr.takeWhile(_\
    \ < 0).reverse).reverse.length\n        val max2 = arr.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.length\n        val min2 = arr.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).length\n        val max3 = arr.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).length\n        val min3 = arr.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.length\n        val max4 = arr.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).length\n        val min4\
    \ = arr.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.length\n        val max5 = arr.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ <\
    \ 0).length\n        val min5 = arr.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.length\n    \
    \    val max6 = arr.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ <\
    \ 0).length\n        val min6 = arr.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ <\
    \ 0).length\n        val max7 = arr.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ <\
    \ 0).reverse.length\n        val min7 = arr.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ <\
    \ 0).reverse.takeWhile(_ < 0).length\n        val max8 = arr.takeWhile(_ < 0).reverse.takeWhile(_\
    \ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ < 0).reverse.takeWhile(_ <\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppf_jm8ji.scala:31:136 --------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmax8\e[0m = arr.takeWhile(_\
    \ < \e[31m0\e[0m).reverse.takeWhile(_ < \e[31m0\e[0m).reverse.takeWhile(_ < \e\
    [31m0\e[0m).reverse.takeWhile(_ < \e[31m0\e[0m).reverse.takeWhile(_ < \n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppf_jm8ji.scala:32:5\
    \ ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ max = (n - 1) / 2\n        val min = (n - 2) / 2\n        var changes = 0\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n       \
    \ var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8\
    \ = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n\
    \        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n    \
    \    var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfb0dgngy.scala:118:5\
    \ --------------------\e[0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val max = (arr.length / 2) - 1\n        val min = 0\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var count =\
    \ 0\n        var maxCount = 0\n        var maxCountIndex = 0\n        var maxCountValue\
    \ = 0\n        var maxCountValueIndex = 0\n        var maxCountValueIndex2 = 0\n\
    \        var maxCountValueIndex3 = 0\n        var maxCountValueIndex4 = 0\n  \
    \      var maxCountValueIndex5 = 0\n        var maxCountValueIndex6 = 0\n    \
    \    var maxCountValueIndex7 = 0\n        var maxCountValueIndex8 = 0\n      \
    \  var maxCountValueIndex9 = 0\n        var maxCountValueIndex10 = 0\n       \
    \ var maxCountValueIndex11 = 0\n        var maxCountValueIndex12 = 0\n       \
    \ var maxCountValueIndex13 = 0\n        var maxCountValueIndex14 = 0\n       \
    \ var maxCountValueIndex15 = 0\n        var maxCountValueIndex16 = 0\n       \
    \ var maxCountValueIndex17 = 0\n        var maxCountValueIndex18 = 0\n       \
    \ var maxCountValueIndex19 = 0\n        var maxCountValueIndex20 = 0\n       \
    \ var maxCountValueIndex21 = 0\n        var maxCountValueIndex22 = 0\n       \
    \ var maxCountValueIndex23 = 0\n        var maxCountValueIndex24 = 0\n       \
    \ var maxCountValueIndex25 = 0\n        var maxCountValueIndex26 = 0\n       \
    \ var maxCountValueIndex27 = 0\n        var maxCountValueIndex28 = 0\n       \
    \ var maxCountValueIndex29 = 0\n        var maxCountValueIndex30 = 0\n       \
    \ var maxCountValueIndex31 = 0\n        var maxCountValueIndex32 = 0\n       \
    \ var maxCountValueIndex33 = 0\n        var maxCountValueIndex34 = 0\n       \
    \ var maxCountValueIndex35 = 0\n        var maxCountValueIndex36 = 0\n       \
    \ var maxCountValueIndex37 = 0\n        var maxCountValueIndex38 = 0\n       \
    \ var maxCountValueIndex39 = 0\n        var maxCountValueIndex40 = 0\n       \
    \ var maxCountValueIndex41 = 0\n        var maxCountValueIndex42 = 0\n       \
    \ var maxCountValueIndex43 = 0\n        var maxCountValueIndex44 = 0\n       \
    \ var maxCountValueIndex45 = 0\n        var maxCountValueIndex46 = 0\n       \
    \ var maxCountValueIndex47 = 0\n        var maxCountValueIndex48 = 0\n       \
    \ var maxCountValueIndex49 = 0\n        var maxCountValueIndex50 = 0\n       \
    \ var maxCountValueIndex51 = 0\n        var maxCountValueIndex52 = 0\n       \
    \ var maxCountValueIndex53 = 0\n        var maxCountValueIndex54 = 0\n       \
    \ var maxCountValueIndex55 = 0\n        var maxCountValueIndex56 = 0\n       \
    \ var \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp7oppdbyl.scala:83:11 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7oppdbyl.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp7oppdbyl.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexArr\
    \ = 0\n        val minChangeIndexArr2 = len\n        val minChangeIndexArr3 =\
    \ len\n        val minChangeIndexArr4 = len\n        val minChangeIndexArr5 =\
    \ len\n        val minChangeIndexArr6 = len\n        val minChangeIndexArr7 =\
    \ len\n        val minChangeIndexArr8 = len\n        val minChangeIndexArr9 =\
    \ len\n        val minChangeIndexArr10 = len\n        val minChangeIndexArr11\
    \ = len\n        val minChangeIndexArr12 = len\n        val minChangeIndexArr13\
    \ = len\n        val minChangeIndexArr14 = len\n        val minChangeIndexArr15\
    \ = len\n        val minChangeIndexArr16 = len\n        val minChangeIndexArr17\
    \ = len\n        val minChangeIndexArr18 = len\n        val minChangeIndexArr19\
    \ = len\n        val minChangeIndexArr20 = len\n        val minChangeIndexArr21\
    \ = len\n        val minChangeIndexArr22 = len\n        val minChangeIndexArr23\
    \ = len\n        val minChangeIndexArr24 = len\n        val minChangeIndexArr25\
    \ = len\n        val minChangeIndexArr26 = len\n        val minChangeIndexArr27\
    \ = len\n        val minChangeIndexArr28 = len\n        val minChangeIndexArr29\
    \ = len\n        val minChangeIndexArr30 = len\n        val minChangeIndexArr31\
    \ = len\n        val minChangeIndexArr32 = len\n        val minChangeIndexArr33\
    \ = len\n        val minChangeIndexArr34 = len\n        val minChangeIndexArr35\
    \ = len\n        val minChangeIndexArr36 = len\n        val minChangeIndexArr37\
    \ = len\n        val minChangeIndexArr38 = len\n        val minChangeIndexArr39\
    \ = len\n        val minChangeIndexArr40 = len\n        val minChangeIndexArr41\
    \ = len\n        val minChangeIndexArr42 = len\n        val minChangeIndexArr43\
    \ = len\n        val minChangeIndexArr44 = len\n        val minChangeIndexArr45\
    \ = len\n        val minChangeIndexArr46 = len\n        val minChangeIndexArr47\
    \ = len\n        val minChangeIndexArr48 = len\n        val minChangeIndexArr49\
    \ = len\n        val minChangeIndexArr50 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp48dyl0is.scala:68:33 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArr50\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp48dyl0is.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48dyl0is.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var max = 0\n        while (i < n) {\n   \
    \         if (arr(i) == arr(n - 1 - i)) {\n                p(k) = arr(i)\n   \
    \             k += 1\n                i += 1\n            } else {\n         \
    \       i += 1\n            }\n        }\n        while (j < n) {\n          \
    \  if (p(j) == p(n - 1 - j)) {\n                p(k) = p(j)\n                k\
    \ += 1\n                j += 1\n            } else {\n                j += 1\n\
    \            }\n        }\n        while (j < n) {\n            if (p(j) == p(n\
    \ - 1 - j)) {\n                p(k) = p(j)\n                k += 1\n         \
    \       j += 1\n            } else {\n                j += 1\n            }\n\
    \        }\n        while (j < n) {\n            if (p(j) == p(n - 1 - j)) {\n\
    \                p(k) = p(j)\n                k += 1\n                j += 1\n\
    \            } else {\n                j += 1\n            }\n        }\n    \
    \    while (j < n) {\n            if (p(j) == p(n - 1 - j)) {\n              \
    \  p(k) = p(j)\n                k += 1\n                j += 1\n            }\
    \ else {\n                j += 1\n            }\n        }\n        while (j <\
    \ n) {\n            if (p(j) == p(n - 1 - j)) {\n                p(k) = p(j)\n\
    \                k += 1\n                j += 1\n            } else {\n      \
    \          j += 1\n            }\n        }\n        while (j < n) {\n       \
    \     if (p(j) == p(n - 1 - j)) {\n                p(k) = p(j)\n             \
    \   k += 1\n                j += 1\n            } else {\n                j +=\
    \ 1\n            }\n        }\n        while (j < n) {\n            if (p(j) ==\
    \ p(n - 1 - j)) {\n                p(k) = p(j)\n                k += 1\n     \
    \           j += 1\n            } else {\n                j += 1\n           \
    \ }\n        }\n        while (j < n) {\n            if (p(j) == p(n - 1 - j))\
    \ {\n                p(k) = p(j)\n                k += 1\n                j +=\
    \ 1\n            } else {\n                j += 1\n            }\n        }\n\
    \        while (j < n) {\n            if (p(j) == p(n - 1 - j)) {\n          \
    \      p(k) = p(j)\n                k += 1\n                j += 1\n         \
    \   } else {\n                j += 1\n            }\n        }\n        while\
    \ (j < n) {\n            if (p(j) == p(n - 1 - j)) {\n                p(k) = p(j)\n\
    \                k += 1\n                j += 1\n            } else {\n      \
    \          j += 1\n            }\n        }\n        while (j < n) {\n       \
    \     if (p(j) == p(n - 1 - j)) {\n                p(k) = p(j)\n             \
    \   k += 1\n                j += 1\n            } else {\n                j +=\
    \ 1\n            }\n        }\n        while (j < n) {\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dds8y5j.scala:146:0 ---------------------------\e\
    [0m\e[0m\n\e[31m146 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8dds8y5j.scala:145:1\
    \ --------------------\e[0m\e[0m\n\e[31m145 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp8dds8y5j.scala:134:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m134 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val maxLen = len / 2\n   \
    \     val maxLen2 = maxLen / 2\n        val maxLen3 = maxLen / 3\n        val\
    \ maxLen4 = maxLen / 4\n        val maxLen5 = maxLen / 5\n        val maxLen6\
    \ = maxLen / 6\n        val maxLen7 = maxLen / 7\n        val maxLen8 = maxLen\
    \ / 8\n        val maxLen9 = maxLen / 9\n        val maxLen10 = maxLen / 10\n\
    \        val maxLen11 = maxLen / 11\n        val maxLen12 = maxLen / 12\n    \
    \    val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen / 14\n        val\
    \ maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n        val maxLen17\
    \ = maxLen / 17\n        val maxLen18 = maxLen / 18\n        val maxLen19 = maxLen\
    \ / 19\n        val maxLen20 = maxLen / 20\n        val maxLen21 = maxLen / 21\n\
    \        val maxLen22 = maxLen / 22\n        val maxLen23 = maxLen / 23\n    \
    \    val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen / 25\n        val\
    \ maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n        val maxLen28\
    \ = maxLen / 28\n        val maxLen29 = maxLen / 29\n        val maxLen30 = maxLen\
    \ / 30\n        val maxLen31 = maxLen / 31\n        val maxLen32 = maxLen / 32\n\
    \        val maxLen33 = maxLen / 33\n        val maxLen34 = maxLen / 34\n    \
    \    val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen / 36\n        val\
    \ maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n        val maxLen39\
    \ = maxLen / 39\n        val maxLen40 = maxLen / 40\n        val maxLen41 = maxLen\
    \ / 41\n        val maxLen42 = maxLen / 42\n        val maxLen43 = maxLen / 43\n\
    \        val maxLen44 = maxLen / 44\n        val maxLen45 = maxLen / 45\n    \
    \    val maxLen46 = maxLen / 46\n        val maxLen47 = maxLen / 47\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyfkz64xv.scala:63:11 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyfkz64xv.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ max = (n / 2).toInt\n        val min = n - max\n        val max2 = max * 2\n\
    \        val min2 = min * 2\n        val max3 = max2 * 2\n        val min3 = min2\
    \ * 2\n        val max4 = max3 * 2\n        val min4 = min3 * 2\n        val max5\
    \ = max4 * 2\n        val min5 = min4 * 2\n        val max6 = max5 * 2\n     \
    \   val min6 = min5 * 2\n        val max7 = max6 * 2\n        val min7 = min6\
    \ * 2\n        val max8 = max7 * 2\n        val min8 = min7 * 2\n        val max9\
    \ = max8 * 2\n        val min9 = min8 * 2\n        val max10 = max9 * 2\n    \
    \    val min10 = min9 * 2\n        val max11 = max10 * 2\n        val min11 =\
    \ min10 * 2\n        val max12 = max11 * 2\n        val min12 = min11 * 2\n  \
    \      val max13 = max12 * 2\n        val min13 = min12 * 2\n        val max14\
    \ = max13 * 2\n        val min14 = min13 * 2\n        val max15 = max14 * 2\n\
    \        val min15 = min14 * 2\n        val max16 = max15 * 2\n        val min16\
    \ = min15 * 2\n        val max17 = max16 * 2\n        val min17 = min16 * 2\n\
    \        val max18 = max17 * 2\n        val min18 = min17 * 2\n        val max19\
    \ = max18 * 2\n        val min19 = min18 * 2\n        val max20 = max19 * 2\n\
    \        val min20 = min19 * 2\n        val max21 = max20 * 2\n        val min21\
    \ = min20 * 2\n        val max22 = max21 * 2\n        val min22 = min21 * 2\n\
    \        val max23 = max22 * 2\n        val min23 = min22 * 2\n        val max24\
    \ = max23 * 2\n        val min24 = min23 * 2\n        val max25 = max24 * 2\n\
    \        val min25 = min24 * 2\n        val max26 = max25 * 2\n        val min26\
    \ = min25 * 2\n        val max27 = max26 * 2\n        val min27 = min26 * 2\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkuia17ye.scala:72:5\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = len - 1\n      \
    \  var change = 0\n        while (i < len) {\n            if (arr(i) != arr(j))\
    \ {\n                change += 1\n            }\n            i += 1\n        \
    \    j -= 1\n        }\n        if (change < minChange) {\n            minChange\
    \ = change\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmys9klv2.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpmys9klv2.scala:29:22 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            minChange = change\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        var count = 0\n        while (i < len) {\n    \
    \        while (j < len) {\n                if (arr(i) == arr(j)) {\n        \
    \            temp = arr(i)\n                    arr(i) = arr(j)\n            \
    \        arr(j) = temp\n                    j++\n                }\n         \
    \       else {\n                    j++\n                }\n            }\n  \
    \          while (k < len) {\n                if (arr(i) == arr(k)) {\n      \
    \              temp = arr(i)\n                    arr(i) = arr(k)\n          \
    \          arr(k) = temp\n                    k++\n                }\n       \
    \         else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr(k)) {\n    \
    \                temp = arr(i)\n                    arr(i) = arr(k)\n        \
    \            arr(k) = temp\n                    k++\n                }\n     \
    \           else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr(k)) {\n    \
    \                temp = arr(i)\n                    arr(i) = arr(k)\n        \
    \            arr(k) = temp\n                    k++\n                }\n     \
    \           else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr(k)) {\n    \
    \                temp = arr(i)\n                    arr(i) = arr(k)\n        \
    \            arr(k) = temp\n                    k++\n                }\n     \
    \           else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr(k)) {\n    \
    \                temp = arr(i)\n                    arr(i) = arr(k)\n        \
    \            arr(k) = temp\n                    k++\n                }\n     \
    \           else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr(k)) {\n    \
    \                temp = arr(i)\n                    arr(i) = arr(k)\n        \
    \            arr(k) = temp\n                    k++\n                }\n     \
    \           else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr(k)) {\n    \
    \                temp = arr(i)\n                    arr(i) = arr(k)\n        \
    \            arr(k) = temp\n                    k++\n                }\n     \
    \           else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr(k)) {\n    \
    \                temp = arr(i)\n                    arr(i) = arr(k)\n        \
    \            arr(k) = temp\n                    k++\n                }\n     \
    \           else {\n                    k++\n                }\n            }\n\
    \            while (k < len) {\n                if (arr(i) == arr\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpluio3l2q.scala:29:23 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpluio3l2q.scala:32:23 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpluio3l2q.scala:40:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpluio3l2q.scala:43:23 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpluio3l2q.scala:51:23 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpluio3l2q.scala:54:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m54 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1660010214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val p\
    \ = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        var temp = 0\n    \
    \    var count = 0\n        while (i < n) {\n            temp = arr(i)\n     \
    \       while (j < n) {\n                if (temp == arr(j)) {\n             \
    \       p(i) = arr(j)\n                    count += 1\n                    j++\n\
    \                }\n                else {\n                    p(i) = temp\n\
    \                    j++\n                }\n            }\n            i = i\
    \ + 1\n            min = math.min(min, count)\n            max = math.max(max,\
    \ count)\n            count = 0\n        }\n        if (min == 0) {\n        \
    \    return 0\n        }\n        if (min == n) {\n            return n\n    \
    \    }\n        if (min == max - 1) {\n            return max - 2\n        }\n\
    \        if (min == max - 2) {\n            return max - 3\n        }\n      \
    \  if (min == max - 3) {\n            return max - 4\n        }\n        if (min\
    \ == max - 4) {\n            return max - 5\n        }\n        if (min == max\
    \ - 5) {\n            return max - 6\n        }\n        if (min == max - 6) {\n\
    \            return max - 7\n        }\n        if (min == max - 7) {\n      \
    \      return max - 8\n        }\n        if (min == max - 8) {\n            return\
    \ max - 9\n        }\n        if (min == max - 9) {\n            return max -\
    \ 10\n        }\n        if (min == max - 10) {\n            return max - 11\n\
    \        }\n        if (min == max - 11) {\n            return max - 12\n    \
    \    }\n        if (min == max - 12) {\n            return max - 13\n        }\n\
    \        if (min == max - 13) {\n            return max - 14\n        }\n    \
    \    if (min == max - 14) {\n            return max - 15\n        }\n        if\
    \ (min == max - 15) {\n            return max - 16\n        }\n        if (min\
    \ == max - 16) {\n            return max - 17\n        }\n        if (min == max\
    \ - 17) {\n            return max - 18\n        }\n        if (min == max - 18)\
    \ {\n            return max - 19\n        }\n        if (min == max - 19) {\n\
    \            return max - 20\n        }\n        if (min == max - 20) {\n    \
    \        return max - 21\n        }\n        if (min == max - 21) {\n        \
    \    return max - 22\n        }\n        if (min == max - 22) {\n            return\
    \ max - 23\n        }\n        if (min == max - 23) {\n            return max\
    \ - 24\n        }\n        if (min == max - 24) {\n            return max - 25\n\
    \        }\n        if (min == max - 25) {\n            return max - 26\n    \
    \    }\n        if (min == max - 26) {\n            return max - 27\n        }\n\
    \        if (min == max - 27) {\n            return max - 28\n        }\n    \
    \    if (min == max - 28) {\n            return max - 29\n        }\n        if\
    \ (min == max - 29\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphopjuc42.scala:31:23 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmphopjuc42.scala:35:23 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphopjuc42.scala:134:4\
    \ ---------------------------\e[0m\e[0m\n\e[31m134 |\e[0m    }\n\e[31m\e[31m \
    \   |\e[0m    ^\e[0m\n\e[31m    |\e[0m    ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphopjuc42.scala:26:22 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            temp = arr(i)\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Long\n\
    \e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ListBuffer[Long]()\n        val\
    \ change = mutable.ListBuffer[Long]()\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var k1 = n - 1\n        var k2 = n - 1\n        var\
    \ k3 = n - 1\n        var k4 = n - 1\n        var k5 = n - 1\n        var k6 =\
    \ n - 1\n        var k7 = n - 1\n        var k8 = n - 1\n        var k9 = n -\
    \ 1\n        var k10 = n - 1\n        var k11 = n - 1\n        var k12 = n - 1\n\
    \        var k13 = n - 1\n        var k14 = n - 1\n        var k15 = n - 1\n \
    \       var k16 = n - 1\n        var k17 = n - 1\n        var k18 = n - 1\n  \
    \      var k19 = n - 1\n        var k20 = n - 1\n        var k21 = n - 1\n   \
    \     var k22 = n - 1\n        var k23 = n - 1\n        var k24 = n - 1\n    \
    \    var k25 = n - 1\n        var k26 = n - 1\n        var k27 = n - 1\n     \
    \   var k28 = n - 1\n        var k29 = n - 1\n        var k30 = n - 1\n      \
    \  var k31 = n - 1\n        var k32 = n - 1\n        var k33 = n - 1\n       \
    \ var k34 = n - 1\n        var k35 = n - 1\n        var k36 = n - 1\n        var\
    \ k37 = n - 1\n        var k38 = n - 1\n        var k39 = n - 1\n        var k40\
    \ = n - 1\n        var k41 = n - 1\n        var k42 = n - 1\n        var k43 =\
    \ n - 1\n        var k44 = n - 1\n        var k45 = n - 1\n        var k46 = n\
    \ - 1\n        var k47 = n - 1\n        var k48 = n - 1\n        var k49 = n -\
    \ 1\n        var k50 = n - 1\n        var k51 = n - 1\n        var k52 = n - 1\n\
    \        var k53 = n - 1\n        var k54 = n - 1\n        var k55 = n - 1\n \
    \       var k56 = n - 1\n        var k57 = n - 1\n        var k58 = n - 1\n  \
    \      var k59 = n - 1\n        var k60 = n - 1\n        var k61 = n - 1\n   \
    \     var k62 = n - 1\n        var k63 = n - 1\n        var k64 = n - 1\n    \
    \    var k65 = n - 1\n        var k66 = n - 1\n        var k67 = n - 1\n     \
    \   var \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpntgu8w_a.scala:90:11 ---------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpntgu8w_a.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpntgu8w_a.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpntgu8w_a.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpntgu8w_a.scala:91:5 ---------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ result = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n    \
    \    var k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3\
    \ = 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n \
    \       var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n\
    \        var temp95 = 0\n        var temp96 = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_fx96xbk.scala:117:5\
    \ --------------------\e[0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ p = new Array[Long](n+1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        var temp = 0\n    \
    \    var flag = false\n        while(i < n) {\n            while(j < n) {\n  \
    \              if(arr(i) == arr(j)) {\n                    p(i) = arr(i)\n   \
    \                 j++\n                }\n                else {\n           \
    \         p(i) = arr(j)\n                    j++\n                }\n        \
    \    }\n            i = i + 1\n            j = n - 1\n            k = i\n    \
    \        while(k >= 0) {\n                temp = p(i)\n                p(i) =\
    \ p(i)\n                p(i) = temp\n                i = i - 1\n             \
    \   k = k - 1\n            }\n            if(p(i) < m) {\n                min\
    \ = min + 1\n            }\n            if(p(i) > m) {\n                max =\
    \ max + 1\n            }\n        }\n        if(min == max) {\n            min\
    \ = 0\n        }\n        if(min > max) {\n            min = max - min\n     \
    \   }\n        if(min == 0) {\n            min = 1\n        }\n        return\
    \ min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3j27u_gb.scala:29:23 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp3j27u_gb.scala:33:23 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3j27u_gb.scala:40:24\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                temp = p(i)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Found:    Long\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var min = 0\n        while(i <\
    \ len){\n            while(j < len){\n                if(arr(i) == arr(j)){\n\
    \                    j++\n                }else{\n                    min = Math.min(min,\
    \ j - i)\n                    j++\n                }\n            }\n        \
    \    i++\n        }\n        min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpo42judm6.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpo42judm6.scala:26:23 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpo42judm6.scala:29:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpo42judm6.scala:15:29 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpo42judm6.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ arr = arr.sortWith(_ < _)\n        val len = arr.size\n        var i = 0\n \
    \       var j = 0\n        var k = 0\n        var ans = 0\n        var temp =\
    \ 0\n        while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ == arr(j)) {\n                    temp = arr(i)\n                    arr(i)\
    \ = arr(j)\n                    arr(j) = temp\n                    j -= 1\n  \
    \                  k += 1\n                }\n                j += 1\n       \
    \     }\n            i += 1\n            ans = min(ans, k - j)\n        }\n  \
    \      ans\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo_awq1c8.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ a = arr.tail\n        val b = a.tail\n        val c = b.tail\n        val d\
    \ = c.tail\n        val e = d.tail\n        val f = e.tail\n        val g = f.tail\n\
    \        val h = g.tail\n        val i = h.tail\n        val j = i.tail\n    \
    \    val k = j.tail\n        val l = k.tail\n        val m = l.tail\n        val\
    \ n = m.tail\n        val o = n.tail\n        val p = o.tail\n        val q =\
    \ p.tail\n        val r = q.tail\n        val s = r.tail\n        val t = s.tail\n\
    \        val u = t.tail\n        val v = u.tail\n        val w = v.tail\n    \
    \    val x = w.tail\n        val y = x.tail\n        val z = y.tail\n        val\
    \ a = z.tail\n        val b = a.tail\n        val c = b.tail\n        val d =\
    \ c.tail\n        val e = d.tail\n        val f = e.tail\n        val g = f.tail\n\
    \        val h = g.tail\n        val i = h.tail\n        val j = i.tail\n    \
    \    val k = j.tail\n        val l = k.tail\n        val m = l.tail\n        val\
    \ n = m.tail\n        val o = n.tail\n        val p = o.tail\n        val q =\
    \ p.tail\n        val r = q.tail\n        val s = r.tail\n        val t = s.tail\n\
    \        val u = t.tail\n        val v = u.tail\n        val w = v.tail\n    \
    \    val x = w.tail\n        val y = x.tail\n        val z = y.tail\n        val\
    \ a = z.tail\n        val b = a.tail\n        val c = b.tail\n        val d =\
    \ c.tail\n        val e = d.tail\n        val f = e.tail\n        val g = f.tail\n\
    \        val h = g.tail\n        val i = h.tail\n        val j = i.tail\n    \
    \    val k = j.tail\n        val l = k.tail\n        val m = l.tail\n        val\
    \ n = m.tail\n        val o = n.tail\n        val p = o.tail\n        val q =\
    \ p.tail\n        val r = q.tail\n        val s = r.tail\n        val t = s.tail\n\
    \        val u = t.tail\n        val v = u.tail\n        val w = v.tail\n    \
    \    val x = w.tail\n        val y = x.tail\n        val z = y.tail\n        val\
    \ a = z.tail\n        val b = a.tail\n        val c = b.tail\n        val d =\
    \ c.tail\n        val e = d.tail\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpys9erl1h.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpys9erl1h.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpys9erl1h.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = m.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpys9erl1h.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = z.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ma is already defined\
    \ as \e[33mvalue\e[0m \e[35ma\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpys9erl1h.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = a.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mb is already defined\
    \ as \e[33mvalue\e[0m \e[35mb\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpys9erl1h.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = b.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already defin"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var l = 0\n        var m1 = new Array[Long](n)\n        var m2\
    \ = new Array[Long](n)\n        var m3 = new Array[Long](n)\n        var m4 =\
    \ new Array[Long](n)\n        var m5 = new Array[Long](n)\n        var m6 = new\
    \ Array[Long](n)\n        var m7 = new Array[Long](n)\n        var m8 = new Array[Long](n)\n\
    \        var m9 = new Array[Long](n)\n        var m10 = new Array[Long](n)\n \
    \       var m11 = new Array[Long](n)\n        var m12 = new Array[Long](n)\n \
    \       var m13 = new Array[Long](n)\n        var m14 = new Array[Long](n)\n \
    \       var m15 = new Array[Long](n)\n        var m16 = new Array[Long](n)\n \
    \       var m17 = new Array[Long](n)\n        var m18 = new Array[Long](n)\n \
    \       var m19 = new Array[Long](n)\n        var m20 = new Array[Long](n)\n \
    \       var m21 = new Array[Long](n)\n        var m22 = new Array[Long](n)\n \
    \       var m23 = new Array[Long](n)\n        var m24 = new Array[Long](n)\n \
    \       var m25 = new Array[Long](n)\n        var m26 = new Array[Long](n)\n \
    \       var m27 = new Array[Long](n)\n        var m28 = new Array[Long](n)\n \
    \       var m29 = new Array[Long](n)\n        var m30 = new Array[Long](n)\n \
    \       var m31 = new Array[Long](n)\n        var m32 = new Array[Long](n)\n \
    \       var m33 = new Array[Long](n)\n        var m34 = new Array[Long](n)\n \
    \       var m35 = new Array[Long](n)\n        var m36 = new Array[Long](n)\n \
    \       var m37 = new Array[Long](n)\n        var m38 = new Array[Long](n)\n \
    \       var m39 = new Array[Long](n)\n        var m40 = new Array[Long](n)\n \
    \       var m41 = new Array[Long](n)\n        var m42 = new Array[Long](n)\n \
    \       var m43 = new Array[Long](n)\n        var m44 = new Array[Long](n)\n \
    \       var m45 = new Array[Long](n)\n        var m46 = new Array[Long](n)\n \
    \       var m47 = new Array[Long](n)\n        var \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp2k7jq617.scala:69:11 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2k7jq617.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = (len / 2) - 1\n        val mid = max /\
    \ 2\n        val leftArr : List[Long] = arr.take(mid)\n        val rightArr :\
    \ List[Long] = arr.drop(mid)\n        val leftMin = smallestChange(leftArr)\n\
    \        val rightMin = smallestChange(rightArr)\n        if (leftMin < rightMin)\
    \ {\n            min = leftMin\n        } else if (leftMin > rightMin) {\n   \
    \         min = rightMin\n        } else {\n            min = 0\n        }\n \
    \       min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8oqhoa3j.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp8oqhoa3j.scala:25:16 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            min = leftMin\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val min\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp8oqhoa3j.scala:27:16 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            min = rightMin\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp8oqhoa3j.scala:29:16\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            min = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \         Reassignment to val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ val m = arr.max\n        val maxChange = arr.filter(_ % 2 == 0).sum\n      \
    \  val maxChange2 = arr.filter(_ % 2 == 1).sum\n        val maxChange3 = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).sum\n        val maxChange4 = arr.filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).sum\n        val maxChange5 = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).sum\n   \
    \     val maxChange6 = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).sum\n        val maxChange7 = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).sum\n        val maxChange8 = arr.filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).sum\n        val maxChange9 = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).sum\n   \
    \     val maxChange10 = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).sum\n        val maxChange11 = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).sum\n        val maxChange12 = arr.filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).sum\n        val maxChange13 = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqcaxybj0.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpqcaxybj0.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqcaxybj0.scala:31:5 ---------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val maxLen = len / 2\n   \
    \     val maxLen2 = maxLen / 2\n        val maxLen3 = maxLen / 3\n        val\
    \ maxLen4 = maxLen / 4\n        val maxLen5 = maxLen / 5\n        val maxLen6\
    \ = maxLen / 6\n        val maxLen7 = maxLen / 7\n        val maxLen8 = maxLen\
    \ / 8\n        val maxLen9 = maxLen / 9\n        val maxLen10 = maxLen / 10\n\
    \        val maxLen11 = maxLen / 11\n        val maxLen12 = maxLen / 12\n    \
    \    val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen / 14\n        val\
    \ maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n        val maxLen17\
    \ = maxLen / 17\n        val maxLen18 = maxLen / 18\n        val maxLen19 = maxLen\
    \ / 19\n        val maxLen20 = maxLen / 20\n        val maxLen21 = maxLen / 21\n\
    \        val maxLen22 = maxLen / 22\n        val maxLen23 = maxLen / 23\n    \
    \    val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen / 25\n        val\
    \ maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n        val maxLen28\
    \ = maxLen / 28\n        val maxLen29 = maxLen / 29\n        val maxLen30 = maxLen\
    \ / 30\n        val maxLen31 = maxLen / 31\n        val maxLen32 = maxLen / 32\n\
    \        val maxLen33 = maxLen / 33\n        val maxLen34 = maxLen / 34\n    \
    \    val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen / 36\n        val\
    \ maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n        val maxLen39\
    \ = maxLen / 39\n        val maxLen40 = maxLen / 40\n        val maxLen41 = maxLen\
    \ / 41\n        val maxLen42 = maxLen / 42\n        val maxLen43 = maxLen / 43\n\
    \        val maxLen44 = maxLen / 44\n        val maxLen45 = maxLen / 45\n    \
    \    val maxLen46 = maxLen / 46\n        val maxLen47 = maxLen / 47\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyfkz64xv.scala:63:11 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyfkz64xv.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val minChange = len\n        var i = 0\n        var j = 0\n        while(i\
    \ < len && j < len) {\n            if(arr(i) == arr(j)) {\n                i +=\
    \ 1\n                j += 1\n            } else {\n                if(arr(i) <\
    \ arr(j)) {\n                    minChange = minChange - 1\n                 \
    \   i += 1\n                } else {\n                    minChange = minChange\
    \ + 1\n                    j += 1\n                }\n            }\n        }\n\
    \        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbgvz4tl9.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpbgvz4tl9.scala:26:30 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    minChange = minChange - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpbgvz4tl9.scala:29:30 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    minChange = minChange + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        val p1 = new Array[Long](n)\n        val p2\
    \ = new Array[Long](n)\n        val p3 = new Array[Long](n)\n        val p4 =\
    \ new Array[Long](n)\n        val p5 = new Array[Long](n)\n        val p6 = new\
    \ Array[Long](n)\n        val p7 = new Array[Long](n)\n        val p8 = new Array[Long](n)\n\
    \        val p9 = new Array[Long](n)\n        val p10 = new Array[Long](n)\n \
    \       val p11 = new Array[Long](n)\n        val p12 = new Array[Long](n)\n \
    \       val p13 = new Array[Long](n)\n        val p14 = new Array[Long](n)\n \
    \       val p15 = new Array[Long](n)\n        val p16 = new Array[Long](n)\n \
    \       val p17 = new Array[Long](n)\n        val p18 = new Array[Long](n)\n \
    \       val p19 = new Array[Long](n)\n        val p20 = new Array[Long](n)\n \
    \       val p21 = new Array[Long](n)\n        val p22 = new Array[Long](n)\n \
    \       val p23 = new Array[Long](n)\n        val p24 = new Array[Long](n)\n \
    \       val p25 = new Array[Long](n)\n        val p26 = new Array[Long](n)\n \
    \       val p27 = new Array[Long](n)\n        val p28 = new Array[Long](n)\n \
    \       val p29 = new Array[Long](n)\n        val p30 = new Array[Long](n)\n \
    \       val p31 = new Array[Long](n)\n        val p32 = new Array[Long](n)\n \
    \       val p33 = new Array[Long](n)\n        val p34 = new Array[Long](n)\n \
    \       val p35 = new Array[Long](n)\n        val p36 = new Array[Long](n)\n \
    \       val p37 = new Array[Long](n)\n        val p38 = new Array[Long](n)\n \
    \       val p39 = new Array[Long](n)\n        val p40 = new Array[Long](n)\n \
    \       val p41 = new Array[Long](n)\n        val p42 = new Array[Long](n)\n \
    \       val p43 = new Array[Long](n)\n        val p44 = new Array[Long](n)\n \
    \       val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpypfaw_f0.scala:62:11 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpypfaw_f0.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var l = 0\n        var m1 = new Array[Long](n)\n        var m2\
    \ = new Array[Long](n)\n        var m3 = new Array[Long](n)\n        var m4 =\
    \ new Array[Long](n)\n        var m5 = new Array[Long](n)\n        var m6 = new\
    \ Array[Long](n)\n        var m7 = new Array[Long](n)\n        var m8 = new Array[Long](n)\n\
    \        var m9 = new Array[Long](n)\n        var m10 = new Array[Long](n)\n \
    \       var m11 = new Array[Long](n)\n        var m12 = new Array[Long](n)\n \
    \       var m13 = new Array[Long](n)\n        var m14 = new Array[Long](n)\n \
    \       var m15 = new Array[Long](n)\n        var m16 = new Array[Long](n)\n \
    \       var m17 = new Array[Long](n)\n        var m18 = new Array[Long](n)\n \
    \       var m19 = new Array[Long](n)\n        var m20 = new Array[Long](n)\n \
    \       var m21 = new Array[Long](n)\n        var m22 = new Array[Long](n)\n \
    \       var m23 = new Array[Long](n)\n        var m24 = new Array[Long](n)\n \
    \       var m25 = new Array[Long](n)\n        var m26 = new Array[Long](n)\n \
    \       var m27 = new Array[Long](n)\n        var m28 = new Array[Long](n)\n \
    \       var m29 = new Array[Long](n)\n        var m30 = new Array[Long](n)\n \
    \       var m31 = new Array[Long](n)\n        var m32 = new Array[Long](n)\n \
    \       var m33 = new Array[Long](n)\n        var m34 = new Array[Long](n)\n \
    \       var m35 = new Array[Long](n)\n        var m36 = new Array[Long](n)\n \
    \       var m37 = new Array[Long](n)\n        var m38 = new Array[Long](n)\n \
    \       var m39 = new Array[Long](n)\n        var m40 = new Array[Long](n)\n \
    \       var m41 = new Array[Long](n)\n        var m42 = new Array[Long](n)\n \
    \       var m43 = new Array[Long](n)\n        var m44 = new Array[Long](n)\n \
    \       var m45 = new Array[Long](n)\n        var m46 = new Array[Long](n)\n \
    \       var m47 = new Array[Long](n)\n        var \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvls7fpf5.scala:69:11 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvls7fpf5.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndex2\
    \ = len - 1\n        val minChangeIndex3 = len - 2\n        val minChangeIndex4\
    \ = len - 3\n        val minChangeIndex5 = len - 4\n        val minChangeIndex6\
    \ = len - 5\n        val minChangeIndex7 = len - 6\n        val minChangeIndex8\
    \ = len - 7\n        val minChangeIndex9 = len - 8\n        val minChangeIndex10\
    \ = len - 9\n        val minChangeIndex11 = len - 10\n        val minChangeIndex12\
    \ = len - 11\n        val minChangeIndex13 = len - 12\n        val minChangeIndex14\
    \ = len - 13\n        val minChangeIndex15 = len - 14\n        val minChangeIndex16\
    \ = len - 15\n        val minChangeIndex17 = len - 16\n        val minChangeIndex18\
    \ = len - 17\n        val minChangeIndex19 = len - 18\n        val minChangeIndex20\
    \ = len - 19\n        val minChangeIndex21 = len - 20\n        val minChangeIndex22\
    \ = len - 21\n        val minChangeIndex23 = len - 22\n        val minChangeIndex24\
    \ = len - 23\n        val minChangeIndex25 = len - 24\n        val minChangeIndex26\
    \ = len - 25\n        val minChangeIndex27 = len - 26\n        val minChangeIndex28\
    \ = len - 27\n        val minChangeIndex29 = len - 28\n        val minChangeIndex30\
    \ = len - 29\n        val minChangeIndex31 = len - 30\n        val minChangeIndex32\
    \ = len - 31\n        val minChangeIndex33 = len - 32\n        val minChangeIndex34\
    \ = len - 33\n        val minChangeIndex35 = len - 34\n        val minChangeIndex36\
    \ = len - 35\n        val minChangeIndex37 = len - 36\n        val minChangeIndex38\
    \ = len - 37\n        val minChangeIndex39 = len - 38\n        val minChangeIndex40\
    \ = len - 39\n        val minChangeIndex41 = len - 40\n        val minChangeIndex42\
    \ = len - 41\n        val minChangeIndex43 = len - 42\n        val minChangeIndex44\
    \ = len - 43\n        val minChangeIndex45 = len - 44\n        val minChangeIndex46\
    \ = len - 45\n        val minChangeIndex47 = len - 46\n        val minChangeIndex48\
    \ = len - 47\n        val minChangeIndex49 = len - 48\n        val minChangeIndex50\
    \ = len - 49\n        val minChangeIndex5\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpslovzkei.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpslovzkei.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpslovzkei.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val maxChange\
    \ = n - m\n        val changes = mutable.ArrayBuffer(0)\n        val change =\
    \ arr.head\n        val i = 2\n        while (i <= n) {\n            if (arr(i)\
    \ == arr(n - i)) {\n                changes += change\n                change\
    \ = arr(i)\n                i += 1\n            } else {\n                changes\
    \ += change\n                change = arr(i)\n                i += 1\n       \
    \     }\n        }\n        val changeCount = changes.toList.length\n        if\
    \ (changeCount > maxChange) {\n            changeCount - maxChange\n        }\
    \ else {\n            0\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppv_rmnb8.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmppv_rmnb8.scala:24:23 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                change = arr(i)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val change\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppv_rmnb8.scala:25:18\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                i += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value += is not a member of Int - did you mean i.!=?\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmppv_rmnb8.scala:28:23 -----------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                change = arr(i)\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val change\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppv_rmnb8.scala:29:18\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                i += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value += is not a member of Int - did you mean i.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        var count = 0\n        while(i < len) {\n     \
    \       while(j < len) {\n                if(arr(i) == arr(j)) {\n           \
    \         temp = arr(i)\n                    arr(i) = arr(j)\n               \
    \     arr(j) = temp\n                    k = j\n                    j++\n    \
    \                count++\n                }\n                else {\n        \
    \            j++\n                }\n            }\n            i = k\n      \
    \      k = j\n            j = 0\n            count++\n        }\n        arr.toList.map(x\
    \ => x.toLong).sum\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6yyvyc_m.scala:31:27 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    count++\n\e[31m\e[31m   |\e[0m  \
    \                         ^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp6yyvyc_m.scala:34:23 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6yyvyc_m.scala:40:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            count++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp6yyvyc_m.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6yyvyc_m.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \              ^^^\e[0m\n\e[31m   |\e[0m                    value ++ is not a\
    \ member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n    \
    \    val changed = mutable.HashSet.empty[Long]\n        val change = mutable.HashMap.empty[Long,\
    \ Long]\n        val changed = mutable.HashSet.empty[Long]\n        val change\
    \ = mutable.HashMap.empty[Long, Long]\n        val changed = mutable.HashSet.empty[Long]\n\
    \        val change = mutable.HashMap.empty[Long, Long]\n        val changed =\
    \ mutable.HashSet.empty[Long]\n        val change = mutable.HashMap.empty[Long,\
    \ Long]\n        val changed = mutable.HashSet.empty[Long]\n        val change\
    \ = mutable.HashMap.empty[Long, Long]\n        val changed = mutable.HashSet.empty[Long]\n\
    \        val change = mutable.HashMap.empty[Long, Long]\n        val changed =\
    \ mutable.HashSet.empty[Long]\n        val change = mutable.HashMap.empty[Long,\
    \ Long]\n        val changed = mutable.HashSet.empty[Long]\n        val change\
    \ = mutable.HashMap.empty[Long, Long]\n        val changed = mutable.HashSet.empty[Long]\n\
    \        val change = mutable.HashMap.empty[Long, Long]\n        val changed =\
    \ mutable.HashSet.empty[Long]\n        val change = mutable.HashMap.empty[Long,\
    \ Long]\n        val changed = mutable.HashSet.empty[Long]\n        val change\
    \ = mutable.HashMap.empty[Long, Long]\n        val changed = mutable.HashSet.empty[Long]\n\
    \        val change = mutable.HashMap.empty[Long, Long]\n        val changed =\
    \ mutable.HashSet.empty[Long]\n        val change = mutable.HashMap.empty[Long,\
    \ Long]\n        val changed = mutable.HashSet.empty[Long]\n        val change\
    \ = mutable.HashMap.empty[Long, Long]\n        val changed = mutable.HashSet.empty[Long]\n\
    \        val change = mutable.HashMap.empty[Long, Long]\n        val changed =\
    \ mutable.HashSet.empty[Long]\n        val change = mutable.HashMap.empty[Long,\
    \ Long]\n        val changed = mutable.HashSet.empty[Long]\n        val change\
    \ = mutable.HashMap.empty[Long, Long]\n        val changed = mut\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoo4xdj9n.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.HashSet.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoo4xdj9n.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoo4xdj9n.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.HashSet.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoo4xdj9n.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoo4xdj9n.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.HashSet.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     var maxChange = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3np3hwcq.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmaxChangeIndex is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3np3hwcq.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3np3hwcq.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3np3hwcq.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3np3hwcq.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e[0m\n\e"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var count = 0\n        var i = 0\n        var j = len - 1\n        while\
    \ (i < j) {\n            if (arr(i) == arr(j)) {\n                count += 1\n\
    \                i += 1\n                j -= 1\n            } else {\n      \
    \          val temp = arr(i)\n                arr(i) = arr(j)\n              \
    \  arr(j) = temp\n                count += 1\n                i += 1\n       \
    \         j -= 1\n            }\n        }\n        arr.length\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp7h5tlzn9.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7h5tlzn9.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010218
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.tail.drop(1).reverse\n        val\
    \ s = arr.tail.drop(1).reverse\n        val r = arr.tail.drop(1).reverse\n   \
    \     val m = arr.head\n        val r = arr.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm4jkxxyg.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpm4jkxxyg.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpm4jkxxyg.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail.drop(\e\
    [31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpm4jkxxyg.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.tail.drop(\e[31m1\e[0m).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0ms is already defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm4jkxxyg.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = arr.tail.drop(\e[31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm4jkxxyg.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.head\n        val\
    \ arr = arr.tail\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr2 = arr.toSeq\n        val arr3 = arr.toArray\n        val arr4\
    \ = arr.toBuffer\n        val arr5 = arr.toList\n        val arr6 = arr.toSeq\n\
    \        val arr7 = arr.toArray\n        val arr8 = arr.toBuffer\n        val\
    \ arr9 = arr.toList\n        val arr10 = arr.toSeq\n        val arr11 = arr.toArray\n\
    \        val arr12 = arr.toBuffer\n        val arr13 = arr.toList\n        val\
    \ arr14 = arr.toSeq\n        val arr15 = arr.toArray\n        val arr16 = arr.toBuffer\n\
    \        val arr17 = arr.toList\n        val arr18 = arr.toSeq\n        val arr19\
    \ = arr.toArray\n        val arr20 = arr.toBuffer\n        val arr21 = arr.toList\n\
    \        val arr22 = arr.toSeq\n        val arr23 = arr.toArray\n        val arr24\
    \ = arr.toBuffer\n        val arr25 = arr.toList\n        val arr26 = arr.toSeq\n\
    \        val arr27 = arr.toArray\n        val arr28 = arr.toBuffer\n        val\
    \ arr29 = arr.toList\n        val arr30 = arr.toSeq\n        val arr31 = arr.toArray\n\
    \        val arr32 = arr.toBuffer\n        val arr33 = arr.toList\n        val\
    \ arr34 = arr.toSeq\n        val arr35 = arr.toArray\n        val arr36 = arr.toBuffer\n\
    \        val arr37 = arr.toList\n        val arr38 = arr.toSeq\n        val arr39\
    \ = arr.toArray\n        val arr40 = arr.toBuffer\n        val arr41 = arr.toList\n\
    \        val arr42 = arr.toSeq\n        val arr43 = arr.toArray\n        val arr44\
    \ = arr.toBuffer\n        val arr45 = arr.toList\n        val arr46 = arr.toSeq\n\
    \        val arr47 = arr.toArray\n        val arr48 = arr.toBuffer\n        val\
    \ arr49 = arr.toList\n        val arr50 = arr.toSeq\n        val arr51 = arr.toArray\n\
    \        val arr52 = arr.toBuffer\n        val arr53 = arr.toList\n        val\
    \ arr54 = arr.toSeq\n        val arr55 = arr.toArray\n        val arr56 = arr.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzjthcalc.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzjthcalc.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpzjthcalc.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpzjthcalc.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val curr = arr(i)\n            val next\
    \ = arr(j)\n            val diff = curr - next\n            if (diff > 0) {\n\
    \                val newMin = min + diff\n                if (newMin < min)\n\
    \                    min = newMin\n                k = j\n            } else {\n\
    \                val newMin = min - diff\n                if (newMin < min)\n\
    \                    min = newMin\n                k = j + 1\n            }\n\
    \            i = i + 1\n            j = j + 1\n        }\n        min\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp5tyq46pa.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5tyq46pa.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var changes = 0\n        while\
    \ (i < len) {\n            while (j < len && arr(i) == arr(j)) {\n           \
    \     j += 1\n            }\n            if (j == len) {\n                changes\
    \ += 1\n                j = 0\n            }\n            i += 1\n        }\n\
    \        changes\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmppf3_78pc.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppf3_78pc.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var max = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var count = 0\n        while(i\
    \ < len) {\n            max = Math.max(max, arr(i))\n            min = Math.min(min,\
    \ arr(i))\n            i += 1\n        }\n        while(j < len) {\n         \
    \   max = Math.max(max, arr(j))\n            min = Math.min(min, arr(j))\n   \
    \         j += 1\n        }\n        while(k < (len-1)) {\n            max = Math.max(max,\
    \ arr(k))\n            min = Math.min(min, arr(k))\n            k += 1\n     \
    \   }\n        while(i < len) {\n            temp = arr(i)\n            arr(i)\
    \ = arr(j)\n            arr(j) = temp\n            i += 1\n            j += 1\n\
    \        }\n        while(j < len) {\n            temp = arr(j)\n            arr(j)\
    \ = arr(k)\n            arr(k) = temp\n            j += 1\n            k += 1\n\
    \        }\n        while(k < (len-1)) {\n            temp = arr(k)\n        \
    \    arr(k) = arr(len-1)\n            arr(len-1) = temp\n            k += 1\n\
    \            len -= 1\n        }\n        while(i < len) {\n            temp =\
    \ arr(i)\n            arr(i) = arr(len-1)\n            arr(len-1) = temp\n   \
    \         i += 1\n            len -= 1\n        }\n        while(j < len) {\n\
    \            temp = arr(j)\n            arr(j) = arr(len-1)\n            arr(len-1)\
    \ = temp\n            j += 1\n            len -= 1\n        }\n        while(k\
    \ < (len-1)) {\n            temp = arr(k)\n            arr(k) = arr(len-1)\n \
    \           arr(len-1) = temp\n            k += 1\n            len -= 1\n    \
    \    }\n        while(i < len) {\n            temp = arr(i)\n            arr(i)\
    \ = arr(len-1)\n            arr(len-1) = temp\n            i += 1\n          \
    \  len -= 1\n        }\n        while(j < len) {\n            temp = arr(j)\n\
    \            arr(j) = arr(len-1)\n            arr(len-1) = temp\n            j\
    \ += 1\n            len -= 1\n        }\n        while(k < (len-1)) {\n      \
    \      temp = arr(k)\n            arr(k) = arr(len-1)\n            arr(len-1)\
    \ = temp\n            k += 1\n            len -= 1\n        }\n        while(i\
    \ < len) {\n            temp = arr(i)\n            arr(i) = arr(len-1)\n     \
    \       arr(len-1) = temp\n            i += 1\n            len -= 1\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphbbaxcgm.scala:121:0 ---------------------------\e\
    [0m\e[0m\n\e[31m121 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphbbaxcgm.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphbbaxcgm.scala:120:1\
    \ --------------------\e[0m\e[0m\n\e[31m120 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmphbbaxcgm.scala:109:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m109 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        var count = 0\n \
    \       var i = 0\n        var j = arr.length - 1\n        while (i < j) {\n \
    \           if (arr(i) == arr(j)) {\n                count += 1\n            \
    \    i += 1\n                j -= 1\n            } else if (arr(i) < arr(j)) {\n\
    \                i += 1\n            } else {\n                j -= 1\n      \
    \      }\n        }\n        count\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1ur8qpb8.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        val changes = new Array[Long](n)\n    \
    \    val changed = new Array[Boolean](n)\n        val p = new Array[Long](n)\n\
    \        val p2 = new Array[Long](n)\n        val p3 = new Array[Long](n)\n  \
    \      val p4 = new Array[Long](n)\n        val p5 = new Array[Long](n)\n    \
    \    val p6 = new Array[Long](n)\n        val p7 = new Array[Long](n)\n      \
    \  val p8 = new Array[Long](n)\n        val p9 = new Array[Long](n)\n        val\
    \ p10 = new Array[Long](n)\n        val p11 = new Array[Long](n)\n        val\
    \ p12 = new Array[Long](n)\n        val p13 = new Array[Long](n)\n        val\
    \ p14 = new Array[Long](n)\n        val p15 = new Array[Long](n)\n        val\
    \ p16 = new Array[Long](n)\n        val p17 = new Array[Long](n)\n        val\
    \ p18 = new Array[Long](n)\n        val p19 = new Array[Long](n)\n        val\
    \ p20 = new Array[Long](n)\n        val p21 = new Array[Long](n)\n        val\
    \ p22 = new Array[Long](n)\n        val p23 = new Array[Long](n)\n        val\
    \ p24 = new Array[Long](n)\n        val p25 = new Array[Long](n)\n        val\
    \ p26 = new Array[Long](n)\n        val p27 = new Array[Long](n)\n        val\
    \ p28 = new Array[Long](n)\n        val p29 = new Array[Long](n)\n        val\
    \ p30 = new Array[Long](n)\n        val p31 = new Array[Long](n)\n        val\
    \ p32 = new Array[Long](n)\n        val p33 = new Array[Long](n)\n        val\
    \ p34 = new Array[Long](n)\n        val p35 = new Array[Long](n)\n        val\
    \ p36 = new Array[Long](n)\n        val p37 = new Array[Long](n)\n        val\
    \ p38 = new Array[Long](n)\n        val p39 = new Array[Long](n)\n        val\
    \ p40 = new Array[Long](n)\n        val p41 = new Array[Long](n)\n        val\
    \ p42 = new Array[Long](n)\n        val p43 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpc0xyya7k.scala:62:17 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mp43\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpc0xyya7k.scala:63:5 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        while (i < n) {\n \
    \           val x = arr(i)\n            val y = arr(n - i - 1)\n            if\
    \ (x == y) {\n                val z = arr(n - i - 2)\n                if (z ==\
    \ y) {\n                    val w = arr(n - i - 3)\n                    if (w\
    \ == y) {\n                        val x = arr(n - i - 4)\n                  \
    \      if (x == y) {\n                            val y = arr(n - i - 5)\n   \
    \                         if (y == y) {\n                                val z\
    \ = arr(n - i - 6)\n                                if (z == y) {\n          \
    \                          val w = arr(n - i - 7)\n                          \
    \          if (w == y) {\n                                        val x = arr(n\
    \ - i - 8)\n                                        if (x == y) {\n          \
    \                                  val y = arr(n - i - 9)\n                  \
    \                          if (y == y) {\n                                   \
    \             val z = arr(n - i - 10)\n                                      \
    \          if (z == y) {\n                                                   \
    \ val w = arr(n - i - 11)\n                                                  \
    \  if (w == y) {\n                                                        val\
    \ x = arr(n - i - 12)\n                                                      \
    \  if (x == y) {\n                                                           \
    \ val y = arr(n - i - 13)\n                                                  \
    \          if (y == y) {\n                                                   \
    \             val z = arr(n - i - 14)\n                                      \
    \                          if (z == y) {\n                                   \
    \                                 val w = arr(n - i - 15)\n                  \
    \                                                  if (w == y) {\n           \
    \                                                             val x = arr(n -\
    \ i - 16)\n                                                                  \
    \      if (x == y) {\n                                                       \
    \                     val y = arr(n - i - 17)\n                              \
    \                                              if (y == y) {\n               \
    \                                                                 val z = arr(n\
    \ - i - 18)\n                                                                \
    \                if (z == y) {\n                                             \
    \                                       val w = arr(n - i - 19)\n            \
    \                                                                        if (w\
    \ == y) {\n                                                                  \
    \                      val x = arr(n - i - 20)\n                             \
    \                                                           if (x == y) {\n  \
    \                                                                            \
    \              val y = arr(n - i - 21)\n                                     \
    \                                                       if (y == y) {\n      \
    \                                                                            \
    \              val z = arr(n - i - 22)\n                                     \
    \                                                           if (z == y) {\n  \
    \                                                                            \
    \                      val w = arr(n - i - 23)\n                             \
    \                                                                       if (w\
    \ == y) {\n                                                                  \
    \                                      val x = arr(n - i - 24)\n             \
    \                                                                            \
    \               if (x == y) {\n                                              \
    \                                                              val y = arr(n -\
    \ i - 25)\n                                                                  \
    \                                          if (y == y) {\n                   \
    \                                                                            \
    \                 val z = arr(n - i - 26)\n                                  \
    \                                                                            \
    \  if (z == y) {\n                                                           \
    \                                                         val w = arr(n - i -\
    \ 27)\n                                                                      \
    \                                              if (w == y) {\n               \
    \                                                                            \
    \                             val x = arr(n - i - 28)\n                      \
    \                                                                            \
    \                      if (x == y) {\n                                       \
    \                                                                            \
    \             val y = arr(n - i - 29)\n                                      \
    \                                                                            \
    \              if (y == y) {\n                                               \
    \                                                                            \
    \         val z = arr(n - i - 30)\n                                          \
    \                      \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi6jmlten.scala:98:0 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi6jmlten.scala:23:8\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mwhile\e[0m (i\
    \ < n) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Unit\n\e[31m   |\e[0m        Required: Long\n\e[31m24 |\e[0m            \e\
    [33mval\e[0m \e[36mx\e[0m = arr(i)\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36my\e[0m = arr(n - i - \e[31m1\e[0m)\n\e[31m26 |\e[0m            \e[33mif\e\
    [0m (x == y) {\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36mz\e[0m = arr(n\
    \ - i - \e[31m2\e[0m)\n\e[31m28 |\e[0m                \e[33mif\e[0m (z == y) {\n\
    \e[31m29 |\e[0m                    \e[33mval\e[0m \e[36mw\e[0m = arr(n - i - \e\
    [31m3\e[0m)\n\e[31m30 |\e[0m                    \e[33mif\e[0m (w == y) {\n\e[31m31\
    \ |\e[0m                        \e[33mval\e[0m \e[36mx\e[0m = arr(n - i - \e[31m4\e\
    [0m)\n\e[31m32 |\e[0m                        \e[33mif\e[0m (x == y) {\n\e[31m33\
    \ |\e[0m                            \e[33mval\e[0m \e[36my\e[0m = arr(n - i -\
    \ \e[31m5\e[0m)\n\e[31m34 |\e[0m                            \e[33mif\e[0m (y ==\
    \ y) {\n\e[31m35 |\e[0m                                \e[33mval\e[0m \e[36mz\e\
    [0m = arr(n - i - \e[31m6\e[0m)\n\e[31m36 |\e[0m                             \
    \   \e[33mif\e[0m (z == y) {\n\e[31m37 |\e[0m                                \
    \    \e[33mval\e[0m \e[36mw\e[0m = arr(n - i - \e[31m7\e[0m)\n\e[31m38 |\e[0m\
    \                                    \e[33mif\e[0m (w == y) {\n\e[31m39 |\e[0m\
    \                                        \e[33mval\e[0m \e[36mx\e[0m = arr(n -\
    \ i - \e[31m8\e[0m)\n\e[31m40 |\e[0m                                        \e\
    [33mif\e[0m (x == y) {\n\e[31m41 |\e[0m                                      \
    \      \e[33mval\e[0m \e[36my\e[0m = arr(n - i - \e[31m9\e[0m)\n\e[31m42 |\e[0m\
    \                                            \e[33mif\e[0m (y == y) {\n\e[31m43\
    \ |\e[0m                                                \e[33mval\e[0m \e[36mz\e\
    [0m = arr(n - i - \e[31m10\e[0m)\n\e[31m44 |\e[0m                            \
    \               "
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var minChange = 0\n        var minChangeIndex = 0\n        var\
    \ maxChangeIndex = 0\n        var maxChange = 0\n        var maxChangeIndex =\
    \ 0\n        while (i < len) {\n            while (j < maxLen && arr(i) == arr(j))\
    \ {\n                j += 1\n            }\n            while (k < maxLen && arr(i)\
    \ != arr(k)) {\n                k += 1\n            }\n            if (j > k)\
    \ {\n                minChange = arr(i)\n                minChangeIndex = i\n\
    \                maxChange = arr(j)\n                maxChangeIndex = j\n    \
    \            maxChangeIndex = k\n            }\n            i += 1\n         \
    \   j += 1\n            k += 1\n        }\n        if (minChange == arr(len))\
    \ {\n            minChangeIndex\n        } else {\n            minChangeIndex\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa5esq87f.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmaxChangeIndex is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpa5esq87f.scala:15:18 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m\
    \   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.last\n        val\
    \ dp = new Array[Long](n + 1)\n        dp(0) = 0\n        dp(1) = 0\n        for\
    \ (i<-2 until n){\n            val left = arr(i).toLong\n            val right\
    \ = arr(n-i-1).toLong\n            val sum = left + right\n            val newLeft\
    \ = sum - right\n            val newRight = sum - left\n            if (newLeft\
    \ < newRight){\n                dp(i+1) = newLeft\n            } else {\n    \
    \            dp(i+1) = newRight\n            }\n        }\n        dp(n)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdp7zpv7s.scala:35)\n\tat Problem.main(tmpdp7zpv7s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010229
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        while (i < len) {\n            if (arr(i) == arr(len - 1 - i)) {\n  \
    \              min = min + 1\n                i = i + 1\n                j = j\
    \ + 1\n                k = k + 1\n            } else {\n                i = i\
    \ + 1\n                j = j + 1\n                k = k + 1\n            }\n \
    \       }\n        if (min == 0) {\n            return 0\n        }\n        return\
    \ k\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp6mc0pt_y.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6mc0pt_y.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var l = 0\n        var m1 = m\n        var m2 = m\n        var\
    \ m3 = m\n        var m4 = m\n        var m5 = m\n        var m6 = m\n       \
    \ var m7 = m\n        var m8 = m\n        var m9 = m\n        var m10 = m\n  \
    \      var m11 = m\n        var m12 = m\n        var m13 = m\n        var m14\
    \ = m\n        var m15 = m\n        var m16 = m\n        var m17 = m\n       \
    \ var m18 = m\n        var m19 = m\n        var m20 = m\n        var m21 = m\n\
    \        var m22 = m\n        var m23 = m\n        var m24 = m\n        var m25\
    \ = m\n        var m26 = m\n        var m27 = m\n        var m28 = m\n       \
    \ var m29 = m\n        var m30 = m\n        var m31 = m\n        var m32 = m\n\
    \        var m33 = m\n        var m34 = m\n        var m35 = m\n        var m36\
    \ = m\n        var m37 = m\n        var m38 = m\n        var m39 = m\n       \
    \ var m40 = m\n        var m41 = m\n        var m42 = m\n        var m43 = m\n\
    \        var m44 = m\n        var m45 = m\n        var m46 = m\n        var m47\
    \ = m\n        var m48 = m\n        var m49 = m\n        var m50 = m\n       \
    \ var m51 = m\n        var m52 = m\n        var m53 = m\n        var m54 = m\n\
    \        var m55 = m\n        var m56 = m\n        var m57 = m\n        var m58\
    \ = m\n        var m59 = m\n        var m60 = m\n        var m61 = m\n       \
    \ var m62 = m\n        var m63 = m\n        var m64 = m\n        var m65 = m\n\
    \        var m66 = m\n        var m67 = m\n        var m68 = m\n        var m69\
    \ = m\n        var m70 = m\n        var m71 = m\n        var m72 = m\n       \
    \ var m73 = m\n        var m74 = m\n        var m75 = m\n        var m76 = m\n\
    \        var m77 = m\n        var m78 = m\n        var m79 = m\n        var m80\
    \ = m\n        var m81 = m\n        var m82 = m\n        var m83 = m\n       \
    \ var m84 = m\n        var m85 = m\n        var m86 = m\n        var m87 = m\n\
    \        var m88 = m\n        var m89 = m\n        var m90 = m\n        var m91\
    \ = m\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw6wctgdm.scala:114:5\
    \ --------------------\e[0m\e[0m\n\e[31m114 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ changes = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex2 = mutable.ListBuffer[Int]()\n        val changeIndex3\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex4 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex5 = mutable.ListBuffer[Int]()\n        val changeIndex6\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex7 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex8 = mutable.ListBuffer[Int]()\n        val changeIndex9\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex10 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex11 = mutable.ListBuffer[Int]()\n        val changeIndex12\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex13 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex14 = mutable.ListBuffer[Int]()\n        val changeIndex15\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex16 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex17 = mutable.ListBuffer[Int]()\n        val changeIndex18\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex19 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex20 = mutable.ListBuffer[Int]()\n        val changeIndex21\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex22 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex23 = mutable.ListBuffer[Int]()\n        val changeIndex24\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex25 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex26 = mutable.ListBuffer[Int]()\n        val changeIndex27\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex28 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex29 = mutable.ListBuffer[Int]()\n        val changeIndex30\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex31 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex32 = mutable.List\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuj7ro_fd.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpuj7ro_fd.scala:18:21 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpuj7ro_fd.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpuj7ro_fd.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpuj7ro_fd.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex2\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpuj7ro_fd.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    "
  stdout: ''
  timestamp: 1660010229
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val maxChange\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange2\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange3\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange4\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange5\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange6\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange7\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange8\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange9\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange10\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange11\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange12\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange13\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange14\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange15\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange16\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange17\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange18\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange19\
    \ = arr.foldLeft(0)((acc, x) => if (x == m) acc + 1 else acc)\n        val maxChange20\
    \ = arr.foldLeft(0)((acc, x) => if (x == \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpv8nr87ed.scala:36:62 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxChange20\e[0m = arr.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => \e[33mif\e[0m (x == \n\e[31m\e[31m\
    \   |\e[0m                                                              ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv8nr87ed.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.max\n        val\
    \ arr = arr.toList\n        val len = arr.length\n        val p = new Array[Long](len)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var max = 0\n        var temp = 0\n        while (i < n) {\n        \
    \    while (j < n) {\n                val temp = arr(j)\n                arr(j)\
    \ = arr(i)\n                arr(i) = temp\n                j++\n             \
    \   i++\n            }\n            val temp = arr(j)\n            arr(j) = arr(i)\n\
    \            arr(i) = temp\n            j++\n            i++\n        }\n    \
    \    val len = arr.length\n        val p = new Array[Long](len)\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        var temp = 0\n        while (i < n) {\n            while (j\
    \ < n) {\n                val temp = arr(j)\n                arr(j) = arr(i)\n\
    \                arr(i) = temp\n                j++\n                i++\n   \
    \         }\n            val temp = arr(j)\n            arr(j) = arr(i)\n    \
    \        arr(i) = temp\n            j++\n            i++\n        }\n        val\
    \ len = arr.length\n        val p = new Array[Long](len)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var min = 0\n        var max =\
    \ 0\n        var temp = 0\n        while (i < n) {\n            while (j < n)\
    \ {\n                val temp = arr(j)\n                arr(j) = arr(i)\n    \
    \            arr(i) = temp\n                j++\n                i++\n       \
    \     }\n            val temp = arr(j)\n            arr(j) = arr(i)\n        \
    \    arr(i) = temp\n            j++\n            i++\n        }\n        val len\
    \ = arr.length\n        val p = new Array[Long](len)\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var min = 0\n        var max = 0\n\
    \        var temp = 0\n        while (i < n) {\n            while (j < n) {\n\
    \                val temp = arr(j)\n                arr(j) = arr(i)\n        \
    \        arr(i) = temp\n                j++\n                i++\n           \
    \ }\n            val temp = arr(j)\n            arr(j) = arr(i)\n            arr(i)\
    \ = temp\n            j++\n            i++\n        }\n        val len = arr.length\n\
    \        val p = new Array[Long](len)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var min = 0\n        var max = 0\n        var temp\
    \ = 0\n        while (i < n) {\n            while (j < n) {\n                val\
    \ temp = arr(j)\n                arr(j) = arr(i)\n                arr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp77eyu4n3.scala:32:19 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                i++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp77eyu4n3.scala:38:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp77eyu4n3.scala:54:19 ---------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m                i++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp77eyu4n3.scala:60:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m60 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp77eyu4n3.scala:76:19 ---------------------------\e[0m\e[0m\n\e[31m76\
    \ |\e[0m                i++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp77eyu4n3.scala:82:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m82 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp77eyu4n3.scala"
  stdout: ''
  timestamp: 1660010233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        while (i < len) {\n            val temp = arr(i)\n            while\
    \ (j < len) {\n                if (arr(j) == temp) {\n                    arr(j)\
    \ = arr(j + 1)\n                    arr(j + 1) = temp\n                    minChange\
    \ = minChange - 1\n                }\n                j++\n            }\n   \
    \         i++\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpe846syj1.scala:29:19 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpe846syj1.scala:31:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpe846syj1.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpe846syj1.scala:27:30 -----------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    minChange = minChange - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var change = 0\n        var i = 0\n       \
    \ var j = 0\n        while (i < len) {\n            while (j < len) {\n      \
    \          if (arr(i) == arr(j)) {\n                    j++\n                }\
    \ else {\n                    change = j - i\n                    if (change <\
    \ minChange) {\n                        minChange = change\n                 \
    \   }\n                    j++\n                }\n            }\n           \
    \ i += 1\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmp6lzn92.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpmp6lzn92.scala:30:23 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmp6lzn92.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpmp6lzn92.scala:28:34\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                   \
    \     minChange = change\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val minChange\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        while (i < len) {\n            while (j < len) {\n            \
    \    if (arr(i) == arr(j)) {\n                    j++\n                }\n   \
    \             else {\n                    minChange = minChange - 1\n        \
    \            i = i + 1\n                    j = j + 1\n                }\n   \
    \         }\n            i = i + 1\n            j = j + 1\n        }\n       \
    \ minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplq8y1esv.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmplq8y1esv.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmplq8y1esv.scala:27:30 -----------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    minChange = minChange - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = len - 1\n      \
    \  while (i < len) {\n            if (arr(i) != arr(j)) {\n                minChange\
    \ = minChange - 1\n                i = i + 1\n                j = j - 1\n    \
    \        } else {\n                i = i + 1\n                j = j - 1\n    \
    \        }\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp89onthci.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp89onthci.scala:22:26 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                minChange = minChange - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ l = arr.tail\n        val p = new Array[Long](n)\n        var i = 0\n      \
    \  var j = 0\n        var k = 0\n        var count = 0\n        var min = Long.MaxValue\n\
    \        while(i < n && j < n) {\n            if(i == j) {\n                p(i)\
    \ = arr(i)\n                i += 1\n                j += 1\n                count\
    \ += 1\n                min = Math.min(min, count)\n            }\n          \
    \  else {\n                val a = arr(i)\n                val b = arr(j)\n  \
    \              if(b < a) {\n                    p(i) = b\n                   \
    \ i += 1\n                    j += 1\n                    count += 1\n       \
    \             min = Math.min(min, count)\n                }\n                else\
    \ {\n                    p(i) = a\n                    i += 1\n              \
    \      j += 1\n                    count += 1\n                    min = Math.min(min,\
    \ count)\n                }\n            }\n        }\n        if(i < n) {\n \
    \           while(i < n) {\n                p(i) = arr(i)\n                i +=\
    \ 1\n                count += 1\n                min = Math.min(min, count)\n\
    \            }\n        }\n        if(j < n) {\n            while(j < n) {\n \
    \               p(j) = arr(j)\n                j += 1\n                count +=\
    \ 1\n                min = Math.min(min, count)\n            }\n        }\n  \
    \      min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprap22r7b.scala:70)\n\tat Problem.main(tmprap22r7b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = -1\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr(len - 1))\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr(len - 2))\n        val minChangeIndex = arr.indexWhere(x => x ==\
    \ arr(len - 3))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len\
    \ - 4))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len - 5))\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr(len - 6))\n       \
    \ val minChangeIndex = arr.indexWhere(x => x == arr(len - 7))\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr(len - 8))\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr(len - 9))\n        val minChangeIndex = arr.indexWhere(x => x ==\
    \ arr(len - 10))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len\
    \ - 11))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len - 12))\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr(len - 13))\n      \
    \  val minChangeIndex = arr.indexWhere(x => x == arr(len - 14))\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr(len - 15))\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr(len - 16))\n        val minChangeIndex = arr.indexWhere(x => x ==\
    \ arr(len - 17))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len\
    \ - 18))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len - 19))\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr(len - 20))\n      \
    \  val minChangeIndex = arr.indexWhere(x => x == arr(len - 21))\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr(len - 22))\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr(len - 23))\n        val minChangeIndex = arr.indexWhere(x => x ==\
    \ arr(len - 24))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len\
    \ - 25))\n        val minChangeIndex = arr.indexWhere(x => x == arr(len - 26))\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr(len - 27))\n      \
    \  val minChangeIndex = arr.indexWhere(x \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc3mezm_m.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc3mezm_m.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminChangeIndex\e[0m = arr.indexWhere(\e[36mx\e[0m => x == arr(len - \e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3mezm_m.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.indexWhere(\e\
    [36mx\e[0m => x == arr(len - \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3mezm_m.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.indexWhere(\e\
    [36mx\e[0m => x == arr(len - \e[31m3\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3mezm_m.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.indexWhere(\e\
    [36mx\e[0m => x == arr(len - \e[31m4\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n     \
    \   var minChangeIndex3 = 0\n        while (i < len) {\n            while (j <\
    \ len) {\n                if (arr(i) == arr(j)) {\n                    j++\n \
    \               }\n                else {\n                    minChange = minChangeIndex\n\
    \                    minChangeIndex2 = minChangeIndex3\n                    minChangeIndex3\
    \ = minChangeIndex\n                    minChangeIndex = j\n                 \
    \   j++\n                }\n            }\n            minChangeIndex = minChangeIndex2\n\
    \            minChangeIndex2 = minChangeIndex3\n            minChangeIndex3 =\
    \ minChangeIndex\n            minChangeIndex = j\n            j++\n          \
    \  i++\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdv28cir0.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpdv28cir0.scala:34:23 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdv28cir0.scala:42:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpdv28cir0.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpdv28cir0.scala:30:30 -----------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                    minChange = minChangeIndex\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \            Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpdv28cir0.scala:41:13 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m            j++\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\
    \e[31m   |\e[0m            value ++ is not a member of Int\n6 errors found\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n\
    \        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n       \
    \ var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp95 = 0\n        var temp96 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3rpp0yn8.scala:118:5\
    \ --------------------\e[0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var min = Long.MaxValue\n        var minIndex = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n        while (i < n) {\n            while (j < n)\
    \ {\n                if (arr(i) == arr(j)) {\n                    j++\n      \
    \          }\n                else {\n                    val temp = arr(i)\n\
    \                    arr(i) = arr(j)\n                    arr(j) = temp\n    \
    \                j++\n                }\n            }\n            val temp =\
    \ arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n           \
    \ i += 1\n            j += 1\n        }\n        while (j < n) {\n           \
    \ val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n\
    \            i += 1\n            j += 1\n        }\n        while (i < n) {\n\
    \            val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j)\
    \ = temp\n            i += 1\n            j += 1\n        }\n        while (j\
    \ < n) {\n            val temp = arr(i)\n            arr(i) = arr(j)\n       \
    \     arr(j) = temp\n            i += 1\n            j += 1\n        }\n     \
    \   while (i < n) {\n            val temp = arr(i)\n            arr(i) = arr(j)\n\
    \            arr(j) = temp\n            i += 1\n            j += 1\n        }\n\
    \        while (j < n) {\n            val temp = arr(i)\n            arr(i) =\
    \ arr(j)\n            arr(j) = temp\n            i += 1\n            j += 1\n\
    \        }\n        while (i < n) {\n            val temp = arr(i)\n         \
    \   arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n         \
    \   j += 1\n        }\n        while (j < n) {\n            val temp = arr(i)\n\
    \            arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n\
    \            j += 1\n        }\n        while (i < n) {\n            val temp\
    \ = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n         \
    \   i += 1\n            j += 1\n        }\n        while (j < n) {\n         \
    \   val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n\
    \            i += 1\n            j += 1\n        }\n        while (i < n) {\n\
    \            val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j)\
    \ = temp\n            i += 1\n            j += 1\n        }\n        while (j\
    \ < n) {\n            val temp = arr(i)\n            arr(i) = arr(j)\n       \
    \     arr(j) = temp\n            i += 1\n            j += 1\n        }\n     \
    \   while (i < \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpexyat78h.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpexyat78h.scala:34:23 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpexyat78h.scala:120:18\
    \ --------------------------\e[0m\e[0m\n\e[31m120 |\e[0m        \e[33mwhile\e\
    [0m (i < \n\e[31m\e[31m    |\e[0m                  ^\e[0m\n\e[31m    |\e[0m  \
    \                expression expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpexyat78h.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010229
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeValue\
    \ = 0\n        val minChangeIndexArr: List[Int] = new Array[Int](len)\n      \
    \  val minChangeValueArr: List[Long] = new Array[Long](len)\n        val minChangeIndexArr2\
    \ = new Array[Int](len)\n        val minChangeValueArr2 = new Array[Long](len)\n\
    \        val minChangeIndexArr3 = new Array[Int](len)\n        val minChangeValueArr3\
    \ = new Array[Long](len)\n        val minChangeIndexArr4 = new Array[Int](len)\n\
    \        val minChangeValueArr4 = new Array[Long](len)\n        val minChangeIndexArr5\
    \ = new Array[Int](len)\n        val minChangeValueArr5 = new Array[Long](len)\n\
    \        val minChangeIndexArr6 = new Array[Int](len)\n        val minChangeValueArr6\
    \ = new Array[Long](len)\n        val minChangeIndexArr7 = new Array[Int](len)\n\
    \        val minChangeValueArr7 = new Array[Long](len)\n        val minChangeIndexArr8\
    \ = new Array[Int](len)\n        val minChangeValueArr8 = new Array[Long](len)\n\
    \        val minChangeIndexArr9 = new Array[Int](len)\n        val minChangeValueArr9\
    \ = new Array[Long](len)\n        val minChangeIndexArr10 = new Array[Int](len)\n\
    \        val minChangeValueArr10 = new Array[Long](len)\n        val minChangeIndexArr11\
    \ = new Array[Int](len)\n        val minChangeValueArr11 = new Array[Long](len)\n\
    \        val minChangeIndexArr12 = new Array[Int](len)\n        val minChangeValueArr12\
    \ = new Array[Long](len)\n        val minChangeIndexArr13 = new Array[Int](len)\n\
    \        val minChangeValueArr13 = new Array[Long](len)\n        val minChangeIndexArr14\
    \ = new Array[Int](len)\n        val minChangeValueArr14 = new Array[Long](len)\n\
    \        val minChangeIndexArr15 = new Array[Int](len)\n        val minChangeValueArr15\
    \ = new Array[Long](len)\n        val minChangeIndexArr16 = new Array[Int](len)\n\
    \        val minChangeValueArr16 = new Array[Long](len)\n        val minChangeIndexArr17\
    \ = new Array[Int](len)\n        val minChangeValueArr17 = new Array[Long](\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpaaz2t4py.scala:53:50 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mminChangeValueArr17\e[0m\
    \ = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](\n\e[31m\e[31m   |\e[0m \
    \                                                 ^\e[0m\n\e[31m   |\e[0m    \
    \                                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\nexception occurred while parser /tmp/tmpaaz2t4py.scala\nexception\
    \ occurred while compiling /tmp/tmpaaz2t4py.scala\nException in thread \"main\"\
    \ java.lang.AssertionError: assertion failed: position error, parent span does\
    \ not contain child span\nparent      = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e\
    [0m](\e[31mnull\e[0m) # -1,\nparent span = <2788..2804>,\nchild       = \e[31mnull\e\
    [0m # -1,\nchild span  = [2804..2809..2809]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\
    \tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positio"
  stdout: "error while checking \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](\e\
    [31mnull\e[0m)\nerror while checking \e[33mval\e[0m \e[36mminChangeValueArr17\e\
    [0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](\e[31mnull\e[0m)\nerror\
    \ while checking {\n  \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n  \e[33mval\e\
    [0m \e[36mlen\e[0m = arr.length\n  \e[33mval\e[0m \e[36mminChange\e[0m = len\n\
    \  \e[33mval\e[0m \e[36mminChangeIndex\e[0m = 0\n  \e[33mval\e[0m \e[36mminChangeValue\e\
    [0m = 0\n  \e[33mval\e[0m \e[36mminChangeIndexArr\e[0m: \e[35mList\e[0m[\e[35mInt\e\
    [0m] = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m\
    \ \e[36mminChangeValueArr\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew \e\
    [0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n  \e[33mval\e[0m \e[36mminChangeIndexArr2\e\
    [0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m \e\
    [36mminChangeValueArr2\e[0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n\
    \  \e[33mval\e[0m \e[36mminChangeIndexArr3\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m \e[36mminChangeValueArr3\e[0m = \e\
    [33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n  \e[33mval\e[0m \e[36mminChangeIndexArr4\e\
    [0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m \e\
    [36mminChangeValueArr4\e[0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n\
    \  \e[33mval\e[0m \e[36mminChangeIndexArr5\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m \e[36mminChangeValueArr5\e[0m = \e\
    [33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n  \e[33mval\e[0m \e[36mminChangeIndexArr6\e\
    [0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m \e\
    [36mminChangeValueArr6\e[0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n\
    \  \e[33mval\e[0m \e[36mminChangeIndexArr7\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m \e[36mminChangeValueArr7\e[0m = \e\
    [33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n  \e[33mval\e[0m \e[36mminChangeIndexArr8\e\
    [0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mInt\e[0m](len)\n  \e[33mval\e[0m \e\
    [36mminChangeValueArr8\e[0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](len)\n\
    \  \e[33mval\e[0m \e[36mminChangeIndexArr9\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35m"
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        while(i < len) {\n            while(j < len) {\n\
    \                if(arr(i) == arr(j)) {\n                    temp = arr(i)\n \
    \                   arr(i) = arr(j)\n                    arr(j) = temp\n     \
    \               j++\n                }\n                else {\n             \
    \       j++\n                }\n            }\n            i++\n            j\
    \ = 0\n            k = k + 1\n        }\n        arr.toList.min\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpe0klic6x.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpe0klic6x.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpe0klic6x.scala:35:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpe0klic6x.scala:15:18 ---------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpe0klic6x.scala:34:13 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            i++\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m            value ++ is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = n\n        while\
    \ (i < n) {\n            while (j < n) {\n                if (arr(i) == arr(j))\
    \ {\n                    j++\n                }\n                else {\n    \
    \                min = Math.min(min, j - k)\n                    k = j\n     \
    \               j++\n                }\n            }\n            i = i + 1\n\
    \            min = Math.min(min, n - i)\n        }\n        min\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5zme9ty8.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp5zme9ty8.scala:29:23 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changed = new mutable.ListBuffer[Long]()\n     \
    \   val change = arr.toSet\n        val changed = arr.toSet\n        val changed\
    \ = arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n        val changed = arr.toSet\n\
    \        val changed = arr.toSet\n        val changed = arr.toSet\n        val\
    \ changed = arr.toSet\n        val changed = arr.toSet\n        val changed =\
    \ arr.toSet\n        val changed = arr.toSet\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5wrqj76t.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = arr.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanged\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5wrqj76t.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanged\e[0m = arr.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5wrqj76t.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = arr.toSet\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanged is already\
    \ defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5wrqj76t.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanged\e[0m = arr.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5wrqj76t.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = arr.toSet\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanged is already\
    \ defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[3"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ max = (n - 1).toLong\n        val min = 0l\n        val palindromic = arr.toSet.toList\n\
    \        val changes = mutable.ListBuffer[Long]()\n        val palindromicChanges\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        var j = 0\n       \
    \ while (i < n && j < n) {\n            if (arr(i) == arr(j)) {\n            \
    \    i += 1\n                j += 1\n            } else {\n                val\
    \ change = arr(i) - arr(j)\n                if (change < min) {\n            \
    \        min = change\n                }\n                i += 1\n           \
    \     j += 1\n            }\n        }\n        while (i < n) {\n            val\
    \ change = arr(i) - arr(j)\n            if (change < min) {\n                min\
    \ = change\n            }\n            i += 1\n            j += 1\n        }\n\
    \        while (j < n) {\n            val change = arr(i) - arr(j)\n         \
    \   if (change < min) {\n                min = change\n            }\n       \
    \     j += 1\n        }\n        if (min == 0l) {\n            return 0l\n   \
    \     }\n        while (i < n) {\n            val change = arr(i) - arr(j)\n \
    \           if (change < min) {\n                min = change\n            }\n\
    \            i += 1\n            j += 1\n        }\n        while (j < n) {\n\
    \            val change = arr(i) - arr(j)\n            if (change < min) {\n \
    \               min = change\n            }\n            j += 1\n        }\n \
    \       if (min == 0l) {\n            return 0l\n        }\n        while (i <\
    \ n) {\n            val change = arr(i) - arr(j)\n            if (change < min)\
    \ {\n                min = change\n            }\n            i += 1\n       \
    \     j += 1\n        }\n        while (j < n) {\n            val change = arr(i)\
    \ - arr(j)\n            if (change < min) {\n                min = change\n  \
    \          }\n            j += 1\n        }\n        if (min == 0l) {\n      \
    \      return 0l\n        }\n        while (i < n) {\n            val change =\
    \ arr(i) - arr(j)\n            if (change < min) {\n                min = change\n\
    \            }\n            i += 1\n            j += 1\n        }\n        while\
    \ (j < n) {\n            val change = arr(i) - arr(j)\n            if (change\
    \ < min) {\n                min = change\n            }\n            j += 1\n\
    \        }\n        if (min == 0l) {\n            return 0l\n        }\n     \
    \   while (i < n) {\n            val change = arr(i) - arr(j)\n            if\
    \ (change < min) {\n                min = change\n            }\n            i\
    \ += 1\n            j += 1\n        }\n        while (j < n) {\n            val\
    \ change = arr(i) - arr(j)\n            if (change < min) {\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjnk76y6f.scala:133:0 ---------------------------\e\
    [0m\e[0m\n\e[31m133 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjnk76y6f.scala:20:22\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjnk76y6f.scala:21:33\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mpalindromicChanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                               Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpjnk76y6f.scala:31:24 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    min = change\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpjnk76y6f.scala:40:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                min\
    \ = change\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpjnk76y6f.scala:48:20 -----------------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m                min = change\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val\
    \ min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpjnk76y6f.scala:58:2"
  stdout: ''
  timestamp: 1660010237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ max = (n - 1).toLong\n        val min = 0\n        val max1 = (max - 1).toLong\n\
    \        val max2 = max - (max1 - 1)\n        val max3 = max - (max2 - 1)\n  \
    \      val max4 = max - (max3 - 1)\n        val max5 = max - (max4 - 1)\n    \
    \    val max6 = max - (max5 - 1)\n        val max7 = max - (max6 - 1)\n      \
    \  val max8 = max - (max7 - 1)\n        val max9 = max - (max8 - 1)\n        val\
    \ max10 = max - (max9 - 1)\n        val max11 = max - (max10 - 1)\n        val\
    \ max12 = max - (max11 - 1)\n        val max13 = max - (max12 - 1)\n        val\
    \ max14 = max - (max13 - 1)\n        val max15 = max - (max14 - 1)\n        val\
    \ max16 = max - (max15 - 1)\n        val max17 = max - (max16 - 1)\n        val\
    \ max18 = max - (max17 - 1)\n        val max19 = max - (max18 - 1)\n        val\
    \ max20 = max - (max19 - 1)\n        val max21 = max - (max20 - 1)\n        val\
    \ max22 = max - (max21 - 1)\n        val max23 = max - (max22 - 1)\n        val\
    \ max24 = max - (max23 - 1)\n        val max25 = max - (max24 - 1)\n        val\
    \ max26 = max - (max25 - 1)\n        val max27 = max - (max26 - 1)\n        val\
    \ max28 = max - (max27 - 1)\n        val max29 = max - (max28 - 1)\n        val\
    \ max30 = max - (max29 - 1)\n        val max31 = max - (max30 - 1)\n        val\
    \ max32 = max - (max31 - 1)\n        val max33 = max - (max32 - 1)\n        val\
    \ max34 = max - (max33 - 1)\n        val max35 = max - (max34 - 1)\n        val\
    \ max36 = max - (max35 - 1)\n        val max37 = max - (max36 - 1)\n        val\
    \ max38 = max - (max37 - 1)\n        val max39 = max - (max38 - 1)\n        val\
    \ max40 = max - (max39 - 1)\n        val max41 = max - (max40 - 1)\n        val\
    \ max42 = max - (max41 - 1)\n        val max43 = max - (max42 - 1)\n        val\
    \ max44 = max - (max43 - 1)\n        val max45 = max - (max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo3ivsere.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpo3ivsere.scala:64:5 ---------------------\e[0m\e[0m\n\e[31m64 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var max = 0\n        var temp = 0\n      \
    \  while (i < n) {\n            while (j < n) {\n                if (arr(i) ==\
    \ arr(j)) {\n                    p(i) = arr(i)\n                    p(j) = arr(j)\n\
    \                    i = i + 1\n                    j = j + 1\n              \
    \  } else {\n                    p(i) = arr(i)\n                    p(j) = arr(j)\n\
    \                    i = i + 1\n                    j = j + 1\n              \
    \  }\n            }\n            k = i\n            while (k < n) {\n        \
    \        if (p(i) > p(k)) {\n                    temp = p(k)\n               \
    \     p(k) = p(j)\n                    p(j) = temp\n                    k = k\
    \ + 1\n                } else {\n                    temp = p(k)\n           \
    \         p(k) = p(j)\n                    p(j) = temp\n                    k\
    \ = k + 1\n                }\n            }\n            min = min + i - k\n \
    \           max = max + k - i\n        }\n        if (min == max) {\n        \
    \    return 0\n        }\n        if (min > max) {\n            smallestChange(arr.take(max))\n\
    \        } else {\n            smallestChange(arr.take(min))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7l1y4x8n.scala:41:28\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m                    temp = p(k)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7l1y4x8n.scala:46:28\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m                    temp = p(k)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = (len / 2) - 1\n        val mid = max /\
    \ 2\n        val left = arr.take(mid)\n        val right = arr.drop(mid)\n   \
    \     val leftLen = left.length\n        val rightLen = right.length\n       \
    \ val leftMin = left.min\n        val rightMin = right.min\n        val leftMax\
    \ = left.max\n        val rightMax = right.max\n        val leftSum = left.sum\n\
    \        val rightSum = right.sum\n        val leftDiff = leftSum - rightSum\n\
    \        val rightDiff = rightSum - leftSum\n        val leftDiff2 = leftDiff\
    \ / 2\n        val rightDiff2 = rightDiff / 2\n        val leftDiff3 = leftDiff2\
    \ / 3\n        val rightDiff3 = rightDiff2 / 3\n        val leftDiff4 = leftDiff3\
    \ / 4\n        val rightDiff4 = rightDiff3 / 4\n        val leftDiff5 = leftDiff4\
    \ / 5\n        val rightDiff5 = rightDiff4 / 5\n        val leftDiff6 = leftDiff5\
    \ / 6\n        val rightDiff6 = rightDiff5 / 6\n        val leftDiff7 = leftDiff6\
    \ / 7\n        val rightDiff7 = rightDiff6 / 7\n        val leftDiff8 = leftDiff7\
    \ / 8\n        val rightDiff8 = rightDiff7 / 8\n        val leftDiff9 = leftDiff8\
    \ / 9\n        val rightDiff9 = rightDiff8 / 9\n        val leftDiff10 = leftDiff9\
    \ / 10\n        val rightDiff10 = rightDiff9 / 10\n        val leftDiff11 = leftDiff10\
    \ / 11\n        val rightDiff11 = rightDiff10 / 11\n        val leftDiff12 = leftDiff11\
    \ / 12\n        val rightDiff12 = rightDiff11 / 12\n        val leftDiff13 = leftDiff12\
    \ / 13\n        val rightDiff13 = rightDiff12 / 13\n        val leftDiff14 = leftDiff13\
    \ / 14\n        val rightDiff14 = rightDiff13 / 14\n        val leftDiff15 = leftDiff14\
    \ / 15\n        val rightDiff15 = rightDiff14 / 15\n        val leftDiff16 = leftDiff15\
    \ / 16\n        val rightDiff16 = rightDiff15 / 16\n        val leftDiff17 = leftDiff16\
    \ / 17\n        val rightDiff17 = rightDiff16 / 17\n        val leftDiff18 = leftDiff17\
    \ / 18\n        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpci3fatuy.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpci3fatuy.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var max = 0\n        while(i < len) {\n            max = arr(i)\n   \
    \         while(j < len) {\n                if(arr(i) == arr(j)) {\n         \
    \           k++\n                    j++\n                }\n                else\
    \ {\n                    if(arr(i) > arr(j)) {\n                        max =\
    \ arr(i)\n                    }\n                    else {\n                \
    \        max = arr(j)\n                    }\n                }\n            }\n\
    \            min = max - k\n            if(min > max) {\n                min =\
    \ max\n            }\n            i += 1\n            j += 1\n        }\n    \
    \    min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnlgh3fbl.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpnlgh3fbl.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnlgh3fbl.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \              ^^^\e[0m\n\e[31m   |\e[0m                    value ++ is not a\
    \ member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1660010238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ d = arr.last\n        val max = (n-1).toLong\n        val min = 0l\n       \
    \ val maxChange = 0l\n        val minChange = 0l\n        val maxChangeCount =\
    \ 0\n        val minChangeCount = 0\n        val maxChangeCountArray = Array[Long]()\n\
    \        val minChangeCountArray = Array[Long]()\n        val maxChangeCountArray2\
    \ = Array[Long]()\n        val minChangeCountArray2 = Array[Long]()\n        val\
    \ maxChangeCountArray3 = Array[Long]()\n        val minChangeCountArray3 = Array[Long]()\n\
    \        val maxChangeCountArray4 = Array[Long]()\n        val minChangeCountArray4\
    \ = Array[Long]()\n        val maxChangeCountArray5 = Array[Long]()\n        val\
    \ minChangeCountArray5 = Array[Long]()\n        val maxChangeCountArray6 = Array[Long]()\n\
    \        val minChangeCountArray6 = Array[Long]()\n        val maxChangeCountArray7\
    \ = Array[Long]()\n        val minChangeCountArray7 = Array[Long]()\n        val\
    \ maxChangeCountArray8 = Array[Long]()\n        val minChangeCountArray8 = Array[Long]()\n\
    \        val maxChangeCountArray9 = Array[Long]()\n        val minChangeCountArray9\
    \ = Array[Long]()\n        val maxChangeCountArray10 = Array[Long]()\n       \
    \ val minChangeCountArray10 = Array[Long]()\n        val maxChangeCountArray11\
    \ = Array[Long]()\n        val minChangeCountArray11 = Array[Long]()\n       \
    \ val maxChangeCountArray12 = Array[Long]()\n        val minChangeCountArray12\
    \ = Array[Long]()\n        val maxChangeCountArray13 = Array[Long]()\n       \
    \ val minChangeCountArray13 = Array[Long]()\n        val maxChangeCountArray14\
    \ = Array[Long]()\n        val minChangeCountArray14 = Array[Long]()\n       \
    \ val maxChangeCountArray15 = Array[Long]()\n        val minChangeCountArray15\
    \ = Array[Long]()\n        val maxChangeCountArray16 = Array[Long]()\n       \
    \ val minChangeCountArray16 = Array[Long]()\n        val maxChangeCountArray17\
    \ = Array[Long]()\n        val minChangeCountArray17 = Array[Long]()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbpgnjp5b.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var count = 0\n        var i = 0\n        var j = 0\n        while (i\
    \ < len) {\n            if (arr(i) == arr(len - 1 - i)) {\n                count\
    \ += 1\n                i += 1\n                j += 1\n            } else {\n\
    \                j = 0\n            }\n        }\n        count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpqig_ivm3.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqig_ivm3.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.head\n        val max = arr.last\n        val mid = len /\
    \ 2\n        val left = arr.take(mid)\n        val right = arr.drop(mid)\n   \
    \     val leftMin = smallestChange(left)\n        val rightMin = smallestChange(right)\n\
    \        val leftMax = smallestChange(left.reverse)\n        val rightMax = smallestChange(right.reverse)\n\
    \        val leftMinMax = if (min > max) leftMin else leftMax\n        val rightMinMax\
    \ = if (min > max) rightMin else rightMax\n        val leftMinMaxMax = if (min\
    \ > max) leftMinMax else rightMinMax\n        val leftMinMaxMaxMin = if (min >\
    \ max) leftMinMaxMax else rightMinMaxMax\n        val leftMinMaxMaxMinMin = if\
    \ (min > max) leftMinMaxMaxMin else rightMinMaxMaxMin\n        val leftMinMaxMaxMinMinMin\
    \ = if (min > max) leftMinMaxMaxMinMin else rightMinMaxMaxMinMin\n        val\
    \ leftMinMaxMaxMinMinMin = if (min > max) leftMinMaxMaxMinMin else rightMinMaxMaxMinMin\n\
    \        val leftMinMaxMaxMinMinMin = if (min > max) leftMinMaxMaxMinMin else\
    \ rightMinMaxMaxMinMin\n        val leftMinMaxMaxMinMinMinMin = if (min > max)\
    \ leftMinMaxMaxMinMin else rightMinMaxMaxMinMinMin\n        val leftMinMaxMaxMinMinMinMin\
    \ = if (min > max) leftMinMaxMaxMinMin else rightMinMaxMaxMinMinMin\n        val\
    \ leftMinMaxMaxMinMinMinMin = if (min > max) leftMinMaxMaxMinMin else rightMinMaxMaxMinMinMin\n\
    \        val leftMinMaxMaxMinMinMinMinMin = if (min > max) leftMinMaxMaxMinMin\
    \ else rightMinMaxMaxMinMinMinMin\n        val leftMinMaxMaxMinMinMinMinMin =\
    \ if (min > max) leftMinMaxMaxMinMinMin else rightMinMaxMaxMinMinMinMin\n    \
    \    val leftMinMaxMaxMinMinMinMinMin = if (min > max) leftMinMaxMaxMinMinMin\
    \ else rightMinMaxMaxMinMinMinMinMin\n        val leftMinMaxMaxMinMinMinMinMin\
    \ = if (min > max) leftMinMaxMaxMinMinMin else rightMinMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfh2on2ey.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mleftMinMaxMaxMinMinMin\e\
    [0m = \e[33mif\e[0m (min > max) leftMinMaxMaxMinMin \e[33melse\e[0m rightMinMaxMaxMinMin\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinMaxMaxMinMinMin is already defined as \e[33mvalue\e\
    [0m \e[35mleftMinMaxMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfh2on2ey.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mleftMinMaxMaxMinMinMin\e\
    [0m = \e[33mif\e[0m (min > max) leftMinMaxMaxMinMin \e[33melse\e[0m rightMinMaxMaxMinMin\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinMaxMaxMinMinMin is already defined as \e[33mvalue\e\
    [0m \e[35mleftMinMaxMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfh2on2ey.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mleftMinMaxMaxMinMinMinMin\e\
    [0m = \e[33mif\e[0m (min > max) leftMinMaxMaxMinMin \e[33melse\e[0m rightMinMaxMaxMinMinMin\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinMaxMaxMinMinMinMin is already defined as \e[33mvalue\e\
    [0m \e[35mleftMinMaxMaxMinMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfh2on2ey.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mleftMinMaxMaxMinMinMinMin\e\
    [0m = \e[33mif\e[0m (min > max) leftMinMaxMaxMinMin \e[33melse\e[0m rightMinMaxMaxMinMinMin\n\
    \e[31m\e[31m "
  stdout: ''
  timestamp: 1660010239
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = len\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var temp = 0\n        var count = 0\n        while(i\
    \ < len) {\n            while(j < len) {\n                if(arr(i) == arr(j))\
    \ {\n                    temp = arr(i)\n                    arr(i) = arr(j)\n\
    \                    arr(j) = temp\n                    j++\n                \
    \    k++\n                }\n                else {\n                    j++\n\
    \                }\n            }\n            i = i + 1\n            j = 0\n\
    \            k = k + 1\n        }\n        while(i < len) {\n            while(j\
    \ < len) {\n                if(arr(i) == arr(j)) {\n                    temp =\
    \ arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = temp\n\
    \                    j++\n                    k++\n                }\n       \
    \         else {\n                    j++\n                }\n            }\n\
    \            i = i + 1\n            j = 0\n            k = k + 1\n        }\n\
    \        while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ == arr(j)) {\n                    temp = arr(i)\n                    arr(i)\
    \ = arr(j)\n                    arr(j) = temp\n                    j++\n     \
    \               k++\n                }\n                else {\n             \
    \       j++\n                }\n            }\n            i = i + 1\n       \
    \     j = 0\n            k = k + 1\n        }\n        while(i < len) {\n    \
    \        while(j < len) {\n                if(arr(i) == arr(j)) {\n          \
    \          temp = arr(i)\n                    arr(i) = arr(j)\n              \
    \      arr(j) = temp\n                    j++\n                    k++\n     \
    \           }\n                else {\n                    j++\n             \
    \   }\n            }\n            i = i + 1\n            j = 0\n            k\
    \ = k + 1\n        }\n        while(i < len) {\n            while(j < len) {\n\
    \                if(arr(i) == arr(j)) {\n                    temp = arr(i)\n \
    \                   arr(i) = arr(j)\n                    arr(j) = temp\n     \
    \               j++\n                    k++\n                }\n            \
    \    else {\n                    j++\n                }\n            }\n     \
    \       i = i + 1\n            j = 0\n            k = k + 1\n        }\n     \
    \   while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ == arr(j)) {\n                    temp = arr(i)\n                    arr(i)\
    \ = arr(j)\n                    arr(j) = temp\n                    j++\n     \
    \               k++\n                }\n                else {\n             \
    \       j++\n                }\n            }\n            i = i + 1\n       \
    \     j = 0\n            k = k + 1\n        }\n        while(i < len) {\n    \
    \        while(j < len) {\n                if(arr(i\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9p8_qx0e.scala:31:23 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp9p8_qx0e.scala:34:23 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9p8_qx0e.scala:48:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp9p8_qx0e.scala:51:23 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp9p8_qx0e.scala:65:23 ---------------------------\e[0m\e[0m\n\e[31m65\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9p8_qx0e.scala:68:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m68 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1660010241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ max = (n - 1) / 2\n        val min = (n - 1) / 2\n        var i = 0\n      \
    \  var j = 0\n        var k = 0\n        var temp = 0\n        var count = 0\n\
    \        var min = Long.MaxValue\n        var max = Long.MinValue\n        while(i\
    \ < n && j < n) {\n            temp = arr(i)\n            arr(i) = arr(j)\n  \
    \          arr(j) = temp\n            i += 1\n            j += 1\n           \
    \ k += 1\n            count += 1\n            if(arr(i) < min) {\n           \
    \     min = arr(i)\n            }\n            if(arr(j) > max) {\n          \
    \      max = arr(j)\n            }\n        }\n        if(count > 1) {\n     \
    \       val change = max - min\n            val change2 = change / 2\n       \
    \     val change3 = change2 * 2\n            val change4 = change3 * 2\n     \
    \       val change5 = change4 * 2\n            val change6 = change5 * 2\n   \
    \         val change7 = change6 * 2\n            val change8 = change7 * 2\n \
    \           val change9 = change8 * 2\n            val change10 = change9 * 2\n\
    \            val change11 = change10 * 2\n            val change12 = change11\
    \ * 2\n            val change13 = change12 * 2\n            val change14 = change13\
    \ * 2\n            val change15 = change14 * 2\n            val change16 = change15\
    \ * 2\n            val change17 = change16 * 2\n            val change18 = change17\
    \ * 2\n            val change19 = change18 * 2\n            val change20 = change19\
    \ * 2\n            val change21 = change20 * 2\n            val change22 = change21\
    \ * 2\n            val change23 = change22 * 2\n            val change24 = change23\
    \ * 2\n            val change25 = change24 * 2\n            val change26 = change25\
    \ * 2\n            val change27 = change26 * 2\n            val change28 = change27\
    \ * 2\n            val change29 = change28 * 2\n            val change30 = change29\
    \ * 2\n            val change31 = change30 * 2\n            val change32 = change31\
    \ * 2\n            val change33 = change32 * 2\n            val change34 = change33\
    \ * 2\n            val change35 = change34 * 2\n            val change36 = change35\
    \ * 2\n            val change37 = change36 * 2\n            val change38 = change37\
    \ * 2\n            val change39 = change38 * 2\n            val change40\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp63ro6czt.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp63ro6czt.scala:95:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63ro6czt.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mvar\e[0m \e[36mmin\e[0m = Long.MaxValue\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmin is already\
    \ defined as \e[33mvalue\e[0m \e[35mmin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp63ro6czt.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mmax\e[0m = Long.MinValue\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp63ro6czt.scala:27:22\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            temp = arr(i)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        Found:    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp63ro6czt.scala:28:12 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp63ro6czt.scala:29:12\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            arr(j) = temp\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you me"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val arr\
    \ = arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.sortBy(-_)\n        val m = arr.max\n        val arr =\
    \ arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.sortBy(-_)\n        val m = arr.max\n        val arr =\
    \ arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.sortBy(-_)\n        val m = arr.max\n        val arr =\
    \ arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.sortBy(-_)\n        val m = arr.max\n        val arr =\
    \ arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.sortBy(-_)\n        val m = arr.max\n        val arr =\
    \ arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.sortBy(-_)\n        val m = arr.max\n        val arr =\
    \ arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.sortBy(-_)\n        val m = arr.max\n        val arr =\
    \ arr.sortBy(-_)\n        val m = arr.max\n        val arr = arr.sortBy(-_)\n\
    \        val m = arr.max\n        val arr = arr.sortBy(-_)\n        val m = arr.max\n\
    \        val arr = arr.\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvw051wv_.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvw051wv_.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.max\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpvw051wv_.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvw051wv_.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvw051wv_.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvw051wv_.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.max\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1660010239
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ changes = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i <\
    \ n) {\n            val j = n - i\n            val diff = arr(i) - arr(j)\n  \
    \          if (diff > 0) changes += diff\n            i += 1\n        }\n    \
    \    if (changes.isEmpty) 0\n        else {\n            val min = changes.min\n\
    \            val index = changes.indexWhere(_ == min)\n            if (index ==\
    \ 0) 0\n            else if (index == 1) 1\n            else (index - 1) * min\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpue2bky_e.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var min = Long.MaxValue\n        var count\
    \ = 0\n        var i = 0\n        var j = 0\n        while (i < len) {\n     \
    \       val left = arr(i)\n            val right = arr(len - 1 - i)\n        \
    \    if (left == right) {\n                count += 1\n            } else {\n\
    \                val mid = left + right\n                if (mid < min) {\n  \
    \                  min = mid\n                    count = j\n                }\n\
    \            }\n            i += 1\n            j += 1\n        }\n        if\
    \ (count > maxLen) {\n            count = maxLen\n        }\n        count\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd_xixexk.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        while(i < len) {\n            while(j < len) {\n              \
    \  if(arr(i) == arr(j)) {\n                    j++\n                }\n      \
    \          else {\n                    if(arr(i) < arr(j)) {\n               \
    \         minChange = minChange - 1\n                        k = i\n         \
    \               i = j\n                        j = k\n                    }\n\
    \                    else {\n                        minChange = minChange + 1\n\
    \                        k = j\n                        j = i\n              \
    \          i = k\n                    }\n                }\n            }\n  \
    \          i = i + 1\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3y0yzxq6.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp3y0yzxq6.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp3y0yzxq6.scala:28:34 -----------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                        minChange = minChange - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                        Reassignment to val minChange\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp3y0yzxq6.scala:34:34 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        minChange = minChange + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val minChange\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val n = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        while(i < n) {\n            while(j < n) {\n                if(arr(i)\
    \ == arr(j)) {\n                    j++\n                }\n                else\
    \ {\n                    min = Math.min(min, j - i)\n                    k = j\n\
    \                    j++\n                }\n            }\n            i = k\n\
    \            k = 0\n            j++\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd3v29w63.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpd3v29w63.scala:29:23 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd3v29w63.scala:34:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            j++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpd3v29w63.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010239
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndex2\
    \ = len\n        val minChangeIndex3 = len\n        val minChangeIndex4 = len\n\
    \        val minChangeIndex5 = len\n        val minChangeIndex6 = len\n      \
    \  val minChangeIndex7 = len\n        val minChangeIndex8 = len\n        val minChangeIndex9\
    \ = len\n        val minChangeIndex10 = len\n        val minChangeIndex11 = len\n\
    \        val minChangeIndex12 = len\n        val minChangeIndex13 = len\n    \
    \    val minChangeIndex14 = len\n        val minChangeIndex15 = len\n        val\
    \ minChangeIndex16 = len\n        val minChangeIndex17 = len\n        val minChangeIndex18\
    \ = len\n        val minChangeIndex19 = len\n        val minChangeIndex20 = len\n\
    \        val minChangeIndex21 = len\n        val minChangeIndex22 = len\n    \
    \    val minChangeIndex23 = len\n        val minChangeIndex24 = len\n        val\
    \ minChangeIndex25 = len\n        val minChangeIndex26 = len\n        val minChangeIndex27\
    \ = len\n        val minChangeIndex28 = len\n        val minChangeIndex29 = len\n\
    \        val minChangeIndex30 = len\n        val minChangeIndex31 = len\n    \
    \    val minChangeIndex32 = len\n        val minChangeIndex33 = len\n        val\
    \ minChangeIndex34 = len\n        val minChangeIndex35 = len\n        val minChangeIndex36\
    \ = len\n        val minChangeIndex37 = len\n        val minChangeIndex38 = len\n\
    \        val minChangeIndex39 = len\n        val minChangeIndex40 = len\n    \
    \    val minChangeIndex41 = len\n        val minChangeIndex42 = len\n        val\
    \ minChangeIndex43 = len\n        val minChangeIndex44 = len\n        val minChangeIndex45\
    \ = len\n        val minChangeIndex46 = len\n        val minChangeIndex47 = len\n\
    \        val minChangeIndex48 = len\n        val minChangeIndex49 = len\n    \
    \    val minChangeIndex50 = len\n        val minChangeIndex51 = len\n        val\
    \ minChangeIndex52 = len\n        val minChangeIndex53 = len\n        val minChangeIndex54\
    \ = len\n        val minChangeIndex55 = len\n        val minChangeIndex56 = len\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt_6nd1pc.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpt_6nd1pc.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val len = arr.length\n        val max = (len / 2) -\
    \ 1\n        val min = (len / 2)\n        val max2 = max / 2\n        val min2\
    \ = min / 2\n        val max3 = max2 / 2\n        val min3 = min2 / 2\n      \
    \  val max4 = max3 / 2\n        val min4 = min3 / 2\n        val max5 = max4 /\
    \ 2\n        val min5 = min4 / 2\n        val max6 = max5 / 2\n        val min6\
    \ = min5 / 2\n        val max7 = max6 / 2\n        val min7 = min6 / 2\n     \
    \   val max8 = max7 / 2\n        val min8 = min7 / 2\n        val max9 = max8\
    \ / 2\n        val min9 = min8 / 2\n        val max10 = max9 / 2\n        val\
    \ min10 = min9 / 2\n        val max11 = max10 / 2\n        val min11 = min10 /\
    \ 2\n        val max12 = max11 / 2\n        val min12 = min11 / 2\n        val\
    \ max13 = max12 / 2\n        val min13 = min12 / 2\n        val max14 = max13\
    \ / 2\n        val min14 = min13 / 2\n        val max15 = max14 / 2\n        val\
    \ min15 = min14 / 2\n        val max16 = max15 / 2\n        val min16 = min15\
    \ / 2\n        val max17 = max16 / 2\n        val min17 = min16 / 2\n        val\
    \ max18 = max17 / 2\n        val min18 = min17 / 2\n        val max19 = max18\
    \ / 2\n        val min19 = min18 / 2\n        val max20 = max19 / 2\n        val\
    \ min20 = min19 / 2\n        val max21 = max20 / 2\n        val min21 = min20\
    \ / 2\n        val max22 = max21 / 2\n        val min22 = min21 / 2\n        val\
    \ max23 = max22 / 2\n        val min23 = min22 / 2\n        val max24 = max23\
    \ / 2\n        val min24 = min23 / 2\n        val max25 = max24 / 2\n        val\
    \ min25 = min24 / 2\n        val max26 = max25 / 2\n        val min26 = min25\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprivx1grq.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprivx1grq.scala:71:5 ---------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val curr = arr(i)\n            if (curr\
    \ == arr(len - 1 - i)) {\n                val temp = arr(j)\n                arr(j)\
    \ = curr\n                arr(len - 1 - i) = temp\n                j++\n     \
    \           k++\n                min = Math.min(min, k - j)\n            }\n \
    \           i += 1\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp604jb7vt.scala:29:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                min = Math.min(min, k - j)\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp604jb7vt.scala:15:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m            \
    \                 ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded\
    \ function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp604jb7vt.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp604jb7vt.scala:27:17 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \      ^^^\e[0m\n\e[31m   |\e[0m                value ++ is not a member of Int\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010244
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var changes = 0\n        var minChanges\
    \ = Long.MaxValue\n        var minChangesIndex = 0\n        while (i < len) {\n\
    \            val curr = arr(i)\n            val next = (i + 1) < len ? arr(i +\
    \ 1) : 0\n            if (curr == next) {\n                i += 1\n          \
    \  } else {\n                val diff = next - curr\n                if (diff\
    \ > 0) {\n                    changes += diff\n                    minChanges\
    \ = Math.min(minChanges, changes)\n                    minChangesIndex = i\n \
    \               }\n                i += 1\n            }\n        }\n        minChangesIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl3g81_6x.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        val r = new Array[Long](n)\n        val s =\
    \ new Array[Long](n)\n        val t = new Array[Long](n)\n        val u = new\
    \ Array[Long](n)\n        val v = new Array[Long](n)\n        val w = new Array[Long](n)\n\
    \        val x = new Array[Long](n)\n        val y = new Array[Long](n)\n    \
    \    val z = new Array[Long](n)\n        val a = new Array[Long](n)\n        val\
    \ b = new Array[Long](n)\n        val c = new Array[Long](n)\n        val d =\
    \ new Array[Long](n)\n        val e = new Array[Long](n)\n        val f = new\
    \ Array[Long](n)\n        val g = new Array[Long](n)\n        val h = new Array[Long](n)\n\
    \        val i = new Array[Long](n)\n        val j = new Array[Long](n)\n    \
    \    val k = new Array[Long](n)\n        val l = new Array[Long](n)\n        val\
    \ m = new Array[Long](n)\n        val n = new Array[Long](n)\n        val o =\
    \ new Array[Long](n)\n        val p = new Array[Long](n)\n        val q = new\
    \ Array[Long](n)\n        val r = new Array[Long](n)\n        val s = new Array[Long](n)\n\
    \        val t = new Array[Long](n)\n        val u = new Array[Long](n)\n    \
    \    val v = new Array[Long](n)\n        val w = new Array[Long](n)\n        val\
    \ x = new Array[Long](n)\n        val y = new Array[Long](n)\n        val z =\
    \ new Array[Long](n)\n        val a = new Array[Long](n)\n        val b = new\
    \ Array[Long](n)\n        val c = new Array[Long](n)\n        val d = new Array[Long](n)\n\
    \        val e = new Array[Long](n)\n        val f = new Array[Long](n)\n    \
    \    val g = new Array[Long](n)\n        val h = new Array[Long](n)\n        val\
    \ i = new Array[Long](n)\n        val j = new Array[Long](n)\n        val k =\
    \ new Array[Long](n)\n        val l = new Array[Long](n)\n        val m = new\
    \ Array[Long](n)\n        val n = new Array[Long](n)\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpoy5lf0jn.scala:67:11 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpoy5lf0jn.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoy5lf0jn.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoy5lf0jn.scala:42:12 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoy5lf0jn.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Err"
  stdout: ''
  timestamp: 1660010244
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ d = arr.last\n        val m = m.toLong\n        val d = d.toLong\n        val\
    \ a = arr.toArray\n        val b = Array[Long]()\n        val c = Array[Long]()\n\
    \        val d = Array[Long]()\n        val e = Array[Long]()\n        val f =\
    \ Array[Long]()\n        val g = Array[Long]()\n        val h = Array[Long]()\n\
    \        val i = Array[Long]()\n        val j = Array[Long]()\n        val k =\
    \ Array[Long]()\n        val l = Array[Long]()\n        val m = Array[Long]()\n\
    \        val n = Array[Long]()\n        val o = Array[Long]()\n        val p =\
    \ Array[Long]()\n        val q = Array[Long]()\n        val r = Array[Long]()\n\
    \        val s = Array[Long]()\n        val t = Array[Long]()\n        val u =\
    \ Array[Long]()\n        val v = Array[Long]()\n        val w = Array[Long]()\n\
    \        val x = Array[Long]()\n        val y = Array[Long]()\n        val z =\
    \ Array[Long]()\n        val a = Array[Long]()\n        val b = Array[Long]()\n\
    \        val c = Array[Long]()\n        val d = Array[Long]()\n        val e =\
    \ Array[Long]()\n        val f = Array[Long]()\n        val g = Array[Long]()\n\
    \        val h = Array[Long]()\n        val i = Array[Long]()\n        val j =\
    \ Array[Long]()\n        val k = Array[Long]()\n        val l = Array[Long]()\n\
    \        val m = Array[Long]()\n        val n = Array[Long]()\n        val o =\
    \ Array[Long]()\n        val p = Array[Long]()\n        val q = Array[Long]()\n\
    \        val r = Array[Long]()\n        val s = Array[Long]()\n        val t =\
    \ Array[Long]()\n        val u = Array[Long]()\n        val v = Array[Long]()\n\
    \        val w = Array[Long]()\n        val x = Array[Long]()\n        val y =\
    \ Array[Long]()\n        val z = Array[Long]()\n        val a = Array[Long]()\n\
    \        val b = Array[\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf5g0gbdr.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpf5g0gbdr.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = m.toLong\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpf5g0gbdr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = d.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf5g0gbdr.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = Array[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf5g0gbdr.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = Array[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpf5g0gbdr.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = Array[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35"
  stdout: ''
  timestamp: 1660010244
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val changes\
    \ = mutable.ArrayBuffer.empty[Long]\n        val reversed = arr.toList.reverse\n\
    \        val palindromic = reversed.toSet == arr\n        val change = if (palindromic)\
    \ 0 else 1\n        val changes = 0 until n by change\n        val min = changes.min\n\
    \        val max = changes.max\n        val mid = max / 2\n        val left =\
    \ if (palindromic) mid else 0\n        val right = if (palindromic) mid + 1 else\
    \ n\n        val midLeft = if (palindromic) left else 0\n        val midRight\
    \ = if (palindromic) right else n\n        val midLeft = if (palindromic) left\
    \ else 0\n        val midRight = if (palindromic) right else n\n        val midLeft\
    \ = if (palindromic) left else 0\n        val midRight = if (palindromic) right\
    \ else n\n        val midLeft = if (palindromic) left else 0\n        val midRight\
    \ = if (palindromic) right else n\n        val midLeft = if (palindromic) left\
    \ else 0\n        val midRight = if (palindromic) right else n\n        val midLeft\
    \ = if (palindromic) left else 0\n        val midRight = if (palindromic) right\
    \ else n\n        val midLeft = if (palindromic) left else 0\n        val midRight\
    \ = if (palindromic) right else n\n        val midLeft = if (palindromic) left\
    \ else 0\n        val midRight = if (palindromic) right else n\n        val midLeft\
    \ = if (palindromic) left else 0\n        val midRight = if (palindromic) right\
    \ else n\n        val midLeft = if (palindromic) left else 0\n        val midRight\
    \ = if (palindromic) right else n\n        val midLeft = if (palindromic) left\
    \ else 0\n        val midRight = if (palindromic) right else n\n        val midLeft\
    \ = if (palindromic) left else 0\n        val midRight = if (palindromic) right\
    \ else n\n        val midLeft = if (palindromic) left else 0\n        val midRight\
    \ = if (palindromic) right else n\n        val midLeft = if (palindromic) left\
    \ else 0\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvjdrrxc1.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpvjdrrxc1.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = \e[31m0\e\
    [0m until n by change\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvjdrrxc1.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmidLeft\e[0m = \e[33mif\e[0m (palindromic)\
    \ left \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmidLeft is already defined as \e[33mvalue\e[0m \e[35mmidLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvjdrrxc1.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmidRight\e[0m = \e[33mif\e[0m (palindromic)\
    \ right \e[33melse\e[0m n\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmidRight is already defined as \e[33mvalue\e[0m \e[35mmidRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvjdrrxc1.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmidLeft\e[0m = \e[33mif\e[0m (palindromic)\
    \ left \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmidLeft is already defined as \e[33mvalue\e[0m \e[35mmidLeft\e\
    [0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660010246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n    \
    \    val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp073optz5.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp073optz5.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp073optz5.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp073optz5.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp073optz5.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660010246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        val minChange = len\n        var i = 0\n        while (i < len) {\n \
    \           if (arr(i) != arr(len - 1 - i)) {\n                minChange = i\n\
    \            }\n            i += 1\n        }\n        minChange\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpaelyokle.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaelyokle.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpaelyokle.scala:21:26 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                minChange = i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010245
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ == arr(j)) {\n                    j++\n                }\n                else\
    \ {\n                    if(arr(i) < arr(j)) {\n                        min =\
    \ arr(i) - arr(j)\n                        k = i\n                    }\n    \
    \                else {\n                        min = arr(j) - arr(i)\n     \
    \                   k = j\n                    }\n                    if(min >\
    \ 0) break\n                }\n                j++\n            }\n          \
    \  i += 1\n            j = 0\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_t8gutwc.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp_t8gutwc.scala:37:19 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m                j++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_t8gutwc.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                \
    \  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_t8gutwc.scala:35:32\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    \e[33mif\e\
    [0m(min > \e[31m0\e[0m) break\n\e[31m\e[31m   |\e[0m                         \
    \       ^^^^^\e[0m\n\e[31m   |\e[0m                                Not found:\
    \ break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010244
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var i = 0\n        var j = 0\n        var k = 0\n \
    \       var temp = 0\n        while (i < len) {\n            while (j < len) {\n\
    \                if (arr(i) == arr(j)) {\n                    temp = arr(i)\n\
    \                    arr(i) = arr(j)\n                    arr(j) = temp\n    \
    \                j++\n                }\n                else {\n            \
    \        j++\n                }\n            }\n            i++\n            j\
    \ = 0\n            k = len - i - 1\n            while (k >= 0) {\n           \
    \     if (arr(k) == arr(k + 1)) {\n                    temp = arr(k)\n       \
    \             arr(k) = arr(k + 1)\n                    arr(k + 1) = temp\n   \
    \                 k--\n                }\n                else {\n           \
    \         k--\n                }\n            }\n            min = Math.min(min,\
    \ arr.length)\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpiifh3q_g.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpiifh3q_g.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpiifh3q_g.scala:35:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpiifh3q_g.scala:42:23 ---------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m                    k--\n\e[31m\e[31m   |\e[0m           \
    \            ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpiifh3q_g.scala:45:23 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m                    k--\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiifh3q_g.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ changes = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n        var j\
    \ = 0\n        while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n\
    \                changes += arr(i)\n                i += 1\n            } else\
    \ {\n                changes += arr(j)\n                j += 1\n            }\n\
    \        }\n        if (i == n) {\n            changes += m\n        }\n     \
    \   if (j == n) {\n            changes += m\n        }\n        changes.min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj24ept6c.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.length\n     \
    \   val p = new Array[Long](n + 1)\n        val p1 = new Array[Long](n + 1)\n\
    \        val p2 = new Array[Long](n + 1)\n        val p3 = new Array[Long](n +\
    \ 1)\n        val p4 = new Array[Long](n + 1)\n        val p5 = new Array[Long](n\
    \ + 1)\n        val p6 = new Array[Long](n + 1)\n        val p7 = new Array[Long](n\
    \ + 1)\n        val p8 = new Array[Long](n + 1)\n        val p9 = new Array[Long](n\
    \ + 1)\n        val p10 = new Array[Long](n + 1)\n        val p11 = new Array[Long](n\
    \ + 1)\n        val p12 = new Array[Long](n + 1)\n        val p13 = new Array[Long](n\
    \ + 1)\n        val p14 = new Array[Long](n + 1)\n        val p15 = new Array[Long](n\
    \ + 1)\n        val p16 = new Array[Long](n + 1)\n        val p17 = new Array[Long](n\
    \ + 1)\n        val p18 = new Array[Long](n + 1)\n        val p19 = new Array[Long](n\
    \ + 1)\n        val p20 = new Array[Long](n + 1)\n        val p21 = new Array[Long](n\
    \ + 1)\n        val p22 = new Array[Long](n + 1)\n        val p23 = new Array[Long](n\
    \ + 1)\n        val p24 = new Array[Long](n + 1)\n        val p25 = new Array[Long](n\
    \ + 1)\n        val p26 = new Array[Long](n + 1)\n        val p27 = new Array[Long](n\
    \ + 1)\n        val p28 = new Array[Long](n + 1)\n        val p29 = new Array[Long](n\
    \ + 1)\n        val p30 = new Array[Long](n + 1)\n        val p31 = new Array[Long](n\
    \ + 1)\n        val p32 = new Array[Long](n + 1)\n        val p33 = new Array[Long](n\
    \ + 1)\n        val p34 = new Array[Long](n + 1)\n        val p35 = new Array[Long](n\
    \ + 1)\n        val p36 = new Array[Long](n + 1)\n        val p37 = new Array[Long](n\
    \ + 1)\n        val p38 = new Array[Long](n + 1)\n        val p39 = new Array[Long](n\
    \ + 1)\n        val p40 = new Array[Long](n + 1)\n        val p41 = new Array\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8xlqitpv.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmp8xlqitpv.scala:58:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mp41\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmissing argument for parameter _length of \e[33mconstructor\e[0m\
    \ \e[35mArray\e[0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[T]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8xlqitpv.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n    \
    \    val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n  \
    \      var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n  \
    \      var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n  \
    \      var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n  \
    \      var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n  \
    \      var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n  \
    \      var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n  \
    \      var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n  \
    \      var m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n  \
    \      var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n  \
    \      var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n  \
    \      var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n  \
    \      var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n  \
    \      var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n  \
    \      var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n  \
    \      var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n  \
    \      var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n  \
    \      var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n  \
    \      var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n  \
    \      var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n  \
    \      var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n  \
    \      var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n  \
    \      var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n  \
    \      var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n  \
    \      var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n  \
    \      var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n  \
    \      var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n  \
    \      var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5wqevea.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi5wqevea.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpi5wqevea.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5wqevea.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5wqevea.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5wqevea.scala:49:12 -----"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var minChange = 0\n        var maxChange =\
    \ 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var\
    \ maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0uj1_6wj.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmaxChangeIndex is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0uj1_6wj.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mvar\e[0m \e[36mminChangeIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mminChangeIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0uj1_6wj.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0uj1_6wj.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mvar\e[0m \e[36mminChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mminChangeIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0uj1_6wj.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e[0m\n\e"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n\
    \        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n       \
    \ var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp95 = 0\n        var temp96 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3rpp0yn8.scala:118:5\
    \ --------------------\e[0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ d = arr.last\n        val r = new Array[Long](n)\n        var i = 0\n      \
    \  var j = 0\n        var k = 0\n        var l = 0\n        var m1 = new Array[Long](n)\n\
    \        var m2 = new Array[Long](n)\n        var m3 = new Array[Long](n)\n  \
    \      var m4 = new Array[Long](n)\n        var m5 = new Array[Long](n)\n    \
    \    var m6 = new Array[Long](n)\n        var m7 = new Array[Long](n)\n      \
    \  var m8 = new Array[Long](n)\n        var m9 = new Array[Long](n)\n        var\
    \ m10 = new Array[Long](n)\n        var m11 = new Array[Long](n)\n        var\
    \ m12 = new Array[Long](n)\n        var m13 = new Array[Long](n)\n        var\
    \ m14 = new Array[Long](n)\n        var m15 = new Array[Long](n)\n        var\
    \ m16 = new Array[Long](n)\n        var m17 = new Array[Long](n)\n        var\
    \ m18 = new Array[Long](n)\n        var m19 = new Array[Long](n)\n        var\
    \ m20 = new Array[Long](n)\n        var m21 = new Array[Long](n)\n        var\
    \ m22 = new Array[Long](n)\n        var m23 = new Array[Long](n)\n        var\
    \ m24 = new Array[Long](n)\n        var m25 = new Array[Long](n)\n        var\
    \ m26 = new Array[Long](n)\n        var m27 = new Array[Long](n)\n        var\
    \ m28 = new Array[Long](n)\n        var m29 = new Array[Long](n)\n        var\
    \ m30 = new Array[Long](n)\n        var m31 = new Array[Long](n)\n        var\
    \ m32 = new Array[Long](n)\n        var m33 = new Array[Long](n)\n        var\
    \ m34 = new Array[Long](n)\n        var m35 = new Array[Long](n)\n        var\
    \ m36 = new Array[Long](n)\n        var m37 = new Array[Long](n)\n        var\
    \ m38 = new Array[Long](n)\n        var m39 = new Array[Long](n)\n        var\
    \ m40 = new Array[Long](n)\n        var m41 = new Array[Long](n)\n        var\
    \ m42 = new Array[Long](n)\n        var m43 = new Array[Long](n)\n        var\
    \ m44 = new Array[Long](n)\n        var m45 = new Array[Long](n)\n        var\
    \ m46 = new Array[Long](n)\n        var m47 = new Array\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyiyl4j0x.scala:69:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mvar\e[0m \e[36mm47\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmissing argument for parameter _length of \e[33mconstructor\e[0m\
    \ \e[35mArray\e[0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[T]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyiyl4j0x.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var min = 0\n        var max = n\n        while(i < max && j < max) {\n\
    \            val a = arr(i)\n            val b = arr(j)\n            if(a.toString\
    \ == b.toString) {\n                min = min + 1\n                i = i + 1\n\
    \                j = j + 1\n            } else if(a.toString < b.toString) {\n\
    \                min = min + 1\n                i = i + 1\n            } else\
    \ {\n                min = min + 1\n                j = j + 1\n            }\n\
    \        }\n        if(min == n) {\n            return 0\n        }\n        if(min\
    \ == 1) {\n            return 1\n        }\n        return min\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7_yjxiz3.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = len / 4\n        val maxLen3\
    \ = len / 8\n        val maxLen4 = len / 16\n        val maxLen5 = len / 32\n\
    \        val maxLen6 = len / 64\n        val maxLen7 = len / 128\n        val\
    \ maxLen8 = len / 256\n        val maxLen9 = len / 512\n        val maxLen10 =\
    \ len / 1024\n        val maxLen11 = len / 2048\n        val maxLen12 = len /\
    \ 4096\n        val maxLen13 = len / 8192\n        val maxLen14 = len / 16384\n\
    \        val maxLen15 = len / 32768\n        val maxLen16 = len / 65536\n    \
    \    val maxLen17 = len / 131072\n        val maxLen18 = len / 262144\n      \
    \  val maxLen19 = len / 524288\n        val maxLen20 = len / 1048576\n       \
    \ val maxLen21 = len / 2097152\n        val maxLen22 = len / 4194304\n       \
    \ val maxLen23 = len / 8388608\n        val maxLen24 = len / 16777216\n      \
    \  val maxLen25 = len / 33554432\n        val maxLen26 = len / 67108864\n    \
    \    val maxLen27 = len / 134217728\n        val maxLen28 = len / 268435456\n\
    \        val maxLen29 = len / 536870912\n        val maxLen30 = len / 1073741824\n\
    \        val maxLen31 = len / 2147483648\n        val maxLen32 = len / 4294967296\n\
    \        val maxLen33 = len / 8589934592\n        val maxLen34 = len / 17179869184\n\
    \        val maxLen35 = len / 34359738368\n        val maxLen36 = len / 68719476736\n\
    \        val maxLen37 = len / 137438953472\n        val maxLen38 = len / 274877906944\n\
    \        val maxLen39 = len / 549755813888\n        val maxLen40 = len / 1099511627776\n\
    \        val maxLen41 = len / 2199023255552\n        val maxLen42 = len / 4398046511104\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpre_5zpyz.scala:59:11 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpre_5zpyz.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpre_5zpyz.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        var count = 0\n\
    \        var i = 0\n        var j = 0\n        while (i < arr.length) {\n    \
    \        while (j < arr.length && arr(i) == arr(j)) {\n                j += 1\n\
    \            }\n            count += 1\n            i = j\n            j = 0\n\
    \        }\n        count + 1\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp6rqiogkt.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6rqiogkt.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010247
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = arr.last\n        val s = arr.init.reverse\n        val r = arr.init.reverse\n\
    \        val d = arr.init.reverse.reverse\n        val c = arr.init.reverse.reverse.reverse\n\
    \        val l = arr.init.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1w55i0g0.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfp05wiii.scala:83:11 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpfp05wiii.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfp05wiii.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfp05wiii.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfp05wiii.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfp05wiii.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val arr\
    \ = arr.sortBy(-_)\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var min = 0\n        var max = 0\n        var change = 0\n        var\
    \ temp = 0\n        while (i < n) {\n            while (j < n) {\n           \
    \     if (arr(i) == arr(j)) {\n                    temp = arr(i)\n           \
    \         arr(i) = arr(j)\n                    arr(j) = temp\n               \
    \     j++\n                }\n                else {\n                    j++\n\
    \                }\n            }\n            while (k < n) {\n             \
    \   if (arr(i) == arr(k)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(k)\n                    arr(k) = temp\n                 \
    \   k++\n                }\n                else {\n                    k++\n\
    \                }\n            }\n            while (j < n) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   j++\n                }\n                else {\n                    j++\n\
    \                }\n            }\n            while (k < n) {\n             \
    \   if (arr(i) == arr(k)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(k)\n                    arr(k) = temp\n                 \
    \   k++\n                }\n                else {\n                    k++\n\
    \                }\n            }\n            while (j < n) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   j++\n                }\n                else {\n                    j++\n\
    \                }\n            }\n            while (k < n) {\n             \
    \   if (arr(i) == arr(k)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(k)\n                    arr(k) = temp\n                 \
    \   k++\n                }\n                else {\n                    k++\n\
    \                }\n            }\n            while (j < n) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   j++\n                }\n                else {\n                    j++\n\
    \                }\n            }\n            while (k < n) {\n             \
    \   if (arr(i) == arr(k)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(k)\n                    arr(k) = temp\n                 \
    \   k++\n                }\n                else {\n                    k++\n\
    \                }\n            }\n            while (j < n) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   j++\n                }\n                else {\n                    j++\n\
    \                }\n            }\n            while (k < n) {\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr00kbndk.scala:31:23 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpr00kbndk.scala:34:23 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr00kbndk.scala:42:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpr00kbndk.scala:45:23 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpr00kbndk.scala:53:23 ---------------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr00kbndk.scala:56:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m56 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1660010247
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ arr = arr.sortBy(-_)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var min = n\n        while (i < n && j < n) {\n            if (arr(i)\
    \ == arr(j)) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                if (k == m) {\n                    min = j - i\n \
    \               }\n            } else if (arr(i) < arr(j)) {\n               \
    \ i += 1\n                k += 1\n                if (k == m) {\n            \
    \        min = j - i\n                }\n            } else {\n              \
    \  j += 1\n                k += 1\n                if (k == m) {\n           \
    \         min = j - i\n                }\n            }\n        }\n        min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7n2n8ysz.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val minLen = len - maxLen\n        val mid\
    \ = maxLen + 1\n        val maxChange = arr.take(maxLen).zip(arr.drop(maxLen)).map\
    \ { case (prev, next) => next - prev }\n        val minChange = arr.take(minLen).zip(arr.drop(minLen)).map\
    \ { case (prev, next) => next - prev }\n        val maxChangeSum = maxChange.sum\n\
    \        val minChangeSum = minChange.sum\n        val maxChangeSum2 = maxChangeSum\
    \ * maxChangeSum\n        val minChangeSum2 = minChangeSum * minChangeSum\n  \
    \      val maxChangeSum3 = maxChangeSum2 * maxChangeSum\n        val minChangeSum3\
    \ = minChangeSum2 * minChangeSum\n        val maxChangeSum4 = maxChangeSum3 *\
    \ maxChangeSum\n        val minChangeSum4 = minChangeSum3 * minChangeSum\n   \
    \     val maxChangeSum5 = maxChangeSum4 * maxChangeSum\n        val minChangeSum5\
    \ = minChangeSum4 * minChangeSum\n        val maxChangeSum6 = maxChangeSum5 *\
    \ maxChangeSum\n        val minChangeSum6 = minChangeSum5 * minChangeSum\n   \
    \     val maxChangeSum7 = maxChangeSum6 * maxChangeSum\n        val minChangeSum7\
    \ = minChangeSum6 * minChangeSum\n        val maxChangeSum8 = maxChangeSum7 *\
    \ maxChangeSum\n        val minChangeSum8 = minChangeSum7 * minChangeSum\n   \
    \     val maxChangeSum9 = maxChangeSum8 * maxChangeSum\n        val minChangeSum9\
    \ = minChangeSum8 * minChangeSum\n        val maxChangeSum10 = maxChangeSum9 *\
    \ maxChangeSum\n        val minChangeSum10 = minChangeSum9 * minChangeSum\n  \
    \      val maxChangeSum11 = maxChangeSum10 * maxChangeSum\n        val minChangeSum11\
    \ = minChangeSum10 * minChangeSum\n        val maxChangeSum12 = maxChangeSum11\
    \ * maxChangeSum\n        val minChangeSum12 = minChangeSum11 * minChangeSum\n\
    \        val maxChangeSum13 = maxChangeSum12 * maxChangeSum\n        val minChangeSum13\
    \ = minChangeSum12 * minChangeSum\n        val maxChangeSum14 = maxChangeSum13\
    \ * maxChangeSum\n        val minChangeSum14 = minChangeSum13 * minChangeSum\n\
    \        val maxChangeSum15 = maxChangeSum14 * max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa3onw4dp.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpa3onw4dp.scala:51:5 ---------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010252
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ max = (n-1).toLong\n        val min = 0l\n        val palindromic = arr.toSet.toList.reverse.tail.forall(x\
    \ => x == m)\n        if(palindromic) min else max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptvzbwtmx.scala:23)\n\tat Problem.main(tmptvzbwtmx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.last\n        val\
    \ dp = new Array[Long](m+1)\n        dp(0) = 0\n        for(i<-1 to m){\n    \
    \        val left = arr(i)\n            val right = arr(n-i)\n            val\
    \ sum = left + right\n            val diff = sum - left\n            dp(i+1) =\
    \ if (diff < 0) dp(i) else dp(i-1) + diff\n        }\n        dp(m)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdp4u3vfz.scala:21:28\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e\
    [36mright\e[0m = arr(n-i)\n\e[31m\e[31m   |\e[0m                            ^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    Long\n\e[31m   |\e[0m\
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            val temp = arr(i)\n            while (j >= 0 && arr(j)\
    \ == temp) {\n                arr(j) = arr(j - 1)\n                j -= 1\n  \
    \          }\n            arr(i) = temp\n            i += 1\n            j +=\
    \ 1\n        }\n        val len = arr.length\n        val minChange = len\n  \
    \      var i = 0\n        var j = 0\n        while (i < len) {\n            val\
    \ temp = arr(i)\n            while (j >= 0 && arr(j) == temp) {\n            \
    \    arr(j) = arr(j - 1)\n                j -= 1\n            }\n            arr(i)\
    \ = temp\n            i += 1\n            j += 1\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpocpwwtxv.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpocpwwtxv.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = len\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChange\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChange\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpocpwwtxv.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpocpwwtxv.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e\
    [0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpocpwwtxv.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val p\
    \ = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var\
    \ m1 = m\n        var m2 = m\n        var m3 = m\n        var m4 = m\n       \
    \ var m5 = m\n        var m6 = m\n        var m7 = m\n        var m8 = m\n   \
    \     var m9 = m\n        var m10 = m\n        var m11 = m\n        var m12 =\
    \ m\n        var m13 = m\n        var m14 = m\n        var m15 = m\n        var\
    \ m16 = m\n        var m17 = m\n        var m18 = m\n        var m19 = m\n   \
    \     var m20 = m\n        var m21 = m\n        var m22 = m\n        var m23 =\
    \ m\n        var m24 = m\n        var m25 = m\n        var m26 = m\n        var\
    \ m27 = m\n        var m28 = m\n        var m29 = m\n        var m30 = m\n   \
    \     var m31 = m\n        var m32 = m\n        var m33 = m\n        var m34 =\
    \ m\n        var m35 = m\n        var m36 = m\n        var m37 = m\n        var\
    \ m38 = m\n        var m39 = m\n        var m40 = m\n        var m41 = m\n   \
    \     var m42 = m\n        var m43 = m\n        var m44 = m\n        var m45 =\
    \ m\n        var m46 = m\n        var m47 = m\n        var m48 = m\n        var\
    \ m49 = m\n        var m50 = m\n        var m51 = m\n        var m52 = m\n   \
    \     var m53 = m\n        var m54 = m\n        var m55 = m\n        var m56 =\
    \ m\n        var m57 = m\n        var m58 = m\n        var m59 = m\n        var\
    \ m60 = m\n        var m61 = m\n        var m62 = m\n        var m63 = m\n   \
    \     var m64 = m\n        var m65 = m\n        var m66 = m\n        var m67 =\
    \ m\n        var m68 = m\n        var m69 = m\n        var m70 = m\n        var\
    \ m71 = m\n        var m72 = m\n        var m73 = m\n        var m74 = m\n   \
    \     var m75 = m\n        var m76 = m\n        var m77 = m\n        var m78 =\
    \ m\n        var m79 = m\n        var m80 = m\n        var m81 = m\n        var\
    \ m82 = m\n        var m83 = m\n        var m84 = m\n        var m85 = m\n   \
    \     var m86 = m\n        var m87 = m\n        var m88 = m\n        var m89 =\
    \ m\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzfozyblf.scala:113:5\
    \ --------------------\e[0m\e[0m\n\e[31m113 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        var\
    \ count = 0\n        var i = 0\n        var j = 0\n        var k = 0\n       \
    \ var temp = 0\n        while (i < n) {\n            while (j < n) {\n       \
    \         if (arr(i) == arr(j)) {\n                    count += 1\n          \
    \          j++\n                }\n                else {\n                  \
    \  j++\n                }\n            }\n            i += 1\n            count\
    \ = 0\n            j = 0\n        }\n        while (k < (n - 1)) {\n         \
    \   while (j < n) {\n                if (arr(k) == arr(j)) {\n               \
    \     count += 1\n                    j++\n                }\n               \
    \ else {\n                    j++\n                }\n            }\n        \
    \    k += 1\n            count = 0\n            j = 0\n        }\n        if (count\
    \ == 0) {\n            return 0\n        }\n        else {\n            val temp\
    \ = count / 2\n            val temp2 = temp.toInt\n            val temp3 = temp2\
    \ - 1\n            val temp4 = temp3 / 2\n            val temp5 = temp4.toInt\n\
    \            val temp6 = temp5 - 1\n            val temp7 = temp6 / 2\n      \
    \      val temp8 = temp7.toInt\n            val temp9 = temp8 - 1\n          \
    \  val temp10 = temp9 / 2\n            val temp11 = temp10.toInt\n           \
    \ val temp12 = temp11 - 1\n            val temp13 = temp12 / 2\n            val\
    \ temp14 = temp13.toInt\n            val temp15 = temp14 - 1\n            val\
    \ temp16 = temp15 / 2\n            val temp17 = temp16.toInt\n            val\
    \ temp18 = temp17 - 1\n            val temp19 = temp18 / 2\n            val temp20\
    \ = temp19.toInt\n            val temp21 = temp20 - 1\n            val temp22\
    \ = temp21 / 2\n            val temp23 = temp22.toInt\n            val temp24\
    \ = temp23 - 1\n            val temp25 = temp24 / 2\n            val temp26 =\
    \ temp25.toInt\n            val temp27 = temp26 - 1\n            val temp28 =\
    \ temp27 / 2\n            val temp29 = temp28.toInt\n            val temp30 =\
    \ temp29 - 1\n            val temp31 = temp30 / 2\n            val temp32 = temp31.toInt\n\
    \            val temp33 = temp32 - 1\n            val temp34 = temp33 / 2\n  \
    \          val temp35 = temp34.toInt\n            val temp36 = temp35 - 1\n  \
    \          val temp37 = temp36 / 2\n            val temp38 = temp37.toInt\n  \
    \          val temp39 = temp38 - 1\n            val temp40 = temp39 / 2\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcdjln4qm.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpcdjln4qm.scala:29:23 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcdjln4qm.scala:40:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpcdjln4qm.scala:43:23 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpcdjln4qm.scala:107:0 ---------------------------\e[0m\e[0m\n\e[31m107\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcdjln4qm.scala:106:1\
    \ --------------------\e[0m\e[0m\n\e[31m106 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpcdjln4qm.scala:95:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m95 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[3"
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val max = (arr.head + arr.last) / 2\n        val max2\
    \ = max / 2\n        val max3 = max / 3\n        val max4 = max / 4\n        val\
    \ max5 = max / 5\n        val max6 = max / 6\n        val max7 = max / 7\n   \
    \     val max8 = max / 8\n        val max9 = max / 9\n        val max10 = max\
    \ / 10\n        val max11 = max / 11\n        val max12 = max / 12\n        val\
    \ max13 = max / 13\n        val max14 = max / 14\n        val max15 = max / 15\n\
    \        val max16 = max / 16\n        val max17 = max / 17\n        val max18\
    \ = max / 18\n        val max19 = max / 19\n        val max20 = max / 20\n   \
    \     val max21 = max / 21\n        val max22 = max / 22\n        val max23 =\
    \ max / 23\n        val max24 = max / 24\n        val max25 = max / 25\n     \
    \   val max26 = max / 26\n        val max27 = max / 27\n        val max28 = max\
    \ / 28\n        val max29 = max / 29\n        val max30 = max / 30\n        val\
    \ max31 = max / 31\n        val max32 = max / 32\n        val max33 = max / 33\n\
    \        val max34 = max / 34\n        val max35 = max / 35\n        val max36\
    \ = max / 36\n        val max37 = max / 37\n        val max38 = max / 38\n   \
    \     val max39 = max / 39\n        val max40 = max / 40\n        val max41 =\
    \ max / 41\n        val max42 = max / 42\n        val max43 = max / 43\n     \
    \   val max44 = max / 44\n        val max45 = max / 45\n        val max46 = max\
    \ / 46\n        val max47 = max / 47\n        val max48 = max / 48\n        val\
    \ max49 = max / 49\n        val max50 = max / 50\n        val max51 = max / 51\n\
    \        val max52 = max / 52\n        val max53 = max / 53\n        val max54\
    \ = max / 54\n        val max55 = max / 55\n        val max56 = max / 56\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqzx6qxie.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqzx6qxie.scala:74:5 ---------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.min\n        val max = arr.max\n        val mid = len / 2\n\
    \        val midVal = arr(mid)\n        val leftVal = arr(len - mid - 1)\n   \
    \     val rightVal = arr(len - mid)\n        val leftMax = arr.take(len - mid\
    \ - 1).max\n        val rightMax = arr.take(len - mid).max\n        val leftMin\
    \ = arr.take(len - mid - 1).min\n        val rightMin = arr.take(len - mid).min\n\
    \        val leftMaxVal = arr.take(len - mid - 1).max\n        val rightMaxVal\
    \ = arr.take(len - mid).max\n        val leftMinVal = arr.take(len - mid - 1).min\n\
    \        val rightMinVal = arr.take(len - mid).min\n        val leftMaxVal2 =\
    \ arr.take(len - mid - 1).max\n        val rightMaxVal2 = arr.take(len - mid).max\n\
    \        val leftMinVal2 = arr.take(len - mid - 1).min\n        val rightMinVal2\
    \ = arr.take(len - mid).min\n        val leftMaxVal3 = arr.take(len - mid - 1).max\n\
    \        val rightMaxVal3 = arr.take(len - mid).max\n        val leftMinVal3 =\
    \ arr.take(len - mid - 1).min\n        val rightMinVal3 = arr.take(len - mid).min\n\
    \        val leftMaxVal4 = arr.take(len - mid - 1).max\n        val rightMaxVal4\
    \ = arr.take(len - mid).max\n        val leftMinVal4 = arr.take(len - mid - 1).min\n\
    \        val rightMinVal4 = arr.take(len - mid).min\n        val leftMaxVal5 =\
    \ arr.take(len - mid - 1).max\n        val rightMaxVal5 = arr.take(len - mid).max\n\
    \        val leftMinVal5 = arr.take(len - mid - 1).min\n        val rightMinVal5\
    \ = arr.take(len - mid).min\n        val leftMaxVal6 = arr.take(len - mid - 1).max\n\
    \        val rightMaxVal6 = arr.take(len - mid).max\n        val leftMinVal6 =\
    \ arr.take(len - mid - 1).min\n        val rightMinVal6 = arr.take(len - mid).min\n\
    \        val leftMaxVal7 = arr.take(len - mid - 1).max\n        val rightMaxVal7\
    \ = arr.take(len - mid).max\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphmn0fbfe.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphmn0fbfe.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val maxChange\
    \ = arr.size - 1\n        val changes = mutable.ArrayBuffer.empty[Long]\n    \
    \    val changed = mutable.ArrayBuffer.empty[Long]\n        val changeCounts =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changeCount = 0\n        val changeCountMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMaxMaxMax = mutable.ArrayBuffer.empty[Long]\n        val\
    \ changeCountMaxMaxMaxMax = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMax =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMax =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMax =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMaxMaxMaxMaxMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_447226z.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_447226z.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCountMaxMaxMaxMax\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMaxMaxMaxMax is already defined as \e[33mvalue\e\
    [0m \e[35mchangeCountMaxMaxMaxMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_447226z.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mchangeCountMaxMaxMaxMaxMaxMax\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mchangeCountMaxMaxMaxMaxMaxMax is already defined as \e[33mvalue\e\
    [0m \e[35mchangeCountMaxMaxMaxMaxMaxMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_447226z.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mchangeCountMaxMaxMaxMaxMaxMaxMaxMaxMax\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMaxMaxMaxMaxMaxMaxMaxMaxMax is already defined\
    \ as \e[33mvalue\e[0m \e[35mchangeCountMaxMaxMaxMaxMaxMaxMaxMaxMax\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_447226z.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mchangeCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\e\
    [0m = mutable.A"
  stdout: ''
  timestamp: 1660010256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var minChangeIndex = 0\n        var minChangeValue\
    \ = arr(0)\n        var minChangeIndexValue = 0\n        var minChangeIndexValueIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValueIndexIndex\
    \ = 0\n        var minChangeIndexValueIndexIndex = 0\n        var minChangeIndexValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7oddsl2_.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oddsl2_.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mminChangeIndexValueIndexIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangeIndexValueIndexIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mminChangeIndexValueIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7oddsl2_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mvar\e[0m \e[36mminChangeIndexValueIndexIndex\e[0m =\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexValueIndexIndex is already defined as \e[33mvariable\e\
    [0m \e[35mminChangeIndexValueIndexIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oddsl2_.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mminChangeIndexValueIndexIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexValueIndexIndex is already defined as \e[33mvariable\e\
    [0m \e[35mminChangeIndexValueIndexIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oddsl2_.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mminChangeIndexValueIndexIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexValueIndexIndex is already defined as \e[33mvariable\e\
    [0m \e[35mminChangeIndexValueIndexIndex\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val cur = arr(i)\n            val next\
    \ = arr(j)\n            val diff = next - cur\n            if (diff > 0) {\n \
    \               min = Math.min(min, diff)\n                k = j\n           \
    \ }\n            i += 1\n            j += 1\n        }\n        min\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp0m4idu6p.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0m4idu6p.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxChange = arr.takeRight(len - 1).foldLeft(0)((acc, x) => acc + x)\n\
    \        val minChange = arr.takeRight(len - 2).foldLeft(0)((acc, x) => acc +\
    \ x)\n        val maxChange2 = arr.takeRight(len - 3).foldLeft(0)((acc, x) =>\
    \ acc + x)\n        val minChange2 = arr.takeRight(len - 4).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange3 = arr.takeRight(len - 5).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange3 = arr.takeRight(len - 6).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange4 = arr.takeRight(len - 7).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange4 = arr.takeRight(len - 8).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange5 = arr.takeRight(len - 9).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange5 = arr.takeRight(len - 10).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange6 = arr.takeRight(len - 11).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange6 = arr.takeRight(len - 12).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange7 = arr.takeRight(len - 13).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange7 = arr.takeRight(len - 14).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange8 = arr.takeRight(len - 15).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange8 = arr.takeRight(len - 16).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange9 = arr.takeRight(len - 17).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange9 = arr.takeRight(len - 18).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val maxChange10 = arr.takeRight(len - 19).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val minChange10 = arr.takeRight(len - 20).foldLeft(0)((acc,\
    \ x) => acc + x)\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpgx_9yj_z.scala:37:11 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgx_9yj_z.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgx_9yj_z.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.size\n        val n = arr.last\n        val\
    \ arr = arr.sortBy(_.toLong)\n        val arr1 = arr.take(arr.size - 1)\n    \
    \    val arr2 = arr.drop(arr.size - 1)\n        val arr3 = arr1.zip(arr2).map(x\
    \ => x._1 - x._2)\n        val arr4 = arr3.map(x => x * x)\n        val arr5 =\
    \ arr4.map(x => x * x)\n        val arr6 = arr5.map(x => x * x)\n        val arr7\
    \ = arr6.map(x => x * x)\n        val arr8 = arr7.map(x => x * x)\n        val\
    \ arr9 = arr8.map(x => x * x)\n        val arr10 = arr9.map(x => x * x)\n    \
    \    val arr11 = arr10.map(x => x * x)\n        val arr12 = arr11.map(x => x *\
    \ x)\n        val arr13 = arr12.map(x => x * x)\n        val arr14 = arr13.map(x\
    \ => x * x)\n        val arr15 = arr14.map(x => x * x)\n        val arr16 = arr15.map(x\
    \ => x * x)\n        val arr17 = arr16.map(x => x * x)\n        val arr18 = arr17.map(x\
    \ => x * x)\n        val arr19 = arr18.map(x => x * x)\n        val arr20 = arr19.map(x\
    \ => x * x)\n        val arr21 = arr20.map(x => x * x)\n        val arr22 = arr21.map(x\
    \ => x * x)\n        val arr23 = arr22.map(x => x * x)\n        val arr24 = arr23.map(x\
    \ => x * x)\n        val arr25 = arr24.map(x => x * x)\n        val arr26 = arr25.map(x\
    \ => x * x)\n        val arr27 = arr26.map(x => x * x)\n        val arr28 = arr27.map(x\
    \ => x * x)\n        val arr29 = arr28.map(x => x * x)\n        val arr30 = arr29.map(x\
    \ => x * x)\n        val arr31 = arr30.map(x => x * x)\n        val arr32 = arr31.map(x\
    \ => x * x)\n        val arr33 = arr32.map(x => x * x)\n        val arr34 = arr33.map(x\
    \ => x * x)\n        val arr35 = arr34.map(x => x * x)\n        val arr36 = arr35.map(x\
    \ => x * x)\n        val arr37 = arr36.map(x => x * x)\n        val arr38 = arr37.map(x\
    \ => x * x)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpkgjhbqfb.scala:56:11 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkgjhbqfb.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkgjhbqfb.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = n\n        var\
    \ change = 0\n        var temp = 0\n        while (i < n) {\n            while\
    \ (j < n) {\n                temp = arr(j).toLong\n                arr(j) = arr(n\
    \ - 1 - j).toLong\n                arr(n - 1 - j) = temp\n                j++\n\
    \            }\n            while (k < n) {\n                if (arr(k) != m)\
    \ {\n                    change = change + 1\n                }\n            \
    \    k++\n            }\n            min = Math.min(min, change)\n           \
    \ change = 0\n            i = 0\n            j = 0\n            k = 0\n      \
    \  }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd1u8iteg.scala:28:19 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd1u8iteg.scala:34:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                k++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpd1u8iteg.scala:25:30 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                temp = arr(j).toLong\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \            Found:    Long\n\e[31m   |\e[0m                       Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd1u8iteg.scala:26:16\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                arr(j) =\
    \ arr(n - \e[31m1\e[0m - j).toLong\n\e[31m\e[31m   |\e[0m                ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd1u8iteg.scala:27:16\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                arr(n - \e\
    [31m1\e[0m - j) = temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m\
    \   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = len\n        var i = 0\n        var j = 0\n        while(i < len)\
    \ {\n            while(j < len) {\n                if(arr(i) == arr(j)) {\n  \
    \                  j++\n                }\n                else {\n          \
    \          if(arr(i) < arr(j)) {\n                        min = Math.min(min,\
    \ j - i)\n                        j++\n                    }\n               \
    \     else {\n                        min = Math.min(min, i - j)\n           \
    \             i++\n                    }\n                }\n            }\n \
    \       }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbto6qf6i.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpbto6qf6i.scala:28:27 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                        j++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpbto6qf6i.scala:32:27 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                        i++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpbto6qf6i.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        while(i < len) {\n            while(j < len && arr(i) == arr(j)) {\n\
    \                j += 1\n            }\n            while(k <= j && arr(i) ==\
    \ arr(k)) {\n                k += 1\n            }\n            if(k > j) {\n\
    \                min = k - j\n                i = k\n                j = k\n \
    \               k = k - min\n            }\n            i += 1\n        }\n  \
    \      min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb85r4rrn.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var min = len\n        while(i\
    \ < len) {\n            while(j < len && arr(i) == arr(j)) {\n               \
    \ j += 1\n            }\n            val k = j - i\n            val c = arr(i)\
    \ - arr(j)\n            val d = arr(i) + arr(j)\n            if(c < 0 || d < 0\
    \ || k < 0 || d < c) {\n                min = k\n            } else {\n      \
    \          min = Math.min(min, k)\n            }\n            i += 1\n       \
    \     j += 1\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzl67ilof.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val len = arr.length\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var min = Long.MaxValue\n        var max =\
    \ 0\n        while(i < len) {\n            max = arr(i)\n            while(j <\
    \ len) {\n                if(arr(j) < max) {\n                    max = arr(j)\n\
    \                }\n                j++\n            }\n            while(j <\
    \ len) {\n                if(arr(j) > max) {\n                    max = arr(j)\n\
    \                }\n                j++\n            }\n            if(max !=\
    \ 0) {\n                min = Math.min(min, max)\n            }\n            i++\n\
    \            j = 0\n            k++\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpobww3b4p.scala:30:19 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpobww3b4p.scala:36:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                j++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpobww3b4p.scala:42:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m \
    \             ^\e[0m\n\e[31m   |\e[0m              end of statement expected but\
    \ '=' found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpobww3b4p.scala:43:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            k++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpobww3b4p.scala:17:18 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpobww3b4p.scala:41:13 ------------------------\e[0m\e[0m\n\e[31m41 |\e\
    [0m            i++\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m\
    \            value ++ is not a member of Int\n6 errors found\n"
  stdout: ''
  timestamp: 1660010260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var minChange = 0\n        var minChangeIndex\
    \ = 0\n        var minChangeIndex2 = 0\n        var minChangeIndex3 = 0\n    \
    \    var minChangeIndex4 = 0\n        var minChangeIndex5 = 0\n        var minChangeIndex6\
    \ = 0\n        var minChangeIndex7 = 0\n        var minChangeIndex8 = 0\n    \
    \    var minChangeIndex9 = 0\n        var minChangeIndex10 = 0\n        var minChangeIndex11\
    \ = 0\n        var minChangeIndex12 = 0\n        var minChangeIndex13 = 0\n  \
    \      var minChangeIndex14 = 0\n        var minChangeIndex15 = 0\n        var\
    \ minChangeIndex16 = 0\n        var minChangeIndex17 = 0\n        var minChangeIndex18\
    \ = 0\n        var minChangeIndex19 = 0\n        var minChangeIndex20 = 0\n  \
    \      var minChangeIndex21 = 0\n        var minChangeIndex22 = 0\n        var\
    \ minChangeIndex23 = 0\n        var minChangeIndex24 = 0\n        var minChangeIndex25\
    \ = 0\n        var minChangeIndex26 = 0\n        var minChangeIndex27 = 0\n  \
    \      var minChangeIndex28 = 0\n        var minChangeIndex29 = 0\n        var\
    \ minChangeIndex30 = 0\n        var minChangeIndex31 = 0\n        var minChangeIndex32\
    \ = 0\n        var minChangeIndex33 = 0\n        var minChangeIndex34 = 0\n  \
    \      var minChangeIndex35 = 0\n        var minChangeIndex36 = 0\n        var\
    \ minChangeIndex37 = 0\n        var minChangeIndex38 = 0\n        var minChangeIndex39\
    \ = 0\n        var minChangeIndex40 = 0\n        var minChangeIndex41 = 0\n  \
    \      var minChangeIndex42 = 0\n        var minChangeIndex43 = 0\n        var\
    \ minChangeIndex44 = 0\n        var minChangeIndex45 = 0\n        var minChangeIndex46\
    \ = 0\n        var minChangeIndex47 = 0\n        var minChangeIndex48 = 0\n  \
    \      var minChangeIndex49 = 0\n        var minChangeIndex50 = 0\n        var\
    \ minChangeIndex51 = 0\n        var minChangeIndex52 = 0\n        var minChangeIndex53\
    \ = 0\n        var minChangeIndex54 = 0\n        var minChangeIndex55 = 0\n  \
    \      var minChangeIndex56 = 0\n        var minChangeIndex57 = 0\n        var\
    \ minChangeIndex58 = 0\n        var minChangeIndex59 = 0\n        var minChangeIndex60\
    \ = 0\n        var minChangeIndex61 = 0\n        var minChangeIndex62 = 0\n  \
    \      var minChangeIndex63 = 0\n        var minChangeIndex64 = 0\n        var\
    \ minChangeIndex65 = 0\n        var minChangeIndex66 = 0\n        var minChangeIndex67\
    \ = 0\n        var minChangeIndex68 = 0\n        var minChangeIndex69 = 0\n  \
    \      var minChangeIndex70\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1ev1orjw.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1ev1orjw.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1ev1orjw.scala:90:5\
    \ ---------------------\e[0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        while(i < len) {\n            while(j < len) {\n\
    \                if(arr(i) == arr(j)) {\n                    temp = arr(i)\n \
    \                   arr(i) = arr(j)\n                    arr(j) = temp\n     \
    \               j++\n                }\n                else {\n             \
    \       j++\n                }\n            }\n            i++\n            j\
    \ = 0\n            k = len - 1\n            while(k >= 0) {\n                if(arr(k)\
    \ == arr(k + 1)) {\n                    temp = arr(k)\n                    arr(k)\
    \ = arr(k + 1)\n                    arr(k + 1) = temp\n                    k--\n\
    \                }\n                else {\n                    k--\n        \
    \        }\n            }\n        }\n        arr.toList.map(_.toLong).min\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0erc6hno.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp0erc6hno.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp0erc6hno.scala:35:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmp0erc6hno.scala:42:23 ---------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m                    k--\n\e[31m\e[31m   |\e[0m           \
    \            ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp0erc6hno.scala:45:23 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m                    k--\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0erc6hno.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error"
  stdout: ''
  timestamp: 1660010260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ p = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ val s = new Array[Long](n + 1)\n        val t = new Array[Long](n + 1)\n   \
    \     val u = new Array[Long](n + 1)\n        val v = new Array[Long](n + 1)\n\
    \        val w = new Array[Long](n + 1)\n        val x = new Array[Long](n + 1)\n\
    \        val y = new Array[Long](n + 1)\n        val z = new Array[Long](n + 1)\n\
    \        val a = new Array[Long](n + 1)\n        val b = new Array[Long](n + 1)\n\
    \        val c = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n\
    \        val e = new Array[Long](n + 1)\n        val f = new Array[Long](n + 1)\n\
    \        val g = new Array[Long](n + 1)\n        val h = new Array[Long](n + 1)\n\
    \        val i = new Array[Long](n + 1)\n        val j = new Array[Long](n + 1)\n\
    \        val k = new Array[Long](n + 1)\n        val l = new Array[Long](n + 1)\n\
    \        val m = new Array[Long](n + 1)\n        val n = new Array[Long](n + 1)\n\
    \        val o = new Array[Long](n + 1)\n        val p = new Array[Long](n + 1)\n\
    \        val q = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n\
    \        val s = new Array[Long](n + 1)\n        val t = new Array[Long](n + 1)\n\
    \        val u = new Array[Long](n + 1)\n        val v = new Array[Long](n + 1)\n\
    \        val w = new Array[Long](n + 1)\n        val x = new Array[Long](n + 1)\n\
    \        val y = new Array[Long](n + 1)\n        val z = new Array[Long](n + 1)\n\
    \        val a = new Array[Long](n + 1)\n        val b = new Array[Long](n + 1)\n\
    \        val c = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n\
    \        val e = new Array[Long](n + 1)\n        val f = new Array[Long](n + 1)\n\
    \        val g = new Array[Long](n + 1)\n        val h = new Array[Long](n + 1)\n\
    \        val i = new Array[Long](n + 1)\n        val j = new Array[Long\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps7_kk726.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7_kk726.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7_kk726.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7_kk726.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7_kk726.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7_kk726.scala:45:12\
    \ ------"
  stdout: ''
  timestamp: 1660010260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val arr\
    \ = arr.sortBy(-_)\n        val p = new Array[Long](n)\n        var i = 0\n  \
    \      var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n  \
    \      var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n  \
    \      var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n  \
    \      var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n  \
    \      var w = 0\n        var a = 0\n        var b = 0\n        var c = 0\n  \
    \      var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n  \
    \      var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n  \
    \      var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n  \
    \      var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n  \
    \      var y = 0\n        var z = 0\n        var w = 0\n        var a = 0\n  \
    \      var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n  \
    \      var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n  \
    \      var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n  \
    \      var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n  \
    \      var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n  \
    \      var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n  \
    \      var w = 0\n        var a = 0\n        var b = 0\n        var c = 0\n  \
    \      var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n  \
    \      var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n  \
    \      var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n  \
    \      var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n  \
    \      var y = 0\n        var z = 0\n        var w = 0\n        var a = 0\n  \
    \      var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n  \
    \      var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n  \
    \      var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n  \
    \      var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n  \
    \      var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n  \
    \      var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n  \
    \      var w = 0\n        var a\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv2fcfrcn.scala:142:4 ---------------------------\e\
    [0m\e[0m\n\e[31m142 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv2fcfrcn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mm\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv2fcfrcn.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mn\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv2fcfrcn.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mp\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv2fcfrcn.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mw\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mw is already defined as \e[33mvariable\e[0m \e[35mw\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv2fcfrcn.scala:45:12 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined as \e[33mvariable\e\
    [0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined "
  stdout: ''
  timestamp: 1660010261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val n = arr.size\n\
    \        val m = arr.head\n        val p = arr.last\n        val changes = 0 //\
    \ number of changes that need to be made\n        val change = (n, m) match {\n\
    \            case (_, 0) => 1\n            case (_, 1) => 0\n            case\
    \ (_, _) => -1\n        }\n        val changed = (n - 1, m) match {\n        \
    \    case (_, 0) => true\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => true\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => true\n        }\n        val changed = (n - 1, m) match {\n          \
    \  case (_, 0) => true\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => true\n        }\n        val changed = (n - 1, m) match {\n          \
    \  case (_, 0) => true\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n        }\n        val changed = (n - 1, m) match {\n         \
    \   case (_, 0) => false\n            case (_, 1) => false\n            case (_,\
    \ _) => false\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuuabysnl.scala:102:0 ---------------------------\e\
    [0m\e[0m\n\e[31m102 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuuabysnl.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanged\e[0m = (n - \e[31m1\e[0m, m) \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e\
    [0m \e[35mchanged\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m31 |\e\
    [0m            \e[33mcase\e[0m (_, \e[31m0\e[0m) => \e[31mfalse\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mcase\e[0m (_, \e[31m1\e[0m) => \e[31mtrue\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mcase\e[0m (_, _) => \e[31mfalse\e[0m\n\e[31m34 |\e[0m\
    \        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuuabysnl.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = (n - \e[31m1\e\
    [0m, m) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m36 |\e[0m            \e[33mcase\e\
    [0m (_, \e[31m0\e[0m) => \e[31mfalse\e[0m\n\e[31m37 |\e[0m            \e[33mcase\e\
    [0m (_, \e[31m1\e[0m) => \e[31mfalse\e[0m\n\e[31m38 |\e[0m            \e[33mcase\e\
    [0m (_, _) => \e[31mtrue\e[0m\n\e[31m39 |\e[0m        }\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpuuabysnl.scala:40:12 ---------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = (n - \e[31m1\e\
    [0m, m) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m41 |\e[0m            \e[33mcase\e\
    [0m (_, \e[31m0\e[0m) => \e[31mtrue\e[0m\n\e[31m42 |\e[0m            \e[33mcase\e\
    [0m (_, \e[31m1\e[0m) => \e[31mfalse\e[0m\n\e[31m43 |\e[0m   "
  stdout: ''
  timestamp: 1660010262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val palindromic = arr.take(len - 1).reverse == arr\n        val changes\
    \ = len - palindromic.length\n        if (changes == 0) 0\n        else if (changes\
    \ == 1) 1\n        else 2\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmj1ywy6q.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxChange = len / 2\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var change =\
    \ 0\n        var temp = 0\n        while (i < len) {\n            while (j < len)\
    \ {\n                if (arr(i) == arr(j)) {\n                    temp += 1\n\
    \                    j += 1\n                } else {\n                    temp\
    \ = 0\n                    j += 1\n                }\n            }\n        \
    \    change = temp\n            changes += change\n            i += 1\n      \
    \      j = 0\n            temp = 0\n        }\n        val min = changes.min\n\
    \        if (min == 0) 0\n        else changes.length - min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfchh52k7.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfchh52k7.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010259
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = Long.MaxValue\n        while (i < n && j < n) {\n   \
    \         if (arr(i) < arr(j)) {\n                p(i) = arr(i)\n            \
    \    i += 1\n            } else {\n                p(i) = arr(j)\n           \
    \     j += 1\n            }\n            k += 1\n            if (k == m) {\n \
    \               min = Math.min(min, p(i))\n                k = 0\n           \
    \ }\n        }\n        min\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa0_cy59h.scala:39)\n\tat Problem.main(tmpa0_cy59h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ max = (n / 2).toInt\n        val min = (n / 2).toInt\n        val maxChange\
    \ = arr.take(max).reverse.take(min).reverse.foldLeft(0)(_ + _)\n        val minChange\
    \ = arr.take(min).reverse.foldLeft(0)(_ + _)\n        if (maxChange < minChange)\
    \ {\n            0\n        } else {\n            maxChange\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp67qm2cil.scala:19:76\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxChange\e\
    [0m = arr.take(max).reverse.take(min).reverse.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \                           Found:    Long\n\e[31m   |\e[0m                  \
    \                                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp67qm2cil.scala:20:58 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = arr.take(min).reverse.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \                               Found:    Long\n\e[31m   |\e[0m              \
    \                                            Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var min = 0\n        var temp =\
    \ 0\n        while(i < len) {\n            temp = arr(i)\n            while(j\
    \ < len) {\n                if(arr(j) == temp) {\n                    j++\n  \
    \              } else {\n                    min = Math.min(min, j - i)\n    \
    \                j = 0\n                }\n            }\n            i = j\n\
    \            j = 0\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp031lp5cj.scala:25:23 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmp031lp5cj.scala:15:29 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp031lp5cj.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var max = 0\n        var count = 0\n     \
    \   while (i < n) {\n            while (j < n) {\n                if (arr(i) ==\
    \ arr(j)) {\n                    p(i) = arr(i)\n                    j++\n    \
    \            } else {\n                    p(i) = arr(j)\n                   \
    \ k++\n                }\n            }\n            while (k < n) {\n       \
    \         if (arr(i) == arr(k)) {\n                    p(i) = arr(i)\n       \
    \             k++\n                } else {\n                    p(i) = arr(k)\n\
    \                    j++\n                }\n            }\n            while\
    \ (j < n) {\n                if (arr(i) == arr(j)) {\n                    p(i)\
    \ = arr(i)\n                    j++\n                } else {\n              \
    \      p(i) = arr(j)\n                    k++\n                }\n           \
    \ }\n            while (k < n) {\n                if (arr(i) == arr(k)) {\n  \
    \                  p(i) = arr(i)\n                    k++\n                } else\
    \ {\n                    p(i) = arr(k)\n                    j++\n            \
    \    }\n            }\n            while (j < n) {\n                if (arr(i)\
    \ == arr(j)) {\n                    p(i) = arr(i)\n                    j++\n \
    \               } else {\n                    p(i) = arr(j)\n                \
    \    k++\n                }\n            }\n            while (k < n) {\n    \
    \            if (arr(i) == arr(k)) {\n                    p(i) = arr(i)\n    \
    \                k++\n                } else {\n                    p(i) = arr(k)\n\
    \                    j++\n                }\n            }\n            while\
    \ (j < n) {\n                if (arr(i) == arr(j)) {\n                    p(i)\
    \ = arr(i)\n                    j++\n                } else {\n              \
    \      p(i) = arr(j)\n                    k++\n                }\n           \
    \ }\n            while (k < n) {\n                if (arr(i) == arr(k)) {\n  \
    \                  p(i) = arr(i)\n                    k++\n                } else\
    \ {\n                    p(i) = arr(k)\n                    j++\n            \
    \    }\n            }\n            while (j < n) {\n                if (arr(i)\
    \ == arr(j)) {\n                    p(i) = arr(i)\n                    j++\n \
    \               } else {\n                    p(i) = arr(j)\n                \
    \    k++\n                }\n            }\n            while (k < n) {\n    \
    \            if (arr(i) == arr(k)) {\n                    p(i) = arr(i)\n    \
    \                k++\n                } else {\n                    p(i) = arr(k)\n\
    \                    j++\n                }\n            }\n            while\
    \ (j < n) {\n                if (arr(i) == arr(j)) {\n                    p(i)\
    \ = arr(i)\n                    j++\n                } else {\n              \
    \      p(i) = arr(j)\n                    k++\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpelznpc65.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpelznpc65.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpelznpc65.scala:37:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpelznpc65.scala:40:23 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpelznpc65.scala:46:23 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpelznpc65.scala:49:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var minChange = 0\n        var minChangeIndex = 0\n        var minChangeIndex2\
    \ = -1\n        var minChangeIndex3 = -1\n        var minChangeIndex4 = -1\n \
    \       var minChangeIndex5 = -1\n        var minChangeIndex6 = -1\n        var\
    \ minChangeIndex7 = -1\n        var minChangeIndex8 = -1\n        var minChangeIndex9\
    \ = -1\n        var minChangeIndex10 = -1\n        var minChangeIndex11 = -1\n\
    \        var minChangeIndex12 = -1\n        var minChangeIndex13 = -1;\n     \
    \   var minChangeIndex14 = -1;\n        var minChangeIndex15 = -1;\n        var\
    \ minChangeIndex16 = -1;\n        var minChangeIndex17 = -1;\n        var minChangeIndex18\
    \ = -1;\n        var minChangeIndex19 = -1;\n        var minChangeIndex20 = -1;\n\
    \        var minChangeIndex21 = -1;\n        var minChangeIndex22 = -1;\n    \
    \    var minChangeIndex23 = -1;\n        var minChangeIndex24 = -1;\n        var\
    \ minChangeIndex25 = -1;\n        var minChangeIndex26 = -1;\n        var minChangeIndex27\
    \ = -1;\n        var minChangeIndex28 = -1;\n        var minChangeIndex29 = -1;\n\
    \        var minChangeIndex30 = -1;\n        var minChangeIndex31 = -1;\n    \
    \    var minChangeIndex32 = -1;\n        var minChangeIndex33 = -1;\n        var\
    \ minChangeIndex34 = -1;\n        var minChangeIndex35 = -1;\n        var minChangeIndex36\
    \ = -1;\n        var minChangeIndex37 = -1;\n        var minChangeIndex38 = -1;\n\
    \        var minChangeIndex39 = -1;\n        var minChangeIndex40 = -1;\n    \
    \    var minChangeIndex41 = -1;\n        var minChangeIndex42 = -1;\n        var\
    \ minChangeIndex43 = -1;\n        var minChangeIndex44 = -1;\n        var minChangeIndex45\
    \ = -1;\n        var minChangeIndex46 = -1;\n        var minChangeIndex47 = -1;\n\
    \        var minChangeIndex48 = -1;\n        var minChangeIndex49 = -1;\n    \
    \    var minChangeIndex50 = -1;\n        var minChangeIndex51 = -1;\n        var\
    \ minChangeIndex52 = -1;\n        var minChangeIndex53 = -1;\n        var minChangeIndex54\
    \ = -1;\n        var minChangeIndex55 = -1;\n        var minChangeIndex56 = -1;\n\
    \        var minChangeIndex57 = -1;\n        var minChangeIndex58 = -1;\n    \
    \    var minChangeIndex59 = -1;\n        var minChangeIndex60 = -1;\n        var\
    \ minChangeIndex61 = -1;\n        var minChangeIndex62 = -1;\n        var minChangeIndex63\
    \ = -1;\n        var minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt2phkqbc.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt2phkqbc.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt2phkqbc.scala:82:5\
    \ ---------------------\e[0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        var count = 0\n        var temp = 0\n        var temp2 = 0\n\
    \        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n       \
    \ var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9\
    \ = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    \
    \    var temp94 = 0\n        var temp95 = 0\n        var temp96 = 0\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk400y6u0.scala:119:5\
    \ --------------------\e[0m\e[0m\n\e[31m119 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var minChange = 0\n        var minIndex = 0\n        var minVal = arr(0)\n\
    \        var minValIndex = 0\n        var maxVal = arr(0)\n        var maxValIndex\
    \ = 0\n        var maxIndex = 0\n        var maxChange = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex = 0\n     \
    \   var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var\
    \ maxChangeValIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeVal\
    \ = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex = 0\n   \
    \     var maxChangeVal = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex = 0\n     \
    \   var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var\
    \ maxChangeValIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeVal\
    \ = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex = 0\n   \
    \     var maxChangeVal = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex = 0\n     \
    \   var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var\
    \ maxChangeValIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeVal\
    \ = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex = 0\n   \
    \     var maxChangeVal = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex = 0\n     \
    \   var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var\
    \ maxChangeValIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeVal\
    \ = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex = 0\n   \
    \     var maxChangeVal = 0\n        var maxChangeValIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex = 0\n     \
    \   var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var maxChangeValIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChangeVal = 0\n        var\
    \ maxChangeValIndex = 0\n        var maxChangeIndex = 0\n        var maxChangeVal\
    \ = 0\n        var maxChangeVal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp75b87vzg.scala:97:4 ----------------------------\e\
    [0m\e[0m\n\e[31m97 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp75b87vzg.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChangeIndex is already defined as \e[33mvariable\e[0m \e\
    [35mmaxChangeIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp75b87vzg.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeVal\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeVal\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeVal\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp75b87vzg.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxChangeValIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChangeValIndex is already defined as \e[33mvariable\e[0m\
    \ \e[35mmaxChangeValIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp75b87vzg.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmaxChangeIndex is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp75b87vzg.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexArr\
    \ = 0\n        val minChangeIndexArrLen = 0\n        val minChangeIndexArrLenArr\
    \ = 0\n        val minChangeIndexArrLenArrLen = 0\n        val minChangeIndexArrLenArrLenArr\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLen = 0\n        val minChangeIndexArrLenArrLenArrLenArr\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLen = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArr\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLen = 0\n        val\
    \ minChangeIndexArrLenArrLenArrLenArrLenArrLen = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLen = 0\n  \
    \      val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen = 0\n    \
    \    val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen = 0\n      \
    \  val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen = 0\n        val\
    \ minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen =\
    \ 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArrLen\
    \ = 0\n        val minChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLenArr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpysa8vi0t.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpysa8vi0t.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminChangeIndexArrLenArrLenArrLenArrLenArrLen\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mminChangeIndexArrLenArrLenArrLenArrLenArrLen is already defined\
    \ as \e[33mvalue\e[0m \e[35mminChangeIndexArrLenArrLenArrLenArrLenArrLen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpysa8vi0t.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArrLenArrLenArrLenArrLenArrLen\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexArrLenArrLenArrLenArrLenArrLen is already defined\
    \ as \e[33mvalue\e[0m \e[35mminChangeIndexArrLenArrLenArrLenArrLenArrLen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpysa8vi0t.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen is\
    \ already defined as \e[33mvalue\e[0m \e[35mminChangeIndexArrLenArrLenArrLenArrLenArrLenArrLenArrLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpysa8vi0t.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArrLenA"
  stdout: ''
  timestamp: 1660010266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        val r = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var max\
    \ = 0\n        var count = 0\n        var temp = 0\n        var temp2 = 0\n  \
    \      var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var\
    \ temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 =\
    \ 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps1c1uwqy.scala:117:5\
    \ --------------------\e[0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ val s = new Array[Long](n + 1)\n        val minChange = Long.MaxValue\n    \
    \    val minChangeIndex = 0\n        val maxChangeIndex = 0\n        val maxChange\
    \ = Long.MinValue\n        val maxChangeIndex = 0\n        val minChangeIndex\
    \ = 0\n        val minChange = Long.MaxValue\n        val minChangeIndex = 0\n\
    \        val minChange = Long.MaxValue\n        val minChangeIndex = 0\n     \
    \   val minChange = Long.MaxValue\n        val minChangeIndex = 0\n        val\
    \ minChange = Long.MaxValue\n        val minChangeIndex = 0\n        val minChange\
    \ = Long.MaxValue\n        val minChangeIndex = 0\n        val minChange = Long.MaxValue\n\
    \        val minChangeIndex = 0\n        val minChange = Long.MaxValue\n     \
    \   val minChangeIndex = 0\n        val minChange = Long.MaxValue\n        val\
    \ minChangeIndex = 0\n        val minChange = Long.MaxValue\n        val minChangeIndex\
    \ = 0\n        val minChange = Long.MaxValue\n        val minChangeIndex = 0\n\
    \        val minChange = Long.MaxValue\n        val minChangeIndex = 0\n     \
    \   val minChange = Long.MaxValue\n        val minChangeIndex = 0\n        val\
    \ minChange = Long.MaxValue\n        val minChangeIndex = 0\n        val minChange\
    \ = Long.MaxValue\n        val minChangeIndex = 0\n        val minChange = Long.MaxValue\n\
    \        val minChangeIndex = 0\n        val minChange = Long.MaxValue\n     \
    \   val minChangeIndex = 0\n        val minChange = Long.MaxValue\n        val\
    \ minChangeIndex = 0\n        val minChange = Long.MaxValue\n        val minChangeIndex\
    \ = 0\n        val minChange = Long.MaxValue\n        val minChangeIndex = 0\n\
    \        val minChange = Long.MaxValue\n        val minChangeIndex = 0\n     \
    \   val minChange = Long.MaxValue\n        val minChangeIndex = 0\n        val\
    \ minChange = Long.MaxValue\n        val minChangeIndex = 0\n        val minChange\
    \ = Long.MaxValue\n        val minChangeIndex = 0\n        val minChange = Long.MaxValue\n\
    \        val minChangeIndex = 0\n        val minChange = Long.MaxValue\n     \
    \   val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpt_qpht7u.scala:75:11 ---------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpt_qpht7u.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpt_qpht7u.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangeIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt_qpht7u.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminChange\e[0m = Long.MaxValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChange is already defined as \e[33mvalue\e[0m \e[35mminChange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpt_qpht7u.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangeIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /"
  stdout: ''
  timestamp: 1660010267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n     \
    \   var minChangeIndex3 = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5\
    \ = 0\n        var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n    \
    \    var minChangeIndex8 = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10\
    \ = 0\n        var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n  \
    \      var minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var\
    \ minChangeIndex15 = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17\
    \ = 0\n        var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n  \
    \      var minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var\
    \ minChangeIndex22 = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24\
    \ = 0\n        var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n  \
    \      var minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var\
    \ minChangeIndex29 = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31\
    \ = 0\n        var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n  \
    \      var minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var\
    \ minChangeIndex36 = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38\
    \ = 0\n        var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n  \
    \      var minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var\
    \ minChangeIndex43 = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45\
    \ = 0\n        var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n  \
    \      var minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var\
    \ minChangeIndex50 = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52\
    \ = 0\n        var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n  \
    \      var minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var\
    \ minChangeIndex57 = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59\
    \ = 0\n        var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n  \
    \      var minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var\
    \ minChangeIndex64 = 0\n        var minChangeIndex65 = 0\n        var minChangeIndex66\
    \ = 0\n        var minChangeIndex67 = 0\n        var minChangeIndex68 = 0\n  \
    \      var minChangeIndex69 = 0\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9qrx2pc8.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp9qrx2pc8.scala:90:5 ---------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var minChange = 0\n        var minChangeIndex = 0\n        var i = 0\n \
    \       var j = 0\n        while(i < len) {\n            while(j < len) {\n  \
    \              if(arr(i) == arr(j)) {\n                    j++\n             \
    \   } else {\n                    minChange = arr(i)\n                    minChangeIndex\
    \ = i\n                    i = j\n                    j = 0\n                }\n\
    \            }\n            i += 1\n        }\n        minChange\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfozcl4y7.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpfozcl4y7.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ maxChange = arr.tail.foldLeft(0l){ (acc, x) => if (x == m) acc + 1 else acc}\n\
    \        val change = arr.tail.foldLeft(0l){ (acc, x) => if (x == m) acc + 1 else\
    \ acc}\n        if (change == maxChange) 0\n        else if (change > maxChange)\
    \ change\n        else maxChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl58h4uft.scala:24)\n\tat Problem.main(tmpl58h4uft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(x => x)\n        var i = 0\n      \
    \  var j = 0\n        var k = 0\n        var min = 0\n        var max = 0\n  \
    \      var count = 0\n        while(i < arr.length && j < arr.length) {\n    \
    \        if(arr(i) == arr(j)) {\n                count += 1\n                i\
    \ += 1\n                j += 1\n            } else {\n                if(arr(i)\
    \ < arr(j)) {\n                    min = count\n                    max = j\n\
    \                    k = i\n                    while(arr(k) == arr(max - 1))\
    \ {\n                        max -= 1\n                    }\n               \
    \     while(arr(k) == arr(min + 1)) {\n                        min += 1\n    \
    \                }\n                    if(min > max) {\n                    \
    \    min = max\n                    }\n                    count = min - max\n\
    \                } else {\n                    min = count\n                 \
    \   max = i\n                    k = j\n                    while(arr(k) == arr(max\
    \ - 1)) {\n                        max -= 1\n                    }\n         \
    \           while(arr(k) == arr(min + 1)) {\n                        min += 1\n\
    \                    }\n                    if(min > max) {\n                \
    \        min = max\n                    }\n                    count = min - max\n\
    \                }\n            }\n        }\n        if(min == 0) {\n       \
    \     return 0\n        }\n        return count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzi2z4hcq.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010266
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val minChange = arr.foldLeft(0l) { (acc, elem) =>\n    \
    \        val newAcc = acc + elem\n            if (newAcc > arr.last) newAcc\n\
    \            else newAcc\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhmom8w1.scala:23)\n\tat Problem.main(tmpdhmom8w1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val maxChange\
    \ = arr.size - 1\n        val changes = mutable.ArrayBuffer(0)\n        var i\
    \ = 0\n        var j = 0\n        while (i < n) {\n            while (j < n &&\
    \ arr(i) == arr(j)) {\n                j += 1\n            }\n            val\
    \ change = j - i\n            if (change > maxChange) {\n                maxChange\
    \ = change\n            }\n            changes += change\n            i += 1\n\
    \            j += 1\n        }\n        if (changes.size == 1) {\n           \
    \ return 0\n        }\n        val smallestChange = changes.min\n        if (smallestChange\
    \ == 0) {\n            return 1\n        }\n        return smallestChange\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi4zmlc9w.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpi4zmlc9w.scala:27:26 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                maxChange = change\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val maxChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        while (i < n) {\n            while (j < n)\
    \ {\n                if (arr(i) == arr(j)) {\n                    p(k) = arr(i)\n\
    \                    j++\n                    k++\n                }\n       \
    \         else {\n                    p(k) = arr(j)\n                    j++\n\
    \                    k++\n                }\n            }\n            while\
    \ (k < n) {\n                if (arr(i) == arr(k)) {\n                    p(k)\
    \ = arr(i)\n                    k++\n                }\n                else {\n\
    \                    p(k) = arr(k)\n                    k++\n                }\n\
    \            }\n            while (k < n) {\n                if (arr(i) == arr(k))\
    \ {\n                    p(k) = arr(i)\n                    k++\n            \
    \    }\n                else {\n                    p(k) = arr(k)\n          \
    \          k++\n                }\n            }\n            while (k < n) {\n\
    \                if (arr(i) == arr(k)) {\n                    p(k) = arr(i)\n\
    \                    k++\n                }\n                else {\n        \
    \            p(k) = arr(k)\n                    k++\n                }\n     \
    \       }\n            while (k < n) {\n                if (arr(i) == arr(k))\
    \ {\n                    p(k) = arr(i)\n                    k++\n            \
    \    }\n                else {\n                    p(k) = arr(k)\n          \
    \          k++\n                }\n            }\n            while (k < n) {\n\
    \                if (arr(i) == arr(k)) {\n                    p(k) = arr(i)\n\
    \                    k++\n                }\n                else {\n        \
    \            p(k) = arr(k)\n                    k++\n                }\n     \
    \       }\n            while (k < n) {\n                if (arr(i) == arr(k))\
    \ {\n                    p(k) = arr(i)\n                    k++\n            \
    \    }\n                else {\n                    p(k) = arr(k)\n          \
    \          k++\n                }\n            }\n            while (k < n) {\n\
    \                if (arr(i) == arr(k)) {\n                    p(k) = arr(i)\n\
    \                    k++\n                }\n                else {\n        \
    \            p(k) = arr(k)\n                    k++\n                }\n     \
    \       }\n            while (k < n) {\n                if (arr(i) == arr(k))\
    \ {\n                    p(k) = arr(i)\n                    k++\n            \
    \    }\n                else {\n                    p(k) = arr(k)\n          \
    \          k++\n                }\n            }\n            while (k < n) {\n\
    \                if (arr(i) == arr(k)) {\n                    p(k) = arr(i)\n\
    \                    k++\n                }\n                else {\n        \
    \            p(k) = arr(k)\n                    k++\n                }\n     \
    \       }\n            while (k < n) {\n                if (arr(i) == arr(k))\
    \ {\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr4z8lq3r.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpr4z8lq3r.scala:32:23 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr4z8lq3r.scala:38:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpr4z8lq3r.scala:42:23 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpr4z8lq3r.scala:48:23 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr4z8lq3r.scala:52:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var max = 0\n        var temp = 0\n      \
    \  var flag = 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4\
    \ = 0\n        var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n \
    \       var temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n       \
    \ var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n        var\
    \ temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n        var temp17\
    \ = 0\n        var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n\
    \        var temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n    \
    \    var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n        var\
    \ temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n        var temp30\
    \ = 0\n        var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n\
    \        var temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n    \
    \    var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n        var\
    \ temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n        var temp43\
    \ = 0\n        var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n\
    \        var temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n    \
    \    var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n        var\
    \ temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n        var temp56\
    \ = 0\n        var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n\
    \        var temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n    \
    \    var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n        var\
    \ temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n        var temp69\
    \ = 0\n        var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n\
    \        var temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n    \
    \    var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n        var\
    \ temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n        var temp82\
    \ = 0\n        var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n\
    \        var temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n    \
    \    var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n        var\
    \ temp92 = 0\n        var temp93 = 0\n        var temp94\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphcl9rd0e.scala:118:4 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmphcl9rd0e.scala:118:5 --------------------\e[0m\e[0m\n\e[31m118 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexSet\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet2 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet3 = mutable.HashSet[Int]()\n        val minChangeIndexSet4\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet5 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet6 = mutable.HashSet[Int]()\n        val minChangeIndexSet7\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet8 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet9 = mutable.HashSet[Int]()\n        val minChangeIndexSet10\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet11 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet12 = mutable.HashSet[Int]()\n        val minChangeIndexSet13\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet14 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet15 = mutable.HashSet[Int]()\n        val minChangeIndexSet16\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet17 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet18 = mutable.HashSet[Int]()\n        val minChangeIndexSet19\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet20 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet21 = mutable.HashSet[Int]()\n        val minChangeIndexSet22\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet23 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet24 = mutable.HashSet[Int]()\n        val minChangeIndexSet25\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet26 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet27 = mutable.HashSet[Int]()\n        val minChangeIndexSet28\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet29 = mutable.HashSet[Int]()\n\
    \        val minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplzj2kdke.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplzj2kdke.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzj2kdke.scala:19:32\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mminChangeIndexSet\e[0m = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplzj2kdke.scala:20:33 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSet2\e[0m\
    \ = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzj2kdke.scala:21:33\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mminChangeIndexSet3\e[0m = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplzj2kdke.scala:22:33 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSet4\e[0m\
    \ = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^^^\e[0m\n"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxChange = len - 1\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex = mutable.ListBuffer[Int]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex\
    \ = mutable.ListBuffer[Int\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpikrj199i.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpikrj199i.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeIndex\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpikrj199i.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpikrj199i.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpikrj199i.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel defin"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val max = (arr.head + arr.last) / 2\n        val max2\
    \ = max / 2\n        val max3 = max / 3\n        val max4 = max / 4\n        val\
    \ max5 = max / 5\n        val max6 = max / 6\n        val max7 = max / 7\n   \
    \     val max8 = max / 8\n        val max9 = max / 9\n        val max10 = max\
    \ / 10\n        val max11 = max / 11\n        val max12 = max / 12\n        val\
    \ max13 = max / 13\n        val max14 = max / 14\n        val max15 = max / 15\n\
    \        val max16 = max / 16\n        val max17 = max / 17\n        val max18\
    \ = max / 18\n        val max19 = max / 19\n        val max20 = max / 20\n   \
    \     val max21 = max / 21\n        val max22 = max / 22\n        val max23 =\
    \ max / 23\n        val max24 = max / 24\n        val max25 = max / 25\n     \
    \   val max26 = max / 26\n        val max27 = max / 27\n        val max28 = max\
    \ / 28\n        val max29 = max / 29\n        val max30 = max / 30\n        val\
    \ max31 = max / 31\n        val max32 = max / 32\n        val max33 = max / 33\n\
    \        val max34 = max / 34\n        val max35 = max / 35\n        val max36\
    \ = max / 36\n        val max37 = max / 37\n        val max38 = max / 38\n   \
    \     val max39 = max / 39\n        val max40 = max / 40\n        val max41 =\
    \ max / 41\n        val max42 = max / 42\n        val max43 = max / 43\n     \
    \   val max44 = max / 44\n        val max45 = max / 45\n        val max46 = max\
    \ / 46\n        val max47 = max / 47\n        val max48 = max / 48\n        val\
    \ max49 = max / 49\n        val max50 = max / 50\n        val max51 = max / 51\n\
    \        val max52 = max / 52\n        val max53 = max / 53\n        val max54\
    \ = max / 54\n        val max55 = max / 55\n        val max56 = max / 56\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqzx6qxie.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqzx6qxie.scala:74:5 ---------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ val s = new Array[Long](n + 1)\n        val minChange = 0\n        val minChangeIndex\
    \ = 0\n        val minChangeIndex2 = 0\n        val minChangeIndex3 = 0\n    \
    \    val minChangeIndex4 = 0\n        val minChangeIndex5 = 0\n        val minChangeIndex6\
    \ = 0\n        val minChangeIndex7 = 0\n        val minChangeIndex8 = 0\n    \
    \    val minChangeIndex9 = 0\n        val minChangeIndex10 = 0\n        val minChangeIndex11\
    \ = 0\n        val minChangeIndex12 = 0\n        val minChangeIndex13 = 0\n  \
    \      val minChangeIndex14 = 0\n        val minChangeIndex15 = 0\n        val\
    \ minChangeIndex16 = 0\n        val minChangeIndex17 = 0\n        val minChangeIndex18\
    \ = 0\n        val minChangeIndex19 = 0\n        val minChangeIndex20 = 0\n  \
    \      val minChangeIndex21 = 0\n        val minChangeIndex22 = 0\n        val\
    \ minChangeIndex23 = 0\n        val minChangeIndex24 = 0\n        val minChangeIndex25\
    \ = 0\n        val minChangeIndex26 = 0\n        val minChangeIndex27 = 0\n  \
    \      val minChangeIndex28 = 0\n        val minChangeIndex29 = 0\n        val\
    \ minChangeIndex30 = 0\n        val minChangeIndex31 = 0\n        val minChangeIndex32\
    \ = 0\n        val minChangeIndex33 = 0\n        val minChangeIndex34 = 0\n  \
    \      val minChangeIndex35 = 0\n        val minChangeIndex36 = 0\n        val\
    \ minChangeIndex37 = 0\n        val minChangeIndex38 = 0\n        val minChangeIndex39\
    \ = 0\n        val minChangeIndex40 = 0\n        val minChangeIndex41 = 0\n  \
    \      val minChangeIndex42 = 0\n        val minChangeIndex43 = 0\n        val\
    \ minChangeIndex44 = 0\n        val minChangeIndex45 = 0\n        val minChangeIndex46\
    \ = 0\n        val minChangeIndex47 = 0\n        val minChangeIndex48 = 0\n  \
    \      val minChangeIndex49 = 0\n        val minChangeIndex50 = 0\n        val\
    \ minChangeIndex51 = 0\n        val minChangeIndex52 = 0\n        val minChangeIndex53\
    \ = 0\n        val minChangeIndex54 = 0\n        val minChangeIndex55 = 0\n  \
    \      val minChangeIndex56 = 0\n        val minChangeIndex57 = 0\n        val\
    \ minChangeIndex58 = 0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplmypg1dq.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ == arr(j)) {\n                    j++\n                }\n                else\
    \ {\n                    if(arr(i) < arr(j)) {\n                        min =\
    \ Math.min(min, j-k)\n                        k++\n                    }\n   \
    \                 else {\n                        min = Math.min(min, i-k)\n \
    \                       k++\n                    }\n                    j++\n\
    \                }\n            }\n            i++\n            j = 0\n      \
    \      k = 0\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp40arvtw.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpp40arvtw.scala:29:27 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                        k++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpp40arvtw.scala:33:27 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                        k++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpp40arvtw.scala:35:23 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpp40arvtw.scala:39:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpp40arvtw.scala:15:18 ---------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1660010271
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        while(i\
    \ < n && j < n) {\n            if(arr(i) == arr(j)) {\n                k = k +\
    \ 1\n                i = i + 1\n                j = j + 1\n            }\n   \
    \         else {\n                if(k > 0) {\n                    min = min +\
    \ 1\n                }\n                k = k - 1\n                i = i + 1\n\
    \                j = j + 1\n            }\n        }\n        if(k > 0) {\n  \
    \          min = min + 1\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgsdd4geh.scala:42)\n\tat Problem.main(tmpgsdd4geh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxagnnr2_.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxagnnr2_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxagnnr2_.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val arr\
    \ = arr.sortWith(_ < _)\n        val len = arr.size\n        var i = 0\n     \
    \   var j = 0\n        var k = 0\n        var min = n\n        var max = n\n \
    \       var change = 0\n        while (i < n) {\n            while (j < n) {\n\
    \                if (arr(i) == arr(j)) {\n                    j++\n          \
    \      } else {\n                    change = arr(i) - arr(j)\n              \
    \      if (change < 0) {\n                        change = -change\n         \
    \           }\n                    if (change < min) {\n                     \
    \   min = change\n                    }\n                    if (change > max)\
    \ {\n                        max = change\n                    }\n           \
    \         j++\n                }\n            }\n            i += 1\n        \
    \    j += 1\n        }\n        if (min == max) {\n            return 0\n    \
    \    }\n        if (min > max) {\n            min = max\n        }\n        return\
    \ min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1pxcfbsb.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp1pxcfbsb.scala:40:23 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1pxcfbsb.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                \
    \  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ l = arr.last\n        val d = arr.init\n        val r = arr.tail\n        val\
    \ m = arr.head\n        val l = arr.last\n        val d = arr.init\n        val\
    \ r = arr.tail\n        val m = arr.head\n        val l = arr.last\n        val\
    \ d = arr.init\n        val r = arr.tail\n        val m = arr.head\n        val\
    \ l = arr.last\n        val d = arr.init\n        val r = arr.tail\n        val\
    \ m = arr.head\n        val l = arr.last\n        val d = arr.init\n        val\
    \ r = arr.tail\n        val m = arr.head\n        val l = arr.last\n        val\
    \ d = arr.init\n        val r = arr.tail\n        val m = arr.head\n        val\
    \ l = arr.last\n        val d = arr.init\n        val r = arr.tail\n        val\
    \ m = arr.head\n        val l = arr.last\n        val d = arr.init\n        val\
    \ r = arr.tail\n        val m = arr.head\n        val l = arr.last\n        val\
    \ d = arr.init\n        val r = arr.tail\n        val m = arr.head\n        val\
    \ l = arr.last\n        val d = arr.init\n        val r = arr.tail\n        val\
    \ m = arr.head\n        val l = arr.last\n        val d = arr.init\n        val\
    \ r = arr.tail\n        val m = arr.head\n        val l = arr.last\n        val\
    \ d = arr.init\n        val r = arr.tail\n        val m = arr.head\n        val\
    \ l = arr.last\n        val d = arr.init\n        val r = arr.tail\n        val\
    \ m = arr.head\n        val l = arr.last\n        val d = arr.init\n        val\
    \ r = arr.tail\n        val m = arr.head\n        val l = arr.last\n        val\
    \ d = arr.init\n        val r = arr.tail\n        val m = arr.head\n        val\
    \ l = arr.last\n        val d = arr.init\n        val r = arr.tail\n        val\
    \ m = arr.head\n        val l = arr.last\n        val d = arr.init\n        val\
    \ r = arr.tail\n        val m = arr.head\n        val l = arr.last\n        val\
    \ d = arr.init\n        val r = arr.tail\n        val m = arr.head\n        val\
    \ l = arr.last\n        val d = arr.init\n        val r = arr.tail\n        val\
    \ m = arr.head\n        val l = arr.last\n        val d = arr.init\n        val\
    \ r = arr.tail\n        val m = arr.head\n        val l = arr.last\n        val\
    \ d = arr.init\n        val r = arr.tail\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp1oc49163.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1oc49163.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1oc49163.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1oc49163.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1oc49163.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1oc49163.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var max = 0\n        var temp = 0\n      \
    \  var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5\
    \ = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n \
    \       var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n      \
    \  var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n        var\
    \ temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var temp18\
    \ = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n\
    \        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n    \
    \    var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n        var\
    \ temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var temp31\
    \ = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n\
    \        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n    \
    \    var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n        var\
    \ temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var temp44\
    \ = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n\
    \        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n    \
    \    var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n        var\
    \ temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var temp57\
    \ = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n\
    \        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n    \
    \    var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n        var\
    \ temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var temp70\
    \ = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n\
    \        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n    \
    \    var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n        var\
    \ temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var temp83\
    \ = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n\
    \        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n    \
    \    var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n        var\
    \ temp93 = 0\n        var temp94 = 0\n        var temp\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcjauz62b.scala:118:4 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpcjauz62b.scala:118:5 --------------------\e[0m\e[0m\n\e[31m118 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val arr\
    \ = arr.sortWith(_ < _)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var min = n\n        while(i < n && j < n) {\n            if(arr(i)\
    \ == arr(j)) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                min += k\n            }\n            else {\n    \
    \            if(arr(i) < arr(j)) {\n                    i += 1\n             \
    \   }\n                else {\n                    j += 1\n                }\n\
    \                k += 1\n                min += k\n            }\n        }\n\
    \        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptyckuldq.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var max = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3\
    \ = 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n \
    \       var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n\
    \        var temp95 = 0\n        var temp96 = 0\n        var \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpl4bqinfd.scala:118:11 --------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl4bqinfd.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpl4bqinfd.scala:119:5 --------------------\e\
    [0m\e[0m\n\e[31m119 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val q = new Array[Long](n + 1)\n       \
    \ var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n     \
    \   var minIndex = 0\n        var maxIndex = 0\n        var max = 0\n        for(i\
    \ <- 0 until n) {\n            p(i) = arr(i)\n            q(i) = arr(i)\n    \
    \    }\n        for(i <- 0 until n) {\n            for(j <- 0 until n) {\n   \
    \             if(j > i) {\n                    if(p(j) < p(i)) {\n           \
    \             p(j) = p(i)\n                        q(i) = q(j)\n             \
    \       }\n                }\n            }\n        }\n        for(i <- 0 until\
    \ n) {\n            for(j <- 0 until n) {\n                if(j > i) {\n     \
    \               if(p(j) < p(i)) {\n                        p(j) = p(i)\n     \
    \                   q(i) = q(j)\n                    }\n                }\n  \
    \          }\n        }\n        for(i <- 0 until n) {\n            for(j <- 0\
    \ until n) {\n                if(j > i) {\n                    if(p(j) < p(i))\
    \ {\n                        p(j) = p(i)\n                        q(i) = q(j)\n\
    \                    }\n                }\n            }\n        }\n        for(i\
    \ <- 0 until n) {\n            for(j <- 0 until n) {\n                if(j > i)\
    \ {\n                    if(p(j) < p(i)) {\n                        p(j) = p(i)\n\
    \                        q(i) = q(j)\n                    }\n                }\n\
    \            }\n        }\n        for(i <- 0 until n) {\n            for(j <-\
    \ 0 until n) {\n                if(j > i) {\n                    if(p(j) < p(i))\
    \ {\n                        p(j) = p(i)\n                        q(i) = q(j)\n\
    \                    }\n                }\n            }\n        }\n        for(i\
    \ <- 0 until n) {\n            for(j <- 0 until n) {\n                if(j > i)\
    \ {\n                    if(p(j) < p(i)) {\n                        p(j) = p(i)\n\
    \                        q(i) = q(j)\n                    }\n                }\n\
    \            }\n        }\n        for(i <- 0 until n) {\n            for(j <-\
    \ 0 until n) {\n                if(j > i) {\n                    if(p(j) < p(i))\
    \ {\n                        p(j) = p(i)\n                        q(i) = q(j)\n\
    \                    }\n                }\n            }\n        }\n        for(i\
    \ <- 0 until n) {\n            for(j <- 0 until n) {\n                if(j > i)\
    \ {\n                    if(p(j) < p(i)) {\n                        p(j) = p(i)\n\
    \                        q(i) = q(j)\n                    }\n                }\n\
    \            }\n        }\n        for(i \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9rad2glm.scala:111:4 ---------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n1 error found\n"
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var change = 0\n        var minChange =\
    \ 0\n        var maxChange = 0\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var minChangeIndex2 = 0\n        var maxChangeIndex2 = 0\n    \
    \    var minChangeIndex3 = 0\n        var maxChangeIndex3 = 0\n        var minChangeIndex4\
    \ = 0\n        var maxChangeIndex4 = 0\n        var minChangeIndex5 = 0\n    \
    \    var maxChangeIndex5 = 0\n        var minChangeIndex6 = 0\n        var maxChangeIndex6\
    \ = 0\n        var minChangeIndex7 = 0\n        var maxChangeIndex7 = 0\n    \
    \    var minChangeIndex8 = 0\n        var maxChangeIndex8 = 0\n        var minChangeIndex9\
    \ = 0\n        var maxChangeIndex9 = 0\n        var minChangeIndex10 = 0\n   \
    \     var maxChangeIndex10 = 0\n        var minChangeIndex11 = 0\n        var\
    \ maxChangeIndex11 = 0\n        var minChangeIndex12 = 0\n        var maxChangeIndex12\
    \ = 0\n        var minChangeIndex13 = 0\n        var maxChangeIndex13 = 0\n  \
    \      var minChangeIndex14 = 0\n        var maxChangeIndex14 = 0\n        var\
    \ minChangeIndex15 = 0\n        var maxChangeIndex15 = 0\n        var minChangeIndex16\
    \ = 0\n        var maxChangeIndex16 = 0\n        var minChangeIndex17 = 0\n  \
    \      var maxChangeIndex17 = 0\n        var minChangeIndex18 = 0\n        var\
    \ maxChangeIndex18 = 0\n        var minChangeIndex19 = 0\n        var maxChangeIndex19\
    \ = 0\n        var minChangeIndex20 = 0\n        var maxChangeIndex20 = 0\n  \
    \      var minChangeIndex21 = 0\n        var maxChangeIndex21 = 0\n        var\
    \ minChangeIndex22 = 0\n        var maxChangeIndex22 = 0\n        var minChangeIndex23\
    \ = 0\n        var maxChangeIndex23 = 0\n        var minChangeIndex24 = 0\n  \
    \      var maxChangeIndex24 = 0\n        var minChangeIndex25 = 0\n        var\
    \ maxChangeIndex25 = 0\n        var minChangeIndex26 = 0\n        var maxChangeIndex26\
    \ = 0\n        var minChangeIndex27 = 0\n        var maxChangeIndex27 = 0\n  \
    \      var minChangeIndex28 = 0\n        var maxChangeIndex28 = 0\n        var\
    \ minChangeIndex29 = 0\n        var maxChangeIndex29 = 0\n        var minChangeIndex30\
    \ = 0\n        var maxChangeIndex30 = 0\n        var minChangeIndex31 = 0\n  \
    \      var maxChangeIndex31 = 0\n        var minChangeIndex32 = 0\n        var\
    \ maxChangeIndex32 = 0\n        var minChangeIndex33 = 0\n        var maxChangeIndex33\
    \ = 0\n        var \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpr2gsawwe.scala:91:11 ---------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr2gsawwe.scala:92:5 ---------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ r = arr.last\n        val max = (r - m + 1) * (n - 1)\n        val min = (r\
    \ - m + 1) * (n - 1)\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var l = 0\n        var count = 0\n        var sum = 0\n        var temp\
    \ = 0\n        while (i < n && j < n) {\n            if (arr(i) == arr(j)) {\n\
    \                count += 1\n                sum += arr(i)\n                i\
    \ += 1\n                j += 1\n            } else if (arr(i) < arr(j)) {\n  \
    \              count += 1\n                sum += arr(i)\n                i +=\
    \ 1\n            } else {\n                count += 1\n                sum +=\
    \ arr(j)\n                j += 1\n            }\n        }\n        if (count\
    \ > max) {\n            temp = count\n            count = max\n            max\
    \ = temp\n        }\n        if (count < min) {\n            temp = count\n  \
    \          count = min\n            min = temp\n        }\n        if (count ==\
    \ 0) {\n            return 0\n        }\n        if (count == 1) {\n         \
    \   return 1\n        }\n        val ans = sum / count\n        return ans\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp93pmd5ta.scala:30:20 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                sum += arr(i)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a\
    \ member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp93pmd5ta.scala:35:20 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m                sum += arr(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value += is not a member of Int - did you\
    \ mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp93pmd5ta.scala:39:20\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                sum += arr(j)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp93pmd5ta.scala:45:20 --------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m            count = max\n\e[31m\e[31m   |\e[0m           \
    \         ^^^\e[0m\n\e[31m   |\e[0m                    Found:    (max : Long)\n\
    \e[31m   |\e[0m                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp93pmd5ta.scala:46:16 -----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            max = temp\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val max\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp93pmd5ta.scala:50:20\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m            count = min\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m                   \
    \ Found:    (min : Long)\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp93pmd5ta.scala:51:16 -----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            min = temp\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var minChange = 0\n        var minChangeIndex = 0\n        var i = 0\n \
    \       var j = 0\n        var k = 0\n        var temp = 0\n        var temp2\
    \ = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n \
    \       var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var\
    \ temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12\
    \ = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n\
    \        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n    \
    \    var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var\
    \ temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25\
    \ = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n\
    \        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n    \
    \    var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var\
    \ temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38\
    \ = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n\
    \        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n    \
    \    var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var\
    \ temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51\
    \ = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n\
    \        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n    \
    \    var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var\
    \ temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64\
    \ = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n\
    \        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n    \
    \    var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var\
    \ temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77\
    \ = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n\
    \        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n    \
    \    var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var\
    \ temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90\
    \ = 0\n        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n\
    \        var temp94 = 0\n        var temp95 = 0\n        var temp96\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprp8s53e5.scala:118:4 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprp8s53e5.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprp8s53e5.scala:118:5\
    \ --------------------\e[0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = len\n        var i = 0\n        var j = 0\n        while(i < len)\
    \ {\n            while(j < len && arr(i) == arr(j)) {\n                j++\n \
    \           }\n            min = Math.min(min, j - i)\n            i = j\n   \
    \         j = 0\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkqyxpqg4.scala:22:19 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkqyxpqg4.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010272
