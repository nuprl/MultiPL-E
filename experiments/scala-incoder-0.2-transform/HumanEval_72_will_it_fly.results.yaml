language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val balanced = maxSum < maxWeight\n        val palindromic =\
    \ q.reverse.forall(e => e == q(0))\n        val sumLessOrEqual = maxSum - maxWeight\n\
    \        balanced && palindromic && sumLessOrEqual < 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt9hhqe3g.scala:28)\n\tat Problem.main(tmpt9hhqe3g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n    \
    \    val isLessThanMaxButNotBalanced = maxSum < maxWeight && !isBalanced\n   \
    \     val isLessThanMaxButBalanced = maxSum < maxWeight && isBalanced\n      \
    \  val isLessThanMaxButNotBalancedButPalindromic = maxSum < maxWeight && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic = maxSum\
    \ < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxButBalancedButPalindromicButNotPalindromic = maxSum <\
    \ maxWeight && isBalanced && isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromicButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromicButNotBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindro\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplmrfbq6n.scala:34:183 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromicButNotBalanced\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindro\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \                                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                                  Not found: isPalindro\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplmrfbq6n.scala:35:5 ---------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlipped = q.forall(_ < maxWeight)\n    \
    \    isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfepc8lwo.scala:28)\n\tat Problem.main(tmpfepc8lwo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = palindromic && isBalanced\n        val\
    \ isFlippableAndBalanced = isFlippable && isBalanced\n        isFlippableAndBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8yz2bn96.scala:30)\n\tat Problem.main(tmp8yz2bn96.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbajh2s5_.scala:28)\n\tat Problem.main(tmpbajh2s5_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlippable = q.tail.forall(_ < q.head)\n  \
    \      isPalindromic && isBalanced && isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgne1_g_a.scala:28)\n\tat Problem.main(tmpgne1_g_a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val balanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q(0))\n        val isLessOrEqual = maxSum\
    \ < maxWeight\n        (balanced && isPalindromic && isLessOrEqual)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5grzr3ed.scala:28)\n\tat Problem.main(tmp5grzr3ed.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n\
    \        val isBalanced = maxSum - maxWeight <= 0\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvblicvph.scala:27)\n\tat Problem.main(tmpvblicvph.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessThanMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80x1_8x1.scala:28)\n\tat Problem.main(tmp80x1_8x1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvau6m78f.scala:28)\n\tat Problem.main(tmpvau6m78f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgas32qf0.scala:27)\n\tat Problem.main(tmpgas32qf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfhbxwzbw.scala:28)\n\tat Problem.main(tmpfhbxwzbw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum - maxWeight < 0\n        (isPalindromic && isBalanced)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpervi87tq.scala:27)\n\tat Problem.main(tmpervi87tq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = palindromic && isBalanced\n        isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1nh9ycs.scala:29)\n\tat Problem.main(tmpj1nh9ycs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfElements\
    \ = w.toLong * q.sum\n        val maxWeightSumOfElementsOfElements = w.toLong\
    \ * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElements =\
    \ w.toLong * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n    \
    \    val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprjkqbvv6.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprjkqbvv6.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x >= maxSum - maxWeight)\n        isPalindromic\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6i5sglo9.scala:27)\n\tat Problem.main(tmp6i5sglo9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n    \
    \    val result = isFly\n        println(s\"$result $q w $w maxSum $maxSum maxWeight\
    \ $maxWeight isPalindromic $isPalindromic isBalanced $isBalanced isFly $isFly\"\
    )\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9h_2m5yt.scala:30)\n\tat Problem.main(tmp9h_2m5yt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: 'false List(3, 2, 3) w 9 maxSum 8 maxWeight 9 isPalindromic false isBalanced
    true isFly false

    '
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val maxList =\
    \ q.max\n        val maxListSize = maxList.size\n        val maxListElements =\
    \ maxList.iterator\n        val maxListElementsSize = maxListElements.size\n \
    \       val maxListElementsSum = maxListElements.sum\n        val maxListElementsSumLessOrEqualToMaxWeight\
    \ = maxListElementsSum < maxWeight\n        val maxListElementsSumGreaterOrEqualToMaxWeight\
    \ = maxListElementsSum > maxWeight\n        val maxListElementsSumLessOrEqualToMaxWeightAndBalanced\
    \ = maxListElementsSumLessOrEqualToMaxWeight && maxListElementsSize == maxListElementsSumLessOrEqualToMaxWeight\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalanced = maxListElementsSumGreaterOrEqualToMaxWeight\
    \ && maxListElementsSize == maxListElementsSumGreaterOrEqualToMaxWeight\n    \
    \    val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic =\
    \ maxListElementsSumLessOrEqualToMaxWeightAndBalanced && maxListElementsIsPalindromic(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromic\
    \ = maxListElementsSumGreaterOrEqualToMaxWeightAndBalanced && maxListElementsIsPalindromic(maxList)\n\
    \        val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsEven\
    \ = maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic && maxListElementsIsEven(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsEven\
    \ = maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromic &&\
    \ maxListElementsIsEven(maxList)\n        val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsOdd\
    \ = maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic && maxListElementsIsOdd(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjxkog4sx.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxkog4sx.scala:23:34\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListSize\e[0m = maxList.size\n\e[31m\e[31m   |\e[0m                   \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value size\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxkog4sx.scala:24:38\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListElements\e[0m = maxList.iterator\n\e[31m\e[31m   |\e[0m           \
    \                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \           value iterator is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjxkog4sx.scala:37:5 ---------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFly = isPalindromic && isBalanced\n        val result\
    \ = isFly\n        println(\"willItFly: isFly = \" + isFly + \", isPalindromic\
    \ = \" + isPalindromic + \", isBalanced = \" + isBalanced + \", maxSum = \" +\
    \ maxSum + \", maxWeight = \" + maxWeight + \", result = \" + result)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplq878lg4.scala:30)\n\tat Problem.main(tmplq878lg4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: 'willItFly: isFly = false, isPalindromic = false, isBalanced = true, maxSum
    = 8, maxWeight = 9, result = false

    '
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.foldLeft(0l)(_ + _) <= maxWeight\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        isPalindromic\
    \ && isLessThanMaxAndBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfkwhk5rn.scala:29)\n\tat Problem.main(tmpfkwhk5rn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptozxrpus.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x.toLong)\n        sums.last <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq3hjyxq4.scala:26)\n\tat Problem.main(tmpq3hjyxq4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlippable\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpji0kbc9t.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1660010163
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum == maxWeight\n        val isFlippable\
    \ = maxWeight - maxSum < 0\n        val isFlippableAndBalanced = isFlippable &&\
    \ isBalanced\n        val isFlippableAndPalindromic = isFlippable && isPalindromic\n\
    \        val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced &&\
    \ isPalindromic\n        val isFlippableAndBalancedAndPalindromicAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable\n  \
    \      val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable && isFlippable\n\
    \        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable && isFlippable\
    \ && isFlippable && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable && isFlippable\
    \ && isFlippable && isFlippable && isFlippable && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsmaj_3jl.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpsmaj_3jl.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010169
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.sum\n       \
    \ val isPalindromic = q.isEmpty\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isFlipped = isPalindromic && isBalanced\n        val isLessThanMaxWeight\
    \ = sumOfElements < maxWeight\n        val isLessThanMaxWeightAndBalanced = isLessThanMaxWeight\
    \ && isBalanced\n        val isLessThanMaxWeightAndFlipped = isLessThanMaxWeight\
    \ && isFlipped\n        val isLessThanMaxWeightAndNotFlipped = isLessThanMaxWeight\
    \ && !isFlipped\n        isLessThanMaxWeightAndNotFlipped\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr6_u68x0.scala:33)\n\tat Problem.main(tmpr6_u68x0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sumOfElements <= maxSum\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp74x4ae7p.scala:26)\n\tat Problem.main(tmp74x4ae7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n\
    \        val isBalanced = maxSum < maxWeight\n        val isWon = isPalindromic\
    \ && isBalanced\n        val isLost = !isPalindromic && !isBalanced\n        isWon\
    \ || isLost\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjo8uqriu.scala:29)\n\tat Problem.main(tmpjo8uqriu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfWeights = q.sum\n        val isPalindromic\
    \ = q.isEmpty\n        val isBalanced = sumOfWeights <= maxWeight\n        val\
    \ isFlippable = q.tail.isEmpty && q.head == q.head.reverse\n        val isFlippableAndBalanced\
    \ = isFlippable && isBalanced\n        val isFlippableAndPalindromic = isFlippable\
    \ && isPalindromic\n        val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced\
    \ && isPalindromic\n        val isFlippableAndBalancedAndPalindromicAndNotFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalanced\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced\n  \
    \      val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromic\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced && !isPalindromic\n\
    \        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromicAndNotFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced && !isPalindromic\
    \ && !isFlippable\n        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotBalanced\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced && !isPalindromic\
    \ && !isFlippable && !isBalanced\n        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotBalancedAndNotPalindromic\
    \ = isFlippableAndBalanced && isPalindrom\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7ep2d_r2.scala:24:61 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.tail.isEmpty\
    \ && q.head == q.head.reverse\n\e[31m\e[31m   |\e[0m                         \
    \                             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                        value reverse is not a member of Long\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7ep2d_r2.scala:33:169 -----------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36misFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotBalancedAndNotPalindromic\e\
    [0m = isFlippableAndBalanced && isPalindrom\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \                                                                            \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \             Not found: isPalindrom\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp7ep2d_r2.scala:34:5 ---------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l)(_ + _)\n\
    \        val isBalanced = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        val isLessOrEqualPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic2 =\
    \ q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic3 = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqualPalindromic4 = q.reverse.forall(x =>\
    \ x == q(0))\n        val isLessOrEqualPalindromic5 = q.reverse.forall(x => x\
    \ == q(0))\n        val isLessOrEqualPalindromic6 = q.reverse.forall(x => x ==\
    \ q(0))\n        val isLessOrEqualPalindromic7 = q.reverse.forall(x => x == q(0))\n\
    \        val isLessOrEqualPalindromic8 = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessOrEqualPalindromic9 = q.reverse.forall(x => x == q(0))\n    \
    \    val isLessOrEqualPalindromic10 = q.reverse.forall(x => x == q(0))\n     \
    \   val isLessOrEqualPalindromic11 = q.reverse.forall(x => x == q(0))\n      \
    \  val isLessOrEqualPalindromic12 = q.reverse.forall(x => x == q(0))\n       \
    \ val isLessOrEqualPalindromic13 = q.reverse.forall(x => x == q(0))\n        val\
    \ isLessOrEqualPalindromic14 = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic15\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic16 =\
    \ q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic17 = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqualPalindromic18 = q.reverse.forall(x =>\
    \ x == q(0))\n        val isLessOrEqualPalindromic19 = q.reverse.forall(x => x\
    \ == q(0))\n        val isLessOrEqualPalindromic20 = q.reverse.forall(\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpt00gqhpp.scala:44:58 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualPalindromic20\e\
    [0m = q.reverse.forall(\n\e[31m\e[31m   |\e[0m                               \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt00gqhpp.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * w.toLong\n        val maxWeightSumOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeights = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeights = w.toLong *\
    \ w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeights = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpafzxxaso.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpafzxxaso.scala:37:5 ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010169
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51sbtrlv.scala:29)\n\tat Problem.main(tmp51sbtrlv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n\
    \        val maxList = q.reverse\n        val maxListSum = maxList.reduceLeft(_\
    \ + _)\n        val isBalanced = maxListSum == maxSum\n        val isPalindromic\
    \ = maxList.reduceLeft(_ + _) == maxList.reduceRight(_ + _)\n        isBalanced\
    \ && isPalindromic\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpisl3jroy.scala:29)\n\tat Problem.main(tmpisl3jroy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.isEmpty\n        val isBalanced = sumOfElements <= maxWeight\n        val\
    \ isFlipped = q.reverse.forall(x => x != q.head)\n        (isPalindromic && isBalanced\
    \ && isFlipped)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpckrnyryy.scala:28)\n\tat Problem.main(tmpckrnyryy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = palindromic && isBalanced\n        isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1nh9ycs.scala:29)\n\tat Problem.main(tmpj1nh9ycs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElements = w.toLong\
    \ * q.length\n        val maxWeightSumOfElementsOfElementsOfElements = w.toLong\
    \ * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.to\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpaz4ip4kd.scala:36:169 -----------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\e\
    [0m = w.to\n\e[31m\e[31m   |\e[0m                                            \
    \                                                                            \
    \                                               ^^^^\e[0m\n\e[31m   |\e[0mAmbiguous\
    \ overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35mto\e[0m in\
    \ \e[33mtrait\e[0m \e[35mIntegralProxy\e[0m with types\n\e[31m   |\e[0m (end:\
    \ Long, step: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0m (end: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0mboth match expected type <?>\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpaz4ip4kd.scala:37:5 ---------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51sbtrlv.scala:29)\n\tat Problem.main(tmp51sbtrlv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        isFlippable\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1fkbjvv4.scala:28)\n\tat Problem.main(tmp1fkbjvv4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.foldLeft(0l)(_ + _) <= maxWeight\n        val isFlippable = q.foldLeft(0l)(_\
    \ + _) <= maxSum && isPalindromic\n        val isFlippable2 = q.foldLeft(0l)(_\
    \ + _) <= maxSum && isPalindromic && isBalanced\n        val isFlippable3 = q.foldLeft(0l)(_\
    \ + _) <= maxSum && isPalindromic && isBalanced && isFlippable2\n        isFlippable3\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyg0hr3zb.scala:30)\n\tat Problem.main(tmpyg0hr3zb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        val isNotFly\
    \ = !palindromic && !isBalanced\n        val isNotBalanced = !palindromic && isBalanced\n\
    \        val isNotFly_2 = !palindromic && !isBalanced && sumOfElements > maxWeight\n\
    \        val isNotBalanced_2 = !palindromic && !isBalanced && sumOfElements <\
    \ maxWeight\n        val isNotFly_3 = !palindromic && !isBalanced && sumOfElements\
    \ == maxWeight\n        val isNotBalanced_3 = !palindromic && !isBalanced && sumOfElements\
    \ != maxWeight\n        val isNotFly_4 = !palindromic && !isBalanced && sumOfElements\
    \ < maxWeight && sumOfElements == maxWeight\n        val isNotBalanced_4 = !palindromic\
    \ && !isBalanced && sumOfElements > maxWeight && sumOfElements == maxWeight\n\
    \        val isNotFly_5 = !palindromic && !isBalanced && sumOfElements < maxWeight\
    \ && sumOfElements != maxWeight\n        val isNotBalanced_5 = !palindromic &&\
    \ !isBalanced && sumOfElements > maxWeight && sumOfElements != maxWeight\n   \
    \     val isNotFly_6 = !palindromic && !isBalanced && sumOfElements == maxWeight\
    \ && sumOfElements != maxWeight\n        val isNotBalanced_6 = !palindromic &&\
    \ !isBalanced && sumOfElements != maxWeight && sumOfElements == maxWeight\n  \
    \      val isNotFly_7 = !palindromic && !isBalanced && sumOfElements < maxWeight\
    \ && sumOfElements != maxWeight && sumOfElements == maxWeight\n        val isNotBalanced_7\
    \ = !palindromic && !isBalanced && sumOfElements > maxWeight && sumOfElements\
    \ != maxWeight && sumOfElements == maxWeight\n        val isNotFly_8 = !palindromic\
    \ && !isBalanced && sumOfElements < maxWeight && sumOfElements != maxWeight &&\
    \ sumOfElements != maxWeight\n        val isNotBalance\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_uhwcsz7.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_uhwcsz7.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.foldLeft(0l) { (sum, elem) => sum\
    \ + elem }\n        val isBalanced = sumOfElements <= maxWeight\n        val isFly\
    \ = palindromic && isBalanced\n        isFly\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdyof7eta.scala:29)\n\tat Problem.main(tmpdyof7eta.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q(0))\n        isBalanced && isPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf851xj29.scala:27)\n\tat Problem.main(tmpf851xj29.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindrome = q.reverse.forall(x => x ==\
    \ x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindrome && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpihgmbrgr.scala:29)\n\tat Problem.main(tmpihgmbrgr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, elem) =>\
    \ sum + elem }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n  \
    \      val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(_\
    \ < maxWeight)\n        isPalindromic && isBalanced && isFlippable\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp54ym504c.scala:28)\n\tat Problem.main(tmp54ym504c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn_6iqm3j.scala:27)\n\tat Problem.main(tmpn_6iqm3j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * w.toLong\n        val maxWeightSumOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElements = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElements = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.to\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl_wp8zov.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\e\
    [0m = w.toLong * w.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpl_wp8zov.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\e\
    [0m = w.to\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpl_wp8zov.scala:37:5 ---------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e"
  stdout: ''
  timestamp: 1660010181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.isPalindromic\n        val isBalanced = q.isBalanced\n        val isFlipped\
    \ = q.isFlipped\n        val isLessOrEqualToMaxWeight = sumOfElements <= maxWeight\n\
    \        val isLessOrEqualToMaxWeightAndBalanced = sumOfElements <= maxWeight\
    \ && isBalanced\n        val isLessOrEqualToMaxWeightAndFlipped = sumOfElements\
    \ <= maxWeight && isFlipped\n        val isLessOrEqualToMaxWeightAndPalindromic\
    \ = sumOfElements <= maxWeight && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedAndFlipped\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped\n        val isLessOrEqualToMaxWeightAndPalindromicAndFlipped\
    \ = sumOfElements <= maxWeight && isPalindromic && isFlipped\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic\n \
    \       val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlipped\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic &&\
    \ isFlipped\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlippedAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic &&\
    \ isFlipped && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlippedAndPalindromicAndFlipped\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic &&\
    \ isFlipped && isPalindromic && isFlipped\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlipped\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7rxtah67.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7rxtah67.scala:22:30\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36misPalindromic\e[0m = q.isPalindromic\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ isPalindromic is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp7rxtah67.scala:23:27 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misBalanced\e[0m = q.isBalanced\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    value isBalanced is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp7rxtah67.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misFlipped\e[0m = q.isFlipped\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        value isFlipped is not a member of List[Long]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp7rxtah67.scala:36:5 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010188
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        val isFlippableAndLessThanMaxWeight = isFlippable && maxWeight\
    \ < q.reduceLeft(_ + _)\n        isFlippableAndLessThanMaxWeight\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyxqqja7m.scala:29)\n\tat Problem.main(tmpyxqqja7m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum ==\
    \ maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n        val\
    \ isLessThanMaxSum = maxSum < q.reduce(_ + _)\n        isPalindromic && isBalanced\
    \ && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpe2blv8dv.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1660010182
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum < maxWeight\n        val isFlipped = isPalindromic\
    \ && isBalanced\n        isFlipped\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn1rwv1oz.scala:28)\n\tat Problem.main(tmpn1rwv1oz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5b9bnlp4.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51sbtrlv.scala:29)\n\tat Problem.main(tmp51sbtrlv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x + maxSum == maxWeight)\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiknblkon.scala:28)\n\tat Problem.main(tmpiknblkon.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlipped = q.forall(_ < maxWeight)\n    \
    \    isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfepc8lwo.scala:28)\n\tat Problem.main(tmpfepc8lwo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoh73jpum.scala:28)\n\tat Problem.main(tmpoh73jpum.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = sumOfElements <=\
    \ maxWeight\n        val isFlippable = isPalindromic && isBalanced\n        isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr7ziit2w.scala:28)\n\tat Problem.main(tmpr7ziit2w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.isEmpty || q.head == q.reverse.head\n\
    \        val isBalanced = maxSum - maxWeight < 0\n        val isFlipped = q.tail\
    \ == q.reverse.tail\n        isPalindromic && isBalanced && isFlipped\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tvi89vc.scala:33)\n\tat Problem.main(tmp0tvi89vc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x <= maxWeight && x >= maxWeight - q.reduce(_ + _))\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxButBalanced = maxSum < maxWeight\
    \ - q.reduce(_ + _)\n        val isLessThanMaxButNotPalindromic = maxSum < maxWeight\
    \ - q.reduce(_ + _) && isPalindromic\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight - q.reduce(_ + _) && !isPalindromic && !isBalanced\n  \
    \      isLessThanMax && isLessThanMaxButBalanced && isLessThanMaxButNotPalindromic\
    \ && isLessThanMaxButNotBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvfqetw_y.scala:31)\n\tat Problem.main(tmpvfqetw_y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x.toLong\
    \ == x)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp87i4to92.scala:29)\n\tat Problem.main(tmp87i4to92.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isBalanced = q.length <= maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMaxSum = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppm4y2l4x.scala:28)\n\tat Problem.main(tmppm4y2l4x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val maxList =\
    \ q.max\n        val maxListSize = maxList.size\n        val maxListSum = maxList.sum\n\
    \        val maxListElements = maxListSize * maxListSum\n        val maxListElementsLessOrEqual\
    \ = maxListElements <= maxWeight\n        val maxListElementsLessOrEqualPalindromic\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic\n        val maxListElementsLessOrEqualPalindromicAndBalanced\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\n\
    \        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqual\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual\n        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromic\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList.isPalindromic\n        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromicAndBalanced\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\n\
    \        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromicAndBalancedAndSumLessOrEqual\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual\n        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromic\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe9ssea_c.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxListSize\e[0m = maxList.size\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value size is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpe9ssea_c.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e[0m = maxList.sum\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value sum is not a member of Long\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpe9ssea_c.scala:34:5 ---------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp49okm4ls.scala:28)\n\tat Problem.main(tmp49okm4ls.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val balanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        (balanced && isPalindromic)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpseaatikj.scala:27)\n\tat Problem.main(tmpseaatikj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.isEmpty || q.reverse == q\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlipped = q.tail == q.head\n        isPalindromic\
    \ && isBalanced && isFlipped\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpktprmt2_.scala:24:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misFlipped\e[0m = q.tail\
    \ == q.head\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mValues of types List[Long @uncheckedVariance] and Long cannot be\
    \ compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isFlippable = isPalindromic && isBalanced\n      \
    \  val isFlippable = maxSum == maxWeight && isPalindromic && isBalanced\n    \
    \    isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyylxcwrk.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = maxSum\
    \ == maxWeight && isPalindromic && isBalanced\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660010182
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        val isBalanced = maxSumOfElements <= maxSum\n\
    \        val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isLessOrEqualToMaxWeight\
    \ = maxSumOfElements <= maxSum\n        val isLessOrEqualToMaxWeightAndBalanced\
    \ = isLessOrEqualToMaxWeight && isBalanced\n        val isLessOrEqualToMaxWeightAndPalindromic\
    \ = isLessOrEqualToMaxWeight && isPalindromic\n        val isLessOrEqualToMaxWeightAndNotBalanced\
    \ = isLessOrEqualToMaxWeight && !isBalanced\n        val isLessOrEqualToMaxWeightAndNotPalindromic\
    \ = isLessOrEqualToMaxWeight && !isPalindromic\n        (isLessOrEqualToMaxWeightAndNotBalanced\
    \ || isLessOrEqualToMaxWeightAndNotPalindromic)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2zikkk2k.scala:33)\n\tat Problem.main(tmp2zikkk2k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        val isFlipped = q.tail.reverse.forall(_ == q.head)\n   \
    \     isFlippable && isFlipped\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpskpil189.scala:29)\n\tat Problem.main(tmpskpil189.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        sumOfElements <= maxWeight\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdmjlaq7t.scala:26)\n\tat Problem.main(tmpdmjlaq7t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ elem) => sum + elem }\n        val isBalanced = maxSum == maxWeight\n      \
    \  val isPalindromic = q.reverse.forall(elem => elem == q.head)\n        isBalanced\
    \ && isPalindromic\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp17suktjd.scala:27)\n\tat Problem.main(tmp17suktjd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.foldLeft(false)((acc, x) => acc && x <= maxWeight && x == q.reduceLeft(_\
    \ + _))\n        val isLessThanMax = q.foldLeft(false)((acc, x) => acc && x <=\
    \ maxWeight && x == maxSum)\n        isPalindromic && isBalanced && isLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprb9mua6j.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight || x < maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpahg6tu4f.scala:28)\n\tat Problem.main(tmpahg6tu4f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isFlippable = maxSum <= maxWeight\
    \ && maxWeight <= maxSum\n        val isFlippablePalindromic = isPalindromic &&\
    \ isBalanced && isFlippable\n        val isFlippablePalindromic2 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic3 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic4 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic5 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic6 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic7 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic8 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic9 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic10 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic11 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic12 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic13 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic14 = isPalindromic\
    \ && isBalanced && isFlippable\n        val isFlippablePalindromic15 = isPalindromic\
    \ && isBalanced && isFlippable\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6q9tamtu.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010201
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sum = q.sum\n        val isBalanced = sum <= maxWeight\n\
    \        val isFly = palindromic && isBalanced\n        isFly\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxb1eqxa1.scala:29)\n\tat Problem.main(tmpxb1eqxa1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val palindromic\
    \ = q.reverse.forall(x => x == x.reverse)\n        val balanced = palindromic\
    \ && q.sum < maxWeight\n        val unbalanced = !palindromic && q.sum > maxWeight\n\
    \        balanced && unbalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvc7b8awm.scala:22:55 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x == x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                  value reverse is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n    \
    \    val isLessThanMaxButNotBalanced = maxSum < maxWeight && !isBalanced\n   \
    \     val isLessThanMaxButBalanced = maxSum < maxWeight && isBalanced\n      \
    \  (isPalindromic && isBalanced && isLessThanMax && isLessThanMaxButNotBalanced\
    \ && isLessThanMaxButBalanced)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnhzvi6iw.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        (isPalindromic && isBalanced && isFlippable)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3z6vo206.scala:28)\n\tat Problem.main(tmp3z6vo206.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum - maxWeight <= 0\n        (isPalindromic\
    \ && isBalanced)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwg4f2of6.scala:27)\n\tat Problem.main(tmpwg4f2of6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxSumOfElements = q.foldLeft(0l) { (sum, element) => sum + element\
    \ }\n        val isBalanced = maxSumOfElements <= maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualPalindromic = maxSumOfElements <= maxSumOfElements.reverse\n\
    \        val isLessOrEqualPalindromicReverse = maxSumOfElements <= maxSumOfElements.reverse\n\
    \        val isLessOrEqualPalindromicReverseReverse = maxSumOfElements <= maxSumOfElements.reverse.reverse\n\
    \        val isLessOrEqualPalindromicReverseReverseReverse = maxSumOfElements\
    \ <= maxSumOfElements.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwoygpph_.scala:26:76 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualPalindromic\e\
    [0m = maxSumOfElements <= maxSumOfElements.reverse\n\e[31m\e[31m   |\e[0m    \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value reverse is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwoygpph_.scala:27:83\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36misLessOrEqualPalindromicReverse\e[0m = maxSumOfElements <= maxSumOfElements.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \               value reverse is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpwoygpph_.scala:28:90 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualPalindromicReverseReverse\e\
    [0m = maxSumOfElements <= maxSumOfElements.reverse.reverse\n\e[31m\e[31m   |\e\
    [0m                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value reverse is not a\
    \ member of Long\nException in thread \"main\" java.lang.StackOverflowError\n\t\
    at dotty.tools.dotc.ast.Trees$Instance$TreeAccumulator.foldOver(Trees.scala:1521)\n\
    \tat dotty.tools.dotc.ast.untpd$UntypedTreeTraverser.traverseChildren(untpd.scala:786)\n\
    \tat dotty.tools.dotc.printing.SyntaxHighlighting$TreeHighlighter$2$.traverse(SyntaxHighlighting.scala:123)\n\
    \tat dotty.tools.dotc.ast.untpd$UntypedTreeTraverser.apply(untpd.scala:785)\n\t\
    at dotty.tools.dotc.ast.untpd$UntypedTreeTraverser.apply(untpd.scala:785)\n\t\
    at dotty.tools.dotc.ast.Trees$Instance$TreeAccumulator.foldOver(Trees.scala:1529)\n\
    \tat dotty.tools.dotc.ast.untpd$UntypedTreeTraverser.traverseChildren(untpd.scala:786)\n\
    \tat dotty.tools.dotc.printing.SyntaxHighlighting$TreeHighlighter$2$.traverse(SyntaxHighlighting.scala:123)\n\
    \tat dotty.tools.dotc.a"
  stdout: 'java.lang.StackOverflowError while compiling /tmp/tmpwoygpph_.scala

    '
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n      \
    \  val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        val isNotFly = !isFly\n        isFly\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplf4q2w6i.scala:29)\n\tat Problem.main(tmplf4q2w6i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n \
    \       val isBalanced = maxSum < maxWeight\n        val isFlipped = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        val isMoreOrEqual\
    \ = maxSum > maxWeight\n        isPalindromic && isBalanced && isFlipped && isLessOrEqual\
    \ && isMoreOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoch1qe58.scala:30)\n\tat Problem.main(tmpoch1qe58.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfWeights = q.foldLeft(0l) { (sum,\
    \ elem) => sum + elem }\n        sumOfWeights <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwqmuqc_l.scala:26)\n\tat Problem.main(tmpwqmuqc_l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw2ynlyfx.scala:28)\n\tat Problem.main(tmpw2ynlyfx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn_6iqm3j.scala:27)\n\tat Problem.main(tmpn_6iqm3j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight <= 0\n        val isFlipped = isPalindromic && isBalanced\n\
    \        val isNotFlipped = !isPalindromic && !isBalanced\n        isFlipped ||\
    \ isNotFlipped\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpngqf_zcf.scala:29)\n\tat Problem.main(tmpngqf_zcf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n   \
    \     val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxAndBalanced = isLessThanMax &&\
    \ isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxAndNotBalanced = isLessThanMax && !isBalanced\n    \
    \    val isLessThanMaxAndNotPalindromic = isLessThanMax && !isPalindromic\n  \
    \      (isLessThanMaxAndNotBalanced || isLessThanMaxAndNotPalindromic || isLessThanMaxAndAndBalanced\
    \ || isLessThanMaxAndPalindromic)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvqj9e2h2.scala:29:74 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        (isLessThanMaxAndNotBalanced || isLessThanMaxAndNotPalindromic\
    \ || isLessThanMaxAndAndBalanced || isLessThanMaxAndPalindromic)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \              Not found: isLessThanMaxAndAndBalanced\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val sumOfElements = q.sum\n\
    \        val isPalindromic = q.isEmpty\n        val isBalanced = sumOfElements\
    \ <= maxSum\n        val isFlippable = isPalindromic && isBalanced\n        val\
    \ isFlipped = q.tail.reverse.forall(x => x == q(0))\n        isFlippable && isFlipped\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwgln3ckp.scala:29)\n\tat Problem.main(tmpwgln3ckp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum,\
    \ element) => sum + element }\n        sumOfElements <= maxWeight\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8hgnhgkg.scala:26)\n\tat Problem.main(tmp8hgnhgkg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val palindromic = q.reverse.forall(x => x == q(0))\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = palindromic && isBalanced\n        val isFlippableAndBalanced = isFlippable\
    \ && isBalanced\n        val isFlippableAndNotBalanced = isFlippable && !isBalanced\n\
    \        val isFlippableAndNotBalancedAndNotPalindromic = isFlippable && !isBalanced\
    \ && !palindromic\n        isFlippableAndNotBalancedAndNotPalindromic\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpavhvqq1b.scala:32)\n\tat Problem.main(tmpavhvqq1b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi5exbff2.scala:28)\n\tat Problem.main(tmpi5exbff2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum - maxWeight < 0\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp559663m7.scala:27)\n\tat Problem.main(tmp559663m7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessOrEqual = maxSum < maxWeight\n        (isPalindromic\
    \ && isBalanced && isLessOrEqual)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcpydpkld.scala:28)\n\tat Problem.main(tmpcpydpkld.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindrome = q.reverse.forall(x => x %\
    \ 2 == 0)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindrome && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb9zg8ncd.scala:28)\n\tat Problem.main(tmpb9zg8ncd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x == q(0) + q(1)) && q.forall(x => x == q(0) + (q(1) / 2))\n\
    \        val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalanced = isBalanced\
    \ && isLessThanMaxWeight\n        val isLessThanMaxSumAndBalanced = isBalanced\
    \ && isLessThanMaxSum\n        val isLessThanMaxWeightAndPalindromic = isPalindromic\
    \ && isLessThanMaxWeight\n        val isLessThanMaxSumAndPalindromic = isPalindromic\
    \ && isLessThanMaxSum\n        val isLessThanMaxWeightAndPalindromicAndBalanced\
    \ = isBalanced && isLessThanMaxWeightAndPalindromic\n        val isLessThanMaxSumAndPalindromicAndBalanced\
    \ = isBalanced && isLessThanMaxSumAndPalindromic\n        val isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromic\
    \ = isBalanced && isLessThanMaxWeightAndPalindromicAndBalanced\n        val isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromic\
    \ = isBalanced && isLessThanMaxSumAndPalindromicAndBalanced\n        val isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromicAndIsBalanced\
    \ = isBalanced && isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromic\n\
    \        val isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromicAndIsBalanced\
    \ = isBalanced && isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromic\n\
    \        val isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromicAndIsBalancedAndIsPalindromic\
    \ = isBalanced && isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromicAndIsBalanced\n\
    \        val isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromicAndIsBalancedAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwo0t2u26.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwo0t2u26.scala:21:35 --------------------\e[0m\e[0m\n\e[31m21 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwo0t2u26.scala:38:5 ---------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0)((sum, element)\
    \ => sum + element)\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppro1_t3q.scala:21:60\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)((\e[36msum\e[0m, \e[36melement\e[0m) => sum + element)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \                     Found:    Long\n\e[31m   |\e[0m                        \
    \                                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong\n        val maxWeight = w\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sum = palindromic && q.sum\
    \ <= maxSum\n        val weight = sum && q.sum == maxSum\n        val balanced\
    \ = palindromic && q.sum == maxSum\n        val isPalindromic = q.forall(x =>\
    \ x == x.toLong)\n        val isBalanced = balance && balance == balance\n   \
    \     val isWeight = weight && weight == weight\n        val isPalindromicBalanced\
    \ = palindromic && balance == balance\n        val isPalindromicWeight = palindromic\
    \ && weight == weight\n        val isPalindromicBalancedWeight = palindromic &&\
    \ balance && weight == weight\n        val isPalindromicWeightBalanced = palindromic\
    \ && weight && balance == balance\n        val isPalindromicBalancedWeightBalanced\
    \ = palindromic && balance && weight && balance == balance\n        val isPalindromicWeightBalancedBalanced\
    \ = palindromic && weight && balance && balance == balance\n        val isPalindromicBalancedWeightBalancedBalanced\
    \ = palindromic && balance && weight && balance && balance == balance\n      \
    \  val isPalindromicWeightBalancedBalancedBalanced = palindromic && weight &&\
    \ balance && balance && balance == balance\n        val isPalindromicWeightBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance == balance\n\
    \        val isPalindromicWeightBalancedBalancedBalancedBalancedBalanced = palindromic\
    \ && weight && balance && balance && balance && balance && balance == balance\n\
    \        val isPalindromicWeightBalancedBalancedBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance && balance\
    \ && balance == balance\n        val isPalindromicWeightBalancedBalancedBalancedBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance && balance\
    \ && balance && balance == balance\n        val isPalindromicWeightBalancedBalancedBalancedBalancedBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance && \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp99oewsa7.scala:41:166 --------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36misPalindromicWeightBalancedBalancedBalancedBalancedBalancedBalancedBalancedBalanced\e\
    [0m = palindromic && weight && balance && balance && balance && balance && \n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                                                            \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                  expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp99oewsa7.scala:27:25 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e[0m = balance\
    \ && balance == balance\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: balance\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp99oewsa7.scala:29:51 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misPalindromicBalanced\e\
    [0m = palindromic && balance == balance\n\e[31m\e[31m   |\e[0m               \
    \                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                                        Not found: balance\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp99oewsa7.scala:31:57 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36misPalindromicBalancedWeight\e\
    [0m = palindromic && balance && weight == weight\n\e[31m\e[31m   |\e[0m      \
    \                                                   ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                      Not found: balance\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp99oewsa7.scala:32:6"
  stdout: ''
  timestamp: 1660010220
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduce(_ + _)\n    \
    \    val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n     \
    \   val isBalanced = isPalindromic && maxSum < maxWeight\n        isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplujgnu53.scala:27)\n\tat Problem.main(tmplujgnu53.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbajh2s5_.scala:28)\n\tat Problem.main(tmpbajh2s5_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isLessOrEqualToMaxWeight\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp25qj6w1r.scala:28)\n\tat Problem.main(tmp25qj6w1r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp64ode7rh.scala:28)\n\tat Problem.main(tmp64ode7rh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val palindromes = q.reverse.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x)\n        val sum = palindromes.foldLeft(0l)((acc, x) => acc\
    \ + x)\n        sum <= maxWeight\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ytnwsw4.scala:27)\n\tat Problem.main(tmp5ytnwsw4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.sum\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = sumOfElements <= maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe8yfw0h7.scala:28)\n\tat Problem.main(tmpe8yfw0h7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        isBalanced && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4w4wp2rl.scala:29)\n\tat Problem.main(tmp4w4wp2rl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n   \
    \     val isPalindromic = q.reverse.forall(e => e == q(0))\n        isBalanced\
    \ && isPalindromic\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo14nuxbr.scala:27)\n\tat Problem.main(tmpo14nuxbr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010229
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfqyyny6t.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sum = q.sum\n        val isBalanced = sum <= maxWeight\n\
    \        val isFly = palindromic && isBalanced\n        val isNotFly = !palindromic\
    \ && !isBalanced\n        val isNotBalanced = !palindromic && isBalanced\n   \
    \     val isNotFlyn = isNotFly && !isBalanced\n        val isNotBalanceyn = isNotBalanced\
    \ && !isBalanced\n        val isNotFlynn = isNotFly && !isBalanceyn\n        val\
    \ isNotBalanceynn = isNotBalanced && !isBalanceyn\n        val isNotFlynnn = isNotFly\
    \ && !isBalanceynn\n        val isNotBalanceynnn = isNotBalanced && !isBalanceynn\n\
    \        val isNotFlynnnn = isNotFly && !isBalanceynnn\n        val isNotBalanceynnnn\
    \ = isNotBalanced && !isBalanceynnn\n        val isNotFlynnnnn = isNotFly && !isBalanceynnnn\n\
    \        val isNotBalanceynnnnn = isNotBalanced && !isBalanceynnnnn\n        val\
    \ isNotFlynnnnnn = isNotFly && !isBalanceynnnnn\n        val isNotBalanceynnnnnn\
    \ = isNotBalanced && !isBalanceynnnnnn\n        val isNotFlynnnnnnn = isNotFly\
    \ && !isBalanceynnnnnnn\n        val isNotBalanceynnnnnnn = isNotBalanced && !isBalanceynnnnnnn\n\
    \        val isNotFlynnnnnnnn = isNotFly && !isBalanceynnnnnnn\n        val isNotBalanceynnnnnnn\
    \ = isNotBalanced && !isBalanceynnnnnnn\n        val isNotFlynnnnnnnnn = isNotFly\
    \ && !isBalanceynnnnnnn\n        val isNotBalanceynnnnnnnn = isNotBalanced &&\
    \ !isBalanceynnnnnnnn\n        val isNotFlynnnnnnnnn = isNotFly && !isBalanceynnnnnnnn\n\
    \        val isNotBalanceynnnnnnnnn = isNotBalanced && !isBalanceynnnnnnnnn\n\
    \        val isNotFlynnnnnnnnnn = isNotFly && !isBalanceynnnnnnnnn\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4je3a2ie.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36misNotBalanceynnnnnnn\e[0m\
    \ = isNotBalanced && !isBalanceynnnnnnn\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misNotBalanceynnnnnnn is already defined as \e[33mvalue\e[0m\
    \ \e[35misNotBalanceynnnnnnn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4je3a2ie.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36misNotFlynnnnnnnnn\e[0m =\
    \ isNotFly && !isBalanceynnnnnnnn\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misNotFlynnnnnnnnn is already defined as \e[33mvalue\e[0m \e\
    [35misNotFlynnnnnnnnn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4je3a2ie.scala:29:38 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misNotFlynn\e[0m = isNotFly\
    \ && !isBalanceyn\n\e[31m\e[31m   |\e[0m                                     \
    \ ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      Not found:\
    \ isBalanceyn\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4je3a2ie.scala:30:48\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36misNotBalanceynn\e[0m = isNotBalanced && !isBalanceyn\n\e[31m\e[31m   |\e[0m\
    \                                                ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                Not found: isBalanceyn\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4je3a2ie.scala:31:39\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36misNotFlynnn\e[0m = isNotFly && !isBalanceynn\n\e["
  stdout: ''
  timestamp: 1660010228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isFlippable = q.forall(x => x\
    \ == q.reverse.head)\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        isPalindromic && isBalanced && isFlippableAndBalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr7828msu.scala:29)\n\tat Problem.main(tmpr7828msu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight <= 0\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpln9ov9_r.scala:28)\n\tat Problem.main(tmpln9ov9_r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps8o6v3l9.scala:27)\n\tat Problem.main(tmps8o6v3l9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        isBalanced && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnir3s0f.scala:29)\n\tat Problem.main(tmpnnir3s0f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight <= 0\n        isPalindromic && isBalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjwkyom1p.scala:27)\n\tat Problem.main(tmpjwkyom1p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFly = isPalindromic && isBalanced\n        val isNotFly\
    \ = !isFly\n        isFly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc_lgi3f_.scala:29)\n\tat Problem.main(tmpc_lgi3f_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n\
    \        val palindromic = q.reverse.forall(x => x.toLong == x)\n        val sumOfElements\
    \ = q.foldLeft(0l) { (acc, x) => acc + x }\n        val isBalanced = sumOfElements\
    \ <= maxSum\n        val isFlippable = sumOfElements <= maxWeight && palindromic\n\
    \        isBalanced && isFlippable\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprbunw1_f.scala:30)\n\tat Problem.main(tmprbunw1_f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51sbtrlv.scala:29)\n\tat Problem.main(tmp51sbtrlv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum == maxWeight\n        isPalindromic\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4ka_klak.scala:27)\n\tat Problem.main(tmp4ka_klak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        (isPalindromic && isBalanced)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5grsfd4h.scala:27)\n\tat Problem.main(tmp5grsfd4h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpqg5ff865.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum == maxWeight\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced && isLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphtxv2ll_.scala:28)\n\tat Problem.main(tmphtxv2ll_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x + maxSum <= maxWeight)\n        isPalindromic\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn2ih1vrd.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxAndNotPalindromic = isLessThanMax\
    \ && !isPalindromic\n        isLessThanMaxAndNotPalindromic || isLessThanMaxAndBalanced\
    \ || isLessThanMaxAndPalindromic\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3jfuz31z.scala:32)\n\tat Problem.main(tmp3jfuz31z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isWightBalanced = isPalindromic && isBalanced\n   \
    \     isWightBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp62d7eblz.scala:28)\n\tat Problem.main(tmp62d7eblz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010240
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n    \
    \    val isNotFly = !isPalindromic || !isBalanced\n        isFly\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp94qv4_y7.scala:29)\n\tat Problem.main(tmp94qv4_y7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)((sum, elem) =>\
    \ sum + elem)\n        val isPalindromic = q.reverse.forall(elem => elem == q.head)\n\
    \        val isBalanced = maxSum == maxWeight\n        val isFlipped = q.forall(elem\
    \ => elem != q.head)\n        isPalindromic && isBalanced && isFlipped\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpam04ja1l.scala:21:50\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)((\e[36msum\e[0m, \e[36melem\e[0m) => sum + elem)\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Long\n\e[31m   |\e[0m                                                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010240
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.map(_.toLong).sum\n\
    \        sums <= maxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnbw6d8yo.scala:26)\n\tat Problem.main(tmpnbw6d8yo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n \
    \       val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic = maxSum\
    \ < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfifpgbap.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpfifpgbap.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.isEmpty\n        val isBalanced = maxSum == maxWeight\n  \
    \      val isFlipped = q.tail == q.head.reverse\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n\
    \        val isLessThanMaxSumAndBalanced = isLessThanMaxWeight && isBalanced\n\
    \        val isLessThanMaxSumAndFlipped = isLessThanMaxWeight && isFlipped\n \
    \       val isLessThanMaxSumAndNotPalindromic = isLessThanMaxWeight && !isPalindromic\n\
    \        val isLessThanMaxSumAndNotBalanced = isLessThanMaxSum && !isBalanced\n\
    \        val isLessThanMaxSumAndNotFlipped = isLessThanMaxSum && !isFlipped\n\
    \        val isLessThanMaxSumAndNotPalindromicAndNotBalanced = isLessThanMaxSum\
    \ && !isPalindromic && !isBalanced\n        val isLessThanMaxSumAndNotFlippedAndNotBalanced\
    \ = isLessThanMaxSum && !isFlipped && !isBalanced\n        val isLessThanMaxSumAndNotPalindromicAndNotFlipped\
    \ = isLessThanMaxSum && !isPalindromic && !isFlipped\n        val isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlipped\
    \ = isLessThanMaxSum && !isPalindromic && !isBalanced && !isFlipped\n        val\
    \ isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlippedAndNotPalindromic\
    \ = isLessThanMaxSum && !isPalindromic && !isBalanced && !isFlipped && !isPalindromic\n\
    \        val isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlippedAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxSum && !isPalindromic && !isBalanced && !isFlipped && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlipped\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiyn4bvp_.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiyn4bvp_.scala:24:41\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36misFlipped\e[0m = q.tail == q.head.reverse\n\e[31m\e[31m   |\e[0m         \
    \                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                   value reverse is not a member of Long\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpiyn4bvp_.scala:39:5 ---------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010245
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51sbtrlv.scala:29)\n\tat Problem.main(tmp51sbtrlv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - q.sum < 0\n        val isFlipped = q.forall(x => x < maxWeight)\n\
    \        isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkw58n689.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010244
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgas32qf0.scala:27)\n\tat Problem.main(tmpgas32qf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        q.reverse.foldLeft(true){ (acc,\
    \ elem) => acc && elem <= maxSum }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpywkc1th_.scala:25)\n\tat Problem.main(tmpywkc1th_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val maxList =\
    \ q.reverse\n        val maxListSum = maxList.sum\n        val maxListWeight =\
    \ maxList.sum\n        val maxListWeightDiff = maxListWeight - maxWeight\n   \
    \     val maxListSumDiff = maxListSum - maxSum\n        val maxListSumDiffAbs\
    \ = maxListSumDiff < 0 ? -maxListSumDiff : maxListSumDiff\n        val maxListWeightDiffAbs\
    \ = maxListWeightDiff < 0 ? -maxListWeightDiff : maxListWeightDiff\n        val\
    \ maxListWeightDiffAbsGreaterThanZero = maxListWeightDiffAbs > 0\n        val\
    \ maxListSumDiffAbsGreaterThanZero = maxListSumDiffAbs > 0\n        val maxListSumDiffLessThanZero\
    \ = maxListSumDiffAbs < 0\n        val maxListWeightDiffLessThanZero = maxListWeightDiffAbs\
    \ < 0\n        val maxListWeightDiffLessThanZeroOrZero = maxListWeightDiffAbs\
    \ == 0 || maxListWeightDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\n\
    \        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZero = maxListSumDiffAbs\
    \ == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs\
    \ == 0 || maxListSumDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\
    \ || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs ==\
    \ 0 || maxListSumDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZeroOrZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\
    \ || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs ==\
    \ 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs ==\
    \ 0\n        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZeroOr\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3d4njln5.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3d4njln5.scala:27:71\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListSumDiffAbs\e[0m = maxListSumDiff < \e[31m0\e[0m ? -maxListSumDiff :\
    \ \e[35mmaxListSumDiff\e[0m\n\e[31m\e[31m   |\e[0m                           \
    \                                            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                          Not found: type maxListSumDiff\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3d4njln5.scala:27:51\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListSumDiffAbs\e[0m = maxListSumDiff < \e[31m0\e[0m ? -maxListSumDiff :\
    \ \e[35mmaxListSumDiff\e[0m\n\e[31m\e[31m   |\e[0m                           \
    \                      ^^^\e[0m\n\e[31m   |\e[0m                             \
    \             value ? is not a member of Int\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp3d4njln5.scala:28:80 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightDiffAbs\e[0m = maxListWeightDiff\
    \ < \e[31m0\e[0m ? -maxListWeightDiff : \e[35mmaxListWeightDiff\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                  Not found: type maxListWeightDiff\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3d4njln5.scala:28:57 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightDiffAbs\e[0m\
    \ = maxListWeightDiff < \e[31m0\e[0m ? -maxListWeightDiff : \e[35mmaxListWeightDiff\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \    ^^^\e[0m\n\e[31m   |\e[0m                                          value\
    \ ? is not a member "
  stdout: ''
  timestamp: 1660010248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val sum = 0\n        val maxWeight\
    \ = w.toLong\n        val maxWeightSum = w.toLong * w.toLong\n        val maxWeightSumOfElements\
    \ = w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n        val\
    \ maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong *\
    \ w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n        val\
    \ maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\
    \ * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n\
    \        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\
    \ * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\
    \ * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\
    \ * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd1kmwhtj.scala:33:148 --------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\e\
    [0m = w.toLong * w.toLong * \n\e[31m\e[31m   |\e[0m                          \
    \                                                                            \
    \                                              ^\e[0m\n\e[31m   |\e[0m       \
    \                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd1kmwhtj.scala:34:5\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010246
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.foldRight(maxWeight)(_ + _) <= maxWeight\n        (isPalindromic && isBalanced)\
    \ && (maxSum < w)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplopmik37.scala:27)\n\tat Problem.main(tmplopmik37.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x == q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < q.sum\n        val isLessThanMaxSumAndBalanced\
    \ = isLessThanMaxWeight && isBalanced\n        val isLessThanMaxSumAndPalindromic\
    \ = isLessThanMaxWeight && isPalindromic\n        val isLessThanMaxSumAndNotBalanced\
    \ = isLessThanMaxWeight && !isBalanced\n        val isLessThanMaxSumAndNotPalindromic\
    \ = isLessThanMaxWeight && !isPalindromic\n        val isLessThanMaxSumAndNotBalancedAndPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxSumAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndNotBalancedAndNotPalindromic = isLessThanMaxWeight\
    \ && !isBalanced && !isPalindromic && !isLessThanMaxSum && !isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndNotBalancedAndNotPalindromic = isLessThanMaxWeight\
    \ && !isBalanced && !isPalindromic && !isLessThanMaxSum && !isLessThanMaxSum &&\
    \ !isLessThanMaxWeight\n        val isLessThanMaxSumAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxSum\
    \ && !isLessThanMaxSum && !isLessThanMaxSum && !isLessThanMaxWeight\n        val\
    \ isLessThanMaxSumAndNotBalancedAndNotPalindromic = isLessThanMaxWeight && !isBalanced\
    \ && !isPalindromic && !isLessThanMaxSum && !isLessThanMaxSum && !isLessThanMaxSum\
    \ && !isLessThanMaxSum && !isLessThanMaxWeight\n        val isLessThanMaxSumAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphe97neo4.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxSum\
    \ && !isLessThanMaxWeight\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndNotBalancedAndNotPalindromic is already\
    \ defined as \e[33mvalue\e[0m \e[35misLessThanMaxSumAndNotBalancedAndNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphe97neo4.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxSum\
    \ && !isLessThanMaxSum && !isLessThanMaxWeight\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndNotBalancedAndNotPalindromic is already\
    \ defined as \e[33mvalue\e[0m \e[35misLessThanMaxSumAndNotBalancedAndNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphe97neo4.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxSum\
    \ && !isLessThanMaxSum && !isLessThanMaxSum && !isLessThanMaxWeight\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.map(_.toLong)\n\
    \        val balanced = sums.forall(x => x <= maxSum)\n        val palindromic\
    \ = sums.forall(x => x == x.reverse)\n        val isPalindromic = sums.forall(x\
    \ => x == x.reverse)\n        val isBalanced = sums.forall(x => x <= maxSum)\n\
    \        val isNotPalindromic = sums.forall(x => x != x.reverse)\n        val\
    \ isNotBalanced = sums.forall(x => x <= maxSum)\n        val isNotPalindromicAndBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpngwmkug_.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpngwmkug_.scala:23:50\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mpalindromic\e[0m = sums.forall(\e[36mx\e[0m => x == x.reverse)\n\e[31m\e[31m\
    \   |\e[0m                                                ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   value reverse is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpngwmkug_.scala:24:52 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = sums.forall(\e\
    [36mx\e[0m => x == x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \               value reverse is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpngwmkug_.scala:26:55 ------------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m        \e[33mval\e[0m \e[36misNotPalindromic\e[0m = sums.forall(\e\
    [36mx\e[0m => x != x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                  value reverse is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpngwmkug_.scala:28:66 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36misNotPalindromicAndBalanced\e\
    [0m = sums.forall(\e[36mx\e[0m => x != x.reverse && x <= maxSum)\n\e[31m\e[31m\
    \   |\e[0m                                                                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value reverse is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpngwmkug_.scala:29:66\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36misNotBalancedAndPalindromic\e[0m = sums.forall(\e[36mx\e[0m => x != x.reverse\
    \ && x <= maxSum)\n\e[31m\e[31m   |\e[0m                                     \
    \                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  "
  stdout: ''
  timestamp: 1660010253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlippable\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_dcj2s9u.scala:28)\n\tat Problem.main(tmp_dcj2s9u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010252
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpya00jz6h.scala:28)\n\tat Problem.main(tmpya00jz6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010251
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, elem) => sum + elem }\n        sumOfElements <= maxSum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg6iw5dub.scala:26)\n\tat Problem.main(tmpg6iw5dub.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010251
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong).sum\n\
    \        sums <= maxSum && sums == maxSum.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4qxsmoqx.scala:25)\n\tat Problem.main(tmp4qxsmoqx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isWightBalanced = isPalindromic && isBalanced\n   \
    \     isWightBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp62d7eblz.scala:28)\n\tat Problem.main(tmp62d7eblz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010240
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxSumOfElements = q.foldLeft(0l) { (sum, e) => sum + e }\n     \
    \   val isBalanced = maxSumOfElements <= maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isFlippable = maxSumOfElements\
    \ - maxWeight <= 0\n        isBalanced && isPalindromic && isFlippable\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpngztdbob.scala:29)\n\tat Problem.main(tmpngztdbob.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMaxWeight = maxSum - w < 0\n        val\
    \ isLessThanMaxSum = maxSum - q.sum < 0\n        isBalanced && isPalindromic &&\
    \ isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfth64_ew.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010252
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        (isBalanced && isPalindromic && isLessOrEqual)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyv45yvwk.scala:28)\n\tat Problem.main(tmpyv45yvwk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = isLessThanMax && !isBalanced\n        val isLessThanMaxButBalanced = isLessThanMax\
    \ && isBalanced\n        val isLessThanMaxButNotPalindromic = isLessThanMax &&\
    \ !isPalindromic\n        val isLessThanMaxButPalindromic = isLessThanMax && isPalindromic\n\
    \        (isLessThanMaxButNotBalanced || isLessThanMaxButBalanced || isLessThanMaxButNotPalindromic\
    \ || isLessThanMaxButPalindromic)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq6ao_vmq.scala:33)\n\tat Problem.main(tmpq6ao_vmq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010254
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q(0))\n        val isLessThanMaxWeight =\
    \ maxSum < maxWeight\n        isBalanced && isPalindromic && isLessThanMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwl02uyry.scala:28)\n\tat Problem.main(tmpwl02uyry.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.foldRight(true)((acc, x) => acc && x == q(0))\n        (isPalindromic &&\
    \ isBalanced) && (maxSum < maxWeight)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplsl2t_80.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplsl2t_80.scala:23:59\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36misBalanced\e[0m = q.foldRight(\e[31mtrue\e[0m)((\e[36macc\e[0m, \e[36mx\e\
    [0m) => acc && x == q(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                  \
    \                                     ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                             value && is not a member of Long\n\e[31m\e[31m--\
    \ Error: /tmp/tmplsl2t_80.scala:23:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e[0m = q.foldRight(\e\
    [31mtrue\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc && x == q(\e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m       Values of types Boolean and Long\
    \ cannot be compared with == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1660010254
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val palindromic = q.reverse.forall(x\
    \ => x.toLong == x)\n        val sumOfElements = q.sum\n        val isBalanced\
    \ = sumOfElements <= maxWeight\n        val isFlippable = palindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp86ew1e5o.scala:29)\n\tat Problem.main(tmp86ew1e5o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sum = q.sum\n        val isBalanced = sum <= maxWeight\n\
    \        val isFly = palindromic && isBalanced\n        val isNotFly = !palindromic\
    \ || !isBalanced\n        isFly\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd_khhuvy.scala:30)\n\tat Problem.main(tmpd_khhuvy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010262
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ val isFlippableAndLessThanMaxWeight = isFlippable && maxSum < maxWeight\n  \
    \      isFlippableAndLessThanMaxWeight\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4vq18mvw.scala:29)\n\tat Problem.main(tmp4vq18mvw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010264
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == q.head)\n\
    \        val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isFlippable = q.reverse.forall(elem => elem == q.head)\n        val isFlippable\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == q.head)\n\
    \        val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isFlippable = q.reverse.forall(elem => elem == q.head)\n        val isFlippable\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == q.head)\n\
    \        val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isFlippable = q.reverse.forall(elem => elem == q.head)\n        val isFlippable\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == q.head)\n\
    \        val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isFlippable = q.reverse.forall(elem => elem == \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphigsxbyn.scala:47:58 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.reverse.forall(\e\
    [36melem\e[0m => elem == \n\e[31m\e[31m   |\e[0m                             \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmphigsxbyn.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.reverse.forall(\e\
    [36melem\e[0m => elem == q.head)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphigsxbyn.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.reverse.forall(\e\
    [36melem\e[0m => elem == q.head)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphigsxbyn.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.reverse.forall(\e\
    [36melem\e[0m => elem == q.head)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphigsxbyn.scala:28:12 ---------------------------\e[0m\e["
  stdout: ''
  timestamp: 1660010262
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.sum\n       \
    \ val isBalanced = sumOfElements <= maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isLessOrEqualToMaxWeight = sumOfElements <= maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_gj4zjdw.scala:28)\n\tat Problem.main(tmp_gj4zjdw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010265
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxhqj1o15.scala:27)\n\tat Problem.main(tmpxhqj1o15.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010266
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum,\
    \ element) => sum + element }\n        sumOfElements <= maxWeight\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8hgnhgkg.scala:26)\n\tat Problem.main(tmp8hgnhgkg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x\
    \ == q(0) + q(1))\n        val isLessThanMax = maxSum - maxWeight < 0\n      \
    \  val isLessThanMaxAndBalanced = maxSum - maxWeight < 0 && isBalanced\n     \
    \   val isLessThanMaxAndPalindromic = maxSum - maxWeight < 0 && isPalindromic\n\
    \        val isLessThanMaxAndBalancedAndPalindromic = maxSum - maxWeight < 0 &&\
    \ isBalanced && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0\n      \
    \  val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZero = maxSum - maxWeight\
    \ < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\n\
    \        val isLessThanMaxAndBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsevpk9af.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpsevpk9af.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010264
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdpxxbu2y.scala:27)\n\tat Problem.main(tmpdpxxbu2y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010267
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum - maxWeight < 0\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdj1siofn.scala:28)\n\tat Problem.main(tmpdj1siofn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.reduceLeft(_\
    \ + _)\n        sumOfElements <= maxWeight && q.isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp15aynbb9.scala:22:40 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        sumOfElements <= maxWeight && q.isBalanced\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          value isBalanced is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010266
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        val isFlippableAndLessThanMaxWeight = isFlippable && maxWeight\
    \ < q.reduceLeft(_ + _)\n        isFlippableAndLessThanMaxWeight\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiywpu02w.scala:29)\n\tat Problem.main(tmpiywpu02w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val palindromic\
    \ = q.reverse.forall(x => x == x.reverse)\n        val balanced = palindromic\
    \ && maxSum < maxWeight\n        val unbalanced = !palindromic && maxSum > maxWeight\n\
    \        balanced && unbalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq9321j3f.scala:22:55 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x == x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                  value reverse is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010267
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isWon = isPalindromic && isBalanced\n      \
    \  val isWonOrNot = isWon || maxSum > maxWeight\n        isWonOrNot\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwuv98fgs.scala:29)\n\tat Problem.main(tmpwuv98fgs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n     \
    \   val isBalanced = maxSum == maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        val isFlippableWithWeight = isFlippable && maxWeight\
    \ <= maxSum\n        val isFlippableWithWeightAndMaxSum = isFlippableWithWeight\
    \ && maxSum == maxWeight\n        val isFlippableWithWeightAndMaxSumAndMaxWeight\
    \ = isFlippableWithWeightAndMaxSum && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeight && maxSum == maxWeight\n      \
    \  val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight && maxSum\
    \ == maxWeight\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\
    \ && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\n\
    \        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp28mc0q_v.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp28mc0q_v.scala:31:99\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36misFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\e\
    [0m = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\
    \ && maxWeight <= maxSum\n\e[31m\e[31m   |\e[0m                              \
    \                                                                     ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp28mc0q_v.scala:32:108 --------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36misFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\e\
    [0m = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ && maxWeight <= maxSum\n\e[31m\e[31m   |\e[0m                              \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m \
    \ isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp28mc0q_v.scala:33:120 -----------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m        \e[33mval\e[0m \e[36misFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\e\
    [0m = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\n\
    \e[31m\e[31m   |"
  stdout: ''
  timestamp: 1660010268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x == q(0)) && q.forall(x => x == q(q.length - 1))\n        val\
    \ isLessThanMaxWeight = maxSum - maxWeight <= 0\n        val isLessThanMaxSum\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxSumAndBalanced = maxSum -\
    \ maxWeight < 0 && maxSum - maxWeight <= maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZero = maxSum -\
    \ maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic && q.forall(x\
    \ => x == 0)\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.forall(x => x == 0))\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.forall(x => x == 0) && (q.forall(x => x == 0)))\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.forall(x => x == 0) && (q.forall(x => x == 0)\
    \ && (q.forall(x => x == 0)))\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.for\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbblpmo50.scala:32:8 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZero\e\
    [0m = maxSum - maxWeight < \e[31m0\e[0m && maxSum - maxWeight <= maxWeight &&\
    \ isPalindromic && q.forall(\e[36mx\e[0m => x == \e[31m0\e[0m) && (q.\e[33mfor\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m        ')' expected,\
    \ but 'val' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbblpmo50.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbblpmo50.scala:43:1\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = isPalindromic && maxSum < maxWeight\n        isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpouckrz3o.scala:27)\n\tat Problem.main(tmpouckrz3o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sumOfElements <= maxSum\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp74x4ae7p.scala:26)\n\tat Problem.main(tmp74x4ae7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlipped = q.tail.forall(_ == q.head)\n        isFlippable && isFlipped\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphc_e062l.scala:29)\n\tat Problem.main(tmphc_e062l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqwn6k_y4.scala:26)\n\tat Problem.main(tmpqwn6k_y4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010274
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlipped = q.reverse.forall(x\
    \ => x == q(0))\n        isPalindromic && isBalanced && isFlipped\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc2vg4avd.scala:28)\n\tat Problem.main(tmpc2vg4avd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010273
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfWeights = q.foldLeft(0L){\
    \ (sum, elem) => sum + elem }\n        sumOfWeights <= maxWeight\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn3hb9_63.scala:26)\n\tat Problem.main(tmpn3hb9_63.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010274
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val isPalindromic = sums.reverse.forall(_ == sums.head)\n        val\
    \ isBalanced = sums.forall(_ <= maxSum)\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9s6f0ss2.scala:27)\n\tat Problem.main(tmp9s6f0ss2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ val isFlippable = if (isFlippable) true else false\n        isFlippable\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7_3_gcyg.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = \e[33mif\e\
    [0m (isFlippable) \e[31mtrue\e[0m \e[33melse\e[0m \e[31mfalse\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660010267
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpad_pogmb.scala:27)\n\tat Problem.main(tmpad_pogmb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010275
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n\
    \        val maxList = q.maxBy(_.toLong)\n        val maxListSum = maxList.toLong\n\
    \        val maxListWeight = maxList.toLong\n        val isPalindromic = maxListSum\
    \ == maxSum\n        val isBalanced = maxListWeight <= maxWeight\n        val\
    \ isFlipping = isPalindromic && isBalanced\n        isFlipping\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi6nsv814.scala:31)\n\tat Problem.main(tmpi6nsv814.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010281
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val palindrome = q.reverse.forall(x\
    \ => x == x.toLong)\n        val sumOfElements = q.foldLeft(0l) { (acc, x) =>\
    \ acc + x }\n        val isBalanced = sumOfElements <= maxWeight\n        val\
    \ isFlippable = palindrome && isBalanced\n        isFlippable\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp113yy1y2.scala:29)\n\tat Problem.main(tmp113yy1y2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010282
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ - maxWeight < 0\n        val isLessThanMaxSum = maxSum - q.sum < 0\n       \
    \ isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1ay0rjvi.scala:29)\n\tat Problem.main(tmp1ay0rjvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        val\
    \ isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndBalancedAndPalindromic\
    \ = isFlippableAndBalanced && isPalindromic\n        isFlippableAndBalancedAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpkeg3tsuk.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1660010276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(_ == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxSumAndBalanced = isLessThanMaxWeight && isBalanced\n        val\
    \ isLessThanMaxWeightAndBalanced = isLessThanMaxSum && isBalanced\n        val\
    \ isLessThanMaxSumAndPalindromic = isLessThanMaxWeight && isPalindromic\n    \
    \    val isLessThanMaxWeightAndPalindromic = isLessThanMaxSum && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = isLessThanMaxWeightAndBalanced\
    \ && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromic =\
    \ isLessThanMaxSumAndBalanced && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxWeightAndBalancedAndPalindromic && maxWeight > 0\n        val\
    \ isLessThanMaxWeightAndBalancedAndPalindromicAndNotZero = isLessThanMaxSumAndBalancedAndPalindromic\
    \ && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxWeightAndBalancedAndPalindromic && maxWeight > 0\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotZero = isLessThanMaxSumAndBalancedAndPalindromic\
    \ && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1b305yjg.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1b305yjg.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxSumAndBalancedAndPalindromicAndNotZero\e[0m = isLessThanMaxWeightAndBalancedAndPalindromic\
    \ && maxWeight > \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromicAndNotZero is already\
    \ defined as \e[33mvalue\e[0m \e[35misLessThanMaxSumAndBalancedAndPalindromicAndNotZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1b305yjg.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromicAndNotZero\e\
    [0m = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromicAndNotZero is already\
    \ defined as \e[33mvalue\e[0m \e[35misLessThanMaxSumAndBalancedAndPalindromicAndNotZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1b305yjg.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromicAndNotZero\e\
    [0m = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromicAn"
  stdout: ''
  timestamp: 1660010280
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n \
    \       val isBalanced = maxSum < maxWeight\n        val isFlipped = q.forall(x\
    \ => x == q.last)\n        isPalindromic && isBalanced && isFlipped\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5jr57aa8.scala:28)\n\tat Problem.main(tmp5jr57aa8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.isPalindromic\n        val isBalanced = isPalindromic && sumOfElements <=\
    \ maxWeight\n        val isFlipped = !isPalindromic && sumOfElements > maxWeight\n\
    \        isBalanced && isFlipped\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi6_151xj.scala:22:30 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010283
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sumOfElements <= maxWeight\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy26hlgzp.scala:26)\n\tat Problem.main(tmpy26hlgzp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = palindromic && isBalanced\n        isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1nh9ycs.scala:29)\n\tat Problem.main(tmpj1nh9ycs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x >= maxSum - maxWeight)\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq1gbefxt.scala:28)\n\tat Problem.main(tmpq1gbefxt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum - maxWeight <= 0\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq4y2okrr.scala:28)\n\tat Problem.main(tmpq4y2okrr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum - q.sum < 0\n\
    \        val isWeightLessThanMax = maxWeight - q.sum < 0\n        val isWeightLessThanMaxAndBalanced\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0\n        val isWeightLessThanMaxAndBalancedAndPalindromic\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic\n        val\
    \ isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromic = maxWeight -\
    \ q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\n       \
    \ val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced\n        val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isBalanced\n        val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\n        val\
    \ isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalance\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbwmplmkw.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbwmplmkw.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010283
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isWightBalanced = isPalindromic && isBalanced\n\
    \        isWightBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9bm__ffh.scala:28)\n\tat Problem.main(tmp9bm__ffh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x.toLong)\n        sums.last <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq3hjyxq4.scala:26)\n\tat Problem.main(tmpq3hjyxq4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isFlipped = q.forall(x => x <\
    \ maxWeight)\n        isPalindromic && isBalanced && isFlipped\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvlchgam3.scala:28)\n\tat Problem.main(tmpvlchgam3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps8o6v3l9.scala:27)\n\tat Problem.main(tmps8o6v3l9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxhqj1o15.scala:27)\n\tat Problem.main(tmpxhqj1o15.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010266
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvau6m78f.scala:28)\n\tat Problem.main(tmpvau6m78f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        isPalindromic\
    \ && isLessThanMaxAndBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdr2gz1e6.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdr2gz1e6.scala:23:39\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) <= maxWeight\n\e[31m\e[31m   |\e[0m    \
    \                                   ^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(x => x == q.last)\n        isPalindromic\
    \ && isBalanced && isFlippable\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoe79y4pk.scala:28)\n\tat Problem.main(tmpoe79y4pk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n    \
    \    val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic\
    \ = isLessThanMax && isPalindromic\n        val isLessThanMaxAndNotBalanced =\
    \ isLessThanMax && !isBalanced\n        val isLessThanMaxAndNotPalindromic = isLessThanMax\
    \ && !isPalindromic\n        val isLessThanMaxAndNotBalancedAndPalindromic = isLessThanMax\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced\n\
    \        val isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMax = isLessThanMax\
    \ && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced && !isLessThanMaxAndNotPalindromic\n\
    \        val isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMaxAndNotBalanced\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced\
    \ && !isLessThanMaxAndNotPalindromic && !isLessThanMaxAndNotBalancedAndPalindromic\n\
    \        val isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMaxAndNotBalancedAndPalindromic\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced\
    \ && !isLessThanMaxAndNotPalindromic && !isLessThanMaxAndNotBalancedAndPalindromic\
    \ && !isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMax\n        val\
    \ isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMaxAndNotBalancedAndPalindromicAndNotLessThanMax\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalance\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6la3h346.scala:34:172 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMaxAndNotBalancedAndPalindromicAndNotLessThanMax\e\
    [0m = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalance\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   Not found: isLessThanMaxAndNotBalance\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6la3h346.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ - maxWeight < 0\n        val isLessThanMaxSum = maxSum - sum < 0\n        isBalanced\
    \ && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvvfw3pea.scala:25:40 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSum\e[0m =\
    \ maxSum - sum < \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                         \
    \               ^^^\e[0m\n\e[31m   |\e[0m                                    \
    \    Not found: sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010284
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sumOfElements <= maxSum\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz1slqhf2.scala:26)\n\tat Problem.main(tmpz1slqhf2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010285
