language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val balanced = maxSum < maxWeight\n        val palindromic =\
    \ q.reverse.forall(e => e == q(0))\n        val sumLessOrEqual = maxSum - maxWeight\n\
    \        balanced && palindromic && sumLessOrEqual < 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt9hhqe3g.scala:28)\n\tat Problem.main(tmpt9hhqe3g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n    \
    \    val isLessThanMaxButNotBalanced = maxSum < maxWeight && !isBalanced\n   \
    \     val isLessThanMaxButBalanced = maxSum < maxWeight && isBalanced\n      \
    \  val isLessThanMaxButNotBalancedButPalindromic = maxSum < maxWeight && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic = maxSum\
    \ < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxButBalancedButPalindromicButNotPalindromic = maxSum <\
    \ maxWeight && isBalanced && isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromicButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromicButNotBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindro\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplmrfbq6n.scala:34:183 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromicButNotBalanced\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindro\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \                                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                                  Not found: isPalindro\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplmrfbq6n.scala:35:5 ---------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlipped = q.forall(_ < maxWeight)\n    \
    \    isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfepc8lwo.scala:28)\n\tat Problem.main(tmpfepc8lwo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = palindromic && isBalanced\n        val\
    \ isFlippableAndBalanced = isFlippable && isBalanced\n        isFlippableAndBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8yz2bn96.scala:30)\n\tat Problem.main(tmp8yz2bn96.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbajh2s5_.scala:28)\n\tat Problem.main(tmpbajh2s5_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlippable = q.tail.forall(_ < q.head)\n  \
    \      isPalindromic && isBalanced && isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgne1_g_a.scala:28)\n\tat Problem.main(tmpgne1_g_a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val balanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q(0))\n        val isLessOrEqual = maxSum\
    \ < maxWeight\n        (balanced && isPalindromic && isLessOrEqual)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5grzr3ed.scala:28)\n\tat Problem.main(tmp5grzr3ed.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n\
    \        val isBalanced = maxSum - maxWeight <= 0\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvblicvph.scala:27)\n\tat Problem.main(tmpvblicvph.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessThanMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80x1_8x1.scala:28)\n\tat Problem.main(tmp80x1_8x1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvau6m78f.scala:28)\n\tat Problem.main(tmpvau6m78f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgas32qf0.scala:27)\n\tat Problem.main(tmpgas32qf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfhbxwzbw.scala:28)\n\tat Problem.main(tmpfhbxwzbw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum - maxWeight < 0\n        (isPalindromic && isBalanced)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpervi87tq.scala:27)\n\tat Problem.main(tmpervi87tq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = palindromic && isBalanced\n        isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1nh9ycs.scala:29)\n\tat Problem.main(tmpj1nh9ycs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfElements\
    \ = w.toLong * q.sum\n        val maxWeightSumOfElementsOfElements = w.toLong\
    \ * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElements =\
    \ w.toLong * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n    \
    \    val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprjkqbvv6.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprjkqbvv6.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x >= maxSum - maxWeight)\n        isPalindromic\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6i5sglo9.scala:27)\n\tat Problem.main(tmp6i5sglo9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl_o3l8i4.scala:28)\n\tat Problem.main(tmpl_o3l8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n    \
    \    val result = isFly\n        println(s\"$result $q w $w maxSum $maxSum maxWeight\
    \ $maxWeight isPalindromic $isPalindromic isBalanced $isBalanced isFly $isFly\"\
    )\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9h_2m5yt.scala:30)\n\tat Problem.main(tmp9h_2m5yt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: 'false List(3, 2, 3) w 9 maxSum 8 maxWeight 9 isPalindromic false isBalanced
    true isFly false

    '
  timestamp: 1659800885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val maxList =\
    \ q.max\n        val maxListSize = maxList.size\n        val maxListElements =\
    \ maxList.iterator\n        val maxListElementsSize = maxListElements.size\n \
    \       val maxListElementsSum = maxListElements.sum\n        val maxListElementsSumLessOrEqualToMaxWeight\
    \ = maxListElementsSum < maxWeight\n        val maxListElementsSumGreaterOrEqualToMaxWeight\
    \ = maxListElementsSum > maxWeight\n        val maxListElementsSumLessOrEqualToMaxWeightAndBalanced\
    \ = maxListElementsSumLessOrEqualToMaxWeight && maxListElementsSize == maxListElementsSumLessOrEqualToMaxWeight\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalanced = maxListElementsSumGreaterOrEqualToMaxWeight\
    \ && maxListElementsSize == maxListElementsSumGreaterOrEqualToMaxWeight\n    \
    \    val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic =\
    \ maxListElementsSumLessOrEqualToMaxWeightAndBalanced && maxListElementsIsPalindromic(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromic\
    \ = maxListElementsSumGreaterOrEqualToMaxWeightAndBalanced && maxListElementsIsPalindromic(maxList)\n\
    \        val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsEven\
    \ = maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic && maxListElementsIsEven(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsEven\
    \ = maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromic &&\
    \ maxListElementsIsEven(maxList)\n        val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsOdd\
    \ = maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic && maxListElementsIsOdd(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjxkog4sx.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxkog4sx.scala:23:34\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListSize\e[0m = maxList.size\n\e[31m\e[31m   |\e[0m                   \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value size\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxkog4sx.scala:24:38\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListElements\e[0m = maxList.iterator\n\e[31m\e[31m   |\e[0m           \
    \                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \           value iterator is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjxkog4sx.scala:37:5 ---------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659800885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFly = isPalindromic && isBalanced\n        val result\
    \ = isFly\n        println(\"willItFly: isFly = \" + isFly + \", isPalindromic\
    \ = \" + isPalindromic + \", isBalanced = \" + isBalanced + \", maxSum = \" +\
    \ maxSum + \", maxWeight = \" + maxWeight + \", result = \" + result)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplq878lg4.scala:30)\n\tat Problem.main(tmplq878lg4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: 'willItFly: isFly = false, isPalindromic = false, isBalanced = true, maxSum
    = 8, maxWeight = 9, result = false

    '
  timestamp: 1659800885
