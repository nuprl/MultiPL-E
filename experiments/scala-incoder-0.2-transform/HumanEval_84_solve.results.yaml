language: scala
name: HumanEval_84_solve
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\")(_ + _)\n        binary.reverse.grouped(2).map(_.mkString).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprs5sips1.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = 0\n        val result = new mutable.ListBuffer[String]()\n\
    \        while(digits.nonEmpty) {\n            val digit = digits.head\n     \
    \       sum += digit.toLong\n            digits.remove(digit)\n            result\
    \ += (sum.toBinaryString).reverse\n        }\n        result.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5vvojdnw.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5vvojdnw.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum += digit.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp5vvojdnw.scala:25:19 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            digits.remove(digit)\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member of List[Char],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = digits.foldLeft(0)(_ + _)\n        val result\
    \ = sum.toBinaryString\n        result + \" \"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0b8gtobw.scala:25)\n\tat Problem.main(tmp0b8gtobw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") { (acc, digit) => acc + (digit + digit.dropRight(1))\
    \ }\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmn6wdntg.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        while(N !=0){\n            remainder = N % 2\n  \
    \          N = N / 2\n            sum = sum + remainder\n            binary =\
    \ binary + remainder\n        }\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcy67ec8z.scala:22:24\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            remainder = N % \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                        Found:    Long\n\e[31m   |\e[0m              \
    \          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpcy67ec8z.scala:23:14 -----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            N = N / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val N\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpcy67ec8z.scala:92:15 --------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m        binary = binary.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        digits.foreach(sum ++= _)\n        sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps2b42n_8.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        digits.foreach(sum ++= _)\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \ value ++= is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val result = new mutable.ListBuffer[String]()\n        var sum = 0\n\
    \        var i = 0\n        while (i < l) {\n            val c = s(i).toInt\n\
    \            sum += c\n            i += 1\n            if (sum > 9) {\n      \
    \          result.append((sum / 10).toString)\n                sum += (sum % 10).toInt\n\
    \            }\n        }\n        if (sum > 0) {\n            result.append((sum\
    \ / 10).toString)\n        }\n        result.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuppsp2ne.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        val bin2 = bin.map(x => if (x ==\
    \ '1') 1 else 0)\n        val bin3 = bin2.map(x => if (x == '1') 1 else 0)\n \
    \       val bin4 = bin3.map(x => if (x == '1') 1 else 0)\n        val bin5 = bin4.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin6 = bin5.map(x => if (x == '1') 1\
    \ else 0)\n        val bin7 = bin6.map(x => if (x == '1') 1 else 0)\n        val\
    \ bin8 = bin7.map(x => if (x == '1') 1 else 0)\n        val bin9 = bin8.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin10 = bin9.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin11 = bin10.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin12 = bin11.map(x => if (x == '1') 1 else 0)\n        val bin13 = bin12.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin14 = bin13.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin15 = bin14.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin16 = bin15.map(x => if (x == '1') 1 else 0)\n        val bin17 = bin16.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin18 = bin17.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin19 = bin18.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin20 = bin19.map(x => if (x == '1') 1 else 0)\n        val bin21 = bin20.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin22 = bin21.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin23 = bin22.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin24 = bin23.map(x => if (x == '1') 1 else 0)\n        val bin25 = bin24.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin26 = bin25.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin27 = bin26.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin28 = bin27.map(x => if (x == '1') 1 else 0)\n        val bin29 = bin28.map(x\
    \ => if (x == '1\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5f0x9nuj.scala:48:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mbin29\e[0m = bin28.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == '1\n\e[31m\e[31m   |\e[0m                  \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                 unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmp5f0x9nuj.scala:50:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m50 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5f0x9nuj.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5f0x9nuj.scala:50:4 -------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    Not found: 1def\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmp5f0x9nuj.scala:49:4 -----------------\e[0m\e[0m\n\e[33m48 |\e\
    [0m        \e[33mval\e[0m \e[36mbin29\e[0m = bin28.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == '1\n\e[33m49 |\e[0m    }\n\e[33m\e[33m   |\e[0m                    \
    \                          ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        digits.foreach { digit =>\n            val binary\
    \ = digit.charAt(0).toInt\n            val decimal = digit.charAt(1).toInt\n \
    \           sum += binary + decimal\n        }\n        val result = sum.toString.reverse\n\
    \        result match {\n            case x if x.length < 2 => \"\"\n        \
    \    case x if x.length == 2 => result\n            case x if x.length == 3 =>\
    \ result + result\n            case x if x.length == 4 => result + result + result\n\
    \            case x if x.length == 5 => result + result + result + result\n  \
    \          case x if x.length == 6 => result + result + result + result + result\n\
    \            case x if x.length == 7 => result + result + result + result + result\
    \ + result\n            case x if x.length == 8 => result + result + result +\
    \ result + result + result + result\n            case x if x.length >= 9 => result\
    \ + result + result + result + result + result + result + result\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp648zmvn9.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val sum = 0\n        var i = 0\n        while (i < l) {\n           \
    \ val x = s(i)\n            val y = s(i + 1)\n            val z = s(i + 2)\n \
    \           sum += x.toInt + y.toInt + z.toInt\n            i += 3\n        }\n\
    \        val result = sum.toBinaryString\n        if (result.length < l) {\n \
    \           result + s.substring(l - result.length)\n        } else {\n      \
    \      result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbu7fb4j0.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            sum += x.toInt + y.toInt + z.toInt\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val binsSum = bins.foldLeft(0)(_ + _)\n        val\
    \ binsSumStr = binsSum.toBinaryString\n        val binsSumStr = binsSumStr.substring(0,\
    \ binsSumStr.length - 1)\n        binsSumStr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_sp2vtd6.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mbinsSumStr\e[0m = binsSumStr.substring(\e\
    [31m0\e[0m, binsSumStr.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumStr is already defined as \e[33mvalue\e[0m \e[35mbinsSumStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659804695
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.asInstanceOf[Int])\n\
    \        val binSumStr = binSum.toBinaryString\n        binSumStr.substring(0,\
    \ binSumStr.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps7qomijz.scala:25)\n\tat Problem.main(tmps7qomijz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val result = new mutable.StringBuilder\n       \
    \ digits.foreach { digit =>\n            sum += digit._1\n            result +=\
    \ digit._2\n        }\n        result + sum.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpda0gqr8y.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpda0gqr8y.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += digit._1\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpda0gqr8y.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += digit._1\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \            value _1 is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = mutable.ArrayBuffer.empty[Int]\n    \
    \    val sum = 0\n        while(N /= 10) {\n            val digit = N % 10\n \
    \           val sum = sum + digit\n            N = (N - digit) / 10\n        \
    \    nums.append(digit)\n        }\n        val result = nums.reverse.mkString(\"\
    \")\n        if(sum > 0) result + sum.toString\n        else result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvlfa5w1i.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpvlfa5w1i.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpvlfa5w1i.scala:22:22 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = sum + digit\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35msum\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpvlfa5w1i.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            N = (N - digit) / \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  Reassignment to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val sum = 0\n        val binSum = bin.foldLeft(0)(_ +\
    \ _)\n        val binSumString = binSum.toString\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        val binSumStringLength\
    \ = binSumString.length\n        val binSumStringLength = binSumString.length\n\
    \        val binSumStringLength = binSumString.length\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7asbrom8.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7asbrom8.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7asbrom8.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7asbrom8.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7asbrom8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength"
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary(i)\n      \
    \  }\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoh_7rzfx.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary(i)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until digits.length){\n            val digit = digits(i)\n\
    \            val bin = digits(i).reverse\n            val binary = binary.filter(_\
    \ != bin)\n            val binary = binary.filter(_ != digit)\n            val\
    \ binary = binary.filter(_ != bin)\n            val binary = binary.filter(_ !=\
    \ digit)\n            val binary = binary.filter(_ != bin)\n            val binary\
    \ = binary.filter(_ != digit)\n            val binary = binary.filter(_ != bin)\n\
    \            val binary = binary.filter(_ != digit)\n            val binary =\
    \ binary.filter(_ != bin)\n            val binary = binary.filter(_ != digit)\n\
    \            val binary = binary.filter(_ != bin)\n            val binary = binary.filter(_\
    \ != digit)\n            val binary = binary.filter(_ != bin)\n            val\
    \ binary = binary.filter(_ != digit)\n            val binary = binary.filter(_\
    \ != bin)\n            val binary = binary.filter(_ != digit)\n            val\
    \ binary = binary.filter(_ != bin)\n            val binary = binary.filter(_ !=\
    \ digit)\n            val binary = binary.filter(_ != bin)\n            val binary\
    \ = binary.filter(_ != digit)\n            val binary = binary.filter(_ != bin)\n\
    \            val binary = binary.filter(_ != digit)\n            val binary =\
    \ binary.filter(_ != bin)\n            val binary = binary.filter(_ != digit)\n\
    \            val binary = binary.filter(_ != bin)\n            val binary = binary.filter(_\
    \ != digit)\n            val binary = binary.filter(_ != bin)\n            val\
    \ binary = binary.filter(_ != digit)\n            val binary = binary.filter(_\
    \ != bin)\n            val binary = binary.filter(_ != digit)\n            val\
    \ binary = binary.filter(_ != bin)\n            val binary = binary.filter(_ !=\
    \ digit)\n            val binary = binary.filter(_ != bin)\n            val binary\
    \ = binary.filter(_ != digit)\n            val binary = binary.filter(_ != bin)\n\
    \            val binary = binary.filter(_ != digit)\n            val binary =\
    \ binary.filter(_ != bin)\n            \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpeyrrxkvw.scala:72:0 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeyrrxkvw.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeyrrxkvw.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mbinary\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpeyrrxkvw.scala:71:1 ---------------------\e[0m\e[0m\n\e[31m71\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpeyrrxkvw.scala:63:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m63 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x.isEmpty) \"\" else x.reverse).mkString(\"\
    \")\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp89cm63jn.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary.charAt(i)\n\
    \        }\n        binary.reverse.foldLeft(\"\") {\n            case(acc, c)\
    \ => acc + c.toChar\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgtxotvi6.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val binary = digits.map(x\
    \ => if (x == 0) \"0\" else \"1\").mkString\n        binary.reverse.grouped(2).map(_.toInt).sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_geomu8z.scala:24)\n\tat Problem.main(tmp_geomu8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.reverse\n        for(i <- 0 until binary.length){\n\
    \            val temp = binary(i)\n            sum += temp.charAt(0)\n       \
    \ }\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbhym2nb9.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbhym2nb9.scala:23:16\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            sum += temp.charAt(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \         value += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpbhym2nb9.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += temp.charAt(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \       value charAt is not a member of Char\n3 errors found\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sum = sums.sum\n        val\
    \ result = sums.map(_.toBinaryString).mkString\n        result + (if (sum > 9)\
    \ \"\" else \"\") + sum.toBinaryString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppa52nz1v.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val result = mutable.ListBuffer[String]()\n       \
    \ var sum = 0\n        for (i <- 0 until digits.size) {\n            sum += digits(i)\n\
    \        }\n        val remainder = sum % 2\n        if (remainder == 0) {\n \
    \           result += \"0\"\n        }\n        else {\n            result +=\
    \ \"1\"\n        }\n        result.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lnp83pf.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        while(N /= 10) {\n            sum += N % 10\n   \
    \         N = (N - sum) / 10\n        }\n        while(sum > 0) {\n          \
    \  binary = sum % 2 == 0 ? \"1\" + binary : \"0\" + binary\n            sum =\
    \ (sum - sum / 2) / 2\n        }\n        remainder = N % 10\n        binary =\
    \ remainder == 0 ? binary : binary + remainder\n        binary.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdjm3bhoz.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpdjm3bhoz.scala:22:16 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m            sum += N % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdjm3bhoz.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            N = (N - sum) / \e[31m10\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdjm3bhoz.scala:26:55\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            binary = sum\
    \ % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m\"1\"\e[0m + binary : \e[31m\"0\"\e[0m\
    \ \e[35m+\e[0m \e[35mbinary\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \                                   Not found: type +\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdjm3bhoz.scala:26:34 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            binary = sum % \e[31m2\e[0m == \e[31m0\e\
    [0m ? \e[31m\"1\"\e[0m + binary : \e[31m\"0\"\e[0m \e[35m+\e[0m \e[35mbinary\e\
    [0m\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\e[31m   |\e\
    [0m                                value ? is not a member of Int\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdjm3bhoz.scala:29:20 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        remainder = N % \e[31m10\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    Long\n\e[31m   |\e[0m                    Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e"
  stdout: ''
  timestamp: 1660010174
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val binary = digits.foldLeft(\"\") { (acc, digit) => acc + digit.toString\
    \ }\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpagu30kad.scala:23)\n\tat Problem.main(tmpagu30kad.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        var remainder2 = 0\n        var remainder3 = 0\n\
    \        var remainder4 = 0\n        var remainder5 = 0\n        var remainder6\
    \ = 0\n        var remainder7 = 0\n        var remainder8 = 0\n        var remainder9\
    \ = 0\n        var remainder10 = 0\n        var remainder11 = 0\n        var remainder12\
    \ = 0\n        var remainder13 = 0\n        var remainder14 = 0\n        var remainder15\
    \ = 0\n        var remainder16 = 0\n        var remainder17 = 0\n        var remainder18\
    \ = 0\n        var remainder19 = 0\n        var remainder20 = 0\n        var remainder21\
    \ = 0\n        var remainder22 = 0\n        var remainder23 = 0\n        var remainder24\
    \ = 0\n        var remainder25 = 0\n        var remainder26 = 0\n        var remainder27\
    \ = 0\n        var remainder28 = 0\n        var remainder29 = 0\n        var remainder30\
    \ = 0\n        var remainder31 = 0\n        var remainder32 = 0\n        var remainder33\
    \ = 0\n        var remainder34 = 0\n        var remainder35 = 0\n        var remainder36\
    \ = 0\n        var remainder37 = 0\n        var remainder38 = 0\n        var remainder39\
    \ = 0\n        var remainder40 = 0\n        var remainder41 = 0\n        var remainder42\
    \ = 0\n        var remainder43 = 0\n        var remainder44 = 0\n        var remainder45\
    \ = 0\n        var remainder46 = 0\n        var remainder47 = 0\n        var remainder48\
    \ = 0\n        var remainder49 = 0\n        var remainder50 = 0\n        var remainder51\
    \ = 0\n        var remainder52 = 0\n        var remainder53 = 0\n        var remainder54\
    \ = 0\n        var remainder55 = 0\n        var remainder56 = 0\n        var remainder57\
    \ = 0\n        var remainder58 = 0\n        var remainder59 = 0\n        var remainder60\
    \ = 0\n        var remainder61 = 0\n        var remainder62 = 0\n        var remainder63\
    \ = 0\n        var remainder64 = 0\n        var remainder65 = 0\n        var remainder66\
    \ = 0\n        var remainder67 = 0\n        var remainder68 = 0\n        var remainder69\
    \ = 0\n        var remainder70 = 0\n        var remainder71 = 0\n        var remainder72\
    \ = 0\n        var remainder73 = 0\n        var remainder74 = 0\n        var remainder75\
    \ = 0\n        var remainder76 = 0\n        var remainder77 = 0\n        var remainder78\
    \ = 0\n        var remainder79 = 0\n        var remainder80 = 0\n        var remainder81\
    \ = 0\n        var remainder82 = 0\n        var remainder83 = 0\n        var remainder84\
    \ = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpunjbcwmr.scala:105:5\
    \ --------------------\e[0m\e[0m\n\e[31m105 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ String\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val sum = 0\n        val binsSum = bins.map(x => sum\
    \ + x.toInt)\n        val binsSumSum = binsSum.map(x => sum + x)\n        val\
    \ binsSumSumSum = binsSumSum.map(x => sum + x)\n        val binsSumSumSumSum =\
    \ binsSumSumSum.map(x => sum + x)\n        val binsSumSumSumSumSum = binsSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSum = binsSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSum = binsSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSumSumSumSum = binsSumSumSumSumSumSumSumSumSumSumSumSum.map(x\
    \ => sum + x)\n        val binsSumSumSumSumSumSumSumSumSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb3fp_hlg.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb3fp_hlg.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinsSumSumSumSumSumSumSumSumSum\e[0m = binsSumSumSumSumSumSumSumSumSum.map(\e\
    [36mx\e[0m => sum + x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumSumSumSumSumSumSumSumSum is already defined as \e[33mvalue\e\
    [0m \e[35mbinsSumSumSumSumSumSumSumSumSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb3fp_hlg.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinsSumSumSumSumSumSumSumSumSumSumSum\e[0m = binsSumSumSumSumSumSumSumSumSumSumSum.map(\e\
    [36mx\e[0m => sum + x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumSumSumSumSumSumSumSumSumSumSum is already defined as\
    \ \e[33mvalue\e[0m \e[35mbinsSumSumSumSumSumSumSumSumSumSumSum\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb3fp_hlg.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinsSumSumSumSumSumSumSumSumSumSumSum\e[0m = binsSumSumSumSumSumSumSumSumSumSumSum.map(\e\
    [36mx\e[0m => sum + x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumSumSumSumSumSumSumSumSumSumSum is already defined as\
    \ \e[33mvalue\e[0m \e[35mbinsSumSumSumSumSumSumSumSumSumSumSum\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[3"
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ != '0')\n        binary.reverse\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpabz7e11b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpabz7e11b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpabz7e11b.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ != \e[31m'0'\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660010163
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1o_hgim2.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1o_hgim2.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1o_hgim2.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val result = mutable.ListBuffer.empty[String]\n        var sum = 0\n\
    \        for (i <- 0 until digits.length) {\n            sum += digits(i).toLong\n\
    \            val binary = sum.toBinaryString\n            val str = binary.padToLength(binary.length,\
    \ \"0\")\n            result += str\n            sum -= digits(i).toLong\n   \
    \     }\n        val str = result.reverse.mkString\n        val length = str.length\n\
    \        val zeros = length - str.length\n        val zeroPad = if (zeros > 0)\
    \ \"0\" * zeros else \"\"\n        val str = zeroPad + str\n        str.substring(0,\
    \ length)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp815n_8bc.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mstr\e[0m = zeroPad + str\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstr\
    \ is already defined as \e[33mvalue\e[0m \e[35mstr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp815n_8bc.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp815n_8bc.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp815n_8bc.scala:24:29\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mstr\e[0m = binary.padToLength(binary.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                    value padToLength is not a member of String\n4 errors found\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        digits.foreach { digit =>\n            sum += digit._1\n            binary.append(digit._2)\n\
    \        }\n        binary.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3snaplz5.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3snaplz5.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += digit._1\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp3snaplz5.scala:22:25 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            sum += digit._1\n\e[31m\e[31m   |\e[0m            \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value _1 is not a member\
    \ of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val binary = new mutable.ArrayBuffer[String]()\n\
    \        digits.foreach(d => {\n            val bin = d.toInt\n            val\
    \ binStr = bin.toString\n            val binLen = binStr.length\n            val\
    \ binSum = binStr.drop(binLen - 1).sum\n            val binSumStr = binSum.toString\n\
    \            val binSumLen = binSumStr.length\n            val binSumSum = binSumStr.drop(binSumLen\
    \ - 1).sum\n            val binSumSumStr = binSumSum.toString\n            val\
    \ binSumSumLen = binSumSumStr.length\n            val binSumSumSum = binSumSumStr.drop(binSumSumLen\
    \ - 1).sum\n            val binSumSumSumStr = binSumSumSum.toString\n        \
    \    val binSumSumSumLen = binSumSumSumStr.length\n            val binSumSumSumSum\
    \ = binSumSumSumStr.drop(binSumSumSumLen - 1).sum\n            val binSumSumSumSumStr\
    \ = binSumSumSumSum.toString\n            val binSumSumSumSumLen = binSumSumSumSumStr.length\n\
    \            val binSumSumSumSumSum = binSumSumSumSumStr.drop(binSumSumSumSumLen\
    \ - 1).sum\n            val binSumSumSumSumSumStr = binSumSumSumSumSum.toString\n\
    \            val binSumSumSumSumSumLen = binSumSumSumSumSumStr.length\n      \
    \      val binSumSumSumSumSumSum = binSumSumSumSumSumStr.drop(binSumSumSumSumLen\
    \ - 1).sum\n            val binSumSumSumSumSumSumStr = binSumSumSumSumSumSum.toString\n\
    \            val binSumSumSumSumSumSumLen = binSumSumSumSumSumSumStr.length\n\
    \            val binSumSumSumSumSumSumSum = binSumSumSumSumSumSumStr.drop(binSumSumSumSumSumLen\
    \ - 1).sum\n            val binSumSumSumSumSumSumSumStr = binSumSumSumSumSumSumSum.toString\n\
    \            val binSumSumSumSumSumSumSumLen = binSumSumSumSumSumSumSumStr.length\n\
    \            val binSumSumSumSumSumSumSumSum = binSumSumSumSumSumSumSumStr.drop(binSumSumSumSumSumSumLen\
    \ - 1).sum\n            val binSumSumSumSumSumSumSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo0v3ye3g.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo0v3ye3g.scala:49:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m49 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpo0v3ye3g.scala:58:0 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo0v3ye3g.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo0v3ye3g.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mbinary\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mString\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpama4bmrr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpama4bmrr.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val result = new mutable.ListBuffer[String]()\n\
    \        for (i <- 0 until digits.length) {\n            val digit = digits(i)\n\
    \            val binary = digits(i).reverse\n            val sum = sum + binary.toInt\n\
    \            val bin = binary.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val bin = bin.reverse\n            val binary = binary.reverse\n\
    \            val \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpnww3hx8i.scala:83:15 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnww3hx8i.scala:94:0 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnww3hx8i.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnww3hx8i.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpnww3hx8i.scala:93:1 ---------------------\e[0m\e[0m\n\e[31m93\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpnww3hx8i.scala:85:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m85 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n5 errors found\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x == \"1\") \"1\" else \"0\").reverse\n\
    \        binary.foldLeft(\"\") { (acc, x) =>\n            acc + (if (x == \"1\"\
    ) \"1\" else \"0\") + x\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1xn4ovyr.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val result = mutable.StringBuilder()\n        val sum = 0\n        for\
    \ (i <- 0 until digits.size) {\n            val digit = digits(i)\n          \
    \  sum += digit.charAt(0).toInt * Math.pow(10, digit.size - i - 1)\n        }\n\
    \        result += (sum % 10).asInstanceOf[String]\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpowzit0x2.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpowzit0x2.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.StringBuilder()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpowzit0x2.scala:23:16 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            sum += digit.charAt(\e[31m0\e[0m).toInt * Math.pow(\e[31m10\e[0m,\
    \ digit.size - i - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value += is not a member of Int - did you mean sum.!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sumsString = sums.mkString(\"\
    \")\n        sumsString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_drw75e1.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.map(_.sum)\n        val result = sums.foldLeft(\"\"\
    ) { (result, sum) =>\n            val remainder = sum % 2\n            val remainderString\
    \ = if (remainder == 0) \"0\" else \"1\"\n            result + remainderString\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgjlwccki.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.map(_.sum)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              value sum is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgjlwccki.scala:21:32 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mremainder\e[0m = sum\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue % is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.toCharArray\n        val binary = binary.filter(_\
    \ != '0')\n        val binary = binary.filter(_ != '1')\n        val binary =\
    \ binary.filter(_ != 'l')\n        val binary = binary.filter(_ != 'L')\n    \
    \    val binary = binary.filter(_ != 'l')\n        val binary = binary.filter(_\
    \ != 'L')\n        val binary = binary.filter(_ != 'l')\n        val binary =\
    \ binary.filter(_ != 'L')\n        val binary = binary.filter(_ != 'l')\n    \
    \    val binary = binary.filter(_ != 'L')\n        val binary = binary.filter(_\
    \ != 'l')\n        val binary = binary.filter(_ != 'L')\n        val binary =\
    \ binary.filter(_ != 'l')\n        val binary = binary.filter(_ != 'L')\n    \
    \    val binary = binary.filter(_ != 'l')\n        val binary = binary.filter(_\
    \ != 'L')\n        val binary = binary.filter(_ != 'l')\n        val binary =\
    \ binary.filter(_ != 'L')\n        val binary = binary.filter(_ != 'l')\n    \
    \    val binary = binary.filter(_ != 'L')\n        val binary = binary.filter(_\
    \ != 'l')\n        val binary = binary.filter(_ != 'L')\n        val binary =\
    \ binary.filter(_ != 'l')\n        val binary = binary.filter(_ != 'L')\n    \
    \    val binary = binary.filter(_ != 'l')\n        val binary = binary.filter(_\
    \ != 'L')\n        val binary = binary.filter(_ != 'l')\n        val binary =\
    \ binary.filter(_ != 'L')\n        val binary = binary.filter(_ != 'l')\n    \
    \    val binary = binary.filter(_ != 'L')\n        val binary = binary.filter(_\
    \ != 'l')\n        val binary = binary.filter(_ != 'L')\n        val binary =\
    \ binary.filter(_ != 'l')\n        val binary = binary.filter(_ != 'L')\n    \
    \    val binary = binary.filter(_ != 'l')\n        val binary = binary.filter(_\
    \ != 'L')\n        val binary = binary.filter(_ != 'l')\n        val binary =\
    \ binary.filter(_ != 'L')\n        val binary = binary.filter(_ != 'l')\n    \
    \    val binary = binary.filter(_ != 'L')\n        val binary = binary.filter(_\
    \ != 'l\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7oobl4qf.scala:61:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.filter(_\
    \ != \e[31m'l\e[0m\n\e[31m\e[31m   |\e[0m                                    \
    \    ^\e[0m\n\e[31m   |\e[0msymbol literal 'l is no longer supported,\n\e[31m\
    \   |\e[0muse a string literal \"l\" or an application Symbol(\"l\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{l} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7oobl4qf.scala:62:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7oobl4qf.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oobl4qf.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.filter(_ != \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oobl4qf.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.filter(_ != \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that ove"
  stdout: ''
  timestamp: 1660010188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        digits.foreach { digit =>\n            val bin = digit.charAt(0).toInt\
    \ + digit.charAt(1).toInt\n            sum += bin\n            binary.append(bin)\n\
    \        }\n        val result = sum.toString.reverse\n        binary.reverse.mkString(\"\
    \") + result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgnmvsfmf.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgnmvsfmf.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        digits.foreach { digit =>\n            sum += digit._1\n            binary.append(digit._2)\n\
    \        }\n        if (sum > 0) {\n            binary.reverse.mkString(\"\")\n\
    \        } else {\n            binary.mkString(\"\")\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ls8241z.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ls8241z.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += digit._1\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp3ls8241z.scala:22:25 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            sum += digit._1\n\e[31m\e[31m   |\e[0m            \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value _1 is not a member\
    \ of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.toInt)\n\
    \        val binSumStr = binSum.toBinaryString\n        val binSumStrLen = binSumStr.length\n\
    \        val binSumStrLenMinusOne = binSumStrLen - 1\n        val binSumStrLenMinusOneMinusOne\
    \ = binSumStrLenMinusOne - 1\n        val binSumStrLenMinusOneMinusOneMinusOne\
    \ = binSumStrLenMinusOneMinusOne - 1\n        val binSumStrLenMinusOneMinusOneMinusOneMinusOne\
    \ = binSumStrLenMinusOneMinusOneMinusOneMinusOne - 1\n        val binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n       \
    \ val binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1eg7ihc9.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1eg7ihc9.scala:26:59\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinSumStrLenMinusOneMinusOneMinusOneMinusOne\e[0m = binSumStrLenMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                     ^\e[0m\n\e[31m   |\e[0m Recursive \e[33mvalue\e[0m \e[35mbinSumStrLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1eg7ihc9.scala:28:75\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mbinSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1eg7ihc9.scala:31:107\
    \ -----------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mbinSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: binSumStrLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinu"
  stdout: ''
  timestamp: 1660010192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val result = new StringBuilder\n        for(i <- 0 to binary.length-1){\n\
    \            val c = binary.charAt(i)\n            val v = if (c == '1') 1 else\
    \ 0\n            sum += v\n            result.append(v)\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw171my1l.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum += v\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ while(N !=0){\n            sum = sum + N % 2\n            N = N / 2\n      \
    \  }\n        while(sum != 0){\n            binary = binary + sum % 2\n      \
    \      sum = sum / 2\n        }\n        binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaos42f3e.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            sum = sum + N % \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Found:    Long\n\e[31m   |\e[0m                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpaos42f3e.scala:22:14\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            N = N /\
    \ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.toCharArray\n        for(i <- 0 until binary.length){\n\
    \            sum += binary(i)\n        }\n        sum.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfj3g_xrk.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfj3g_xrk.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += binary(i)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = N.toBinaryString\n        val sums =\
    \ nums.toList.map(_.toInt)\n        val sumsSum = sums.sum\n        val sumsSumString\
    \ = sumsSum.toString\n        val sumsSumStringLen = sumsSumString.length\n  \
    \      val sumsSumStringLenMinusOne = sumsSumStringLen - 1\n        val sumsSumStringLenMinusOneString\
    \ = sumsSumStringLen - \"1\"\n        val sumsSumStringLenMinusOneStringLen =\
    \ sumsSumStringLenMinusOne - \"0\"\n        val sumsSumStringLenMinusOneStringLenMinusOne\
    \ = sumsSumStringLenMinusOne - \"1\"\n        val sumsSumStringLenMinusOneStringLenMinusOneString\
    \ = sumsSumStringLenMinusOneString - \"0\"\n        val sumsSumStringLenMinusOneStringLenMinusOneStringLen\
    \ = sumsSumStringLenMinusOneStringLen - \"1\"\n        val sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOne\
    \ = sumsSumStringLenMinusOneStringLenMinusOne - \"0\"\n        val sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneString\
    \ = sumsSumStringLenMinusOneStringLenMinusOneString - \"1\"\n        val sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLen\
    \ = sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOne - \"0\"\n     \
    \   val sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOne\
    \ = sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLen - \"1\"\
    \n        val sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLen\
    \ = sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOne\
    \ - \"0\"\n        val sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLen\
    \ = sumsSumStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLenMinusOneStringLen\
    \ - \"1\"\n        val sum\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpadn1xlgb.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpadn1xlgb.scala:24:62\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36msumsSumStringLenMinusOneString\e[0m = sumsSumStringLen - \e[31m\"1\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments ((\e[32m\"1\"\e[0m : String))\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpadn1xlgb.scala:25:73 -----------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        \e[33mval\e[0m \e[36msumsSumStringLenMinusOneStringLen\e\
    [0m = sumsSumStringLenMinusOne - \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((\e[32m\"0\"\e[0m : String))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpadn1xlgb.scala:26:81\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e\
    [0m \e[36msumsSumStringLenMinusOneStringLenMinusOne\e[0m = sumsSumStringLenMinusOne\
    \ - \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m                                  \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e["
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ while(N /= 10) {\n            sum += N % 10\n            N /= 10\n        }\n\
    \        while(sum > 0) {\n            binary += (sum % 2).toString\n        \
    \    sum /= 2\n        }\n        binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu51ntn9o.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpu51ntn9o.scala:21:16 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            sum += N % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu51ntn9o.scala:22:14\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            N /= \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ /= is not a member of Long - did you mean N.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(new mutable.HashMap[Int, Int]()) {\n     \
    \       case (acc, digit) =>\n                acc + (digit._1 -> (digit._2 + acc.get(digit._1)))\n\
    \        }\n        val result = sums.filter(_._2 > 0).map(_._1).mkString\n  \
    \      result + (if (sums.isEmpty) \"\" else \" \") + (if (sums.size == 1) \"\"\
    \ else \" \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkdo07j7.scala:19:39 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.foldLeft(\e\
    [33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()) {\n\e[31m\e[31m\
    \   |\e[0m                                       ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                       Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpnkdo07j7.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                acc + (digit._1 -> (digit._2 + acc.get(digit._1)))\n\
    \e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of Any, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnkdo07j7.scala:21:29 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                acc + (digit._1 -> (digit._2 + acc.get(digit._1)))\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                    value _1 is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpnkdo07j7.scala:23:26 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = sums.filter(_._2 > \e\
    [31m0\e[0m).map(_._1).mkString\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value filter is not a member of Any\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (d <- digits) {\n            sum += d.toInt\n\
    \        }\n        val result = sum.toBinaryString\n        val result = result.substring(0,\
    \ result.length - 1)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppfjxxb8q.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.substring(\e\
    [31m0\e[0m, result.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmppfjxxb8q.scala:18:67 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toCharArray\n        val binary = new mutable.ArrayBuffer(bin)\n\
    \        binary.reverse.foreach(x => {\n            val y = x.toInt\n        \
    \    sum += y\n        })\n        val result = binary.reverse.toString.reverse\n\
    \        result + sum.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1yzq4vnt.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(bin)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp1yzq4vnt.scala:24:16 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m            sum += y\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (i <- 0 until digits.length) {\n           \
    \ val digit = digits(i)\n            val bin = digit.toInt\n            val binStr\
    \ = bin.toString\n            val binLen = binStr.length\n            val binDigit\
    \ = binStr.charAt(binLen - 1)\n            val binDigitStr = binDigit.toString\n\
    \            val binDigitLen = binDigitStr.length\n            val binDigitSum\
    \ = binDigitStr.charAt(binDigitLen - 1)\n            val binDigitSumStr = binDigitSum.toString\n\
    \            val binDigitSumLen = binDigitSumStr.length\n            val binDigitSumSum\
    \ = binDigitSumStr.charAt(binDigitSumLen - 1)\n            val binDigitSumSumStr\
    \ = binDigitSumSum.toString\n            val binDigitSumSumLen = binDigitSumSumStr.length\n\
    \            val binDigitSumSumSum = binDigitSumSumStr.charAt(binDigitSumSumLen\
    \ - 1)\n            val binDigitSumSumSumStr = binDigitSumSumSum.toString\n  \
    \          val binDigitSumSumSumLen = binDigitSumSumSumStr.length\n          \
    \  val binDigitSumSumSumSum = binDigitSumSumSumStr.charAt(binDigitSumSumSumLen\
    \ - 1)\n            val binDigitSumSumSumSumStr = binDigitSumSumSumSum.toString\n\
    \            val binDigitSumSumSumSumLen = binDigitSumSumSumSumStr.length\n  \
    \          val binDigitSumSumSumSumSum = binDigitSumSumSumSumStr.charAt(binDigitSumSumSumSumLen\
    \ - 1)\n            val binDigitSumSumSumSumSumStr = binDigitSumSumSumSumSumStr.toString\n\
    \            val binDigitSumSumSumSumSumLen = binDigitSumSumSumSumSumStr.length\n\
    \            val binDigitSumSumSumSumSumSum = binDigitSumSumSumSumSumStr.charAt(binDigitSumSumSumSumSumLen\
    \ - 1)\n            val binDigitSumSumSumSumSumSumStr = binDigitSumSumSumSumSumSumStr.toString\n\
    \            val binDigitSumSumSumSumSumSumLen = binDigitSumSumSumSumSumSumStr.length\n\
    \            val binDigitSumSumSumSumSumSumSum = binDigitSumSumSumSumSumSumStr.charAt(binDigitSumSumSumSumSumSumLen\
    \ - 1)\n            val binDigitSumSumSumSumSumSumSumStr = binDigitSumSumSumSumSumSumSumStr.toString\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwpiqvtzn.scala:59:0 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwpiqvtzn.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwpiqvtzn.scala:58:1 ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m}\n\
    \e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m\
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpwpiqvtzn.scala:50:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m50 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(Map[String, Int]()){\n            case (acc,\
    \ digit) =>\n                val key = digit.mkString\n                val value\
    \ = acc.getOrElse(key, 0)\n                acc + (key -> value + 1)\n        }\n\
    \        val result = sums.map{\n            case (key, value) =>\n          \
    \      val binary = key.mkString(\"\")\n                val digit = math.pow(2,value).floor.toString.toInt\n\
    \                binary + digit.toString\n        }.mkString(\"\")\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3h8lfkli.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(_.toBinaryString).mkString(\"\")\n        val\
    \ result = binary.reverse.grouped(2).map(_.mkString).reverse\n        result.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxt4c2siv.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt).sum\n        val result = sums.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr9a1fb21.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = N\n        var remainder2 = N\n        var remainder3 = N\n\
    \        var remainder4 = N\n        var remainder5 = N\n        var remainder6\
    \ = N\n        var remainder7 = N\n        var remainder8 = N\n        var remainder9\
    \ = N\n        var remainder10 = N\n        var remainder11 = N\n        var remainder12\
    \ = N\n        var remainder13 = N\n        var remainder14 = N\n        var remainder15\
    \ = N\n        var remainder16 = N\n        var remainder17 = N\n        var remainder18\
    \ = N\n        var remainder19 = N\n        var remainder20 = N\n        var remainder21\
    \ = N\n        var remainder22 = N\n        var remainder23 = N\n        var remainder24\
    \ = N\n        var remainder25 = N\n        var remainder26 = N\n        var remainder27\
    \ = N\n        var remainder28 = N\n        var remainder29 = N\n        var remainder30\
    \ = N\n        var remainder31 = N\n        var remainder32 = N\n        var remainder33\
    \ = N\n        var remainder34 = N\n        var remainder35 = N\n        var remainder36\
    \ = N\n        var remainder37 = N\n        var remainder38 = N\n        var remainder39\
    \ = N\n        var remainder40 = N\n        var remainder41 = N\n        var remainder42\
    \ = N\n        var remainder43 = N\n        var remainder44 = N\n        var remainder45\
    \ = N\n        var remainder46 = N\n        var remainder47 = N\n        var remainder48\
    \ = N\n        var remainder49 = N\n        var remainder50 = N\n        var remainder51\
    \ = N\n        var remainder52 = N\n        var remainder53 = N\n        var remainder54\
    \ = N\n        var remainder55 = N\n        var remainder56 = N\n        var remainder57\
    \ = N\n        var remainder58 = N\n        var remainder59 = N\n        var remainder60\
    \ = N\n        var remainder61 = N\n        var remainder62 = N\n        var remainder63\
    \ = N\n        var remainder64 = N\n        var remainder65 = N\n        var remainder66\
    \ = N\n        var remainder67 = N\n        var remainder68 = N\n        var remainder69\
    \ = N\n        var remainder70 = N\n        var remainder71 = N\n        var remainder72\
    \ = N\n        var remainder73 = N\n        var remainder74 = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpluayd4g2.scala:93:25 ---------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m        \e[33mvar\e[0m \e[36mremainder74\e[0m = \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpluayd4g2.scala:94:5 ---------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val sums = bins.map(x => x.toInt)\n        val sum\
    \ = sums.sum\n        val result = sums.map(x => x.toBinaryString).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm19atd5c.scala:26)\n\tat Problem.main(tmpm19atd5c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010198
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        for (i <- 0 until digits.length) {\n            val d = digits(i)\n \
    \           val bin = d.toString.reverse.grouped(2).map(_.toInt)\n           \
    \ val sum = sum + bin(0) * bin(1)\n            binary.append(bin.mkString(\"\"\
    ))\n        }\n        binary.reverse.mkString(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt_khyufq.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpt_khyufq.scala:22:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e\
    [0m \e[36md\e[0m = digits(i)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    \e[33mvalue\e[0m \e[35mdigits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 to binary.length-1){\n            val bin = binary.charAt(i)\n\
    \            val num = bin.toInt\n            sum += num\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3i3201y5.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += num\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x.isEmpty) 0 else x).mkString(\"\")\n\
    \        binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpie5zfv_e.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        digits.foreach(x => {\n            val bin = x.toInt\n            val\
    \ binStr = bin.toString\n            val binLen = binStr.length\n            val\
    \ binLenStr = binLen.toString\n            val binLenInt = binLen.toInt\n    \
    \        val binLenIntStr = binLenInt.toString\n            val binLenIntStrInt\
    \ = binLenIntStr.toInt\n            val binLenIntStrIntStr = binLenIntStrInt.toString\n\
    \            val binLenIntStrIntStrInt = binLenIntStrIntStr.toInt\n          \
    \  val binLenIntStrIntStrIntStrInt = binLenIntStrIntStrIntStr.toInt\n        \
    \    val binLenIntStrIntStrIntStrIntStrInt = binLenIntStrIntStrIntStrIntStr.toInt\n\
    \            val binLenIntStrIntStrIntStrIntStrIntStrInt = binLenIntStrIntStrIntStrIntStrIntStr.toInt\n\
    \            val binLenIntStrIntStrIntStrIntStrIntStrIntStrInt = binLenIntStrIntStrIntStrIntStrIntStrIntStr.toInt\n\
    \            val binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrInt = binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStr.toInt\n\
    \            val binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrInt\
    \ = binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStr.toInt\n     \
    \       val binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrInt\
    \ = binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStr.toInt\n\
    \            val binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrInt\
    \ = binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStr.toInt\n\
    \            val binLenIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStrIntStr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq23ht161.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq23ht161.scala:41:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpq23ht161.scala:50:0 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq23ht161.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq23ht161.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mbinary\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010207
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        for (d <- digits) {\n            sum += d\n    \
    \    }\n        val binary = sum.toString.reverse\n        binary.takeWhile(_\
    \ != '0')\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpme__yceb.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += d\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt).sum\n        val result = sums.toBinaryString\n\
    \        result match {\n            case \"\" => \"\"\n            case _ =>\
    \ result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprkdbyzhw.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") { (result, digit) => result + digit }\n    \
    \    result + binary.reverse.dropWhile(_ == '0').takeWhile(_ != '0').mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpte4j8y_l.scala:23)\n\tat Problem.main(tmpte4j8y_l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(_.toBinaryString).mkString(\"\")\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5559egou.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") {\n            case (acc, digit) =>\
    \ acc + (if (digit.isEmpty) \"\" else digit)\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp38_9xrjs.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ != '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4lqul3m_.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4lqul3m_.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4lqul3m_.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ != \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary.charAt(i)\n\
    \        }\n        binary.reverse.foldLeft(\"\") {\n            (a, b) => a +\
    \ b.charAt(0)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h6ifst7.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h6ifst7.scala:24:28\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            (\e[36ma\e[0m,\
    \ \e[36mb\e[0m) => a + b.charAt(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value\
    \ charAt is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val binsSum = bins.sum\n        val binsSumString =\
    \ binsSum.toString\n        val binsSumStringLength = binsSumString.length\n \
    \       val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSumStringLength = binsSumString.length\n\
    \        val binsSumStringLength = binsSumString.length\n        val binsSumStringLength\
    \ = binsSumString.length\n        val binsSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp345e2g84.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp345e2g84.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinsSumStringLength\e[0m = binsSumString.length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinsSumStringLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinsSumStringLength\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp345e2g84.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinsSumStringLength\e[0m = binsSumString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinsSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp345e2g84.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mbinsSumStringLength\e[0m\
    \ = binsSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinsSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp345e2g84.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbinsSumStringLength\e[0m\
    \ = binsSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinsSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods mus"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)((sum, digit) => sum + digit.toInt)\n   \
    \     val result = sum.toBinaryString\n        val resultString = result.substring(0,\
    \ result.length - 1)\n        resultString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8ckycgq4.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt).sum\n        val result = sums.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr9a1fb21.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.asInstanceOf[Int])\n\
    \        binSum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2dr8wu2i.scala:24)\n\tat Problem.main(tmp2dr8wu2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ == '1').reverse\n        binary.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8iq59f5.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8iq59f5.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpm8iq59f5.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpama4bmrr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpama4bmrr.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ while(N /= 10) {\n            sum += N % 10\n            N /= 10\n        }\n\
    \        while(sum > 0) {\n            binary += sum % 2\n            sum /= 2\n\
    \        }\n        binary\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppm_bqi64.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmppm_bqi64.scala:21:16 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            sum += N % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppm_bqi64.scala:22:14\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            N /= \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ /= is not a member of Long - did you mean N.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)(_ + _)\n        val binSumStr\
    \ = binSum.toBinaryString\n        binSumStr.substring(0, binSumStr.length - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj0v2dml2.scala:25)\n\tat Problem.main(tmpj0v2dml2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(mutable.Map[Int, Int]()){\n            case\
    \ (acc, digit) => acc + (digit._1 -> digit._2)\n        }\n        val result\
    \ = sums.map{\n            case (digit, sum) => if (sum > 0) \"1\" + digit else\
    \ digit\n        }.mkString(\"\")\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnxc3a8qj.scala:19:35 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.foldLeft(mutable.Map[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()){\n\e[31m\e[31m   |\e[0m                     \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnxc3a8qj.scala:20:37\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e\
    [0m (acc, digit) => acc + (digit._1 -> digit._2)\n\e[31m\e[31m   |\e[0m      \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of Any, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnxc3a8qj.scala:20:46 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m (acc, digit) => acc + (digit._1\
    \ -> digit._2)\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnxc3a8qj.scala:22:26\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = sums.map{\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value map is not a member of Any\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x.isEmpty) \"\" else x.reverse).mkString(\"\
    \")\n        val result = binary.reverse.grouped(2).map(_.mkString).reverse\n\
    \        binary.reverse.grouped(2).map(_.mkString).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppid6rf3c.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sum = sums.sum\n        val\
    \ binary = sums.map(x => if (x == 0) \"0\" else (x % 2 + \"1\"))\n        binary.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm_zggjun.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x == \"1\") \"1\" else \"0\").mkString\n\
    \        binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp7r3pzo0.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val sum = 0\n        bins.foreach(x => sum += x.toInt)\n\
    \        bins.toList.map(x => x.toBinaryString).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2vv7goh9.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        bins.foreach(\e[36mx\e[0m => sum += x.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                value += is not a member of Int - did you mean sum.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2vv7goh9.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        bins.toList.map(\e[36mx\e[0m => x.toBinaryString).mkString\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      value toBinaryString is not a member of Char.\n\e[31m   |\e[0m\
    \      An extension method was tried, but could not be fully constructed:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m          intWrapper(x)\n2 errors found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.length.toInt) {\n            sum += binary.charAt(i).toInt\n\
    \        }\n        binary.reverse.foldLeft(\"\")(_ + _)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprue0w6bh.scala:20:17 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m(i <- binary.length.toInt) {\n\e\
    [31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 value foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010218
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") {\n            case (acc, digit) => acc + digit\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2qeyc2dx.scala:25)\n\tat Problem.main(tmp2qeyc2dx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val result = new mutable.ListBuffer[String]()\n        for(i <- 0\
    \ to binary.length-1){\n            val bin = binary.charAt(i)\n            val\
    \ num = Integer.parseInt(bin)\n            sum += num\n            result += (bin)\n\
    \        }\n        val result = sum.toBinaryString\n        return result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjgn_f_qb.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = sum.toBinaryString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjgn_f_qb.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjgn_f_qb.scala:23:39 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            \e[33mval\e[0m \e[36mnum\e[0m = Integer.parseInt(bin)\n\e\
    [31m\e[31m   |\e[0m                                       ^^^\e[0m\n\e[31m   |\e\
    [0m                                       Found:    (bin : Char)\n\e[31m   |\e\
    [0m                                       Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpjgn_f_qb.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum += num\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean sum.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010218
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val result = new mutable.ListBuffer[String]\n        val digits = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < l) {\n            digits += s.charAt(i).toLong\n\
    \            i += 1\n        }\n        val sum = 0\n        while (i < l) {\n\
    \            sum += digits.head\n            i += 1\n        }\n        val binary\
    \ = sum.toBinaryString\n        result += binary\n        result += solve(N.toInt)\n\
    \        result.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx47dyr8_.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx47dyr8_.scala:29:16\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            sum += digits.head\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1o_hgim2.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1o_hgim2.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1o_hgim2.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ == '1').reverse\n        binary.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8iq59f5.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8iq59f5.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpm8iq59f5.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val sum = 0\n        var sumOfDigits = 0\n        for(i\
    \ <- 0 until bin.length){\n            val digit = bin(i)\n            sum +=\
    \ digit.toInt\n            sumOfDigits += digit.toInt\n        }\n        val\
    \ result = sum.toBinaryString\n        val result = result.substring(0, result.length\
    \ - sumOfDigits)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvkbip8_7.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.substring(\e\
    [31m0\e[0m, result.length - sumOfDigits)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpvkbip8_7.scala:24:16 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m            sum += digit.toInt\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val ans = \"\"\n        val arr = new Array[String](l)\n        for(i\
    \ <- 0 until l){\n            arr(i) = s(i)\n        }\n        val sum = 0\n\
    \        for(i <- 0 until l){\n            sum = sum + arr(i).toInt\n        }\n\
    \        val binary = sum.toBinaryString\n        val ans = binary.substring(binary.length-1)\n\
    \        ans\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpngzez5ec.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = binary.substring(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mans is already defined as \e[33mvalue\e[0m \e[35mans\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpngzez5ec.scala:23:22 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            arr(i) = s(i)\n\e[31m\e[31m   |\e[0m                     ^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Char\n\e[31m   |\e[0m     \
    \                Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpngzez5ec.scala:27:16 -----------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            sum = sum + arr(i).toInt\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = N.toBinaryString\n        val sums =\
    \ nums.map(_.toInt).sum\n        val bins = nums.map(_.toInt).map(Integer.parseInt).map(Integer.toString).mkString(\"\
    \")\n        bins + sums.toString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxgkxfuv5.scala:20:49 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = nums.map(_.toInt).map(Integer.parseInt).map(Integer.toString).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                        \
    \ ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mparseInt\e[0m in \e[33mobject\e[0m \e[35mInteger\e[0m\
    \ with types\n\e[31m   |\e[0m (x$0: String): Int\n\e[31m   |\e[0m (x$0: CharSequence,\
    \ x$1: Int, x$2: Int, x$3: Int): Int\n\e[31m   |\e[0m (x$0: String, x$1: Int):\
    \ Int\n\e[31m   |\e[0mmatch expected type Int => B\n1 error found\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpama4bmrr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpama4bmrr.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            sum += binary.charAt(i).toInt\n\
    \        }\n        binary.reverse\n        binary.reverse.takeWhile(x => x !=\
    \ '0').reverse\n        binary.reverse.takeWhile(x => x != '1').mkString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw_a9n36o.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i).toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        var i = 0\n        while(i < binary.length) {\n            val x\
    \ = binary(i)\n            val y = binary(i+1)\n            val z = binary(i+2)\n\
    \            val a = x.toInt\n            val b = y.toInt\n            val c =\
    \ z.toInt\n            val d = a + b + c\n            sum += d\n            i\
    \ += 3\n        }\n        binary.reverse.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz7jyy4du.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            sum += d\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val result = new mutable.ListBuffer[String]\n        var sum = 0\n  \
    \      var i = 0\n        while (i < l) {\n            sum = sum + s.charAt(i).toInt\n\
    \            i += 1\n        }\n        val binary = sum.toBinaryString\n    \
    \    val l = binary.length\n        val result = new mutable.ListBuffer[String]\n\
    \        var sum = 0\n        var i = 0\n        while (i < l) {\n           \
    \ sum = sum + binary.charAt(i).toInt\n            i += 1\n        }\n        val\
    \ binary = sum.toBinaryString\n        val l = binary.length\n        val result\
    \ = new mutable.ListBuffer[String]\n        var sum = 0\n        var i = 0\n \
    \       while (i < l) {\n            sum = sum + binary.charAt(i).toInt\n    \
    \        i += 1\n        }\n        val binary = sum.toBinaryString\n        val\
    \ l = binary.length\n        val result = new mutable.ListBuffer[String]\n   \
    \     var sum = 0\n        var i = 0\n        while (i < l) {\n            sum\
    \ = sum + binary.charAt(i).toInt\n            i += 1\n        }\n        val binary\
    \ = sum.toBinaryString\n        val l = binary.length\n        val result = new\
    \ mutable.ListBuffer[String]\n        var sum = 0\n        var i = 0\n       \
    \ while (i < l) {\n            sum = sum + binary.charAt(i).toInt\n          \
    \  i += 1\n        }\n        val binary = sum.toBinaryString\n        val l =\
    \ binary.length\n        val result = new mutable.ListBuffer[String]\n       \
    \ var sum = 0\n        var i = 0\n        while (i < l) {\n            sum = sum\
    \ + binary.charAt(i).toInt\n            i += 1\n        }\n        val binary\
    \ = sum.toBinaryString\n        val l = binary.length\n        val result = new\
    \ mutable.ListBuffer[String]\n        var sum = 0\n        var i = 0\n       \
    \ while (i < l) {\n            sum = sum + binary.charAt(i).toInt\n          \
    \  i += 1\n        }\n        val binary = sum.toBinaryString\n        val l =\
    \ binary.length\n        val result = new mutable.ListBuffer[String]\n       \
    \ var sum = 0\n        var i = 0\n        while (i < l) {\n            sum = sum\
    \ + binary.charAt(i).toInt\n            i += 1\n        }\n        val binary\
    \ = sum.toBinaryString\n        val l = binary.length\n        val result = new\
    \ mutable.ListBuffer[String]\n        var sum = 0\n        var i = 0\n       \
    \ while (i < l) {\n            sum = sum + binary.charAt(i).toInt\n          \
    \  i += 1\n        }\n        val binary = sum.toBinaryString\n        val l =\
    \ binary.length\n        val result = new mut\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2hz1nsa.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = binary.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already\
    \ defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2hz1nsa.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx2hz1nsa.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mvar\e[0m \e[36msum\e[0m = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msum is already defined as \e\
    [33mvariable\e[0m \e[35msum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpx2hz1nsa.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2hz1nsa.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = sum.toBinaryString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitio"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0')\n        val\
    \ binary = binary.takeWhile(_ != '0')\n        binary.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9gp1ts72.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9gp1ts72.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9gp1ts72.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.takeWhile(_ != \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.split(\"\")\n        val sums = bins.map(_.toInt)\n        val sumsSum\
    \ = sums.sum\n        val binsSum = bins.map(_.toInt).sum\n        val binsSumStr\
    \ = binsSum.toString\n        val binsSumStrLen = binsSumStr.length\n        val\
    \ binsSumStrLen2 = binsSumStrLen / 2\n        val binsSumStrLen3 = binsSumStrLen\
    \ / 3\n        val binsSumStrLen4 = binsSumStrLen / 4\n        val binsSumStrLen5\
    \ = binsSumStrLen / 5\n        val binsSumStrLen6 = binsSumStrLen / 6\n      \
    \  val binsSumStrLen7 = binsSumStrLen / 7\n        val binsSumStrLen8 = binsSumStrLen\
    \ / 8\n        val binsSumStrLen9 = binsSumStrLen / 9\n        val binsSumStrLen10\
    \ = binsSumStrLen / 10\n        val binsSumStrLen11 = binsSumStrLen / 11\n   \
    \     val binsSumStrLen12 = binsSumStrLen / 12\n        val binsSumStrLen13 =\
    \ binsSumStrLen / 13\n        val binsSumStrLen14 = binsSumStrLen / 14\n     \
    \   val binsSumStrLen15 = binsSumStrLen / 15\n        val binsSumStrLen16 = binsSumStrLen\
    \ / 16\n        val binsSumStrLen17 = binsSumStrLen / 17\n        val binsSumStrLen18\
    \ = binsSumStrLen / 18\n        val binsSumStrLen19 = binsSumStrLen / 19\n   \
    \     val binsSumStrLen20 = binsSumStrLen / 20\n        val binsSumStrLen21 =\
    \ binsSumStrLen / 21\n        val binsSumStrLen22 = binsSumStrLen / 22\n     \
    \   val binsSumStrLen23 = binsSumStrLen / 23\n        val binsSumStrLen24 = binsSumStrLen\
    \ / 24\n        val binsSumStrLen25 = binsSumStrLen / 25\n        val binsSumStrLen26\
    \ = binsSumStrLen / 26\n        val binsSumStrLen27 = binsSumStrLen / 27\n   \
    \     \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5c4u6a0f.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.toCharArray\n        val binary = binary.map{x =>\
    \ if (x == '1') 1 else 0}\n        val binary = binary.sum.toString\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb5qxdifw.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb5qxdifw.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb5qxdifw.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.toCharArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb5qxdifw.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.map{\e[36mx\e[0m\
    \ => \e[33mif\e[0m (x == \e[31m'1'\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e\
    [0m}\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb5qxdifw.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.sum.toString\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = N\n        while (remainder > 0) {\n            val digit =\
    \ remainder % 2\n            binary = digit + binary\n            remainder =\
    \ remainder / 2\n        }\n        binary = binary.reverse\n        sum = sum\
    \ + binary.length\n        binary = binary.reverse\n        sum = sum + binary.length\n\
    \        binary = binary.reverse\n        sum = sum + binary.length\n        binary\
    \ = binary.reverse\n        sum = sum + binary.length\n        binary = binary.reverse\n\
    \        sum = sum + binary.length\n        binary = binary.reverse\n        sum\
    \ = sum + binary.length\n        binary = binary.reverse\n        sum = sum +\
    \ binary.length\n        binary = binary.reverse\n        sum = sum + binary.length\n\
    \        binary = binary.reverse\n        sum = sum + binary.length\n        binary\
    \ = binary.reverse\n        sum = sum + binary.length\n        binary = binary.reverse\n\
    \        sum = sum + binary.length\n        binary = binary.reverse\n        sum\
    \ = sum + binary.length\n        binary = binary.reverse\n        sum = sum +\
    \ binary.length\n        binary = binary.reverse\n        sum = sum + binary.length\n\
    \        binary = binary.reverse\n        sum = sum + binary.length\n        binary\
    \ = binary.reverse\n        sum = sum + binary.length\n        binary = binary.reverse\n\
    \        sum = sum + binary.length\n        binary = binary.reverse\n        sum\
    \ = sum + binary.length\n        binary = binary.reverse\n        sum = sum +\
    \ binary.length\n        binary = binary.reverse\n        sum = sum + binary.length\n\
    \        binary = binary.reverse\n        sum = sum + binary.length\n        binary\
    \ = binary.reverse\n        sum = sum + binary.length\n        binary = binary.reverse\n\
    \        sum = sum + binary.length\n        binary = binary.reverse\n        sum\
    \ = sum + binary.length\n        binary = binary.reverse\n        sum = sum +\
    \ binary.length\n        binary = binary.reverse\n        sum = sum + binary.length\n\
    \        binary = binary.reverse\n        sum = sum + binary.length\n        binary\
    \ = binary.reverse\n        sum = sum + binary.length\n        binary = binary.reverse\n\
    \        sum = sum + binary.length\n        binary = binary.reverse\n        sum\
    \ = sum + binary.length\n        binary = binary.reverse\n        sum = sum +\
    \ binary.length\n        \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi2kfy030.scala:87:12\
    \ --------------------\e[0m\e[0m\n\e[31m87 |\e[0m        sum = sum + binary.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    Unit\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = N\n        while (remainder > 0) {\n            val remainderDigit\
    \ = remainder % 10\n            sum += remainderDigit\n            binary = remainderDigit\
    \ + binary\n            remainder = remainder / 10\n        }\n        binary\
    \ = binary.reverse\n        binary.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpec2ps7qx.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += remainderDigit\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.split(\"\")\n        val sum = 0\n        bins.foreach(x => sum +=\
    \ x.toInt)\n        bins.toList.map(x => x.toBinaryString).mkString(\"\")\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1d2xiy24.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        bins.foreach(\e[36mx\e[0m => sum += x.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                value += is not a member of Int - did you mean sum.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1d2xiy24.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        bins.toList.map(\e[36mx\e[0m => x.toBinaryString).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value toBinaryString is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660010236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.map(_.sum)\n        val sumsString = sums.mkString(\"\
    \")\n        val sumsString = sumsString.reverse.grouped(2).map(_.toInt).mkString(\"\
    \")\n        sumsString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvtw87099.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msumsString\e[0m = sumsString.reverse.grouped(\e\
    [31m2\e[0m).map(_.toInt).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsString is already defined as \e[33mvalue\e[0m \e[35msumsString\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpvtw87099.scala:19:32 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.map(_.sum)\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                             value sum is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = (N.toString.reverse.grouped(2).map(_.mkString).reverse).sum\n\
    \        val result = digits.takeWhile(_ != 0).foldLeft(sum.toString){\n     \
    \       case (acc, digit) => acc + digit\n        }\n        result + digits.last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4lz84t4r.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4lz84t4r.scala:19:65 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = (N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse).sum\n\e[31m\e[31m   |\e[0m              \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            val c = binary.charAt(i)\n\
    \            val d = c.toInt\n            sum += d\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp80sa8bqj.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += d\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = mutable.ArrayBuffer.empty[String]\n \
    \       var sum = 0\n        var remainder = 0\n        while(N !=0){\n      \
    \      sum = sum + N % 2\n            N = N / 2\n        }\n        while(sum\
    \ > 0){\n            remainder = sum % 2\n            sum = sum / 2\n        \
    \    nums += remainder.toString\n        }\n        nums.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsyepkzf3.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpsyepkzf3.scala:22:18 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum = sum + N % \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \  Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpsyepkzf3.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            N = N / \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.map(_.sum)\n        val result = sums.foldLeft(\"\"\
    )(_ + _)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpejj7iroj.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.map(_.sum)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              value sum is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            val c = binary.charAt(i)\n\
    \            val d = c.toInt\n            sum += d\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp80sa8bqj.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += d\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (i <- 0 until digits.length) {\n           \
    \ val digit = digits(i)\n            sum += digit.asInstanceOf[Long]\n       \
    \ }\n        sum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqqwlagzg.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqqwlagzg.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += digit.asInstanceOf[\e[35mLong\e[0m]\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpama4bmrr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpama4bmrr.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") {\n            case (acc, digit) =>\
    \ acc + (if (digit.isEmpty) \"\" else digit)\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp38_9xrjs.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val bin2 = bin.map(x => x.toInt)\n        val bin3 =\
    \ bin2.map(x => x.toInt)\n        val bin4 = bin3.map(x => x.toInt)\n        val\
    \ bin5 = bin4.map(x => x.toInt)\n        val bin6 = bin5.map(x => x.toInt)\n \
    \       val bin7 = bin6.map(x => x.toInt)\n        val bin8 = bin7.map(x => x.toInt)\n\
    \        val bin9 = bin8.map(x => x.toInt)\n        val bin10 = bin9.map(x =>\
    \ x.toInt)\n        val bin11 = bin10.map(x => x.toInt)\n        val bin12 = bin11.map(x\
    \ => x.toInt)\n        val bin13 = bin12.map(x => x.toInt)\n        val bin14\
    \ = bin13.map(x => x.toInt)\n        val bin15 = bin14.map(x => x.toInt)\n   \
    \     val bin16 = bin15.map(x => x.toInt)\n        val bin17 = bin16.map(x =>\
    \ x.toInt)\n        val bin18 = bin17.map(x => x.toInt)\n        val bin19 = bin18.map(x\
    \ => x.toInt)\n        val bin20 = bin19.map(x => x.toInt)\n        val bin21\
    \ = bin20.map(x => x.toInt)\n        val bin22 = bin21.map(x => x.toInt)\n   \
    \     val bin23 = bin22.map(x => x.toInt)\n        val bin24 = bin23.map(x =>\
    \ x.toInt)\n        val bin25 = bin24.map(x => x.toInt)\n        val bin26 = bin25.map(x\
    \ => x.toInt)\n        val bin27 = bin26.map(x => x.toInt)\n        val bin28\
    \ = bin27.map(x => x.toInt)\n        val bin29 = bin28.map(x => x.toInt)\n   \
    \     val bin30 = bin29.map(x => x.toInt)\n        val bin31 = bin30.map(x =>\
    \ x.toInt)\n        val bin32 = bin31.map(x => x.toInt)\n        val bin33 = bin32.map(x\
    \ => x.toInt)\n        val bin34 = bin33.map(x => x.toInt)\n        val bin35\
    \ = bin34.map(x => \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpt5v6ogti.scala:53:34 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mbin35\e[0m = bin34.map(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\
    \e[31m   |\e[0m                                  expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt5v6ogti.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(_.toBinaryString).mkString(\"\")\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5559egou.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        bin.foreach(x => {\n           \
    \ sum += x.toInt\n        })\n        binary.toList.map(x => x.toString + sum.toString\
    \ + x.toString.toInt).mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp395_nmnn.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += x.toInt\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(mutable.HashMap[String, Long]())((map, digit)\
    \ => {\n            val key = digit.mkString\n            val value = map.getOrElse(key,\
    \ 0L)\n            map += (key -> value + 1)\n            map\n        })\n  \
    \      val result = sums.foldLeft(\"\")(\n            (acc, (key, value)) => acc\
    \ + (key + value.toString + key)\n        )\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnpsq33h3.scala:26:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            (\e[36macc\e[0m, (key, value)) => acc + (key\
    \ + value.toString + key)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  not a legal formal parameter\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnpsq33h3.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010239
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val result = mutable.Stack[String]()\n        val stack = mutable.Stack[String]()\n\
    \        val digit = mutable.Stack[String]()\n        val digitCount = mutable.Stack[Int]()\n\
    \        val digitSum = mutable.Stack[Int]()\n        val digitSumCount = mutable.Stack[Int]()\n\
    \        val digitSumCount2 = mutable.Stack[Int]()\n        val digitSumCount3\
    \ = mutable.Stack[Int]()\n        val digitSumCount4 = mutable.Stack[Int]()\n\
    \        val digitSumCount5 = mutable.Stack[Int]()\n        val digitSumCount6\
    \ = mutable.Stack[Int]()\n        val digitSumCount7 = mutable.Stack[Int]()\n\
    \        val digitSumCount8 = mutable.Stack[Int]()\n        val digitSumCount9\
    \ = mutable.Stack[Int]()\n        val digitSumCount10 = mutable.Stack[Int]()\n\
    \        val digitSumCount11 = mutable.Stack[Int]()\n        val digitSumCount12\
    \ = mutable.Stack[Int]()\n        val digitSumCount13 = mutable.Stack[Int]()\n\
    \        val digitSumCount14 = mutable.Stack[Int]()\n        val digitSumCount15\
    \ = mutable.Stack[Int]()\n        val digitSumCount16 = mutable.Stack[Int]()\n\
    \        val digitSumCount17 = mutable.Stack[Int]()\n        val digitSumCount18\
    \ = mutable.Stack[Int]()\n        val digitSumCount19 = mutable.Stack[Int]()\n\
    \        val digitSumCount20 = mutable.Stack[Int]()\n        val digitSumCount21\
    \ = mutable.Stack[Int]()\n        val digitSumCount22 = mutable.Stack[Int]()\n\
    \        val digitSumCount23 = mutable.Stack[Int]()\n        val digitSumCount24\
    \ = mutable.Stack[Int]()\n        val digitSumCount25 = mutable.Stack[Int]()\n\
    \        val digitSumCount26 = mutable.Stack[Int]()\n        val digitSumCount27\
    \ = mutable.Stack[Int]()\n        val digitSumCount28 = mutable.Stack[Int]()\n\
    \        val digitSumCount29 = mutable.Stack[Int]()\n        val digitSumCount30\
    \ = mutable.Stack\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz2y8s9ep.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz2y8s9ep.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz2y8s9ep.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz2y8s9ep.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mdigit\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz2y8s9ep.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdigitCount\e[0m = mutable.Stack[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpz2y8s9ep.scala:23:23 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33m"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpama4bmrr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpama4bmrr.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660010172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.toInt)\n\
    \        val binSumStr = binSum.toBinaryString\n        binSumStr.substring(0,\
    \ binSumStr.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ugmak8n.scala:25)\n\tat Problem.main(tmp0ugmak8n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        for (i <- 0 until digits.size) {\n            sum\
    \ += digits(i)\n        }\n        val result = sum.toString.reverse\n       \
    \ val result = result.substring(0, result.length - 1)\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaz7814w6.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.substring(\e\
    [31m0\e[0m, result.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpaz7814w6.scala:21:16 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            sum += digits(i)\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int - did\
    \ you mean sum.!=?\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpaz7814w6.scala:21:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            sum += digits(i)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \          \e[33mvalue\e[0m \e[35mdigits\e[0m does not take parameters\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010247
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binNum = binary.reverse.foldLeft(0)((sum, digit) => {\n     \
    \       val sum = sum + digit.toInt\n            sum\n        })\n        binNum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpguy2qc7w.scala:21:22 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = sum + digit.toInt\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35msum\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.toCharArray\n        binary.foreach(x => {\n\
    \            val y = x.toInt\n            sum += y\n        })\n        val result\
    \ = sum.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6tx1suqe.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6tx1suqe.scala:23:16\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            sum += y\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (i <- 0 until digits.length) {\n           \
    \ sum += digits(i).toLong * 2\n        }\n        sum.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj1l3_6by.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj1l3_6by.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += digits(i).toLong * \e[31m2\e[0m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val binary = digits.map(x => x.toBinaryString).mkString(\"\")\n     \
    \   val sum = 0\n        for (i <- 0 until binary.length) {\n            sum +=\
    \ binary(i)\n        }\n        binary.toString + sum.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmperho7s2w.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += binary(i)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt).foldLeft(0)((sum, digit) => sum + digit)\n\
    \        val result = sums.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        result match {\n            case Nil => \"0\"\n            case _ =>\
    \ result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppfd13z4z.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010252
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.toCharArray\n        for(i <- 0 until binary.length){\n\
    \            sum += binary(i).toInt\n        }\n        binary.toString.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo01q5utt.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo01q5utt.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += binary(i).toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sumsString = sums.mkString(\"\
    \")\n        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sums\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpflql1vpw.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m =\
    \ sumsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsStringLength is already defined as \e[33mvalue\e[0m \e\
    [35msumsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpflql1vpw.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m =\
    \ sumsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsStringLength is already defined as \e[33mvalue\e[0m \e\
    [35msumsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpflql1vpw.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m =\
    \ sumsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsStringLength is already defined as \e[33mvalue\e[0m \e\
    [35msumsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpflql1vpw.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m =\
    \ sumsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsStringLength is already defined as \e[33mvalue\e[0m \e\
    [35msumsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpflql1vpw.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m =\
    \ sumsString.length\n\e[31m\e[31m   |\e[0m       "
  stdout: ''
  timestamp: 1660010255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.asInstanceOf[Int])\n\
    \        binSum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2dr8wu2i.scala:24)\n\tat Problem.main(tmp2dr8wu2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            val value = binary.charAt(i)\n\
    \            sum += value.asDigit\n        }\n        binary.reverse.foldLeft(\"\
    \"){ (result, digit) =>\n            val value = digit.asDigit\n            val\
    \ remainder = sum % value\n            val newResult = result + digit.asDigit\
    \ + remainder.asDigit\n            sum -= remainder\n            newResult\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr58yhoy3.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += value.asDigit\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr58yhoy3.scala:27:63\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m\
    \ \e[36mnewResult\e[0m = result + digit.asDigit + remainder.asDigit\n\e[31m\e\
    [31m   |\e[0m                                                     ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value asDigit is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr58yhoy3.scala:28:16\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            sum -= remainder\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Int - did you mean sum.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val result = new mutable.ListBuffer[String]()\n\
    \        digits.foreach { digit =>\n            sum += digit.charAt(0).toInt\n\
    \            result += (sum.toString + digit.substring(1))\n        }\n      \
    \  result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf65bin12.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf65bin12.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(_.toBinaryString).mkString(\"\")\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5559egou.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = N.toString.reverse.grouped(2).map(_.mkString).map(_.toInt)\n\
    \        val sums = nums.map(_.sum)\n        val result = sums.foldLeft(\"\")(_\
    \ + _)\n        result + nums.foldLeft(\"\")(_ + _)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_t5oyw36.scala:19:30 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = nums.map(_.sum)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           value sum is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = mutable.ArrayBuffer.empty[Int]\n    \
    \    val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mutable.ArrayBuffer.empty[String]\n        val bin = mutable.ArrayBuffer.empty[String]\n\
    \        val bins = mut\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp31d0j1qq.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbins is already defined as \e[33mvalue\e[0m \e[35mbins\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp31d0j1qq.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbin\e[0m = mutable.ArrayBuffer.empty[\e[35mString\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbin is already defined as \e[33mvalue\e[0m \e[35mbin\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp31d0j1qq.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbins is already defined as \e[33mvalue\e[0m \e[35mbins\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp31d0j1qq.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mbin\e[0m = mutable.ArrayBuffer.empty[\e[35mString\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbin is already defined as \e[33mvalue\e[0m \e[35mbin\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp31d0j1qq.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mbins\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.reverse\n        val binary = binary.drop\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnt_u604t.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnt_u604t.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(\e[36mx\e[0m => x != \e[31m'0'\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnt_u604t.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnt_u604t.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(\e[36mx\e[0m => x != \e[31m'1'\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnt_u604t.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[3"
  stdout: ''
  timestamp: 1660010258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = mutable.ArrayBuffer.empty[Int]\n    \
    \    var sum = 0\n        while(N /= 10) {\n            sum += N % 10\n      \
    \      N = (N / 10).toInt\n        }\n        val str = sum.toBinaryString\n \
    \       val len = str.length\n        for(i <- 0 until len) {\n            val\
    \ c = str.charAt(i)\n            val b = if (c == '1') 1 else 0\n            nums\
    \ += b\n        }\n        nums.toList.map(_.toString).mkString(\"\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp8ydx2_0.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpp8ydx2_0.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpp8ydx2_0.scala:21:16 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            sum += N % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpp8ydx2_0.scala:22:14 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            N = (N / \e[31m10\e[0m).toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val binary = digits.map(x\
    \ => if (x == 1) \"1\" else \"0\").mkString\n        binary.padToLength(sum, \"\
    0\")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc1nhb_c2.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = mutable.ArrayBuffer.empty[String]\n \
    \       var sum = 0\n        var i = N\n        while (i > 0) {\n            val\
    \ remainder = i % 2\n            sum += remainder\n            nums += remainder.toString\n\
    \            i /= 2\n        }\n        nums.reverse.mkString(\"\")\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7s9gcqug.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp7s9gcqug.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += remainder\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010258
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val m = s.toInt\n        var sum = 0\n        var i = 0\n        while\
    \ (i < l) {\n            val c = s(i)\n            val d = s(i+1)\n          \
    \  sum += ((m / 10) * c) + ((m % 10) * d)\n            i += 2\n        }\n   \
    \     if (sum < 10) {\n            sum.toBinaryString\n        } else {\n    \
    \        sum.toBinaryString + solve((sum.toInt/10).toLong)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"111111111100100101111001110\"\
    \n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.solve(tmp46i7pdid.scala:20)\n\
    \tat Problem$.solve(tmp46i7pdid.scala:32)\n\tat Problem$.main(tmp46i7pdid.scala:36)\n\
    \tat Problem.main(tmp46i7pdid.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(_.toBinaryString).mkString(\"\")\n        val\
    \ result = binary.reverse.grouped(2).map(_.mkString).reverse\n        result.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxt4c2siv.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010195
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnsqerp8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvnsqerp8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            sum += binary.charAt(i).toInt\n\
    \        }\n        binary.reverse\n        binary.reverse.takeWhile(x => x !=\
    \ '1').mkString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6vj5n808.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i).toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sums = digits.foldLeft(List[Int]())((sums, digit)\
    \ => {\n            val sum = sums.sum\n            val index = sums.indexOf(sum)\n\
    \            val newSum = if (index == 0) digit else sum + digit\n           \
    \ sums.updated(index, newSum)\n            sums\n        })\n        val result\
    \ = sums.foldLeft(List[String]())((sums, digit) => {\n            val sum = sums.sum\n\
    \            val index = sums.indexOf(sum)\n            val newSum = if (index\
    \ == 0) digit else sum + digit\n            sums.updated(index, newSum)\n    \
    \        sums\n        }).mkString\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9jx206qo.scala:28:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = sums.sum\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   \
    \             No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m                where:    B is a type variable with constraint >: String\n\e\
    [31m   |\e[0m                .\n1 error found\n"
  stdout: ''
  timestamp: 1660010261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val sum = 0\n        val binary = new mutable.ArrayBuffer[String]()\n\
    \        var i = 0\n        while (i < l) {\n            val c = s(i)\n      \
    \      val d = c.toInt\n            val n = d * 2\n            val m = n % 2\n\
    \            val r = if (m) 1 else 0\n            val x = sum + r\n          \
    \  val y = sum + d\n            val z = sum + n\n            binary.append(if\
    \ (z > y) \"1\" else \"0\")\n            sum += x\n            i += 1\n      \
    \  }\n        if (sum > 0) binary.reverse.mkString\n        else \"\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxuaqvq2m.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxuaqvq2m.scala:28:24\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e\
    [36mr\e[0m = \e[33mif\e[0m (m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       Found:    (m : Int)\n\e[31m   |\e[0m                        Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxuaqvq2m.scala:33:16\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            sum += x\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean sum.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val binary = digits.map(x\
    \ => if (x == 1) \"1\" else \"0\") + digits.map(x => if (x == 1) \"0\" else \"\
    1\")\n        binary.mkString(\"\") + sum.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph815mu1v.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x.isEmpty) \"\" else x.reverse).mkString(\"\
    \")\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp89cm63jn.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = digits.foldLeft(0)(_ + _)\n        binary.reverse.foldLeft(\"\
    \")(_ + _ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp0j3lvdsa.scala:21:36 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        binary.reverse.foldLeft(\e[31m\"\"\e[0m)(_ +\
    \ _ + _)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1660010259
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)(_ + _)\n        val binSumStr\
    \ = binSum.toBinaryString\n        binSumStr.substring(0, binSumStr.length - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj0v2dml2.scala:25)\n\tat Problem.main(tmpj0v2dml2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.map(_.sum)\n        val maxSum = sums.max\n       \
    \ val minSum = sums.min\n        val maxDigit = digits.max\n        val minDigit\
    \ = digits.min\n        val maxDigits = maxDigit.length\n        val minDigits\
    \ = minDigit.length\n        val maxSums = maxSum.length\n        val minSums\
    \ = minSum.length\n        val maxDigits = maxDigits.toInt\n        val minDigits\
    \ = minDigits.toInt\n        val maxSums = maxSums.toInt\n        val minSums\
    \ = minSums.toInt\n        val maxDigits = maxDigits.toInt\n        val minDigits\
    \ = minDigits.toInt\n        val maxSum = maxSum.toInt\n        val minSum = minSum.toInt\n\
    \        val maxDigit = maxDigit.toInt\n        val minDigit = minDigit.toInt\n\
    \        val maxSums = maxSums.toInt\n        val minSums = minSums.toInt\n  \
    \      val maxDigits = maxDigits.toInt\n        val minDigits = minDigits.toInt\n\
    \        val maxSum = maxSum.toInt\n        val minSum = minSum.toInt\n      \
    \  val maxDigit = maxDigit.toInt\n        val minDigit = minDigit.toInt\n    \
    \    val maxSums = maxSums.toInt\n        val minSums = minSums.toInt\n      \
    \  val maxDigits = maxDigits.toInt\n        val minDigits = minDigits.toInt\n\
    \        val maxSum = maxSum.toInt\n        val minSum = minSum.toInt\n      \
    \  val maxDigit = maxDigit.toInt\n        val minDigit = minDigit.toInt\n    \
    \    val maxSums = maxSums.toInt\n        val minSums = minSums.toInt\n      \
    \  val maxDigits = maxDigits.toInt\n        val minDigits = minDigits.toInt\n\
    \        val maxSum = maxSum.toInt\n        val minSum = minSum.toInt\n      \
    \  val maxDigit = maxDigit.toInt\n        val minDigit = minDigit.toInt\n    \
    \    val maxSums = maxSums.toInt\n        val minSums = minSums.toInt\n      \
    \  val maxDigits = maxDigits.toInt\n        val minDigits = minDigits.toInt\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d5kiajx.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxDigits\e[0m = maxDigits.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxDigits is already defined as \e[33mvalue\e[0m \e[35mmaxDigits\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3d5kiajx.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mminDigits\e[0m = minDigits.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminDigits\
    \ is already defined as \e[33mvalue\e[0m \e[35mminDigits\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d5kiajx.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxSums\e[0m = maxSums.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSums is already defined as \e[33mvalue\e[0m \e[35mmaxSums\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3d5kiajx.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mminSums\e[0m = minSums.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminSums\
    \ is already defined as \e[33mvalue\e[0m \e[35mminSums\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d5kiajx.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxDigits\e[0m = maxDigits.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxDigits is already defined as \e[33mvalue\e[0m \e[35mmaxDigits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overload"
  stdout: ''
  timestamp: 1660010267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val binary = new mutable.ArrayBuffer[String]()\n\
    \        digits.foreach { digit =>\n            val bin = digit.toBinaryString\n\
    \            val binary = binary.updated(binary.size, bin)\n            sum +=\
    \ binary.last.length\n        }\n        binary.reverse.mkString(\"\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwijlwut7.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwijlwut7.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum += binary.last.length\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010264
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)(_ + _)\n        val binSumStr\
    \ = binSum.toBinaryString\n        binSumStr.substring(0, binSumStr.length - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj0v2dml2.scala:25)\n\tat Problem.main(tmpj0v2dml2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val binary = digits.foldLeft(\"\")(_ + _)\n        binary.reverse\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl02ld9bu.scala:23)\n\tat Problem.main(tmpl02ld9bu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(_.toBinaryString).mkString(\"\")\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5559egou.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary(i)\n      \
    \  }\n        binary.reverse.foldLeft(\"\") {\n            case(acc, i) => acc\
    \ + (if (sum > i) \"1\" + \"0\" * (sum - i) else \"0\" * (sum - i))\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpws_demdd.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary(i)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = 0\n        val result = new mutable.ListBuffer[String]()\n\
    \        for (i <- 0 until digits.length) {\n            val digit = digits(i)\n\
    \            sum += digit.toLong\n            val bin = sum.toBinaryString\n \
    \           if (bin.length == 1) {\n                result += \"0\"\n        \
    \    } else {\n                result += \"1\"\n            }\n        }\n   \
    \     result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ez9imwj.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5ez9imwj.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum += digit.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val result = new mutable.ListBuffer[String]\n        for(i <- 0 until\
    \ binary.length){\n            val temp = binary.charAt(i).toInt\n           \
    \ sum += temp\n            if(sum > 9){\n                result.append((sum /\
    \ 10).toString)\n                sum -= (sum / 10).toInt\n            }\n    \
    \    }\n        if(sum > 0){\n            result.append((sum / 10).toString)\n\
    \        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqfnospop.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqfnospop.scala:23:16\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            sum += temp\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpqfnospop.scala:26:20 ------------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m                sum -= (sum / \e[31m10\e[0m).toInt\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value -=\
    \ is not a member of Int - did you mean sum.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)((sum, digit) => sum + digit.toInt)\n   \
    \     val binary = digits.map(digit => digit.toString + digit.toString).mkString\n\
    \        binary.substring(0, binary.length - sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv7nqvwp8.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(mutable.HashMap[Int, Int]())((map, digit)\
    \ => {\n            val digitStr = digit.toString\n            val digitCount\
    \ = digitStr.length\n            val digitValue = digitStr.charAt(0) - '0'\n \
    \           val digitSum = map.getOrElse(digitCount, 0)\n            map.update(digitCount,\
    \ digitSum + digitValue)\n            map\n        })\n        val result = sums.foldLeft(\"\
    \")(_ + _)\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph9umos8j.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n \
    \       val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp379nc6ws.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp379nc6ws.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp379nc6ws.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp379nc6ws.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp379nc6ws.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp379nc6ws.scala:23:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1660010273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = digits.foldLeft(0)(_ + _)\n        val result\
    \ = binary.reverse.foldLeft(\"\")(_ + _ + _)\n        result + sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpoitilpvy.scala:21:49 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = binary.reverse.foldLeft(\e\
    [31m\"\"\e[0m)(_ + _ + _)\n\e[31m\e[31m   |\e[0m                             \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \        Wrong number of parameters, expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1660010269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sum = sums.sum\n        val\
    \ binary = digits.map(_.toBinaryString).mkString\n        binary.padTo(sum, \"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr3bpc6qb.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = mutable.ArrayBuffer.empty[String]\n \
    \       val sum = 0\n        while(N /= 10) {\n            val remainder = N %\
    \ 10\n            sum += remainder\n            nums.append(remainder)\n     \
    \       N = (N - remainder) / 10\n        }\n        nums.reverse.mkString(\"\"\
    ) + sum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8n17owuv.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8n17owuv.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8n17owuv.scala:22:16 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m            sum += remainder\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value += is not a member of Int - did you mean sum.!=?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp8n17owuv.scala:24:14 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            N = (N - remainder) / \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \      Reassignment to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpama4bmrr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpama4bmrr.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") { (acc, digit) =>\n            acc\
    \ + (if (digit.length == 1) \"0\" + digit else digit)\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_0ab2h6k.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        var remainder2 = N\n        while (remainder2 > 0)\
    \ {\n            remainder2 = remainder2 % 2\n            sum = sum + remainder2\n\
    \            remainder = remainder + 1\n        }\n        binary = binary(sum)\n\
    \        binary = binary.reverse\n        binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw9v31mx3.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum = sum + remainder2\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  Found:    Long\n\e[31m   |\e[0m                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw9v31mx3.scala:27:23\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        binary = binary(sum)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \           Found:    Char\n\e[31m   |\e[0m                 Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x.isEmpty) 0 else (x.charAt(0) - '0')\
    \ + (x.charAt(1) - '0'))\n        val sum = binary.sum\n        val result = binary.map(x\
    \ => if (x == sum) 1 else 0).mkString\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7y1c291f.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpama4bmrr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpama4bmrr.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpama4bmrr.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(Map[String, Long]()){\n            case (acc,\
    \ digit) =>\n                val key = digit.takeWhile(c => c != '0').mkString\n\
    \                val value = digit.dropWhile(c => c != '0').sum\n            \
    \    acc + (key -> value)\n        }\n        val result = sums.map{case (key,\
    \ value) => key + value}\n        val result = result.sortWith(_.compareTo(_)\
    \ < 0)\n        val result = result.mkString(\"\")\n        result + sums.map{case\
    \ (key, value) => key + value}.sum.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp03faxy7f.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.sortWith(_.compareTo(_)\
    \ < \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp03faxy7f.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.mkString(\e[31m\"\
    \"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp03faxy7f.scala:18:67 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e\
    [0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val result = new mutable.ListBuffer[String]()\n\
    \        digits.foreach { digit =>\n            sum += digit._1\n            sum\
    \ += digit._2\n            result += (sum.toString + digit._1.toString + digit._2.toString)\n\
    \        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqjt_3762.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjt_3762.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += digit._1\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpqjt_3762.scala:22:25 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            sum += digit._1\n\e[31m\e[31m   |\e[0m            \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value _1 is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjt_3762.scala:23:16\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            sum += digit._2\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpqjt_3762.scala:23:25 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m            sum += digit._2\n\e[31m\e[31m   |\e[0m            \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value _2 is not a member\
    \ of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660010275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") { (result, digit) =>\n            val index\
    \ = result.length - 1\n            if (digit == \"1\") result else result + (\"\
    0\" * (index - binary.indexOf(digit))) + digit\n        }\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpk3vmocr7.scala:21:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (digit == \e[31m\"1\"\e[0m)\
    \ result \e[33melse\e[0m result + (\e[31m\"0\"\e[0m * (index - binary.indexOf(digit)))\
    \ + digit\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val sum = 0\n        var i = 0\n        while(i < bin.length){\n\
    \            sum += bin(i).toInt\n            i += 1\n        }\n        binary.toString.reverse.foldLeft(\"\
    \"){(acc, elem) => acc + (elem.toString.reverse.foldLeft(0){(acc, elem) => acc\
    \ + elem.toInt}.toString.reverse)}\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf2mw3on_.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += bin(i).toInt\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010275
