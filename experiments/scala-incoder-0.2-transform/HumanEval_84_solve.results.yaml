language: scala
name: HumanEval_84_solve
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\")(_ + _)\n        binary.reverse.grouped(2).map(_.mkString).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprs5sips1.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = 0\n        val result = new mutable.ListBuffer[String]()\n\
    \        while(digits.nonEmpty) {\n            val digit = digits.head\n     \
    \       sum += digit.toLong\n            digits.remove(digit)\n            result\
    \ += (sum.toBinaryString).reverse\n        }\n        result.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5vvojdnw.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5vvojdnw.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum += digit.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp5vvojdnw.scala:25:19 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            digits.remove(digit)\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member of List[Char],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = digits.foldLeft(0)(_ + _)\n        val result\
    \ = sum.toBinaryString\n        result + \" \"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0b8gtobw.scala:25)\n\tat Problem.main(tmp0b8gtobw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") { (acc, digit) => acc + (digit + digit.dropRight(1))\
    \ }\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmn6wdntg.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        while(N !=0){\n            remainder = N % 2\n  \
    \          N = N / 2\n            sum = sum + remainder\n            binary =\
    \ binary + remainder\n        }\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n        binary\
    \ = binary.reverse\n        binary = binary.reverse\n        binary = binary.reverse\n\
    \        binary = binary.reverse\n        binary = binary.reverse\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcy67ec8z.scala:22:24\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            remainder = N % \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                        Found:    Long\n\e[31m   |\e[0m              \
    \          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpcy67ec8z.scala:23:14 -----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            N = N / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val N\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpcy67ec8z.scala:92:15 --------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m        binary = binary.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        digits.foreach(sum ++= _)\n        sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps2b42n_8.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        digits.foreach(sum ++= _)\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \ value ++= is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val result = new mutable.ListBuffer[String]()\n        var sum = 0\n\
    \        var i = 0\n        while (i < l) {\n            val c = s(i).toInt\n\
    \            sum += c\n            i += 1\n            if (sum > 9) {\n      \
    \          result.append((sum / 10).toString)\n                sum += (sum % 10).toInt\n\
    \            }\n        }\n        if (sum > 0) {\n            result.append((sum\
    \ / 10).toString)\n        }\n        result.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuppsp2ne.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        val bin2 = bin.map(x => if (x ==\
    \ '1') 1 else 0)\n        val bin3 = bin2.map(x => if (x == '1') 1 else 0)\n \
    \       val bin4 = bin3.map(x => if (x == '1') 1 else 0)\n        val bin5 = bin4.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin6 = bin5.map(x => if (x == '1') 1\
    \ else 0)\n        val bin7 = bin6.map(x => if (x == '1') 1 else 0)\n        val\
    \ bin8 = bin7.map(x => if (x == '1') 1 else 0)\n        val bin9 = bin8.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin10 = bin9.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin11 = bin10.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin12 = bin11.map(x => if (x == '1') 1 else 0)\n        val bin13 = bin12.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin14 = bin13.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin15 = bin14.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin16 = bin15.map(x => if (x == '1') 1 else 0)\n        val bin17 = bin16.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin18 = bin17.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin19 = bin18.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin20 = bin19.map(x => if (x == '1') 1 else 0)\n        val bin21 = bin20.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin22 = bin21.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin23 = bin22.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin24 = bin23.map(x => if (x == '1') 1 else 0)\n        val bin25 = bin24.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin26 = bin25.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin27 = bin26.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin28 = bin27.map(x => if (x == '1') 1 else 0)\n        val bin29 = bin28.map(x\
    \ => if (x == '1\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5f0x9nuj.scala:48:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mbin29\e[0m = bin28.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == '1\n\e[31m\e[31m   |\e[0m                  \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                 unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmp5f0x9nuj.scala:50:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m50 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5f0x9nuj.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5f0x9nuj.scala:50:4 -------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    Not found: 1def\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmp5f0x9nuj.scala:49:4 -----------------\e[0m\e[0m\n\e[33m48 |\e\
    [0m        \e[33mval\e[0m \e[36mbin29\e[0m = bin28.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == '1\n\e[33m49 |\e[0m    }\n\e[33m\e[33m   |\e[0m                    \
    \                          ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        digits.foreach { digit =>\n            val binary\
    \ = digit.charAt(0).toInt\n            val decimal = digit.charAt(1).toInt\n \
    \           sum += binary + decimal\n        }\n        val result = sum.toString.reverse\n\
    \        result match {\n            case x if x.length < 2 => \"\"\n        \
    \    case x if x.length == 2 => result\n            case x if x.length == 3 =>\
    \ result + result\n            case x if x.length == 4 => result + result + result\n\
    \            case x if x.length == 5 => result + result + result + result\n  \
    \          case x if x.length == 6 => result + result + result + result + result\n\
    \            case x if x.length == 7 => result + result + result + result + result\
    \ + result\n            case x if x.length == 8 => result + result + result +\
    \ result + result + result + result\n            case x if x.length >= 9 => result\
    \ + result + result + result + result + result + result + result\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp648zmvn9.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val sum = 0\n        var i = 0\n        while (i < l) {\n           \
    \ val x = s(i)\n            val y = s(i + 1)\n            val z = s(i + 2)\n \
    \           sum += x.toInt + y.toInt + z.toInt\n            i += 3\n        }\n\
    \        val result = sum.toBinaryString\n        if (result.length < l) {\n \
    \           result + s.substring(l - result.length)\n        } else {\n      \
    \      result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbu7fb4j0.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            sum += x.toInt + y.toInt + z.toInt\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val binsSum = bins.foldLeft(0)(_ + _)\n        val\
    \ binsSumStr = binsSum.toBinaryString\n        val binsSumStr = binsSumStr.substring(0,\
    \ binsSumStr.length - 1)\n        binsSumStr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_sp2vtd6.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mbinsSumStr\e[0m = binsSumStr.substring(\e\
    [31m0\e[0m, binsSumStr.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinsSumStr is already defined as \e[33mvalue\e[0m \e[35mbinsSumStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659804695
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.asInstanceOf[Int])\n\
    \        val binSumStr = binSum.toBinaryString\n        binSumStr.substring(0,\
    \ binSumStr.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps7qomijz.scala:25)\n\tat Problem.main(tmps7qomijz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val result = new mutable.StringBuilder\n       \
    \ digits.foreach { digit =>\n            sum += digit._1\n            result +=\
    \ digit._2\n        }\n        result + sum.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpda0gqr8y.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpda0gqr8y.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += digit._1\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpda0gqr8y.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += digit._1\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \            value _1 is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = mutable.ArrayBuffer.empty[Int]\n    \
    \    val sum = 0\n        while(N /= 10) {\n            val digit = N % 10\n \
    \           val sum = sum + digit\n            N = (N - digit) / 10\n        \
    \    nums.append(digit)\n        }\n        val result = nums.reverse.mkString(\"\
    \")\n        if(sum > 0) result + sum.toString\n        else result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvlfa5w1i.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpvlfa5w1i.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpvlfa5w1i.scala:22:22 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = sum + digit\n\e[31m\e[31m\
    \   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      Recursive\
    \ \e[33mvalue\e[0m \e[35msum\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpvlfa5w1i.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            N = (N - digit) / \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  Reassignment to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
