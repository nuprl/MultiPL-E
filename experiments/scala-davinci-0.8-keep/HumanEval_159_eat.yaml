name: HumanEval_159_eat
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You're a hungry rabbit, and you already have eaten a certain number of carrots,\n\
  \    // but now you need to eat more carrots to complete the day's meals.\n    //\
  \ you should return an array of [ total number of eaten carrots after your meals,\n\
  \    // the number of carrots left after your meals ]\n    // if there are not enough\
  \ remaining carrots, you will eat all remaining carrots, but will still be hungry.\n\
  \    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n    // * eat(4, 8, 9) -> [12,\
  \ 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    // * eat(2, 11, 5) -> [7, 0]\n   \
  \ // Variables:\n    // @number : integer\n    // the number of carrots that you\
  \ have eaten.\n    // @need : integer\n    // the number of carrots that you need\
  \ to eat.\n    // @remaining : integer\n    // the number of remaining carrots thet\
  \ exist in stock\n    // Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <=\
  \ need <= 1000\n    // * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number\
  \ : Long, need : Long, remaining : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
  \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
  \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
  \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
  \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
  \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
  \ 0l.toLong))));\n    }\n\n}\n"
completions: ["        var arr = List[Long]()\n        arr = arr :+ number\n     \
    \   arr = arr :+ need\n        var sum = 0L\n        var remainder = 0L\n    \
    \    if(remaining < need) {\n            sum = number + remaining\n          \
    \  remainder = 0\n        } else {\n            sum = number + need\n        \
    \    remainder = remaining - need\n        }\n        arr = List[Long](sum, remainder)\n\
    \        return arr", "        val eaten = min(need, remaining)\n        List(number\
    \ + eaten, remaining - eaten)", "        // Write your code here\n        var\
    \ llist = List(0, 0)\n        if (remaining < number + need) {\n            llist\
    \ = List(number + remaining, 0)\n        } else {\n            llist = List(number\
    \ + need, remaining - (number + need))\n        }\n        llist", "        var\
    \ list : List[Long] = List(0, 0)\n        if (remaining >= need) {\n         \
    \   list = List(number + need, remaining - need)\n        } else {\n         \
    \   list = List(number + remaining, 0)\n        }\n        return list", "   \
    \     // your code here\n        List[Long](0, 0)", "        // your code\n  \
    \      // var carrotsEaten : Long = number + min(need, remaining)\n        //\
    \ var carrotsLeft  : Long = max(0, remaining - need)\n        List(number + min(need,\
    \ remaining), max(0, remaining - need))", "        // your code here\n       \
    \ def helper(n : Long, r : Long) : Long = if (n < r) n else r\n        val eaten\
    \ = number + helper(need, remaining)\n        List(eaten, remaining - helper(need,\
    \ remaining))", "        //Your code starts here\n        List(0, 0)\n       \
    \ //Your code ends here", '        return List(0, 0)', "        val canEat = need\
    \ - number\n        val totalEaten = number + min(canEat, remaining)\n       \
    \ val left = max(remaining - canEat, 0)\n        List(totalEaten, left)", "  \
    \      val result = number + min(need, remaining)\n        val rem = max(0, remaining\
    \ - need)\n        List(result, rem)", "        if (remaining >= need) {\n   \
    \         return List(number + need, remaining - need)\n        } else {\n   \
    \         return List(number + remaining, 0)\n        }", "        // Write your\
    \ code here\n        val n = List(number, need, remaining)\n        n.map(x =>\
    \ if (x < 0 || x > 1000) throw new IllegalArgumentException)\n        List(number\
    \ + min(need, remaining), remaining - min(need, remaining))", "        // Your\
    \ code here...\n        return List(0, 0)", "      // input your code here.\n\
    \      var numberTemp = number\n      var needTemp = need\n      var remainingTemp\
    \ = remaining\n      var t = 0\n      val z : List[Long] = List[Long]()\n    \
    \  while (remainingTemp > 0 && needTemp > 0) {\n        numberTemp += 1\n    \
    \    needTemp -= 1\n        remainingTemp -= 1\n        t += 1\n      }\n    \
    \  if (numberTemp > 1000) {\n        return List[Long](1000, 0)\n      }\n   \
    \   List[Long](numberTemp, remainingTemp)", "        if (number + need > remaining)\
    \ List(remaining, 0)\n        else List(number + need, remaining - (number + need))",
  "        var result = new ListBuffer[Long]()\n        result += number + min(need,\
    \ remaining)\n        result += max(remaining - need, 0)\n        result.toList",
  "        //your code here\n        val eaten = number + remaining.min(need)\n  \
    \      val left = remaining - need.min(remaining)\n        List(eaten, left)",
  '        List(min(number + remaining, need), max(0, remaining - need + number))',
  "        // your code here!\n        var result = List[Long]()\n        if (number\
    \ == 0 && need == 0 && remaining == 0) {\n            result = List(0, 0)\n  \
    \      } else if (number == 1000 && need == 1000 && remaining == 1000) {\n   \
    \         result = List(1000, 0)\n        } else if (remaining == 0) {\n     \
    \       result = List(number, 0)\n        } else if (remaining > 0 && remaining\
    \ < need) {\n            result = List(remaining + number, 0)\n        } else\
    \ if (remaining > 0 && remaining > need) {\n            result = List(need + number,\
    \ remaining - need)\n        }\n        result"]
stop_tokens:
- "\n    }\n"
