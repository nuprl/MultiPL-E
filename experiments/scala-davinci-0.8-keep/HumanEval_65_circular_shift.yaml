name: HumanEval_65_circular_shift
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Circular shift the digits of the integer x, shift the digits right by shift\n\
  \    // and return the result as a string.\n    // If shift > number of digits,\
  \ return digits reversed.\n    // >>> circular_shift(12, 1)\n    // \"21\"\n   \
  \ // >>> circular_shift(12, 2)\n    // \"12\"\n    def circularShift(x : Long, shift\
  \ : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(circularShift((100l),\
  \ (2l)).equals((\"001\")));\n    assert(circularShift((12l), (2l)).equals((\"12\"\
  )));\n    assert(circularShift((97l), (8l)).equals((\"79\")));\n    assert(circularShift((12l),\
  \ (1l)).equals((\"21\")));\n    assert(circularShift((11l), (101l)).equals((\"11\"\
  )));\n    }\n\n}\n"
completions: ["        var digs = x.toString.split(\"\").toList.tail\n        if (shift\
    \ >= digs.length) {\n            return digs.reverse.mkString\n        }\n   \
    \     var shifted = (digs.reverse.take(shift.toInt) ::: digs.reverse.drop(shift.toInt)).reverse\n\
    \        return shifted.mkString", "        x.toString.reverse.padTo(shift.toInt,\
    \ '0').reverse", "        if (shift >= getNumDigits(x)) {\n            getDigits(x).reverse.mkString\n\
    \        } else {\n            val digits = getDigits(x)\n            val numDigits\
    \ = digits.length\n            (digits.slice(numDigits - shift.toInt, numDigits)\
    \ ++ digits.slice(0, numDigits - shift.toInt)).mkString\n        }", "       \
    \ if (shift == 0) return x.toString\n        if (shift >= x.toString.length) return\
    \ x.toString.reverse\n        val last = x.toString.substring(x.toString.length\
    \ - shift.toInt)\n        val first = x.toString.substring(0, x.toString.length\
    \ - shift.toInt)\n        return last + first", "        if (shift == 0) return\
    \ x.toString\n        val numStr = x.toString\n        val result = new StringBuilder(numStr)\n\
    \        for (i <- 0 until shift) {\n            val last = result.charAt(result.length\
    \ - 1)\n            result.deleteCharAt(result.length - 1)\n            result.insert(0,\
    \ last)\n        }\n        return result.toString", "        val digits = x.toString.toList\n\
    \        if (shift > digits.length) digits.reverse.mkString\n        else {\n\
    \            val rotated = digits.slice(digits.length - shift.toInt, digits.length)\
    \ ++ digits.slice(0, digits.length - shift.toInt)\n            rotated.mkString\n\
    \        }", "        if (shift == 0)\n            return x.toString\n       \
    \ val digits = x.toString.length\n        val steps = shift % digits\n       \
    \ var shifted = x / 10.pow(steps.toInt)\n        shifted.toString.reverse + x.toString.drop(steps.toInt)",
  "        val digits = (x.toString.toList)\n        val shift_size = min(shift, digits.size)\n\
    \        val shifted = digits.drop(shift_size) ++ digits.take(shift_size)\n  \
    \      shifted.reverse.mkString", "        val n = x.toString.length\n       \
    \ val s = shift.toString.length\n        if (shift >= n) {\n            val t\
    \ = x.toString.reverse\n            val y = Long.parseLong(t)\n            y.toString\n\
    \        } else {\n            val t = x.toString.takeRight(n - s) + x.toString.take(s)\n\
    \            val y = Long.parseLong(t)\n            y.toString\n        }", " \
    \       val chars = x.toString.toList\n        val size = chars.size\n       \
    \ def helper(acc : List[Char], index : Int) : List[Char] = {\n            if (index\
    \ == size) acc\n            else {\n                val shifted = chars((index\
    \ + shift) % size)\n                helper(shifted :: acc, index + 1)\n      \
    \      }\n        }\n        if (shift >= size) chars.reverse.mkString\n     \
    \   else helper(Nil, 0).reverse.mkString", "        val len = numberOfDigits(x)\n\
    \        if (shift > len) \n            return x.toString.reverse\n        val\
    \ shift2 = shift % len\n        val str = x.toString\n        str.substring(len\
    \ - shift2) + str.substring(0, len - shift2)", "        val n = x.toString.length\n\
    \        val s = x.toString\n        if (shift > n) {\n            s.reverse\n\
    \        } else {\n            s.substring(n - shift.toInt) + s.substring(0, n\
    \ - shift.toInt)\n        }", "        var a = x\n        var result = ArrayBuffer[Long]()\n\
    \        while (a > 0) {\n            result += a % 10\n            a /= 10\n\
    \        }\n        for (i <- 1 to shift) {\n            val b = result.remove(result.length\
    \ - 1)\n            result.insert(0, b)\n        }\n        result.reverse.mkString",
  "        var x2 = x\n        var s = \"\"\n        var t = \"\"\n        while (x2\
    \ > 0) {\n            s += (x2 % 10).toString\n            x2 /= 10\n        }\n\
    \        if (shift > s.length) {\n            t = s.reverse\n        } else {\n\
    \            t = s.substring(s.length - shift.toInt) + s.substring(0, s.length\
    \ - shift.toInt)\n        }\n        return t", "        val string = x.toString\n\
    \        val n = string.length\n        val shifted = (string.substring(shift\
    \ % n) + string.substring(0, shift % n)).reverse\n        (shifted.substring(n\
    \ - (shift % n)) + shifted.substring(0, n - (shift % n))).reverse", "        val\
    \ size = floor(log10(x)).toInt + 1\n        val result = x.toString.takeRight(shift.toInt)\
    \ + x.toString.dropRight(shift.toInt)\n        return result", "        val str\
    \ = x.toString\n        val len = str.length\n        val s = if (shift < len)\
    \ {\n            str.substring(len - shift, len) + str.substring(0, len - shift)\n\
    \        } else {\n            str.reverse\n        }\n        s", "        val\
    \ numDigits = log10(x).toInt + 1\n        val shift2 = if (shift > numDigits)\
    \ (shift % numDigits) else shift\n        if (shift2 == 0) x.toString else (1\
    \ to shift2).foldLeft(x) {case (acc, _) => acc / 10} + ((x % 10) * pow(10, numDigits\
    \ - shift2)).toLong", "        if (shift == 0)\n            return x.toString()\n\
    \        if (shift > x.toString().length)\n            return x.toString().reverse\n\
    \        val a = x.toString().substring(0, x.toString().length - shift.toInt)\n\
    \        val b = x.toString().substring(x.toString().length - shift.toInt)\n \
    \       return b + a", "        if (shift >= x.toString.length) return x.toString.reverse\n\
    \        x.toString.substring(shift.toInt) + x.toString.substring(0, shift.toInt)"]
stop_tokens:
- "\n    }\n"
