name: HumanEval_10_make_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Find the shortest palindrome that begins with a supplied string.\n    //\
  \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
  \ that is a palindrome.\n    // - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome('')\n\
  \    // ''\n    // >>> make_palindrome('cat')\n    // 'catac'\n    // >>> make_palindrome('cata')\n\
  \    // 'catac'\n    def makePalindrome(string : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        def expand(l : Int, r : Int) : Int = {\n            var l2\
    \ = l\n            var r2 = r\n            while (l2 >= 0 && r2 < string.length\
    \ && string(l2) == string(r2)) {\n                l2 -= 1\n                r2\
    \ += 1\n            }\n            r2 - l2 - 1\n        }\n        var longest\
    \ = 0\n        var mid = 0\n        for (i <- (0 until string.length)) {\n   \
    \         val len = max(expand(i, i), expand(i, i + 1))\n            if (len >\
    \ longest) {\n                longest = len\n                mid = i\n       \
    \     }\n        }\n        val prefix = string.substring(0, mid - longest / 2\
    \ + 1)\n        prefix + string + prefix.reverse", "        val reverseString\
    \ = string.reverse\n        val n = string.length\n        val L = Array.ofDim[Int](n\
    \ + 1)\n        L(0) = -1\n        L(1) = 0\n        var i = 2\n        var j\
    \ = 0\n        while (i <= n) {\n            if (string(i - 1) == string(j)) {\n\
    \                L(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else if (j > 0) {\n                j = L(j)\n            } else\
    \ {\n                L(i) = 0\n                i += 1\n            }\n       \
    \ }\n        val suffixSize = L(n)\n        val prefixSize = if (suffixSize ==\
    \ 0) 0 else n - suffixSize\n        string + reverseString.substring(0, prefixSize)",
  "        // Takes string and returns the longest substring of it that is a palindrome.\n\
    \        def findLongestPalindromeSubstring(string : String) : String = {\n  \
    \          def isPalindrome(string : String) : Boolean = {\n                def\
    \ helper(string : String, leftIndex : Int, rightIndex : Int) : Boolean = {\n \
    \                   if (leftIndex > rightIndex) return true\n                \
    \    if (string(leftIndex) != string(rightIndex)) return false\n             \
    \       return helper(string, leftIndex + 1, rightIndex - 1)\n               \
    \ }\n                helper(string, 0, string.length - 1)\n            }\n   \
    \         def helper(string : String, leftIndex : Int, rightIndex : Int) : String\
    \ = {\n                if (leftIndex < 0) return string.substring(0, rightIndex\
    \ + 1)\n                if (isPalindrome(string.substring(leftIndex, rightIndex\
    \ + 1))) {\n                    return string.substring(leftIndex, rightIndex\
    \ + 1)\n                }\n                return helper(string, leftIndex - 1,\
    \ rightIndex + 1)\n            }\n            helper(string, string.length - 1,\
    \ 0)\n        }\n        val palindromeSubstring = findLongestPalindromeSubstring(string)\n\
    \        val commonPrefixSubstring = string.substring(0, string.length - palindromeSubstring.length)\n\
    \        return string + commonPrefixSubstring.reverse", "        val reverse\
    \ = string.reverse\n        val result = new StringBuilder\n        val n = string.length\n\
    \        for (i <- 0 until n) {\n            if (string.substring(0, n - i) ==\
    \ reverse.substring(i)) {\n                result.append(string.substring(n -\
    \ i))\n                result.append(string)\n                return result.toString\n\
    \            }\n        }\n        result.append(string)\n        result.append(reverse)\n\
    \        result.toString", "        def postfixPalindrome(s : String) : String\
    \ = {\n            def helper(a : Int, b : Int) : String = {\n               \
    \ val n = s.length\n                if (a >= b) \"\"\n                else if\
    \ (s(a) == s(b)) s(a) + helper(a + 1, b - 1) + s(a)\n                else postfixPalindrome(s.substring(0,\
    \ a)) + s.substring(a)\n            }\n            helper(0, s.length - 1)\n \
    \       }\n        postfixPalindrome(string)", "        var substring = string.reverse\n\
    \        var stringSize = string.size\n        var palindromeSize = 0\n      \
    \  for (i <- 1 to stringSize) {\n            if (string.substring(stringSize -\
    \ i) == substring.substring(0, i)) {\n                palindromeSize = i\n   \
    \         }\n        }\n        if (palindromeSize == stringSize) {\n        \
    \    return string\n        }\n        return string + substring.substring(palindromeSize)",
  "        val n = string.length\n        def isPalindrome(i : Int, j : Int) : Boolean\
    \ = {\n            if (i > j) return true\n            if (string(i) != string(j))\
    \ return false\n            isPalindrome(i + 1, j - 1)\n        }\n        var\
    \ maxLength = 0\n        var maxi = 0\n        var maxj = 0\n        for (i <-\
    \ 0 until n) {\n            for (j <- n - 1 to i by -1) {\n                if\
    \ (isPalindrome(i, j)) {\n                    if (j - i + 1 > maxLength) {\n \
    \                       maxLength = j - i + 1\n                        maxi =\
    \ i\n                        maxj = j\n                    }\n               \
    \ }\n            }\n        }\n        if (maxLength == n) return string\n   \
    \     else {\n            var result = \"\"\n            for (i <- maxj + 1 until\
    \ n) result += string(i)\n            result += string\n            result\n \
    \       }", "        var suffix = new StringBuilder\n        var prefix = new\
    \ StringBuilder\n        var prefixAppended = false\n        for (j <- string.length\
    \ to 0 by -1) {\n            if (isPalindrome(string.substring(j))) {\n      \
    \          suffix = new StringBuilder(string.substring(j))\n                prefix\
    \ = new StringBuilder(string.substring(0, j)).reverse\n                prefixAppended\
    \ = true\n                break\n            }\n        }\n        if (!prefixAppended)\
    \ prefix = new StringBuilder(string).reverse\n        return prefix.append(suffix).toString",
  "        var maxLength = 0\n        var substring : String = null\n        for (i\
    \ <- 0 to string.length / 2) {\n            if (string(i) == string(string.length\
    \ - 1 - i)) {\n                val substring = string.substring(0, i + 1)\n  \
    \              if (substring == substring.reverse) {\n                    maxLength\
    \ = substring.length\n                }\n            }\n        }\n        string\
    \ + string.substring(0, string.length - maxLength).reverse", "        val longestPalindromeSuffix\
    \ = string.indices.reverse.takeWhile(i => string.take(i).isPalindrome).lastOption.getOrElse(0)\n\
    \        string + string.take(string.length - longestPalindromeSuffix).reverse",
  "        if (string.length == 0) return string\n        var prefix = string\n  \
    \      var postfix = string\n        var minPalindrome = string + string.reverse\n\
    \        var maxPalindrome : String = null\n        while (prefix.length > 0)\
    \ {\n            if (postfix.startsWith(prefix) && postfix.length + prefix.length\
    \ - 1 == string.length) {\n                maxPalindrome = string + string.substring(prefix.length).reverse\n\
    \                break\n            }\n            prefix = prefix.substring(0,\
    \ prefix.length - 1)\n            postfix = postfix.substring(1)\n        }\n\
    \        if (maxPalindrome != null) minPalindrome = maxPalindrome\n        return\
    \ minPalindrome", "        if (string.length == 0)\n            return string\n\
    \        var prefix = string\n        var suffix = \"\"\n        for (i <- 0 until\
    \ string.length) {\n            if (isPalindrome(prefix)) {\n                return\
    \ prefix + reverse(suffix)\n            }\n            suffix = prefix(0) + suffix\n\
    \            prefix = prefix.substring(1)\n        }\n        throw new Exception(\"\
    should never reach here\")", "        val ls = string.length\n        if (ls ==\
    \ 0) \"\"\n        else {\n            // This function iterates backwards and\
    \ finds the biggest postfix that is a palindrome.\n            // Example:\n \
    \           // string = \"cata\"\n            // ls = 4\n            // longestPalindrome\
    \ = 0\n            // i = 3\n            // string.substring(i, ls) = \"a\"\n\
    \            // string.substring(0, i + 1) = \"cata\"\n            // if \"a\"\
    \ is palindrome then \"a\" is the biggest palindrome\n            // string.substring(i,\
    \ ls) = \"ata\"\n            // string.substring(0, i + 1) = \"cat\"\n       \
    \     // if \"ata\" is palindrome then \"ata\" is the biggest palindrome\n   \
    \         // string.substring(i, ls) = \"cata\"\n            // string.substring(0,\
    \ i + 1) = \"c\"\n            // if \"cata\" is palindrome then \"cata\" is the\
    \ biggest palindrome\n            def findLongestPalindrome(i : Int, longestPalindrome\
    \ : Int) : Int = {\n                if (i < 0) longestPalindrome\n           \
    \     else {\n                    val substr = string.substring(i, ls)\n     \
    \               val prefix = string.substring(0, i + 1)\n                    if\
    \ (substr == prefix.reverse) findLongestPalindrome(i - 1, max(substr.length, longestPalindrome))\n\
    \                    else findLongestPalindrome(i - 1, longestPalindrome)\n  \
    \              }\n            }\n            val longestPalindrome = findLongestPalindrome(ls\
    \ - 1, 0)\n            val prefix = string.substring(0, ls - longestPalindrome)\n\
    \            string + prefix.reverse\n        }", "        var i = 0\n       \
    \ var j = string.length - 1\n        var k = 0\n        while (i < j) {\n    \
    \        if (string(i) == string(j)) {\n                i += 1\n             \
    \   j -= 1\n            } else {\n                i = 0\n                k +=\
    \ 1\n                j = string.length - k - 1\n            }\n        }\n   \
    \     var result = string\n        if (k > 0) {\n            val prefix = string.substring(0,\
    \ k)\n            val suffix = string.substring(k)\n            result = prefix\
    \ + suffix + prefix.reverse\n        }\n        result", "        if (string.length\
    \ < 2) return string\n        var longestPalindromeSuffix = \"\"\n        for\
    \ (i <- 0 to string.length - 1) {\n            val substr = string.substring(i)\n\
    \            if (substr.length > longestPalindromeSuffix.length && isPalindrome(substr))\
    \ longestPalindromeSuffix = substr\n        }\n        val prefix = string.substring(0,\
    \ string.length - longestPalindromeSuffix.length)\n        prefix + longestPalindromeSuffix\
    \ + prefix.reverse", "        if (string.length == 0) return string\n        //\
    \ Find the longest palindromic suffix of the string.\n        var maxPalindrome\
    \ = (1, string.substring(string.length - 1))\n        var index = string.length\
    \ - 2\n        while (index >= 0) {\n            if (string(index) == string(string.length\
    \ - 1)) {\n                val palindrome = makePalindrome(string.substring(index,\
    \ string.length - 1))\n                if (palindrome.length > maxPalindrome._2.length)\
    \ maxPalindrome = (index, palindrome)\n            }\n            index -= 1\n\
    \        }\n        string.substring(0, maxPalindrome._1) + maxPalindrome._2 +\
    \ string.substring(maxPalindrome._1)", '        string + string.slice(0, string.length
    - maxSuffixLength(string)).reverse', "        if (string.length == 0) {\n    \
    \        return string\n        }\n        var longestPalindromeSuffix = string.last\
    \ + makePalindrome(string.slice(0, string.length - 1)) + string.last\n       \
    \ if (longestPalindromeSuffix.length > string.length) {\n            return longestPalindromeSuffix\n\
    \        }\n        return string.slice(string.length - longestPalindromeSuffix.length,\
    \ string.length) + longestPalindromeSuffix", "        val s = string + \"##\"\
    \ + string.reverse\n        val z = computeZ(s)\n        string.substring(z(string.length\
    \ + 1) - 1) + string", "        // Return the longest palindromic substring starting\
    \ at specified index.\n        def longestPalindrome(string : String, index :\
    \ Int) : String = {\n            var max : Int = -1\n            var palindrome\
    \ = \"\"\n            // Return the length of the longest palindromic suffix.\n\
    \            def explore(string : String, start : Int, end : Int) : Int = {\n\
    \                if (end == string.length) -1\n                else if (string(start)\
    \ == string(end)) explore(string, start - 1, end + 1)\n                else end\
    \ - start - 1\n            }\n            for (i <- 0 to string.length) {\n  \
    \              val length = explore(string, index + i, index + i)\n          \
    \      if (length > max) {\n                    max = length\n               \
    \     palindrome = string.substring(index + i - max, index + i + max + 1)\n  \
    \              }\n            }\n            palindrome\n        }\n        val\
    \ reversed = string.reverse\n        val palindrome = longestPalindrome(string,\
    \ 0)\n        if (palindrome.length == string.length) palindrome\n        else\
    \ palindrome + reversed.substring(palindrome.length)"]
stop_tokens:
- "\n    }\n"
