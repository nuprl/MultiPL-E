name: HumanEval_20_find_closest_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n    // other and return them in order (smaller\
  \ number, larger number).\n    // >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2])\n    // (2.0, 2.2)\n    // >>> find_closest_elements([1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.0])\n    // (2.0, 2.0)\n    def findClosestElements(numbers : List[Float])\
  \ : Tuple2[Float, Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f,\
  \ 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f,\
  \ 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n\
  \    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"
completions: ["        var closestDist = Float.MaxValue\n        var closestElements\
    \ = (0, 0)\n        for (i <- 0 until numbers.length - 1) {\n            for (j\
    \ <- i + 1 until numbers.length) {\n                val diff = abs(numbers(i)\
    \ - numbers(j))\n                if (diff < closestDist) {\n                 \
    \   closestDist = diff\n                    closestElements = (i, j)\n       \
    \         }\n            }\n        }\n        if (numbers(closestElements._1)\
    \ < numbers(closestElements._2)) (numbers(closestElements._1), numbers(closestElements._2))\n\
    \        else (numbers(closestElements._2), numbers(closestElements._1))", " \
    \       var minDistance = 1000000.0f\n        var closestPair = Tuple2(0.0f, 0.0f)\n\
    \        for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1\
    \ until numbers.length) {\n                val absDistance = abs(numbers(i) -\
    \ numbers(j))\n                if (absDistance < minDistance) {\n            \
    \        minDistance = absDistance\n                    closestPair = if (numbers(i)\
    \ < numbers(j)) (numbers(i), numbers(j)) else (numbers(j), numbers(i))\n     \
    \           }\n            }\n        }\n        closestPair", '        (numbers.head,
    numbers.head)', "        val sortedNumbers = numbers.sorted.toArray\n        var\
    \ i = 0\n        var minDist = Float.MaxValue\n        var minIndex = 0\n    \
    \    while (i < sortedNumbers.length - 1) {\n            val dist = abs(sortedNumbers(i)\
    \ - sortedNumbers(i + 1))\n            if (dist < minDist) {\n               \
    \ minDist = dist\n                minIndex = i\n            }\n            i +=\
    \ 1\n        }\n        Tuple2(sortedNumbers(minIndex), sortedNumbers(minIndex\
    \ + 1))", "        def calculateDistance(currentIndex : Int, currentDistance :\
    \ Float, numbers : List[Float]) : Float = currentIndex match {\n            case\
    \ x if (x + 1 == numbers.length) => currentDistance\n            case _ => calculateDistance(currentIndex\
    \ + 1, min(currentDistance, abs(numbers(currentIndex) - numbers(currentIndex +\
    \ 1))), numbers)\n        }\n        def getClosestElements(currentIndex : Int,\
    \ currentDistance : Float, numbers : List[Float]) : List[Float] = currentIndex\
    \ match {\n            case x if (x + 1 == numbers.length) => List(numbers(currentIndex),\
    \ numbers(currentIndex))\n            case _ => {\n                if (abs(numbers(currentIndex)\
    \ - numbers(currentIndex + 1)) == currentDistance)\n                    List(numbers(currentIndex),\
    \ numbers(currentIndex + 1))\n                else\n                    getClosestElements(currentIndex\
    \ + 1, currentDistance, numbers)\n            }\n        }\n        val closestDistance\
    \ = calculateDistance(0, abs(numbers(0) - numbers(1)), numbers)\n        val closestElements\
    \ = getClosestElements(0, closestDistance, numbers)\n        Tuple2(closestElements(0),\
    \ closestElements(1))", "      var min = Float.MaxValue\n      var result : Tuple2[Float,\
    \ Float] = null\n      var left = 0\n      while (left < numbers.length - 1) {\n\
    \        var right = left + 1\n        while (right < numbers.length) {\n    \
    \      val currentMin = abs(numbers(left) - numbers(right))\n          if (currentMin\
    \ < min) {\n            min = currentMin\n            result = (numbers(left),\
    \ numbers(right))\n          }\n          right += 1\n        }\n        left\
    \ += 1\n      }\n      result", "        var closest = Float.MaxValue\n      \
    \  var closestTuple : Tuple2[Float, Float] = (0.0f, 0.0f)\n        for (i <- 0\
    \ until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                if (abs(numbers(i) - numbers(j)) < closest) {\n         \
    \           closest = abs(numbers(i) - numbers(j))\n                    closestTuple\
    \ = (numbers(i), numbers(j))\n                }\n            }\n        }\n  \
    \      closestTuple", "        // Return Tuple2[Float, Float]\n        val numbersSorted\
    \ = numbers.sorted\n        var currentMinDiff = math.abs(numbersSorted(0) - numbersSorted(1))\n\
    \        var currentMinDiffNumbers = (numbersSorted(0), numbersSorted(1))\n  \
    \      for (i <- 0 until numbersSorted.length - 1) {\n            val currentDiff\
    \ = math.abs(numbersSorted(i) - numbersSorted(i + 1))\n            if (currentDiff\
    \ < currentMinDiff) {\n                currentMinDiff = currentDiff\n        \
    \        currentMinDiffNumbers = (numbersSorted(i), numbersSorted(i + 1))\n  \
    \          }\n        }\n        currentMinDiffNumbers", "      require(numbers.length\
    \ >= 2)\n      val (min, max) = numbers.foldLeft((numbers.head, numbers.head))((b,\
    \ a) => (min(b._1, a), max(b._2, a)))\n      numbers.filter(n => n != min && n\
    \ != max).foldLeft((min, max))((b, a) => if (abs(b._1 - b._2) > abs(a - b._1))\
    \ (a, b._1) else (b._1, a))", "        var minDiff : Float = Float.MaxValue\n\
    \        var minTuple : Tuple2[Float, Float] = null\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            val diff = abs(numbers(i) - numbers(i + 1))\n\
    \            if (diff < minDiff) {\n                minDiff = diff\n         \
    \       minTuple = Tuple2(numbers(i), numbers(i + 1))\n            }\n       \
    \ }\n        minTuple", "        val sortedNumbers = numbers.sorted\n        val\
    \ pairs = sortedNumbers.zip(sortedNumbers.tail)\n        pairs.reduce( (x, y)\
    \ => if (abs(x._1 - x._2) < abs(y._1 - y._2)) x else y)", "        var closest\
    \ = (numbers(0), numbers(1))\n        for (i <- numbers.indices; j <- numbers.indices\
    \ if (i != j && abs(numbers(i) - numbers(j)) < abs(closest._1 - closest._2)))\
    \ closest = (numbers(i), numbers(j))\n        closest", "        val sorted =\
    \ numbers.sorted\n        val diffs = new ArrayBuffer[Float]\n        for (i <-\
    \ 0 until sorted.length - 1) {\n            diffs += abs(sorted(i) - sorted(i\
    \ + 1))\n        }\n        val min = diffs.min\n        val minIndex = diffs.indexOf(min)\n\
    \        return (sorted(minIndex), sorted(minIndex + 1))", "        def findMin(a\
    \ : Float, b : Float) : Tuple2[Float, Float] = {\n            if (a < b) {\n \
    \               (a, b)\n            } else {\n                (b, a)\n       \
    \     }\n        }\n        var min = findMin(numbers(0), numbers(1))\n      \
    \  for (i <- 2 until numbers.length) {\n            val closest = findMin(numbers(i\
    \ - 1), numbers(i))\n            if (abs(closest._1 - closest._2) < abs(min._1\
    \ - min._2)) {\n                min = closest\n            }\n        }\n    \
    \    min", "        val l = numbers.length\n        if (l < 2) throw new IllegalArgumentException(\"\
    List length must be at least 2\")\n        var min = (numbers(0), numbers(1))\n\
    \        var minDiff = abs(min._1 - min._2)\n        for (i <- 0 until l - 1)\
    \ {\n            val diff = abs(numbers(i) - numbers(i + 1))\n            if (diff\
    \ < minDiff) {\n                min = (numbers(i), numbers(i + 1))\n         \
    \       minDiff = diff\n            }\n        }\n        min", "        val pq\
    \ = new PriorityQueue[Float]()(Ordering.by(math.abs(_)))\n        for (i <- 0\
    \ until numbers.length) {\n            pq.enqueue(numbers(i))\n        }\n   \
    \     var last = pq.dequeue\n        while (pq.nonEmpty) {\n            val next\
    \ = pq.dequeue\n            if (abs(last - next) <= 0.000001) return (last, next)\n\
    \            last = next\n        }\n        throw new Exception(\"Should never\
    \ reach here!\")", "        var differences = new ListBuffer[Float]\n        var\
    \ previousValue = numbers(0)\n        for (i <- 1 until numbers.length) {\n  \
    \          differences += abs(numbers(i) - previousValue)\n            previousValue\
    \ = numbers(i)\n        }\n        var index = 0\n        var bestDifference =\
    \ differences(0)\n        for (i <- 1 until differences.length) {\n          \
    \  if (differences(i) < bestDifference) {\n                bestDifference = differences(i)\n\
    \                index = i\n            }\n        }\n        (numbers(index),\
    \ numbers(index + 1))", "        var smallestDifference : Float = Float.MaxValue\n\
    \        var closestPair : Tuple2[Float, Float] = null\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                val difference = abs(numbers(i) - numbers(j))\n             \
    \   if (difference < smallestDifference) {\n                    smallestDifference\
    \ = difference\n                    closestPair = if (numbers(i) < numbers(j))\
    \ (numbers(i), numbers(j)) else (numbers(j), numbers(i))\n                }\n\
    \            }\n        }\n        closestPair", "        var diff = Float.MaxValue\n\
    \        var closest = numbers.zip(numbers.tail).minBy(x => abs(x._1 - x._2))\n\
    \        return closest", "        var minDist = Float.MaxValue\n        var minNum\
    \ = Float.MaxValue\n        var minNum2 = Float.MaxValue\n        var c = 0\n\
    \        for (n <- numbers) {\n            if (c > 0) {\n                val dist\
    \ = abs(n - numbers(c - 1))\n                if (dist < minDist) {\n         \
    \           minDist = dist\n                    minNum = numbers(c - 1)\n    \
    \                minNum2 = n\n                }\n            }\n            c\
    \ += 1\n        }\n        if (minNum > minNum2) return (minNum2, minNum)\n  \
    \      (minNum, minNum2)"]
stop_tokens:
- "\n    }\n"
