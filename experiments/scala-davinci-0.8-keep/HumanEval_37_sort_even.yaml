name: HumanEval_37_sort_even
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // This function takes a list l and returns a list l' such that\n    // l'\
  \ is identical to l in the odd indicies, while its values at the even indicies are\
  \ equal\n    // to the values of the even indicies of l, but sorted.\n    // >>>\
  \ sort_even([1, 2, 3])\n    // [1, 2, 3]\n    // >>> sort_even([5, 6, 3, 4])\n \
  \   // [3, 6, 5, 4]\n    def sortEven(l : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sortEven((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));\n\
  \    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong,\
  \ 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong,\
  \ 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong,\
  \ 9l.toLong, 1l.toLong, 123l.toLong))));\n    assert(sortEven((List[Long](5l.toLong,\
  \ 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong,\
  \ 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        var sortedEven = List[Long]()\n        var odd = List[Long]()\n\
    \        var even = List[Long]()\n        for (i <- l.indices) {\n           \
    \ if (i % 2 == 0) {\n                even = even :+ l(i)\n            } else {\n\
    \                odd = odd :+ l(i)\n            }\n        }\n        even = even.sorted\n\
    \        for (i <- l.indices) {\n            if (i % 2 == 0) {\n             \
    \   sortedEven = sortedEven :+ even(i / 2)\n            } else {\n           \
    \     sortedEven = sortedEven :+ odd(i / 2)\n            }\n        }\n      \
    \  sortedEven", '        l.grouped(2).map(x => if (x.length == 2) x.sortBy(y =>
    y) else x).flatten.toList', "        val l0 = l.zipWithIndex\n        val l1 =\
    \ l0.filter(_._2 % 2 == 0)\n        val l2 = l1.map(_._1).sorted\n        val\
    \ l3 = l0.filter(_._2 % 2 == 1)\n        val l4 = l3.map(_._1)\n        l2 :::\
    \ l4", "        if (l.length % 2 == 1) return l\n        var result = new ListBuffer[Long]\n\
    \        for (i <- 0 until l.length) {\n            if (i % 2 == 0) result +=\
    \ l(i)\n            else {\n                var temp = l.slice(i, i + 2)\n   \
    \             temp = temp.sorted\n                result += temp(0)\n        \
    \        result += temp(1)\n            }\n        }\n        return result.toList",
  "        val l1 = l.filter((e, i) => i % 2 == 0)\n        val l2 = l.filter((e,\
    \ i) => i % 2 == 1)\n        val l3 = l1.sorted\n        val z = (l3 zip l2).flatten.toList\n\
    \        z", "        val (evens, odds) = l.zipWithIndex.partition(p => p._2 %\
    \ 2 == 0)\n        (odds.map(_._1) ::: evens.map(_._1).sortWith(_ < _)).toList",
  "    \tl.zipWithIndex.map(x => {if (x._2 % 2 == 0) x._1 else x._1.toString.toList.sortWith(_\
    \ < _).mkString.toLong}).toList", "        val result = new ListBuffer[Long]\n\
    \        for (i <- 0 until l.length) {\n            if (i % 2 == 0) result +=\
    \ l(i)\n            else {\n                val values = l.slice(i, i + 2)\n \
    \               val sorted = values.sorted\n                result += sorted(0)\n\
    \                result += sorted(1)\n            }\n        }\n        result.toList",
  "    \tvar l2 = List[Long]()\n    \tfor (i <- 0 until l.length) {\n    \t\tif (i\
    \ % 2 == 0) l2 ::= l(i)\n    \t\telse {\n    \t\t\tval l3 = l.drop(i).filter(_\
    \ % 2 == 0).sorted\n    \t\t\tl2 ::= l3(0)\n    \t\t}\n    \t}\n    \tl2.reverse",
  "    \tvar t = l.clone\n    \tfor (i <- 2 to l.length) {\n    \t\tif (i % 2 == 0)\
    \ t = swap(t, i, findMin(t, i))\n    \t}\n    \tt", "        if (l.length == 0)\
    \ Nil\n        else if (l.length == 1) l\n        else if (l.length == 2) List(l(1),\
    \ l(0))\n        else {\n            val even = l.zipWithIndex.filter(x => x._2\
    \ % 2 == 0).map(x => x._1)\n            val odd = l.zipWithIndex.filter(x => x._2\
    \ % 2 == 1).map(x => x._1)\n            List(even.head) ::: odd.head :: sortEven(even.tail\
    \ ::: odd.tail)\n        }", "        var result = l.to[ArrayBuffer]\n       \
    \ for (i <- l.indices if i % 2 == 0) {\n            val index = i + 1\n      \
    \      var temp = result(index)\n            var j = index - 1\n            while\
    \ (j >= 0 && result(j) > temp) {\n                result(j + 1) = result(j)\n\
    \                j -= 1\n            }\n            result(j + 1) = temp\n   \
    \     }\n        result.toList", "    \tif (l.length % 2 == 1)\n    \t\tthrow\
    \ new Exception(\"The list must have an even number of elements.\")\n    \telse\
    \ {\n    \t\tval evenList = l.grouped(2).map(x => x(1)).toList\n    \t\tval oddList\
    \ = l.grouped(2).map(x => x(0)).toList\n    \t\tevenList.sortBy(x => x) ++ oddList\n\
    \    \t}", "        def helper(l : List[Long], res : List[Long]) : List[Long]\
    \ = {\n            l match {\n                case x1 :: x2 :: xs => helper(xs,\
    \ res :+ x1 :+ x2.toString.sorted.toLong)\n                case _ => res\n   \
    \         }\n        }\n        helper(l, List())", "        if (l.length % 2\
    \ == 1) {\n            println(\"Warning: Expected List of even length; returning\
    \ original List.\")\n            return l\n        }\n        val sorted = (l.slice(0,\
    \ l.length / 2) ::: l.slice(l.length / 2, l.length)).sortWith(_ < _)\n       \
    \ sorted.slice(0, sorted.length / 2) ::: sorted.slice(sorted.length / 2, sorted.length)",
  "      var l2 = l.toBuffer\n      for (i <- 0 until l.length) {\n        if (i %\
    \ 2 == 0) {\n          val l3 = l2.slice(i, i + 2).toBuffer\n          l3(0) =\
    \ min(l3(0), l3(1))\n          l3(1) = max(l3(0), l3(1))\n          l2(i) = l3(0)\n\
    \          l2(i + 1) = l3(1)\n        }\n      }\n      l2.toList", "        def\
    \ sortEvenHelper(l : List[Long], sorted : List[Long]) : List[Long] = l match {\n\
    \            case Nil => sorted\n            case l(0) :: l(1) :: t => {\n   \
    \             val (evens, odds) = t.splitAt(2)\n                val sortedEvens\
    \ = evens.sorted\n                sortEvenHelper(odds, sortedEvens ::: l)\n  \
    \          }\n        }\n        sortEvenHelper(l, Nil)", "      if (l.size <=\
    \ 1) l\n      else l.grouped(2).map(x => x match {\n        case List(a, b) =>\
    \ List(a, b.sorted)\n        case List(a) => List(a)\n      }).flatten.toList",
  "        def sortEven(odd : List[Long], even : List[Long]) : List[Long] = {\n  \
    \          if (even.length == 0) odd\n            else {\n                sortEven(odd.head\
    \ :: even.sorted.head :: sortEven(odd.tail, even.tail), Nil)\n            }\n\
    \        }\n        if (l.length == 0) l\n        else sortEven(List(l.head),\
    \ l.tail)", "        val (evens, odds) = l.zipWithIndex.partition {case (element,\
    \ index) => index % 2 == 0}\n        odds.map(_._1) ::: evens.map(_._1).sortWith(_\
    \ < _)"]
stop_tokens:
- "\n    }\n"
