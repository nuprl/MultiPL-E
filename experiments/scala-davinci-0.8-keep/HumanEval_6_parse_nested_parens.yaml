name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parse_nested_parens('(()()) ((()))\
  \ () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string :\
  \ String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        var level : Long = 0\n        var maxLevel : Long = 0\n   \
    \     var groups : List[Long] = List()\n        for (i <- 0 until paren_string.length)\
    \ {\n            if (paren_string(i) == '(') {\n                level += 1\n \
    \               maxLevel = max(maxLevel, level)\n            } else if (paren_string(i)\
    \ == ')') {\n                level -= 1\n            } else if (paren_string(i)\
    \ == ' ') {\n                groups = groups :+ maxLevel\n                maxLevel\
    \ = 0\n            }\n        }\n        groups = groups :+ maxLevel\n       \
    \ return groups", "        // keep track of the maximum number of consecutive\
    \ open parentheses\n        var max_open_parens = 0\n        // keep track of\
    \ the current level of nested parentheses\n        var current_open_parens = 0\n\
    \        var output = List[Long]()\n        // iterate through the string\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  current_open_parens += 1\n                max_open_parens = max(max_open_parens,\
    \ current_open_parens)\n            } else if (c == ')') {\n                current_open_parens\
    \ -= 1\n            } else if (c == ' ') {\n                output = max_open_parens\
    \ :: output\n                max_open_parens = 0\n                current_open_parens\
    \ = 0\n            }\n        }\n        // for the last one\n        output =\
    \ max_open_parens :: output\n        return output.reverse", "      paren_string.split(\"\
    \ \").map(s => {\n      \ts.toList.foldLeft((0, List[Long]()))((tuple, ch) =>\
    \ {\n          ch match {\n            case '(' => (tuple._1 + 1, tuple._2 :+\
    \ tuple._1 + 1)\n            case ')' => (tuple._1 - 1, tuple._2)\n          }\n\
    \        })._2\n      }).toList", "    \tvar paren_groups = paren_string.split(\"\
    \ \")\n    \tvar result = List[Long]()\n    \tfor (group <- paren_groups) {\n\
    \    \t\tvar cur_result = 1\n    \t\tvar depth = 0\n    \t\tfor (i <- 0 until\
    \ group.length) {\n    \t\t\tif (group(i) == '(') {\n    \t\t\t\tdepth += 1\n\
    \    \t\t\t\tcur_result = max(cur_result, depth)\n    \t\t\t} else {\n    \t\t\
    \t\tdepth -= 1\n    \t\t\t}\n    \t\t}\n    \t\tresult = result :+ cur_result\n\
    \    \t}\n    \tresult", "        val max_parens = new ListBuffer[Long]\n    \
    \    val paren_list = paren_string.split(\" \")\n        for (paren <- paren_list)\
    \ {\n            val paren_lvl = new ListBuffer[Int]\n            for (c <- paren)\
    \ {\n                c match {\n                    case '(' => paren_lvl += 1\n\
    \                    case ')' => paren_lvl += -1\n                    case _ =>\n\
    \                }\n            }\n            max_parens += paren_lvl.max\n \
    \       }\n        max_parens.toList", '        paren_string.split(" ").map(x
    => parseNestedParens2(x.toList, 0, 0)).toList', "        def parse(paren_string\
    \ : String, temp : List[Long]) : List[Long] = {\n            val paren_string_trimmed\
    \ = paren_string.trim\n            if (paren_string_trimmed.isEmpty) return temp\n\
    \            val paren_string_trimmed_split = paren_string_trimmed.split(\" \"\
    )\n            val paren_string_first = paren_string_trimmed_split(0)\n      \
    \      val paren_string_rest = paren_string_trimmed_split.slice(1, paren_string_trimmed_split.length).mkString(\"\
    \ \")\n            if (paren_string_first.charAt(0) != '(') {\n              \
    \  temp :+ 0\n            } else {\n                var count = 0\n          \
    \      var max = 0\n                for (i <- 0 until paren_string_first.length)\
    \ {\n                    val c = paren_string_first.charAt(i)\n              \
    \      if (c == '(') {\n                        count += 1\n                 \
    \       max = max.max(count)\n                    } else if (c == ')') {\n   \
    \                     count -= 1\n                    }\n                }\n \
    \               parse(paren_string_rest, temp :+ max)\n            }\n       \
    \ }\n        parse(paren_string, List())", "        // Step 1: Split the string\
    \ by whitespace\n        val paren_groups = paren_string.split(\" \")\n      \
    \  val depths = new ListBuffer[Long]()\n        // Step 2: For each paren group,\
    \ determine its depth\n        for (group <- paren_groups) {\n            var\
    \ depth = 0\n            var max_depth = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    depth += 1\n       \
    \             max_depth = max(max_depth, depth)\n                } else if (paren\
    \ == ')') {\n                    depth -= 1\n                }\n            }\n\
    \            depths += max_depth\n        }\n        depths.toList", "       \
    \ val tokens = paren_string.split(\" \")\n        var res = List[Long]()\n   \
    \     for (token <- tokens) {\n            var stack = Stack[Char]()\n       \
    \     var max_depth = 0\n            var count = 0\n            for (ch <- token)\
    \ {\n                if (ch == '(') {\n                    stack.push(ch)\n  \
    \                  count += 1\n                    max_depth = max(max_depth,\
    \ count)\n                } else if (ch == ')') {\n                    if (stack.isEmpty)\
    \ throw new Exception(\"Invalid parentheses token!\")\n                    stack.pop\n\
    \                    count -= 1\n                }\n            }\n          \
    \  if (!stack.isEmpty) throw new Exception(\"Invalid parentheses token!\")\n \
    \           res = res :+ max_depth\n        }\n        res", "        val parens\
    \ = paren_string.toCharArray\n        val stack = new Stack[Char]\n        var\
    \ stack_count = 0\n        var max_stack_count = 0\n        for (i <- 0 until\
    \ parens.length) {\n            if (parens(i) == '(') {\n                stack.push(parens(i))\n\
    \                stack_count += 1\n                max_stack_count = max(max_stack_count,\
    \ stack_count)\n            } else if (parens(i) == ')') {\n                stack.pop\n\
    \                stack_count -= 1\n            }\n        }\n        List(max_stack_count)",
  "        var results = List[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var count = 0\n            var level = 0\n            for\
    \ (char <- group) {\n                if (char == '(') level += 1\n           \
    \     else if (char == ')') level -= 1\n                if (level > count) count\
    \ = level\n            }\n            results = results :+ count\n        }\n\
    \        results", "        val stack = new Stack[Long]\n        for (i <- 0 until\
    \ paren_string.length) {\n            paren_string(i) match {\n              \
    \  case '(' => {\n                    stack.push(0)\n                }\n     \
    \           case ')' => {\n                    if (stack.isEmpty) throw new IllegalArgumentException(\"\
    Invalid input string - too many closing parenthesis\")\n                    else\
    \ {\n                        var total = 0\n                        var level\
    \ = 0\n                        while (!stack.isEmpty && stack.top != -1) {\n \
    \                           level += 1\n                            total += stack.pop()\n\
    \                        }\n                        if (stack.isEmpty) throw new\
    \ IllegalArgumentException(\"Invalid input string - too many closing parenthesis\"\
    )\n                        else {\n                            stack.pop()\n \
    \                           stack.push(total + level)\n                      \
    \  }\n                    }\n                }\n                case ' ' => {\n\
    \                    if (stack.isEmpty) throw new IllegalArgumentException(\"\
    Invalid input string - too many spaces\")\n                    else {\n      \
    \                  if (stack.top == -1) throw new IllegalArgumentException(\"\
    Invalid input string - too many spaces\")\n                        else stack.push(-1)\n\
    \                    }\n                }\n                case _ => throw new\
    \ IllegalArgumentException(\"Invalid input string - unrecognized character\")\n\
    \            }\n        }\n        if (stack.isEmpty) throw new IllegalArgumentException(\"\
    Invalid input string - too many spaces\")\n        if (stack.top != -1) throw\
    \ new IllegalArgumentException(\"Invalid input string - too many closing parenthesis\"\
    )\n        return stack.toList.reverse.filter(_ != -1)", "        var paren_groups\
    \ = paren_string.split(\" \")\n        var max_nested_list = new ListBuffer[Long]()\n\
    \        for (i <- 0 until paren_groups.length) {\n            var paren_group\
    \ = paren_groups(i)\n            var max_nested = 0\n            var nested =\
    \ 0\n            for (c <- paren_group) {\n                if (c == '(') nested\
    \ += 1\n                else nested -= 1\n                max_nested = max(max_nested,\
    \ nested)\n            }\n            max_nested_list += max_nested\n        }\n\
    \        return max_nested_list.toList", "        val stacks = HashMap[Long, Stack[Char]]()\n\
    \        var max_level = 0L\n        paren_string.toCharArray.foreach { paren\
    \ =>\n            paren match {\n                case '(' => {\n             \
    \       max_level += 1\n                    if (!stacks.contains(max_level)) stacks\
    \ += max_level -> Stack[Char]()\n                    stacks(max_level).push(paren)\n\
    \                }\n                case ')' => {\n                    if (stacks(max_level).pop\
    \ != '(') throw new Exception(\"Invalid parenthesis!\")\n                    if\
    \ (stacks(max_level).size == 0) max_level -= 1\n                }\n          \
    \      case _ => throw new Exception(\"Invalid input!\")\n            }\n    \
    \    }\n        stacks.keys.toList.sorted", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.toList.map(s => {\n            var count = 0\n   \
    \         s.foreach(c => {\n                if (c == '(') count += 1\n       \
    \         else if (c == ')') count -= 1\n            })\n            count\n \
    \       })", "        var result = new ListBuffer[Long]\n        var parens =\
    \ paren_string.toList\n        while (!parens.isEmpty) {\n            var count\
    \ = 0\n            var depth = 0\n            var temp = List[Char]()\n      \
    \      while (!parens.isEmpty && parens.head != ' ') {\n                temp =\
    \ parens.head :: temp\n                parens = parens.tail\n            }\n \
    \           parens = parens.tail\n            for (c <- temp) {\n            \
    \    c match {\n                    case '(' => count += 1\n                 \
    \   case ')' => count -= 1\n                }\n                depth = max(depth,\
    \ count)\n            }\n            result += depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_per_group\
    \ = paren_groups.map(group => group.count(c => c == '(') - group.count(c => c\
    \ == ')')).toList\n        // This is the issue ...\n        max_nesting_per_group.map(max_nesting\
    \ => max_nesting / 2)", "      val processed_paren_string = paren_string.replaceAll(\"\
    \ \", \"\")\n      val results = ListBuffer[Long]()\n      var max_depth = 0\n\
    \      var current_depth = 0\n      var i = 0\n      while (i < processed_paren_string.length)\
    \ {\n        if (processed_paren_string(i) == '(') {\n          current_depth\
    \ += 1\n          max_depth = max(max_depth, current_depth)\n        } else if\
    \ (processed_paren_string(i) == ')') {\n          results += max_depth\n     \
    \     current_depth = 0\n          max_depth = 0\n        }\n        i += 1\n\
    \      }\n      results.toList", "        val split_paren_strings = paren_string.split(\"\
    \ \")\n        val results = ArrayBuffer[Long]()\n        for (split_paren_string\
    \ <- split_paren_strings) {\n            var current_depth = 0\n            var\
    \ max_depth = 0\n            for (paren <- split_paren_string) {\n           \
    \     if (paren == '(') {\n                    current_depth += 1\n          \
    \          max_depth = max(max_depth, current_depth)\n                } else if\
    \ (paren == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            results += max_depth\n        }\n        results.toList",
  "        val res = ListBuffer[Long]()\n        var depth = 0\n        for (c <-\
    \ paren_string) {\n            if (c == '(') depth += 1\n            else if (c\
    \ == ')') {\n                res += depth\n                depth -= 1\n      \
    \      }\n        }\n        res.toList"]
stop_tokens:
- "\n    }\n"
