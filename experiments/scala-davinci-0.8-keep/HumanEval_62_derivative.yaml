name: HumanEval_62_derivative
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // xs represent coefficients of a polynomial.\n    // xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n    // Return derivative of this polynomial in the same form.\n\
  \    // >>> derivative([3, 1, 2, 4, 5])\n    // [1, 4, 12, 20]\n    // >>> derivative([1,\
  \ 2, 3])\n    // [2, 6]\n    def derivative(xs : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(derivative((List[Long](3l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong,\
  \ 12l.toLong, 20l.toLong))));\n    assert(derivative((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));\n    assert(derivative((List[Long](3l.toLong,\
  \ 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(derivative((List[Long](3l.toLong,\
  \ 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong,\
  \ 0l.toLong, 16l.toLong))));\n    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        if (xs.size == 1) List(0)\n        else {\n            val\
    \ r = (1 until xs.size).map(xs(_) * _).toList\n            r\n        }", "  \
    \      if (xs.length <= 1) return List()\n        var i = 1\n        val result\
    \ = new ListBuffer[Long]\n        for (c <- xs.tail) {\n            result +=\
    \ i * c\n            i += 1\n        }\n        result.toList", '        for ((c,
    i) <- xs.zipWithIndex if i != 0) yield i * c', "        var ys = List[Long]()\n\
    \        for (i <- 1 until xs.length) {\n            ys = xs(i) * i +: ys\n  \
    \      }\n        ys", '        (1 until xs.length).map(i => xs(i) * i).toList',
  '        (for (i <- 1 until xs.length) yield xs(i) * i).toList', "      val temp\
    \ = xs.zipWithIndex\n      temp.filter(_._2 > 0).map(t => t._1 * t._2).toList",
  "        var ys = List[Long]()\n        for (i <- Range(1, xs.length)) {\n     \
    \       ys = (xs(i) * i) :: ys\n        }\n        ys.reverse", "        if (xs.length\
    \ < 2) return List()\n        val ys = new ListBuffer[Long]\n        for (i <-\
    \ 1 until xs.length) ys += i * xs(i)\n        ys.toList", '        xs.view.zipWithIndex.map(x
    => x._1 * x._2).tail.toList', '      xs.zipWithIndex.map(x => x._1 * x._2).tail',
  "        val n = xs.length\n        val ret = new ListBuffer[Long]\n        for\
    \ (i <- 1 until n) ret += xs(i) * i\n        ret.toList", "        val n = xs.length\n\
    \        List.tabulate(n - 1)(i => (i + 1) * xs(i + 1))", "        val ans = new\
    \ ArrayBuffer[Long]\n        for (i <- 1 until xs.length) ans += xs(i) * i\n \
    \       ans.toList", "        if (xs.length < 2) return List()\n        return\
    \ xs.zipWithIndex.map(p => p._1 * p._2).drop(1)", "        var ys = new ListBuffer[Long]\n\
    \        for (i <- 0 until xs.length - 1) ys += (xs(i + 1) * (i + 1))\n      \
    \  ys.toList", "        var result = List[Long]()\n        for (i <- 1 until xs.length)\
    \ result = result :+ (xs(i) * i)\n        result", "        val m = xs.length\
    \ - 1\n        val result = ArrayBuffer[Long]()\n        for (i <- 1 to m) result\
    \ += xs(i) * i\n        result.toList", "        def f(xs : List[Long], n : Int)\
    \ : List[Long] = xs match {\n            case Nil => Nil\n            case _ =>\
    \ (n * xs.head) :: f(xs.tail, n + 1)\n        }\n        f(xs.tail, 1)", '        xs.drop(1).zipWithIndex.map(p
    => (p._1 * (p._2 + 1))).toList']
stop_tokens:
- "\n    }\n"
