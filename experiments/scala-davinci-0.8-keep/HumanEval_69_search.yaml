name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    // search([4, 1, 2, 2, 3, 1]) == 2\n    // search([1,\
  \ 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n    // search([5, 5, 4, 4, 4]) == -1\n    def search(lst\
  \ : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        val result = lst.distinct.map(x => (x, lst.count(_ == x))).filter(x\
    \ => x._1 <= x._2).sortBy(_._1).reverse\n        if (result.length == 0) -1 else\
    \ result(0)._1", "        val m = new HashMap[Long, Long]()\n        lst.foreach(x\
    \ => {\n            if (!m.contains(x)) {\n                m += (x -> 1)\n   \
    \         } else {\n                m += (x -> (m(x) + 1))\n            }\n  \
    \      })\n        val keys = m.keySet.toList.sorted\n        val ans = keys.filter(x\
    \ => {\n            if (x == 0) false\n            else m(x) >= x\n        })\n\
    \        if (ans.isEmpty) -1 else ans.last", "        var max = 0L\n        var\
    \ map = Map[Long, Long]()\n        for (i <- lst) {\n            map += (i ->\
    \ (map.getOrElse(i, 0L) + 1))\n            max = max max i\n        }\n      \
    \  for (i <- max to 1 by -1) {\n            if (map.getOrElse(i, 0L) >= i) return\
    \ i\n        }\n        return -1", "        if (lst.size == 0) -1\n        else\
    \ {\n        \tvar dic = Map[Long, Long]()\n        \tfor (num <- lst) {\n   \
    \     \t\tif (dic.contains(num)) dic(num) += 1\n        \t\telse dic(num) = 1\n\
    \        \t}\n        \tvar result = -1L\n        \tfor (num <- lst) {\n     \
    \   \t\tif (num >= dic(num) && num > result) result = num\n        \t}\n     \
    \   \tresult\n        }", "        val count = new HashMap[Long, Long]\n     \
    \   lst.foreach(i => count(i) = count.getOrElse(i, 0) + 1)\n        val maxFrequency\
    \ = lst.max\n        val maxFrequencyCount = count(maxFrequency)\n        val\
    \ keys = count.keys.toList.sortWith(_ > _)\n        for (i <- keys) {\n      \
    \      if (i <= maxFrequencyCount && count(i) >= i) return i\n        }\n    \
    \    -1", "        val map = new scala.collection.mutable.HashMap[Long, Long]\n\
    \        for (value <- lst) {\n            if (map.contains(value)) map(value)\
    \ += 1\n            else map += value -> 1\n        }\n        var maxvalue =\
    \ -1\n        for (value <- map.keys) {\n            if (value <= map(value) &&\
    \ value > maxvalue) maxvalue = value\n        }\n        maxvalue", "        val\
    \ countMap = new HashMap[Long, Long]()\n        for (i <- lst) {\n           \
    \ if (countMap.contains(i)) countMap(i) += 1\n            else countMap += (i\
    \ -> 1)\n        }\n        for (i <- lst.sorted.reverse) {\n            if (countMap(i)\
    \ >= i) return i\n        }\n        return -1", "        var hash = Map[Long,\
    \ Long]()\n        for (e <- lst) hash(e) = hash.getOrElse(e, 0) + 1\n       \
    \ for (i <- 1 to lst.length) {\n            if (hash.contains(i) && hash(i) >=\
    \ i) return i\n        }\n        return -1", "        val freqMap = HashMap[Long,\
    \ Long]()\n        for (x <- lst) {\n            if (freqMap.contains(x)) freqMap(x)\
    \ += 1 else freqMap(x) = 1\n        }\n        var res = -1L\n        for (key\
    \ <- freqMap.keys) {\n            if (key <= freqMap(key) && res < key) res =\
    \ key\n        }\n        res", "        val c = lst.groupBy(x => x).mapValues(_.size)\n\
    \        c.filter(x => x._1 <= x._2).toList.sortBy(x => -x._1).headOption match\
    \ {\n            case Some(x) => x._1\n            case None => -1\n        }",
  "        val frequencies = scala.collection.mutable.Map[Long, Long]()\n        for\
    \ (n <- lst) {\n            if (frequencies.contains(n)) {\n                frequencies(n)\
    \ += 1\n            } else {\n                frequencies(n) = 1\n           \
    \ }\n        }\n        if (frequencies.toList.sortBy(x => x._1).forall(y => y._1\
    \ > y._2)) -1\n        else frequencies.toList.sortBy(x => x._1).find(y => y._1\
    \ <= y._2).get._1", "        val freq = new HashMap[Long, Long]()\n        for\
    \ (i <- lst) freq(i) = freq.getOrElse(i, 0) + 1\n        val keys = freq.keySet.toList.sorted\n\
    \        for (i <- keys.reverse) {\n            if (freq(i) >= i) return i\n \
    \       }\n        return -1", "    \tvar map = new HashMap[Long, Long]()\n  \
    \  \tfor (i <- lst) {\n    \t\tif (map.contains(i)) {\n    \t\t\tmap(i) += 1\n\
    \    \t\t} else {\n    \t\t\tmap += (i -> 1)\n    \t\t}\n    \t}\n    \tval a\
    \ = map.filter(x => x._1 <= x._2).toList.sortBy(x => -x._1)\n    \tif (a.length\
    \ > 0) a(0)._1 else -1", "        val map = new HashMap[Long, Long]()\n      \
    \  lst.foreach(n => map.update(n, map.getOrElse(n, 0) + 1))\n        map.filter(p\
    \ => p._1 <= p._2).keySet.toList.sorted.lastOption.getOrElse(-1)", "    \tval\
    \ map = lst.groupBy(x => x).mapValues(_.size)\n    \tval keys = map.keys.toList.sorted\n\
    \    \tfor (key <- keys) {\n    \t\tif (key == map(key)) return key\n    \t}\n\
    \    \treturn -1", "        val m = Map[Long, Long]()\n        for (i <- lst)\
    \ {\n            if (m.contains(i)) m(i) += 1\n            else m += (i -> 1)\n\
    \        }\n        for (i <- lst.sortWith(_ > _)) if (i <= m(i)) return i\n \
    \       return -1", "        val count = Map[Long, Long]()\n        for (i <-\
    \ lst) {\n            if (count.contains(i)) count(i) += 1\n            else count(i)\
    \ = 1\n        }\n        val keys = ListBuffer[Long]()\n        for (i <- lst.distinct)\
    \ {\n            if (i <= count(i)) keys += i\n        }\n        if (keys.isEmpty)\
    \ -1\n        else keys.max", "        val c = lst.groupBy(identity).mapValues(_.size)\n\
    \        val k = c.keys.toList.sorted.reverse\n        k.find(k => k <= c(k)).getOrElse(-1L)",
  "        val count = Array.fill(lst.length + 1)(0L)\n        for (i <- lst) {\n\
    \            count(i.toInt) += 1\n        }\n        for (i <- (count.length -\
    \ 1) to 1 by -1) {\n            if (count(i) >= i) return i\n        }\n     \
    \   return -1", "        var max = -1L\n        var freq = 1L\n        val map\
    \ = new HashMap[Long, Long]()\n        for (e <- lst) {\n            map.put(e,\
    \ 1L + map.getOrElse(e, 0L))\n            if (e > max && e >= map(e)) {\n    \
    \            max = e\n                freq = map(e)\n            }\n        }\n\
    \        if (max >= freq) max else -1"]
stop_tokens:
- "\n    }\n"
