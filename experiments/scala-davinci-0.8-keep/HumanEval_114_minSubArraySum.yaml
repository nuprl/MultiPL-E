name: HumanEval_114_minSubArraySum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given an array of integers nums, find the minimum sum of any non-empty sub-array\n\
  \    // of nums.\n    // Example\n    // minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n\
  \    // minSubArraySum([-1, -2, -3]) == -6\n    def minSubArraySum(nums : List[Long])\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minSubArraySum((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));\n    assert(minSubArraySum((List[Long](-9999999999999999l.toLong)))\
  \ == (-9999999999999999l));\n    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong,\
  \ 20l.toLong, 1000000l.toLong))) == (0l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n   \
  \ assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong,\
  \ 3l.toLong, 4l.toLong))) == (3l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));\n  \
  \  assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));\n    assert(minSubArraySum((List[Long](7l.toLong)))\
  \ == (7l));\n    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));\n\
  \    }\n\n}\n"
completions: ["        var csum = 0L\n        var minsum = Long.MaxValue\n       \
    \ for (n <- nums) {\n            csum += n\n            minsum = min(minsum, csum)\n\
    \            csum = max(csum, 0)\n        }\n        return minsum", "       \
    \ var sum = 0L\n        val sums = new HashMap[Long, Int]()\n        sums += (0\
    \ -> -1)\n        var minSum = Long.MaxValue\n        for (i <- 0 until nums.length)\
    \ {\n            sum += nums(i)\n            val d = sum - minSum\n          \
    \  if (sums.contains(d)) minSum = sum - d\n            sums += (sum -> i)\n  \
    \      }\n        minSum", '        nums.sum', "        // Sort the array and\
    \ start tracking sub-arrays using two pointers.\n        val sorted = nums.sorted\n\
    \        var min = Long.MaxValue\n        var start = 0\n        var end = 0\n\
    \        while (end < sorted.length) {\n            if (end < start) end = start\n\
    \            val sum = sorted.slice(start, end + 1).sum\n            if (sum <\
    \ min) min = sum\n            if (start < end) start += 1\n            else end\
    \ += 1\n        }\n        min", "      var x = nums.head\n      var y = nums.tail.head\n\
    \      var min_so_far = min(x, y)\n      var min_ending_here = 0L\n      for (num\
    \ <- nums.tail.tail) {\n        min_ending_here = min(num, min_ending_here + num)\n\
    \        min_so_far = min(min_so_far, min_ending_here)\n      }\n      min_so_far",
  "        if (nums.length == 0) return 0\n        var min = nums(0)\n        var\
    \ sum = nums(0)\n        for (i <- 1 until nums.length) {\n            sum = min(sum\
    \ + nums(i), nums(i))\n            min = min(min, sum)\n        }\n        min",
  "        val list = mutable.Buffer[Long]()\n        list.append(nums(0))\n     \
    \   for (i <- 1 until nums.length) {\n            list.append(list(i - 1) + nums(i))\n\
    \        }\n        if (list.min > 0) {\n            return 0\n        }\n   \
    \     var min = Long.MaxValue\n        for (i <- list.indices) {\n           \
    \ for (j <- i until list.length) {\n                val diff = list(j) - list(i)\
    \ + nums(i)\n                if (diff < min) {\n                    min = diff\n\
    \                }\n            }\n        }\n        min", "      if (nums.isEmpty)\
    \ 0\n      else {\n        var res = nums.head\n        var cur = 0L\n       \
    \ for (e <- nums) {\n          cur += e\n          res = res min cur\n       \
    \   if (cur > 0) cur = 0\n        }\n        res\n      }", "        // https://leetcode.com/problems/minimum-size-subarray-sum/discuss/59093/Two-AC-solutions-in-Java-with-time-complexity-of-N-and-NLogN-with-explanation\n\
    \        val numsLen = nums.length\n        // val sums = new Array[Long](numsLen\
    \ + 1)\n        // sums(0) = 0\n        // for (i <- 1 to numsLen) sums(i) = sums(i\
    \ - 1) + nums(i - 1)\n        // var min = Long.MaxValue\n        // for (i <-\
    \ 0 to numsLen) {\n        //     for (j <- i + 1 to numsLen) {\n        //  \
    \       val sum = sums(j) - sums(i)\n        //         if (sum < min) min = sum\n\
    \        //     }\n        // }\n        // return min\n        // Time complexity:\
    \ O(n^2)\n        // Space complexity: O(n)\n        // val sums = new Array[Long](numsLen\
    \ + 1)\n        // sums(0) = 0\n        // for (i <- 1 to numsLen) sums(i) = sums(i\
    \ - 1) + nums(i - 1)\n        // var min = Long.MaxValue\n        // for (i <-\
    \ 0 to numsLen) {\n        //     var j = i + 1\n        //     while (j <= numsLen\
    \ && sums(j) - sums(i) < min) {\n        //         min = sums(j) - sums(i)\n\
    \        //         j += 1\n        //     }\n        // }\n        // return\
    \ min\n        // Time complexity: O(n^2)\n        // Space complexity: O(n)\n\
    \        // val sums = new Array[Long](numsLen + 1)\n        // sums(0) = 0\n\
    \        // for (i <- 1 to numsLen) sums(i) = sums(i - 1) + nums(i - 1)\n    \
    \    // var min = Long.MaxValue\n        // var i = 0\n        // while (i < numsLen)\
    \ {\n        //     var j = i + 1\n       ", "        var sum = 0L\n        var\
    \ minSum = nums.head\n        for (i <- nums) {\n            sum += i\n      \
    \      if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n    \
    \    }\n        minSum", "        var minSum = Long.MaxValue\n        var result\
    \ = nums.foldLeft(0L)((sum, x) => {\n            minSum = min(minSum, sum)\n \
    \           sum + x\n        })\n        min(minSum, result)", "        // After\
    \ the given array is summed, the remaining array can be used again.\n        val\
    \ sums = for (i <- nums.indices) yield nums.slice(i, nums.length).sum\n      \
    \  sums.min", "        val minSum = Array.fill(nums.length)(0l)\n        minSum(0)\
    \ = nums(0)\n        for (i <- 1 until nums.length) minSum(i) = min(minSum(i -\
    \ 1) + nums(i), nums(i))\n        minSum.min", "        var result = 1L << 60\n\
    \        var sum = 0L\n        for (n <- nums) {\n            sum += n\n     \
    \       result = min(result, sum)\n            if (sum < 0) sum = 0\n        }\n\
    \        result", "        var res = Int.MaxValue.toLong\n        var a : Long\
    \ = 0\n        for (i <- 0 until nums.length) {\n            var sum = 0L\n  \
    \          for (j <- i until nums.length) {\n                sum += nums(j)\n\
    \                res = min(res, sum)\n            }\n        }\n        res",
  "        if (nums.isEmpty) return 0\n        var current = nums.head\n        var\
    \ min = Long.MaxValue\n        for (num <- nums.tail) {\n            current =\
    \ min(current + num, num)\n            min = min(min, current)\n        }\n  \
    \      min", "        // dp[i] := the minimum sum of any sub-array ending at index\
    \ i\n        val dp = Array.fill(nums.length)(0L)\n        var min = Long.MaxValue\n\
    \        for (i <- 0 until nums.length) {\n            if (i == 0) dp(i) = nums(i)\n\
    \            else {\n                dp(i) = min(dp(i - 1) + nums(i), nums(i))\n\
    \            }\n            min = min(min, dp(i))\n        }\n        min", " \
    \       val preSum = Array.fill(nums.length + 1)(0L)\n        for (i <- 0 until\
    \ nums.length) preSum(i + 1) = preSum(i) + nums(i)\n        val min = new BinaryIndexedTree(nums.length\
    \ + 1)\n        min.update(0, preSum(0))\n        for (i <- 1 to nums.length)\
    \ {\n            min.update(i, preSum(i) - min.rangeQuery(i))\n        }\n   \
    \     return min.rangeQuery(nums.length)", "        val total = nums.sum\n   \
    \     val n = nums.length\n        // the minimum subarray ending at i\n     \
    \   val f = new Array[Long](n + 1)\n        for (i <- n to 1 by -1) {\n      \
    \      f(i) = f(i + 1) + nums(i - 1)\n            if (f(i) > nums(i - 1)) f(i)\
    \ = nums(i - 1)\n        }\n        var result = total\n        for (i <- 0 until\
    \ n) {\n            if (f(i + 1) < 0) result = result - f(i + 1)\n        }\n\
    \        result", "        // since there is no sub-array whose sum is negative\
    \ so the minimum must be negative\n        // or zero\n        // keep track of\
    \ the minimum sub-array sum\n        // at any given index, the minimum is either\
    \ 0 or the minimum sub-array sum from\n        // the previous index plus the\
    \ next element\n        var min = 0L\n        var total = 0L\n        for (num\
    \ <- nums) {\n            total += num\n            if (total < min) min = total\n\
    \            if (total > 0) total = 0\n        }\n        min"]
stop_tokens:
- "\n    }\n"
