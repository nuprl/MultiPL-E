name: HumanEval_127_intersection
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given two intervals,\n    // where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n    // The given intervals are\
  \ closed which means that the interval (start, end)\n    // includes both start\
  \ and end.\n    // For each given interval, it is assumed that its start is less\
  \ or equal its end.\n    // Your task is to determine whether the length of intersection\
  \ of these two \n    // intervals is a prime number.\n    // Example, the intersection\
  \ of the intervals (1, 3), (2, 4) is (2, 3)\n    // which its length is 1, which\
  \ not a prime number.\n    // If the length of the intersection is a prime number,\
  \ return \"YES\",\n    // otherwise, return \"NO\".\n    // If the two intervals\
  \ don't intersect, return \"NO\".\n    // [input/output] samples:\n    // intersection((1,\
  \ 2), (2, 3)) ==> \"NO\"\n    // intersection((-1, 1), (0, 4)) ==> \"NO\"\n    //\
  \ intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    def intersection(interval1 :\
  \ Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
  \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
  \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
  YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
  \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
  \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
  \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
  NO\")));\n    }\n\n}\n"
completions: ["        val start = max(interval1._1, interval2._1)\n        val end\
    \ = min(interval1._2, interval2._2)\n        val length = end - start + 1\n  \
    \      if (length < 1) \"NO\"\n        else {\n            val isPrime = (length\
    \ == 2) || (length % 2 != 0 && !((3L to sqrt(length).toLong by 2).exists(length\
    \ % _ == 0)))\n            if (isPrime) \"YES\" else \"NO\"\n        }", "   \
    \     // Given the above, the intersection will always be a subset of a set of\
    \ consecutive integers.\n        // let the intervals be (a, b) and (c, d)\n \
    \       // then the intersection is [max(a, c), min(b, d)]\n        // thus the\
    \ length is min(b, d) - max(a, c) + 1\n        val a = interval1._1\n        val\
    \ b = interval1._2\n        val c = interval2._1\n        val d = interval2._2\n\
    \        if (a > b || c > d) {\n            return \"NO\"\n        }\n       \
    \ val length = (min(b, d) - max(a, c) + 1).toInt\n        if (length < 0) {\n\
    \            return \"NO\"\n        }\n        // use the Identity of Sum of Squares\n\
    \        // x^2 is prime iff x is prime\n        // the sum of squares of two\
    \ prime numbers is not prime\n        // the sum of squares of two non-prime numbers\
    \ can be prime\n        // thus the length of intersection is prime iff length\
    \ is prime\n        // and for a given prime length,\n        // there are two\
    \ pairs of primes whose sum of squares is length\n        // we only need to check\
    \ if length is prime\n        if (length == 1) {\n            return \"NO\"\n\
    \        }\n        // then check if length is prime\n        val sqrtLen = sqrt(length).toInt\n\
    \        if (length == sqrtLen * sqrtLen) {\n            return \"NO\"\n     \
    \   }\n        if (length % 2 == 0) {\n            return \"NO\"\n        }\n\
    \        var i = 3\n        while (i <= sqrtLen) {\n            if (length % i\
    \ == 0) {\n                return \"NO\"\n            }\n            i += 2\n\
    \        }\n        \"YES\"", "        var result = \"NO\"\n        var i1 = interval1._1.toInt\n\
    \        var i2 = interval1._2.toInt\n        var j1 = interval2._1.toInt\n  \
    \      var j2 = interval2._2.toInt\n        if (i1 > i2) {\n            val tmp\
    \ = i1\n            i1 = i2\n            i2 = tmp\n        }\n        if (j1 >\
    \ j2) {\n            val tmp = j1\n            j1 = j2\n            j2 = tmp\n\
    \        }\n        if (i1 > j2 || j1 > i2) {\n            result = \"NO\"\n \
    \       } else {\n            var count = 0\n            for (i <- i1 to i2; j\
    \ <- j1 to j2; if (i >= j)) {\n                count += 1\n            }\n   \
    \         if (Prime.isPrime(count)) {\n                result = \"YES\"\n    \
    \        }\n        }\n        result", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) {\n            \"NO\"\n        } else {\n  \
    \          val (low, high) = (max(interval1._1, interval2._1), min(interval1._2,\
    \ interval2._2))\n            val a = low - 1\n            val b = high - low\
    \ + 1\n            val c = high\n            if (a * c == b * b) \"YES\" else\
    \ \"NO\"\n        }", "        val v1 = interval1._1\n        val v2 = interval1._2\n\
    \        val v3 = interval2._1\n        val v4 = interval2._2\n        if(v1 >\
    \ v2 || v3 > v4) throw new Exception(\"illegal interval\")\n        val left =\
    \ max(v1, v3)\n        val right = min(v2, v4)\n        if(left > right) \"NO\"\
    \n        else {\n            val len = right - left + 1\n            if(len <\
    \ 2) \"NO\"\n            else if(len == 2) \"YES\"\n            else {\n     \
    \           val v = len\n                var i = 2L\n                while(i *\
    \ i <= v) {\n                    if(v % i == 0) return \"NO\"\n              \
    \      i += 1\n                }\n                \"YES\"\n            }\n   \
    \     }", "        var start = max(interval1._1, interval2._1)\n        var end\
    \ = min(interval1._2, interval2._2)\n        if (start <= end) {\n           \
    \ if (isPrime(end - start + 1)) return \"YES\"\n            else return \"NO\"\
    \n        }\n        return \"NO\"", "        val (s1, e1) = interval1\n     \
    \   val (s2, e2) = interval2\n        var l = 0L\n        if (s1 > s2) {\n   \
    \         if (e1 > e2) {\n                if (s1 > e2) return \"NO\"\n       \
    \         l = e2 - s1 + 1\n            } else {\n                if (s1 > e1)\
    \ return \"NO\"\n                l = e1 - s1 + 1\n            }\n        } else\
    \ {\n            if (e1 > e2) {\n                if (s2 > e2) return \"NO\"\n\
    \                l = e2 - s2 + 1\n            } else {\n                if (s2\
    \ > e1) return \"NO\"\n                l = e1 - s2 + 1\n            }\n      \
    \  }\n        if (l == 1) return \"NO\"\n        else {\n            for (i <-\
    \ 2L to sqrt(l).toLong) if (l % i == 0) return \"NO\"\n            return \"YES\"\
    \n        }", "        val start = max(interval1._1, interval2._1)\n        val\
    \ end = min(interval1._2, interval2._2)\n        val range = end - start + 1\n\
    \        if (range < 0) \"NO\"\n        else if (isPrime(range)) \"YES\"\n   \
    \     else \"NO\"", "        val (lower, upper) = if (interval1._1 > interval2._1)\
    \ (interval1, interval2) else (interval2, interval1)\n        if (lower._2 < upper._1)\
    \ return \"NO\"\n        val intersectionLength = lower._2 - upper._1 + 1\n  \
    \      (1L to sqrt(intersectionLength).toLong).forall(intersectionLength % _ !=\
    \ 0) match {\n            case true => \"YES\"\n            case false => \"NO\"\
    \n        }", "        val (start1, end1) = interval1\n        val (start2, end2)\
    \ = interval2\n        val (x1, x2) = if (start1 < start2) (start1, start2) else\
    \ (start2, start1)\n        val (y1, y2) = if (end1 < end2) (end1, end2) else\
    \ (end2, end1)\n        val interval = (max(x1, y1), min(x2, y2))\n        if\
    \ (interval._1 > interval._2) \"NO\"\n        else if (isPrime(interval._2 - interval._1\
    \ + 1)) \"YES\"\n        else \"NO\"", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val intervalStart = interval1._1\
    \ max interval2._1\n        val intervalEnd = interval1._2 min interval2._2\n\
    \        val intervalLength = intervalEnd - intervalStart + 1\n        if (isPrime(intervalLength))\
    \ return \"YES\"\n        \"NO\"", "        if (interval1._1 < interval2._1)\n\
    \            return intersection(interval2, interval1)\n        if (interval1._1\
    \ > interval2._2)\n            return \"NO\"\n        val length = interval1._1\
    \ - interval2._2\n        if (length == 1)\n            return \"YES\"\n     \
    \   else if (length == 0)\n            return \"NO\"\n        else {\n       \
    \     for (i <- 2 until length.toInt) {\n                if (length % i == 0)\n\
    \                    return \"NO\"\n            }\n            return \"YES\"\n\
    \        }", "        val (start1, end1) = interval1\n        val (start2, end2)\
    \ = interval2\n        if (end1 < start2 || end2 < start1) return \"NO\"\n   \
    \     val start = max(start1, start2)\n        val end = min(end1, end2)\n   \
    \     if (isPrime(end - start + 1)) \"YES\" else \"NO\"", "        val (start1,\
    \ end1) = interval1\n        val (start2, end2) = interval2\n        if (end1\
    \ < start2 || end2 < start1) return \"NO\"\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        val length = end - start + 1\n   \
    \     if (length == 1) return \"NO\"\n        val sqrt = math.sqrt(length).toLong\n\
    \        for (i <- 2L to sqrt) {\n            if (length % i == 0) return \"NO\"\
    \n        }\n        \"YES\"", "        val a = interval1._1\n        val b =\
    \ interval1._2\n        val c = interval2._1\n        val d = interval2._2\n \
    \       if(b < c || d < a) return \"NO\"\n        val intersection = if(b > d)\
    \ d - max(a, c) + 1 else b - max(a, c) + 1\n        if(intersection < 2) return\
    \ \"NO\"\n        return if(intersection == 2) \"YES\" else if(isPrime(intersection))\
    \ \"YES\" else \"NO\"", "        val l = interval1._1 max interval2._1\n     \
    \   val r = interval1._2 min interval2._2\n        if (l <= r) {\n           \
    \ if (isPrime(r - l + 1)) \"YES\" else \"NO\"\n        } else \"NO\"", "     \
    \   if (interval1._1 > interval2._2 || interval2._1 > interval1._2) return \"\
    NO\"\n        val a = if (interval1._1 < interval2._1) interval2._1 else interval1._1\n\
    \        val b = if (interval1._2 < interval2._2) interval1._2 else interval2._2\n\
    \        val range = Range(a.toInt, b.toInt + 1)\n        val length = range.length\n\
    \        range.takeWhile(p => p * p <= length).forall(p => length % p != 0) match\
    \ {\n            case true => \"YES\"\n            case false => \"NO\"\n    \
    \    }", "        val start = max(interval1._1, interval2._1)\n        val end\
    \ = min(interval1._2, interval2._2)\n        if (start > end) \"NO\"\n       \
    \ else if (end - start == 0) \"YES\"\n        else if (end - start == 1) \"NO\"\
    \n        else if (end - start == 2) \"YES\"\n        else if (end - start ==\
    \ 3) \"NO\"\n        else \"YES\"", "    \tval (start1, end1) = interval1\n  \
    \  \tval (start2, end2) = interval2\n    \tval min1 = min(start1, end1)\n    \t\
    val max1 = max(start1, end1)\n    \tval min2 = min(start2, end2)\n    \tval max2\
    \ = max(start2, end2)\n    \tval maxStart = max(min1, min2)\n    \tval minEnd\
    \ = min(max1, max2)\n    \tval interval = (maxStart, minEnd)\n    \tif (maxStart\
    \ > minEnd) return \"NO\"\n    \tval (start, end) = interval\n    \tval mid =\
    \ (start + end) / 2\n    \tval n = mid - start + 1\n    \tif (isPrime(n)) return\
    \ \"YES\"\n    \telse return \"NO\"", "        val ((x1, y1), (x2, y2)) = (interval1,\
    \ interval2)\n        if (y1 < x2 || y2 < x1) return \"NO\"\n        val i = List(x1,\
    \ y1, x2, y2).sorted.slice(1, 3)\n        if (i(0) == i(1)) return \"YES\"\n \
    \       if (isPrime(i(1) - i(0))) return \"YES\"\n        \"NO\""]
stop_tokens:
- "\n    }\n"
