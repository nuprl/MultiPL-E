name: HumanEval_87_get_row
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a 2 dimensional data, as a nested lists,\n    // which is\
  \ similar to matrix, however, unlike matrices,\n    // each row may contain a different\
  \ number of columns.\n    // Given lst, and integer x, find integers x in the list,\n\
  \    // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each\
  \ tuple is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
  \ initially by rows in ascending order.\n    // Also, sort coordinates of the row\
  \ by columns in descending order.\n    // Examples:\n    // get_row([\n    // [1,2,3,4,5,6],\n\
  \    // [1,2,3,4,1,6],\n    // [1,2,3,4,5,1]\n    // ], 1) == [(0, 0), (1, 4), (1,\
  \ 0), (2, 5), (2, 0)]\n    // get_row([], 1) == []\n    // get_row([[], [1], [1,\
  \ 2, 3]], 3) == [(2, 2)]\n    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long,\
  \ Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l,\
  \ 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
  \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
  \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
  \ Long]]((2l, 2l)))));\n    }\n\n}\n"
completions: ['        ???', "    \tlst.map(e => e.zipWithIndex.map(p => (e.indexOf(x),\
    \ p._2))).flatten.filter(p => p._1 != -1).sortWith((p1, p2) => (p1._1 < p2._1)\
    \ || (p1._1 == p2._1 && p1._2 > p2._2))", "        var row = 0\n        var col\
    \ = 0\n        var result = new ListBuffer[Tuple2[Long, Long]]()\n        for\
    \ (row <- 0 until lst.length) {\n            for (col <- 0 until lst(row).length)\
    \ {\n                if (lst(row)(col) == x) result += ((row, col))\n        \
    \    }\n        }\n        result.toList.sortWith(_._1 < _._1).sortWith(_._2 >\
    \ _._2)", "        var xs = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            val ls = lst(i)\n            for (j <- 0 until ls.length)\
    \ {\n                if (ls(j) == x) xs = (i, j) :: xs\n            }\n      \
    \  }\n        return xs.sortWith((a, b) => if (a._1 != b._1) {\n            a._1\
    \ < b._1\n        } else {\n            a._2 > b._2\n        })", "        //\
    \ Iterate through all rows, and\n        // generate list of tuples,\n       \
    \ // where first element is row,\n        // and second element is column,\n \
    \       // where x is found in the row.\n        var result = new ListBuffer[Tuple2[Long,\
    \ Long]]()\n        lst.foreach(row => {\n            // Iterate through row,\
    \ and\n            // find index of x in this row.\n            val indx = row.indexOf(x)\n\
    \            if (indx != -1) {\n                // Add tuple (row, column) to\
    \ result.\n                result += Tuple2(lst.indexOf(row), indx)\n        \
    \    }\n        })\n        // Sort the list by rows in ascending order.\n   \
    \     val sorted = result.sortWith((t1, t2) => {\n            t1._1 < t2._1\n\
    \        })\n        // Sort by columns in descending order.\n        val sorted2\
    \ = sorted.sortWith((t1, t2) => {\n            if (t1._1 == t2._1) {\n       \
    \         t1._2 > t2._2\n            } else {\n                t1._1 < t2._1\n\
    \            }\n        })\n        sorted2.toList", "    \t// Fill up this function\
    \ body\n        // You have to return a list of Tuple2[Long, Long] (i.e List[(Long,\
    \ Long)])\n        // Example: List((0, 0), (1, 0))\n    \tlst.zipWithIndex.flatMap(x\
    \ => x._1.zipWithIndex.filter(y => y._1 == x._2).map(y => (x._2, y._2))).sortBy(x\
    \ => x._1).sortBy(x => -x._2)", "      var a = List[Tuple2[Long, Long]]()\n  \
    \    for (i <- 0 until lst.length) {\n        for (j <- 0 until lst(i).length)\
    \ {\n          if (lst(i)(j) == x) a = (i, j) :: a\n        }\n      }\n     \
    \ a.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))", "     \
    \   // Extract all elements that equals x.\n        val array = for (i <- 0 until\
    \ lst.length; j <- 0 until lst(i).length if lst(i)(j) == x) yield (i, j)\n   \
    \     // Sort by rows in ascending order and then by columns in descending order.\n\
    \        array.toList.sortWith((x, y) => {\n            if (x._1 == y._1) x._2\
    \ > y._2\n            else x._1 < y._1\n        })", "      var result = List[Tuple2[Long,\
    \ Long]]()\n      for (i <- 0 until lst.length) {\n        val lst2 = lst(i)\n\
    \        for (j <- 0 until lst2.length) {\n          if (lst2(j) == x) {\n   \
    \         result = (i, j) :: result\n          }\n        }\n      }\n      result.sortWith((a,\
    \ b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i, j)\n                }\n   \
    \         }\n        }\n        result.sortWith((x, y) => x._1 < y._1 || (x._1\
    \ == y._1 && x._2 > y._2))", "        val indexes = for(\n            (row, rowIndex)\
    \ <- lst.zipWithIndex;\n            (col, colIndex) <- row.zipWithIndex;\n   \
    \         if col == x) yield (rowIndex, colIndex)\n        val sortedIndexes =\
    \ indexes.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n \
    \       sortedIndexes", "        var ans = List[Tuple2[Long, Long]]()\n      \
    \  for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) ans ::= (i, j)\n            }\n     \
    \   }\n        ans.sortWith((a, b) => a._1 > b._1 || (a._1 == b._1 && a._2 < b._2))",
  "        // Fill up this function body\n        // You may add another function\
    \ as well, if required\n        var output = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            val row = lst(i)\n         \
    \   for (j <- 0 until row.length) {\n                if (row(j) == x) {\n    \
    \                output = output :+ (i, j)\n                }\n            }\n\
    \        }\n        output.sortBy(p => (p._1, -p._2))", "        def remove(tpl\
    \ : Tuple2[Long, Long], lst : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            if (lst.isEmpty) return List()\n            if (lst.head ==\
    \ tpl) return lst.tail\n            lst.head :: remove(tpl, lst.tail)\n      \
    \  }\n        def get(lst : List[List[Long]], x : Long, row : Long, col : Long,\
    \ acc : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]] = {\n           \
    \ if (lst.isEmpty) return acc\n            val pos = lst.head.indexOf(x)\n   \
    \         if (pos != -1) {\n                val newacc = (row, pos.toLong) ::\
    \ acc\n                return get(lst.tail, x, row + 1, pos.toLong, newacc)\n\
    \            }\n            get(lst.tail, x, row + 1, col, acc)\n        }\n \
    \       val res = get(lst, x, 0, 0, List())\n        return res.sortWith((tpl1,\
    \ tpl2) => (tpl1._1 < tpl2._1) || (tpl1._1 == tpl2._1 && tpl1._2 > tpl2._2))",
  '        lst.zipWithIndex.map(x => x._1.zipWithIndex.filter(y => y._1 == x._2)).flatten.map(x
    => Tuple2(x._2, x._1)).sortWith((x, y) => if (x._1 == y._1) x._2 > y._2 else x._1
    < y._1)', "        // Fill up this function body\n        // You can add another\
    \ function as well, if required\n        var ret = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    ret = ret :+ (i,\
    \ j)\n                }\n            }\n        }\n        ret.sortWith((a, b)\
    \ => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n       \
    \     } else {\n                a._1 < b._1\n            }\n        })", "   \
    \     // if list empty, return empty list\n        if (lst.isEmpty) return List[Tuple2[Long,\
    \ Long]]()\n        // if nested list empty, return empty list\n        if (lst.head.isEmpty)\
    \ return List[Tuple2[Long, Long]]()\n        // create a new list of tuples that\
    \ contains the coordinates of x\n        var lst2 = for (i <- 0 until lst.length;\
    \ j <- 0 until lst(i).length; if (lst(i)(j) == x)) yield (i, j)\n        // sort\
    \ the coordinates\n        lst2 = lst2.sortWith((x, y) => x._1 > y._1 || (x._1\
    \ == y._1 && x._2 < y._2))\n        // return list of sorted coordinates\n   \
    \     lst2.toList", "        var res = List[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) res = res :+ (i, j)\n            }\n    \
    \    }\n        res.sortWith((t1, t2) => t1._1 < t2._1 || (t1._1 == t2._1 && t1._2\
    \ > t2._2))", "        lst.zipWithIndex.flatMap(p => p._1.zipWithIndex.map(q =>\
    \ (p._2, q._2))).filter(p => lst(p._1.toInt)(p._2.toInt) == x).sortWith((p, q)\
    \ => {\n            if (p._1 < q._1) true\n            else if (p._1 > q._1) false\n\
    \            else p._2 > q._2\n        })", "      return (for {\n        i <-\
    \ 0 until lst.length\n        j <- 0 until lst(i).length\n        if (lst(i)(j)\
    \ == x)\n      } yield (i, j)).toList.sortWith(_._1 < _._1).sortWith(_._2 > _._2)"]
stop_tokens:
- "\n    }\n"
