name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode('test')\n\
  \    // 'TGST'\n    // >>> encode('This is a message')\n    // 'tHKS KS C MGSSCGG'\n\
  \    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        val vowels = \"aeiou\"\n        val alpha = ('a' to 'z').toArray\n\
    \        val dict = vowels.zip(alpha.drop(2) ++ alpha.take(2)).toMap\n       \
    \ message.map(ch => if (ch.isUpper) ch.toLower else ch.toUpper).map(ch => if (dict.contains(ch))\
    \ dict(ch) else ch).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val map = (alphabet zip alphabet.drop(2)\
    \ :+ alphabet.head).toMap\n        return message.map(c => \n            if (vowels.contains(c.toLower))\
    \ map(c.toLower)\n            else c.toLower match {\n                case 'z'\
    \ => 'a'\n                case 'y' => 'z'\n                case x => (x.toInt\
    \ + 2).toChar\n            })", "        // TODO\n        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val vowels2 = List('c', 'f', 'j', 'n', 'r')\n \
    \       message.map(ch => {\n            if(vowels.contains(ch)) vowels2(vowels.indexOf(ch))\n\
    \            else if(vowels2.contains(ch)) vowels(vowels2.indexOf(ch))\n     \
    \       else if(ch.isUpper) ch.toLower\n            else ch.toUpper\n        })",
  "        // 1. swap case\n        // 2. if vowel, shift it forward two places\n\
    \        var result = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ result += c.toLower else result += c.toUpper\n            c match {\n      \
    \          case 'a' => result += 'c'\n                case 'e' => result += 'g'\n\
    \                case 'i' => result += 'k'\n                case 'o' => result\
    \ += 'q'\n                case 'u' => result += 'y'\n                case _ =>\
    \ result += c\n            }\n        }\n        result", '        null', "  \
    \      val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val shiftMap = new HashMap[Char,\
    \ Char]()\n        for (i <- 1 to 26) {\n            val shifted = (i + 2) % 26\n\
    \            shiftMap += ('a' + i - 1 -> ('a' + shifted - 1))\n        }\n   \
    \     val encoded = new StringBuilder()\n        for (c <- message) {\n      \
    \      if (vowels.contains(c.toLower)) encoded += shiftMap(c.toLower)\n      \
    \      else if (c.isUpper) encoded += c.toLower\n            else encoded += c.toUpper\n\
    \        }\n        encoded.toString", "        if (message.length == 0) return\
    \ \"\"\n        var encoded = \"\"\n        for (i <- 0 until message.length)\
    \ {\n            val letter = message(i)\n            if (letter.isUpper) {\n\
    \                encoded += letter.toLower\n            } else if (letter.isLower)\
    \ {\n                encoded += letter.toUpper\n            } else {\n       \
    \         encoded += letter\n            }\n        }\n        encoded", "   \
    \     var vowels = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' ->\
    \ 'y')\n        message.map(ch => if (vowels.contains(ch)) vowels(ch) else ch).map(ch\
    \ => if (ch.isUpper) ch.toLower else ch.toUpper)", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        def encodeChar(ch : Char) : Char = {\n        \
    \    if ('a' <= ch && ch <= 'z') {\n                if (vowels contains ch) {\n\
    \                    val idx = (ch - 'a' + 2) % 26\n                    ('a' +\
    \ idx).toChar\n                } else {\n                    ch.toUpper\n    \
    \            }\n            } else if ('A' <= ch && ch <= 'Z') {\n           \
    \     if (vowels contains ch.toLower) {\n                    val idx = (ch - 'A'\
    \ + 2) % 26\n                    ('A' + idx).toChar\n                } else {\n\
    \                    ch.toLower\n                }\n            } else {\n   \
    \             ch\n            }\n        }\n        (for (ch <- message) yield\
    \ encodeChar(ch)).mkString", "        val vowels = \"aeiouAEIOU\"\n        val\
    \ shiftBy = 2\n        val alphabet = ('a' to 'z').toList\n        def shift(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ startIndex = alphabet.indexOf(c.toLower)\n                val shiftedIndex =\
    \ (startIndex + shiftBy) % alphabet.length\n                alphabet(shiftedIndex)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isLetter) c.toLower.toString match {\n            case c if c.toLower\
    \ == c => c.toUpper\n            case c => c\n        } else c).map(shift).mkString",
  "        var result = \"\"\n        val vowels = \"aeiouAEIOU\"\n        var alphabet\
    \ = 'a' to 'z'\n        val dict = Map[Char, Char]()\n        alphabet.zipWithIndex.foreach\
    \ { case (char, index) => \n            if (vowels.contains(char)) {\n       \
    \         dict += char -> alphabet(if (index + 2 > 25) (index + 2) % 26 else index\
    \ + 2)\n            }\n        }\n        for (char <- message) {\n          \
    \  if (dict.contains(char)) {\n                result += dict(char)\n        \
    \    } else {\n                result += char\n            }\n        }\n    \
    \    result", "    \tval vowels = List('a', 'e', 'i', 'o', 'u')\n    \tvar s =\
    \ \"\"\n    \tfor (c <- message) {\n    \t\tif (vowels.contains(c.toLower)) {\n\
    \    \t\t\tval pos = vowels.indexOf(c.toLower)\n    \t\t\tif (pos == vowels.length\
    \ - 1) {\n    \t\t\t\ts += vowels(0).toUpper\n    \t\t\t} else {\n    \t\t\t\t\
    s += vowels(pos + 2).toUpper\n    \t\t\t}\n    \t\t} else {\n    \t\t\ts += c.toUpper\n\
    \    \t\t}\n    \t}\n    \ts", "        // Implements a bijective function from\
    \ A-Z to C-Z,A,B.\n        // Recall that the ASCII number for 'A' is 65 and for\
    \ 'a' is 97.\n        def encodeLetter(c : Char) : Char = {\n            def shift(x\
    \ : Int) : Int = {\n                val n = x + 2\n                if (n <= 90)\
    \ n else n - 26\n            }\n            if (c.isUpper) shift(c.toInt).toChar\
    \ else c.toUpper.toInt.toChar\n        }\n        def encodeVowel(c : Char) :\
    \ Char = {\n            val pos = (encodeLetter(c) - 65 + 2) % 26\n          \
    \  if (c.isUpper) pos.toChar else (pos + 65).toChar\n        }\n        message.map(c\
    \ => if (c.isLetter) {\n            if (\"AEIOU\".contains(c.toUpper)) encodeVowel(c)\
    \ else encodeLetter(c)\n        } else c)", "        def encodeChar(c : Char)\
    \ : Char = {\n            val vowelNext = \"aeiou\".toList\n            val vowelNextNext\
    \ = \"cdfghjklmnpqrstvwxyz\".toList\n            if (vowelNext.contains(c.toLower))\
    \ \n                vowelNextNext((vowelNext.indexOf(c.toLower) + 2) % vowelNextNext.length)\n\
    \            else if (vowelNextNext.contains(c.toLower)) \n                vowelNext((vowelNextNext.indexOf(c.toLower)\
    \ + 2) % vowelNext.length)\n            else if (c.isUpper) c.toLower\n      \
    \      else c.toUpper\n        }\n        message.map(encodeChar)", "        var\
    \ u = encodeOne('A') _\n        val m = message.map(u)\n        m", '        ""',
  "        val vowels = \"aeiou\"\n        var encodedMessage = \"\"\n        for\
    \ (i <- 0 until message.length) {\n            val c = message(i)\n          \
    \  val nc = if (c.isLower) c.toUpper else c.toLower\n            encodedMessage\
    \ += if (vowels.contains(nc)) \n                (nc.toInt + 2).toChar else nc\n\
    \        }\n        encodedMessage", "        val encodeMap = Map[Char, Char](\n\
    \            'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',\n   \
    \         'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W')\n      \
    \  return message.toSeq.map(c => encodeMap.getOrElse(c, c)).mkString", "     \
    \   def encodeHelper(message : List[Char], vowelMapping : HashMap[Char, Char])\
    \ : String = {\n            message match {\n                case x :: xs => {\n\
    \                    if (vowelMapping.contains(x)) {\n                       \
    \ vowelMapping(x).toString() + encodeHelper(xs, vowelMapping)\n              \
    \      } else {\n                        x.toString() + encodeHelper(xs, vowelMapping)\n\
    \                    }\n                }\n                case Nil => \"\"\n\
    \            }\n        }\n        val vowelMapping = new HashMap[Char, Char]()\n\
    \        var currentVowel = 'A'\n        while (currentVowel != 'U') {\n     \
    \       vowelMapping += currentVowel -> ((currentVowel + 2).toChar)\n        \
    \    currentVowel = (currentVowel + 1).toChar\n        }\n        encodeHelper(message.toList,\
    \ vowelMapping)", "        // TODO\n        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        var str = \"\"\n        for (c <- message) {\n            if (vowels\
    \ contains c.toLower) {\n                if (c.isUpper) {\n                  \
    \  val idx = c.toLower - 'a'\n                    val offset = (idx + 2) % 26\n\
    \                    str += ('A' + offset).toChar\n                } else {\n\
    \                    val idx = c - 'a'\n                    val offset = (idx\
    \ + 2) % 26\n                    str += ('a' + offset).toChar\n              \
    \  }\n            } else {\n                if (c.isUpper) str += c.toLower\n\
    \                else str += c.toUpper\n            }\n        }\n        str"]
stop_tokens:
- "\n    }\n"
