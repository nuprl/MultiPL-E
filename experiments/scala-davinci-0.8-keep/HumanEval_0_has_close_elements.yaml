name: HumanEval_0_has_close_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Check if in given list of numbers, are any two numbers closer to each other\
  \ than\n    // given threshold.\n    // >>> has_close_elements([1.0, 2.0, 3.0],\
  \ 0.5)\n    // False\n    // >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
  \ 0.3)\n    // True\n    def hasCloseElements(numbers : List[Float], threshold :\
  \ Float) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f))\
  \ == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));\n\
  \    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat,\
  \ 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));\n\
  \    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
  \ 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat,\
  \ 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));\n\
  \    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));\n    }\n\n}\n"
completions: ["        val sorted = numbers.sorted\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            if (abs(sorted(i) - sorted(i + 1)) < threshold) return true\n\
    \        }\n        return false", "        for (i <- 0 until numbers.length -\
    \ 1) for (j <- i + 1 until numbers.length) {\n            if (abs(numbers(i) -\
    \ numbers(j)) < threshold) return true\n        }\n        return false", "  \
    \      val sortedNumbers = numbers.sorted\n        for (i <- 0 until sortedNumbers.length\
    \ - 1) {\n            if (abs(sortedNumbers(i) - sortedNumbers(i + 1)) < threshold)\
    \ return true\n        }\n        return false", "        // TODO solve it in\
    \ O(n log n)\n        var result = false\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  if (abs(numbers(i) - numbers(j)) < threshold) {\n                    result\
    \ = true\n                }\n            }\n        }\n        result", "    \
    \    if (numbers.length <= 1) return false\n        var i = 0\n        var j =\
    \ 1\n        while (i < numbers.length) {\n            var d = numbers(i) - numbers(j)\n\
    \            if (d < 0) d = -d\n            if (d < threshold) return true\n \
    \           j += 1\n            if (j == numbers.length) {\n                i\
    \ += 1\n                j = i + 1\n            }\n        }\n        return false",
  "      // For every element i in numbers\n      //   For every element j in numbers\n\
    \      //     if abs(numbers[i] - numbers[j]) < threshold\n      //       return\
    \ True\n      //\n      // return False\n      def helper(xs : List[Float], i\
    \ : Int) : Boolean = {\n        if (i == xs.length) false\n        else if (helper2(xs,\
    \ i + 1, xs(i))) true\n        else helper(xs, i + 1)\n      }\n      def helper2(xs\
    \ : List[Float], j : Int, x : Float) : Boolean = {\n        if (j == xs.length)\
    \ false\n        else if (abs(x - xs(j)) < threshold) true\n        else helper2(xs,\
    \ j + 1, x)\n      }\n      helper(numbers, 0)", "        var has : Boolean =\
    \ false\n        var sorted : List[Float] = numbers.sorted\n        for (i <-\
    \ 0 until sorted.length - 1) {\n            if (abs(sorted(i) - sorted(i + 1))\
    \ < threshold) {\n                has = true\n                return has\n   \
    \         }\n        }\n        has", "        if (numbers.length < 2) return\
    \ false\n        var diffs = new ArrayBuffer[Float]\n        for (i <- 0 until\
    \ numbers.length - 1) {\n            for (j <- i + 1 until numbers.length) {\n\
    \                diffs += abs(numbers(i) - numbers(j))\n            }\n      \
    \  }\n        return diffs.min <= threshold", "        def hasCloseElementsRec(numbers\
    \ : List[Float], threshold : Float, \n                                       \
    \         closest : (Float, Float)) : Boolean = {\n            if (numbers.isEmpty)\
    \ {\n                abs(closest._1 - closest._2) < threshold\n            } else\
    \ {\n                val number = numbers.head\n                val (first, second)\
    \ = if (abs(number - closest._1) < abs(number - closest._2)) {\n             \
    \       (number, closest._1)\n                } else {\n                    (closest._1,\
    \ number)\n                }\n                hasCloseElementsRec(numbers.tail,\
    \ threshold, (first, second))\n            }\n        }\n        if (numbers.length\
    \ < 2) false\n        else hasCloseElementsRec(numbers.tail, threshold, (numbers.head,\
    \ Float.MaxValue))", "        require(numbers.length >= 2)\n        var prev :\
    \ Float = numbers(0)\n        for (i <- 1 until numbers.length) {\n          \
    \  val curr : Float = numbers(i)\n            if (abs(curr - prev) < threshold)\
    \ return true\n            prev = curr\n        }\n        return false", "  \
    \      var found = false\n        numbers.sorted.sliding(2).foreach(pair => {\n\
    \            val dist = pair(1) - pair(0)\n            if (dist <= threshold)\
    \ {\n                found = true\n            }\n        })\n        found",
  "        for (i <- 0 until numbers.length) {\n            for (j <- 0 until numbers.length)\
    \ {\n                if (abs(numbers(i) - numbers(j)) < threshold) return true\n\
    \            }\n        }\n        return false", "        def hasCloseElementsHelper(numbers\
    \ : List[Float], threshold : Float, lastNumber : Float) : Boolean = {\n      \
    \      if (numbers.length == 0) {\n                false\n            } else {\n\
    \                val head = numbers.head\n                val distance = abs(head\
    \ - lastNumber)\n                if (distance < threshold) {\n               \
    \     true\n                } else {\n                    hasCloseElementsHelper(numbers.tail,\
    \ threshold, head)\n                }\n            }\n        }\n        hasCloseElementsHelper(numbers.tail,\
    \ threshold, numbers.head)", "        for (i <- 1 until numbers.length) {\n  \
    \          if (abs(numbers(i - 1) - numbers(i)) < threshold) {\n             \
    \   return true\n            }\n        }\n        return false", "        var\
    \ result = false\n        for (i <- 0 until numbers.length) {\n            for\
    \ (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) {\n                    result = true\n                }\n     \
    \       }\n        }\n        result", "        var l = new ListBuffer[Float]\n\
    \        var i = 0\n        while (i < numbers.length) {\n            var j =\
    \ 0\n            while (j < l.length) {\n                if (abs(numbers(i) -\
    \ l(j)) < threshold) return true\n                j += 1\n            }\n    \
    \        l += numbers(i)\n            i += 1\n        }\n        return false",
  "        def helper(numbers : List[Float], threshold : Float, min : Float) : Boolean\
    \ = {\n            if (numbers.length == 0) false\n            else {\n      \
    \          val minDistance = numbers.reduce((a, b) => min(abs(a - b), minDistance))\n\
    \                if (minDistance <= threshold) true\n                else helper(numbers.tail,\
    \ threshold, minDistance)\n            }\n        }\n        helper(numbers, threshold,\
    \ 1.0f)", "    \tif (numbers.length <= 1) return false\n    \tval sortedNumbers\
    \ = numbers.sorted\n    \tfor (i <- 0 until sortedNumbers.length - 1) {\n    \t\
    \tif (sortedNumbers(i+1) - sortedNumbers(i) < threshold) return true\n    \t}\n\
    \    \treturn false", "        var set = new TreeSet[Float]()\n        for (number\
    \ <- numbers) {\n            val b = set.iteratorFrom(number - threshold)\n  \
    \          if (b.hasNext && (b.next - number <= threshold)) return true\n    \
    \        val s = set.iteratorFrom(number + threshold)\n            if (s.hasNext\
    \ && (number - s.next <= threshold)) return true\n            set += number\n\
    \        }\n        return false", "        var min = numbers(0)\n        var\
    \ max = numbers(0)\n        for (n <- numbers) {\n            if (n < min) min\
    \ = n\n            if (n > max) max = n\n        }\n        val distance = max\
    \ - min\n        for (i <- 0 until numbers.length; j <- i + 1 until numbers.length)\
    \ {\n            if (abs(numbers(i) - numbers(j)) < threshold) return true\n \
    \       }\n        return false"]
stop_tokens:
- "\n    }\n"
