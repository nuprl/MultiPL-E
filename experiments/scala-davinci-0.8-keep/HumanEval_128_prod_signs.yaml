name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given an array arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the array, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) == -9\n    // >>> prod_signs([0,\
  \ 1]) == 0\n    // >>> prod_signs([]) == None\n    def prodSigns(arr : List[Long])\
  \ : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        if (arr.isEmpty) return None\n        var signProduct = 1.toLong\n\
    \        var magnitudeSum = 0.toLong\n        for (elem <- arr) {\n          \
    \  if (elem == 0) {\n                signProduct = 0\n                magnitudeSum\
    \ = 0\n            } else {\n                signProduct *= signum(elem)\n   \
    \             magnitudeSum += abs(elem)\n            }\n        }\n        return\
    \ Some(signProduct * magnitudeSum)", "        if (arr.isEmpty) None\n        else\
    \ Some(arr.map(x => x.abs).sum * (arr.foldLeft(1L)((x, y) => x * signum(y))))",
  "        if (arr.isEmpty) {\n            None\n        } else {\n            val\
    \ product = arr.map(x => signum(x)).product\n            val sum = arr.map(x =>\
    \ abs(x)).sum\n            Some(product * sum)\n        }", "    \tif (arr.isEmpty)\
    \ return None\n    \tval res = for (a <- arr) yield if (a > 0) (1, a) else if\
    \ (a < 0) (-1, -a) else (0, 0)\n    \tval (sign, abs) = res.unzip\n    \tSome(sign.foldLeft(1)(_\
    \ * _) * abs.foldLeft(0)(_ + _))", "        if (arr.length == 0) None\n      \
    \  else Some(arr.map(num => abs(num) * (if (num == 0) 0 else signum(num))).sum)",
  "        if (arr.isEmpty) None\n        else Some(arr.foldLeft(0L)((x, y) => x +\
    \ (if (y > 0) 1 else if (y < 0) -1 else 0)) * arr.map(abs(_)).product)", "   \
    \     if (arr.length == 0) return None\n        var sum = 0L\n        var prod\
    \ = 1L\n        for (i <- arr) {\n            sum += abs(i)\n            prod\
    \ *= i.signum\n        }\n        return Some(sum * prod)", "        if (arr.isEmpty)\
    \ None\n        else Some(arr.map(abs(_)).foldLeft(1L)(_ * _) * arr.foldLeft(1L)(_\
    \ * _))", "        arr match {\n            case Nil => None\n            case\
    \ h :: t => {\n                val (mags, signs) = arr.foldLeft((List[Long](),\
    \ List[Long]()))((acc, x) => (abs(x) :: acc._1, x.signum :: acc._2))\n       \
    \         Some(mags.sum * signs.product)\n            }\n        }", "       \
    \ val prod = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else 0).product\n  \
    \      val ans = arr.map(x => abs(x)).sum\n        if (arr.isEmpty) None else\
    \ Some(ans * prod)", "        if (arr.isEmpty) {\n            None\n        }\
    \ else {\n            Some(arr.map(x => x * x * x.signum).sum)\n        }", " \
    \       if (arr.isEmpty) return None\n        arr.foldLeft((1L, 1L))((b, a) =>\
    \ {\n            val sign = if (a == 0) 0 else if (a > 0) 1 else -1\n        \
    \    (b._1 * sign, b._2 * abs(a))\n        }) match {\n            case (sign,\
    \ mag) => Some(sign * mag)\n        }", "        if (arr.isEmpty) return None\n\
    \        // Returns product of signs in list\n        def prodSignsHelp(arr :\
    \ List[Long]) : Long = {\n            var prod = 1\n            for (i <- arr)\
    \ prod *= signum(i)\n            prod\n        }\n        // Returns sum of magnitudes\
    \ in list\n        def sumMagnitudes(arr : List[Long]) : Long = {\n          \
    \  var sum = 0\n            for (i <- arr) sum += abs(i)\n            sum\n  \
    \      }\n        val list = arr.filter(_ != 0)\n        val sum = sumMagnitudes(list)\n\
    \        val prod = prodSignsHelp(list)\n        Some(sum * prod)", "        var\
    \ sum = 0L\n        if (arr.length == 0) return None\n        arr.foreach(x =>\
    \ {\n            if (x > 0) sum += x\n            else if (x < 0) sum -= x\n \
    \       })\n        var prod = 1L\n        arr.foreach(x => {\n            if\
    \ (x > 0) prod *= 1\n            else if (x < 0) prod *= -1\n        })\n    \
    \    Some(sum * prod)", "        if (arr.length == 0) {\n            None\n  \
    \      } else {\n            val prod = arr.map(n => (n.signum match {\n     \
    \           case 0 => 0\n                case 1 => 1\n                case -1\
    \ => -1\n            })).reduce(_ * _)\n            Some(arr.map(n => abs(n)).reduce(_\
    \ + _) * prod)\n        }", "        arr match {\n            case Nil => None\n\
    \            case _ => Some(arr.map(x => x.abs).sum * arr.filter(_ != 0).map(x\
    \ => if (x > 0) 1 else -1).product)\n        }", "        def prodSigns_R(arr\
    \ : List[Long], count : Int, prod : Long) : Option[Long] = arr match {\n     \
    \       case Nil => Some(count * prod)\n            case x :: xs => x match {\n\
    \                case 0 => Some(count * prod)\n                case _ => prodSigns_R(xs,\
    \ count + abs(x).toInt, if (x > 0) prod else -prod)\n            }\n        }\n\
    \        prodSigns_R(arr, 0, 1)", "        var product = 1\n        var sum =\
    \ 0\n        for (i <- arr) {\n            if (i > 0) {\n                product\
    \ *= 1\n                sum += i\n            } else if (i < 0) {\n          \
    \      product *= -1\n                sum += -i\n            }\n        }\n  \
    \      if (arr.isEmpty) None else Some(product * sum)", "        if (arr.length\
    \ == 0) return None\n        val p : Long = arr.map(n => if (n > 0) 1 else if\
    \ (n < 0) -1 else 0).product\n        val s : Long = arr.map(n => abs(n)).sum\n\
    \        Some(p * s)", "        if (arr.isEmpty) None\n        else {\n      \
    \      val (sum, prod) = arr.foldLeft((0L, 1L))((x, y) => {\n                if\
    \ (y > 0) (x._1 + y, x._2 * 1)\n                else if (y < 0) (x._1 + y, x._2\
    \ * -1)\n                else (x._1, x._2)\n            })\n            Some(sum\
    \ * prod)\n        }"]
stop_tokens:
- "\n    }\n"
