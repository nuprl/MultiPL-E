name: HumanEval_119_match_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of two strings, both strings consist of open\n    //\
  \ parentheses '(' or close parentheses ')' only.\n    // Your job is to check if\
  \ it is possible to concatenate the two strings in\n    // some order, that the\
  \ resulting string will be good.\n    // A string S is considered to be good if\
  \ and only if all parentheses in S\n    // are balanced. For example: the string\
  \ '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes'\
  \ if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n\
  \    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')', ')']) ==\
  \ 'No'\n    def matchParens(lst : List[String]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
  ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
  , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
  , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
  , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
  , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\"\
  , \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\",\
  \ \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
  , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
  , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \"\
  )(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"\
  Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\"\
  )));\n    }\n\n}\n"
completions: ["    \tval s = new Stack[Char]\n    \tfor (i <- 0 until lst(0).length)\
    \ {\n    \t\ts.push(lst(0)(i))\n    \t}\n    \tfor (i <- 0 until lst(1).length)\
    \ {\n    \t\tif (s.isEmpty) return \"No\"\n    \t\tval c = s.pop\n    \t\tif (c\
    \ == '(' && lst(1)(i) == ')') continue\n    \t\treturn \"No\"\n    \t}\n    \t\
    \"Yes\"", "        if (lst.length == 0) \"Yes\"\n        else {\n            val\
    \ a = lst.head\n            val b = lst.tail.head\n            if (a == \"\")\
    \ {\n                if (b == \"\") \"Yes\"\n                else if (b.contains(\"\
    (\")) \"No\"\n                else matchParens(List(b, \"\"))\n            }\n\
    \            else if (b == \"\") {\n                if (a.contains(\")\")) \"\
    No\"\n                else matchParens(List(\"\", a))\n            }\n       \
    \     else if (a.contains(\"(\") && b.contains(\")\")) matchParens(List(a.dropRight(1),\
    \ b.drop(1)))\n            else if (a.contains(\"(\") && !b.contains(\")\")) matchParens(List(a.dropRight(1),\
    \ b))\n            else if (!a.contains(\"(\") && b.contains(\")\")) matchParens(List(a,\
    \ b.drop(1)))\n            else if (!a.contains(\"(\") && !b.contains(\")\"))\
    \ matchParens(List(a, b))\n            else throw new Exception(\"Invalid input:\
    \ \" + lst)\n        }", "        var cnt = 0\n        for (s <- lst) {\n    \
    \        for (c <- s) {\n                if (c == '(') cnt += 1\n            \
    \    else cnt -= 1\n                if (cnt < 0) return \"No\"\n            }\n\
    \        }\n        if (cnt == 0) \"Yes\" else \"No\"", "        if (lst.exists(s\
    \ => !s.forall(c => c == '(' || c == ')'))) return \"No\"\n        val len1 =\
    \ lst(0).length\n        val len2 = lst(1).length\n        var left1 = 0\n   \
    \     var left2 = 0\n        var mismatch = false\n        var i = 0\n       \
    \ while (i < len1 && !mismatch) {\n            if (lst(0)(i) == '(') left1 +=\
    \ 1\n            else left1 -= 1\n            if (left1 < 0) mismatch = true\n\
    \            i += 1\n        }\n        if (left1 > 0) {\n            i = 0\n\
    \            while (i < len2 && !mismatch) {\n                if (lst(1)(i) ==\
    \ '(') left2 += 1\n                else left2 -= 1\n                if (left2\
    \ < 0) mismatch = true\n                i += 1\n            }\n        }\n   \
    \     if (left1 + left2 != 0) \"No\"\n        else \"Yes\"", "        def recur(lst\
    \ : List[String], stack : List[Char]) : Boolean = {\n            if (lst.isEmpty)\
    \ true\n            else {\n                val cur = lst.head\n             \
    \   if (cur == \")\") {\n                    if (stack.isEmpty) false\n      \
    \              else recur(lst.tail, stack.tail)\n                }\n         \
    \       else recur(lst.tail, '(' :: stack)\n            }\n        }\n       \
    \ recur(lst, Nil) match {\n            case true => \"Yes\"\n            case\
    \ false => \"No\"\n        }", "        val str1 = lst(0)\n        val str2 =\
    \ lst(1)\n        // It's okay to take \"Yes\" as the default answer\n       \
    \ // If one of the strings is already good, then we can just concatenate\n   \
    \     // them to make a good string.\n        if (checkParens(str1) || checkParens(str2))\n\
    \            return \"Yes\"\n        // Now we know that neither string is good.\n\
    \        // So, check if the reversed form of str1, concatenated with str2, would\n\
    \        // make a good string.\n        val str3 = str1.reverse\n        if (checkParens(str3\
    \ + str2))\n            return \"Yes\"\n        // Check if str1 concatenated\
    \ with reversed str2 is good.\n        val str4 = str2.reverse\n        if (checkParens(str1\
    \ + str4))\n            return \"Yes\"\n        // In all other cases, return\
    \ \"No\".\n        return \"No\"", "        val total = lst.foldLeft(0)((acc,\
    \ x) => {\n            if (x.length % 2 == 1) return \"No\"\n            val temp\
    \ = acc + x.length\n            if (temp % 2 == 1) return \"No\"\n           \
    \ temp\n        })\n        val front = lst.head.take(total / 2)\n        val\
    \ back = lst.last.take(total / 2)\n        val frontParen = front.count(_ == '(')\n\
    \        val backParen = back.count(_ == '(')\n        if (frontParen == backParen)\
    \ \"Yes\"\n        else \"No\"", "        val lst0 = lst(0).filter(c => c == '('\
    \ || c == ')')\n        val lst1 = lst(1).filter(c => c == '(' || c == ')')\n\
    \        if (lst0.length == 0 && lst1.length == 0) \"Yes\"\n        else if (lst0.length\
    \ != 0 && lst1.length == 0) if (isGood(lst0)) \"Yes\" else \"No\"\n        else\
    \ if (lst0.length == 0 && lst1.length != 0) if (isGood(lst1)) \"Yes\" else \"\
    No\"\n        else if (lst0.length != 0 && lst1.length != 0) {\n            if\
    \ (lst0.length % 2 == 0 && lst1.length % 2 == 0) {\n                if (isGood(lst0\
    \ + lst1)) \"Yes\"\n                else if (isGood(lst1 + lst0)) \"Yes\"\n  \
    \              else \"No\"\n            }\n            else if (lst0.length %\
    \ 2 == 1 && lst1.length % 2 == 1) {\n                if (isGood(lst0 + lst1))\
    \ \"Yes\"\n                else if (isGood(lst1 + lst0)) \"Yes\"\n           \
    \     else \"No\"\n            }\n            else if (lst0.length % 2 == 0 &&\
    \ lst1.length % 2 == 1) {\n                if (isGood(lst0 + lst1)) \"Yes\"\n\
    \                else if (isGood(lst1 + lst0)) \"Yes\"\n                else \"\
    No\"\n            }\n            else if (lst0.length % 2 == 1 && lst1.length\
    \ % 2 == 0) {\n                if (isGood(lst0 + lst1)) \"Yes\"\n            \
    \    else if (isGood(lst1 + lst0)) \"Yes\"\n                else \"No\"\n    \
    \        }\n            else \"No\"\n        }\n        else \"No\"", "      \
    \  if (lst.length != 2) {\n            throw new Exception(\"lst must have exactly\
    \ two elements.\")\n        }\n        def isGood(str : String) : Boolean = {\n\
    \            var balance = 0\n            for (i <- 0 until str.length) {\n  \
    \              str(i) match {\n                    case '(' => balance += 1\n\
    \                    case ')' => balance -= 1\n                    case _ => throw\
    \ new Exception(\"str must consist of parentheses only.\")\n                }\n\
    \                if (balance < 0) return false\n            }\n            balance\
    \ == 0\n        }\n        if (isGood(lst(0) + lst(1))) \"Yes\"\n        else\
    \ if (isGood(lst(1) + lst(0))) \"Yes\"\n        else \"No\"", "        if (lst.size\
    \ == 1) {\n            var ret = \"Yes\"\n            var balance = 0\n      \
    \      for (c <- lst(0)) {\n                if (c == '(') balance += 1\n     \
    \           else balance -= 1\n                if (balance < 0) {\n          \
    \          ret = \"No\"\n                    break\n                }\n      \
    \      }\n            if (balance != 0) ret = \"No\"\n            return ret\n\
    \        }\n        var result = \"No\"\n        for (i <- 0 until lst.size) {\n\
    \            val subList = lst.zipWithIndex.filter(tup => tup._2 != i).map(tup\
    \ => tup._1)\n            if (matchParens(subList) == \"Yes\") {\n           \
    \     result = \"Yes\"\n                break\n            }\n        }\n    \
    \    return result", "        val open = lst(0).filter(_ == '(').length\n    \
    \    val close = lst(1).filter(_ == ')').length\n        if (open == close) \"\
    Yes\" else \"No\"", "        def count(s : String) : Int = {\n            var\
    \ cnt = 0\n            for (c <- s) c match {\n                case '(' => cnt\
    \ += 1\n                case ')' => cnt -= 1\n            }\n            cnt\n\
    \        }\n        val (s1, s2) = (lst(0), lst(1))\n        val (c1, c2) = (count(s1),\
    \ count(s2))\n        if (c1 < 0 || c2 < 0) \"No\"\n        else if (c1 == 0 &&\
    \ c2 == 0) \"Yes\"\n        else if (c1 == 0 && c2 > 0) \"No\"\n        else if\
    \ (c1 > 0 && c2 == 0) \"No\"\n        else {\n            val nums = Array.fill(c1)(0)\n\
    \            var i = 0\n            while (i < c1) {\n                nums(i)\
    \ = i + 1\n                i += 1\n            }\n            def go(nums : Array[Int],\
    \ ind : Int, tgt : Int) : Boolean = {\n                if (nums(ind) > tgt) false\n\
    \                else if (nums(ind) == tgt) true\n                else go(nums,\
    \ ind + 1, tgt) || go(nums, ind + 1, tgt - nums(ind))\n            }\n       \
    \     if (go(nums, 0, c2)) \"Yes\"\n            else \"No\"\n        }", "   \
    \     // A string is good if and only if it contains the same number of\n    \
    \    // open and close parentheses. Then we only need to check if the\n      \
    \  // sum of open parentheses in the first string is equal to the\n        //\
    \ sum of close parentheses in the second string.\n        def countParens(str\
    \ : String) : Int = {\n            var sum = 0\n            for (c <- str) {\n\
    \                c match {\n                    case '(' => sum += 1\n       \
    \             case ')' => sum -= 1\n                }\n            }\n       \
    \     sum\n        }\n        if (countParens(lst(0)) == -countParens(lst(1)))\
    \ \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      var numberOfOpenParens = 0\n        for (c <- s1) {\n            if (c\
    \ == '(') numberOfOpenParens += 1\n            else numberOfOpenParens -= 1\n\
    \        }\n        for (c <- s2) {\n            if (c == '(') numberOfOpenParens\
    \ += 1\n            else numberOfOpenParens -= 1\n        }\n        if (numberOfOpenParens\
    \ != 0) return \"No\"\n        val s = s1 + s2\n        var numberOfValidParens\
    \ = 0\n        for (c <- s) {\n            if (c == '(') numberOfValidParens +=\
    \ 1\n            else numberOfValidParens -= 1\n            if (numberOfValidParens\
    \ < 0) return \"No\"\n        }\n        if (numberOfValidParens == 0) \"Yes\"\
    \ else \"No\"", "        // ()(())(()(\n        // ))(\n        //  ^\n      \
    \  // )\n        // ^\n        def helper(stack : List[Char], str : String) :\
    \ Boolean = {\n            if (str.isEmpty) {\n                if (stack.isEmpty)\
    \ return true\n                else return false\n            }\n            val\
    \ c = str.head\n            if (c == '(') {\n                helper(c :: stack,\
    \ str.tail)\n            } else {\n                if (stack.isEmpty) return false\n\
    \                else if (stack.head == '(') {\n                    helper(stack.tail,\
    \ str.tail)\n                } else {\n                    return false\n    \
    \            }\n            }\n        }\n        if (helper(List(), lst(0) +\
    \ lst(1))) return \"Yes\"\n        else return \"No\"", "        lst.foldLeft(0)((s,\
    \ str) => s + balanceParens(str)) match {\n            case 0 => \"Yes\"\n   \
    \         case _ => \"No\"\n        }", "        val arr = lst.toArray\n     \
    \   if (arr(0) == \"\") return if (arr(1) == \"\") \"Yes\" else \"No\"\n     \
    \   val ch = arr(0)(0)\n        if (ch == '(') {\n            val lst1 = List(arr(0).substring(1),\
    \ arr(1))\n            val ans1 = matchParens(lst1)\n            if (ans1 == \"\
    Yes\") return \"Yes\"\n            else {\n                val lst2 = List(arr(0),\
    \ arr(1).substring(1))\n                val ans2 = matchParens(lst2)\n       \
    \         return ans2\n            }\n        } else {\n            if (arr(1)\
    \ == \"\") return \"No\"\n            val lst1 = List(arr(0).substring(1), arr(1))\n\
    \            val ans1 = matchParens(lst1)\n            if (ans1 == \"Yes\") return\
    \ \"Yes\"\n            else {\n                val lst2 = List(arr(0), arr(1).substring(1))\n\
    \                val ans2 = matchParens(lst2)\n                return ans2\n \
    \           }\n        }", "        if (lst.length != 2) {\n            throw\
    \ new IllegalArgumentException(\"lst should contain two strings\")\n        }\n\
    \        var stack = new Stack[Char]\n        lst(0).foreach(c => {\n        \
    \    if (c == '(') {\n                stack.push(c)\n            } else {\n  \
    \              if (stack.isEmpty) {\n                    return \"No\"\n     \
    \           } else {\n                    stack.pop\n                }\n     \
    \       }\n        })\n        if (stack.length == 0) {\n            \"Yes\"\n\
    \        } else {\n            lst(1).foreach(c => {\n                if (c ==\
    \ ')') {\n                    if (stack.isEmpty) {\n                        return\
    \ \"No\"\n                    } else {\n                        stack.pop\n  \
    \                  }\n                } else {\n                    stack.push(c)\n\
    \                }\n            })\n            if (stack.length == 0) {\n   \
    \             \"Yes\"\n            } else {\n                \"No\"\n        \
    \    }\n        }", "        val s = lst.mkString\n        if (s.count(c => c\
    \ == '(') == s.count(c => c == ')')) \"Yes\" else \"No\"", "        if (lst.size\
    \ != 2) return \"No\"\n        val s1 = lst(0)\n        val s2 = lst(1)\n    \
    \    var currentBalance = 0\n        for (i <- 0 until s1.length) {\n        \
    \    val c = s1(i)\n            if (c == '(') currentBalance += 1\n          \
    \  else currentBalance -= 1\n            if (currentBalance < 0) return \"No\"\
    \n        }\n        for (i <- 0 until s2.length) {\n            val c = s2(i)\n\
    \            if (c == '(') currentBalance += 1\n            else currentBalance\
    \ -= 1\n            if (currentBalance < 0) return \"No\"\n        }\n       \
    \ if (currentBalance == 0) \"Yes\" else \"No\""]
stop_tokens:
- "\n    }\n"
