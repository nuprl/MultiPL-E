name: HumanEval_89_encrypt
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function encrypt that takes a string as an argument and\n    //\
  \ returns a string encrypted with the alphabet being rotated. \n    // The alphabet\
  \ should be rotated in a manner such that the letters \n    // shift down by two\
  \ multiplied to two places.\n    // For example:\n    // encrypt('hi') returns 'lm'\n\
  \    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf') returns 'kj'\n\
  \    // encrypt('et') returns 'ix'\n    def encrypt(s : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
  lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
  gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n   \
  \ assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
  hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
  a\")).equals((\"e\")));\n    }\n\n}\n"
completions: ['        ""', "        val alphabet = (0 to 26).map(x => ('a' + x).toChar).toArray\n\
    \        val encryptalphabet = (0 to 26).map(x => ('a' + (x + 4) % 26).toChar).toArray\n\
    \        val encrypted = s.map(x => {\n            val t = encryptalphabet(alphabet.indexOf(x))\n\
    \            t\n        })\n        encrypted.mkString", "        def encryptChar(c\
    \ : Char) : Char = {\n            val newValue = c + 2 * 2\n            if (newValue\
    \ <= 'z') newValue.toChar\n            else encryptChar((newValue - 'z' + 'a'\
    \ - 1).toChar)\n        }\n        s.map(encryptChar)", "        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val shiftedAlphabet = alphabet.drop(2)\
    \ + alphabet.take(2)\n        var message = \"\"\n        for (c <- s) {\n   \
    \         message += shiftedAlphabet(alphabet.indexOf(c))\n        }\n       \
    \ message", '        s.map(x => (x + 2 * 2).toChar)', '        return (s.map {(c
    : Char) => c - 2}).mkString', "        def c(x : Char) : Char = {\n          \
    \  if (x >= 'a' && x <= 'z')\n                (((x - 'a') + 1) % 26 + 'a').toChar\n\
    \            else if (x >= 'A' && x <= 'Z')\n                (((x - 'A') + 1)\
    \ % 26 + 'A').toChar\n            else\n                x\n        }\n       \
    \ return s.map(c)", "        val l = (a : Char) => a match {\n            case\
    \ 'a' => 'c'\n            case 'b' => 'd'\n            case 'c' => 'e'\n     \
    \       case 'd' => 'f'\n            case 'e' => 'g'\n            case 'f' =>\
    \ 'h'\n            case 'g' => 'i'\n            case 'h' => 'j'\n            case\
    \ 'i' => 'k'\n            case 'j' => 'l'\n            case 'k' => 'm'\n     \
    \       case 'l' => 'n'\n            case 'm' => 'o'\n            case 'n' =>\
    \ 'p'\n            case 'o' => 'q'\n            case 'p' => 'r'\n            case\
    \ 'q' => 's'\n            case 'r' => 't'\n            case 's' => 'u'\n     \
    \       case 't' => 'v'\n            case 'u' => 'w'\n            case 'v' =>\
    \ 'x'\n            case 'w' => 'y'\n            case 'x' => 'z'\n            case\
    \ 'y' => 'a'\n            case 'z' => 'b'\n            case _ => ' '\n       \
    \ }\n        s.map(l)", "        s.toLowerCase.map(x => {\n            if(x ==\
    \ 'z') 'b'\n            else if(x == 'y') 'a'\n            else (((x - 'a') +\
    \ 4) % 26).toChar + 'a'\n        })", "        var result = \"\"\n        for\
    \ (i <- 0 until s.length) {\n            val c = s(i)\n            val x = (2\
    \ * c - 97 + 2) % 26 + 97\n            result += x.toChar\n        }\n       \
    \ result", "        var enc = \"\"\n        for (c <- s) enc += (c.toInt + 2*2).toChar\n\
    \        enc", "        var result = \"\"\n        for (i <- 0 until s.length)\
    \ {\n            val c = s(i)\n            if (c == 'z') result += 'b'\n     \
    \       else if (c == 'y') result += 'a'\n            else result += (c + 2).toChar\n\
    \        }\n        result", "        var p = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        var s2 = s.split(\"\")\n        var s3 = \"\"\n        for (i <- 0 to\
    \ s2.length - 1) {\n            var c = s2(i)\n            var idx = p.indexOf(c)\n\
    \            var newIdx = (idx + (2 * 2)) % 26\n            var newChar = p.substring(newIdx,\
    \ newIdx + 1)\n            s3 += newChar\n        }\n        return s3", "   \
    \     var encryptedString = \"\"\n        for (i <- 0 until s.length) {\n    \
    \        var c = s(i)\n            var newC = if (c + 2 * 2 > 'z') (c + 2 * 2\
    \ - 26).toChar else (c + 2 * 2).toChar\n            encryptedString += newC\n\
    \        }\n        encryptedString", "        var result = \"\"\n        for\
    \ (i <- 0 until s.length) {\n            var c = s(i)\n            if (c == 'z')\
    \ c = 'b'\n            else if (c == 'y') c = 'a'\n            else if (c >= 'a'\
    \ && c <= 'x') c = (c + 2).toChar\n            result += c\n        }\n      \
    \  result", "        // Write your code here\n        \"\";", "        def encryptRec(s\
    \ : String, acc : String) : String = {\n            if (s.length() == 0) acc\n\
    \            else {\n                val c = s.charAt(0)\n                val\
    \ nextC = if (c == 'z') 'a'\n                    else if (c == 'y') 'a'\n    \
    \                else c + 2\n                encryptRec(s.drop(1), acc + nextC)\n\
    \            }\n        }\n        encryptRec(s, \"\")", "        s.map(c => (((c\
    \ - 'a') * 2) % 26 + 'a').toChar)", '        ""', "        def to_int(c : Char)\
    \ : Int = {\n            c.toInt - 97\n        }\n        def to_char(i : Int)\
    \ : Char = {\n            (i + 97).toChar\n        }\n        s.map(c => to_char((to_int(c)\
    \ + 2 * 2) % 26))"]
stop_tokens:
- "\n    }\n"
