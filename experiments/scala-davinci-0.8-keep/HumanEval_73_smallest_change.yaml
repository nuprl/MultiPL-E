name: HumanEval_73_smallest_change
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given an array arr of integers, find the minimum number of elements that\n\
  \    // need to be changed to make the array palindromic. A palindromic array is\
  \ an array that\n    // is read the same backwards and forwards. In one change,\
  \ you can change one element to any other element.\n    // For example:\n    //\
  \ smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2, 3, 4, 3,\
  \ 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def smallestChange(arr\
  \ : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
  \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
  \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
  \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));\n\
  \    }\n\n}\n"
completions: ["        val palindrome = (arr.take(arr.length / 2) ::: arr.takeRight(arr.length\
    \ / 2).reverse).toList\n        arr.zip(palindrome).map(x => math.abs(x._1 - x._2)).sum",
  "        val n = arr.length\n        // dp(i)(j) is the number of changes needed\
    \ to make the array palindromic\n        // in the range i..j\n        val dp\
    \ = Array.ofDim[Long](n, n)\n        for (size <- 1 to n) {\n            for (left\
    \ <- 0 to n - size) {\n                val right = left + size - 1\n         \
    \       if (size == 1) dp(left)(right) = 0\n                else if (size == 2)\
    \ dp(left)(right) = if (arr(left) == arr(right)) 0 else 1\n                else\
    \ if (arr(left) == arr(right)) dp(left)(right) = dp(left + 1)(right - 1)\n   \
    \             else dp(left)(right) = min(dp(left + 1)(right), dp(left)(right -\
    \ 1)) + 1\n            }\n        }\n        dp(0)(n - 1)", "        var left\
    \ = 0\n        var right = arr.length - 1\n        var ans = 0\n        while\
    \ (left < right) {\n            if (arr(left) != arr(right)) {\n             \
    \   ans += 1\n            }\n            left += 1\n            right -= 1\n \
    \       }\n        ans", "        def solve(i : Int, j : Int) : Long = {\n   \
    \         if (i >= j) 0\n            else if (arr(i) == arr(j)) solve(i + 1, j\
    \ - 1)\n            else min(solve(i + 1, j), solve(i, j - 1)) + 1\n        }\n\
    \        solve(0, arr.length - 1)", "        val n = arr.length\n        val dp\
    \ = Array.ofDim[Long](n, n)\n        for (l <- 2 to n) {\n            for (i <-\
    \ 0 to n - l) {\n                val j = i + l - 1\n                dp(i)(j) =\
    \ min(dp(i + 1)(j), dp(i)(j - 1)) + 1\n                if (arr(i) == arr(j)) dp(i)(j)\
    \ = min(dp(i)(j), dp(i + 1)(j - 1))\n            }\n        }\n        dp(0)(n\
    \ - 1)", "        val n = arr.length\n        val left = new Array[Long](n + 1)\n\
    \        left(0) = 0\n        for (i <- 1 to n) left(i) = left(i - 1) + arr(i\
    \ - 1)\n        val right = new Array[Long](n + 1)\n        right(n) = 0\n   \
    \     for (i <- n - 1 to 0 by -1) right(i) = right(i + 1) + arr(i)\n        var\
    \ res = Long.MaxValue\n        for (i <- 0 to n) {\n            val s = left(i)\
    \ + right(i)\n            res = min(res, s)\n        }\n        res", "      \
    \  def loop(l : List[Long], r : List[Long], c : Long) : Long = (l, r) match {\n\
    \            case (Nil, Nil) => c\n            case (x :: xs, y :: ys) => if (x\
    \ == y) loop(xs, ys, c) else loop(xs, ys, c + 1)\n            case _ => c\n  \
    \      }\n        loop(arr, arr.reverse, 0)", "        val n = arr.length\n  \
    \      val dp = Array.ofDim[Long](n, n)\n        for (len <- 1 to n - 1) {\n \
    \           for (i <- 0 to n - len - 1) {\n                val j = i + len\n \
    \               if (arr(i) == arr(j)) dp(i)(j) = dp(i + 1)(j - 1)\n          \
    \      else dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1)) + 1\n            }\n  \
    \      }\n        dp(0)(n - 1)", "        def loop(left : Int, right : Int, count\
    \ : Long) : Long = {\n            if (left >= right) return count\n          \
    \  if (arr(left) == arr(right)) return loop(left + 1, right - 1, count)\n    \
    \        val l = loop(left + 1, right, count + 1)\n            val r = loop(left,\
    \ right - 1, count + 1)\n            min(l, r)\n        }\n        if (arr.length\
    \ % 2 == 0) loop(0, arr.length - 1, 0)\n        else loop(0, arr.length - 2, 0)",
  "        val firstHalf = arr.slice(0, arr.length / 2)\n        val secondHalf =\
    \ arr.slice(arr.length / 2 + (if (arr.length % 2 == 0) 0 else 1), arr.length)\n\
    \        val pairwiseDifferences = firstHalf.zip(secondHalf.reverse).map(x =>\
    \ abs(x._1 - x._2))\n        pairwiseDifferences.sum", "        def reverse(l\
    \ : List[Long]) : List[Long] = {\n            if (l.isEmpty) l\n            else\
    \ reverse(l.tail) :+ l.head\n        }\n        def countChanges(a : List[Long],\
    \ b : List[Long]) : Long = {\n            if (a.isEmpty) 0\n            else if\
    \ (a.head == b.head) countChanges(a.tail, b.tail)\n            else 1 + countChanges(a.tail,\
    \ b.tail)\n        }\n        countChanges(arr, reverse(arr))", "        // Compute\
    \ how many elements are missing from the left and right sides of the array\n \
    \       val mid = arr.length / 2\n        var leftIndex = 0\n        var rightIndex\
    \ = arr.length - 1\n        var result = 0L\n        for (i <- 0 until mid) {\n\
    \            if (arr(leftIndex) != arr(rightIndex)) {\n                if (arr(leftIndex)\
    \ < arr(rightIndex)) {\n                    result += arr(rightIndex) - arr(leftIndex)\n\
    \                    leftIndex += 1\n                } else {\n              \
    \      result += arr(leftIndex) - arr(rightIndex)\n                    rightIndex\
    \ -= 1\n                }\n            } else {\n                leftIndex +=\
    \ 1\n                rightIndex -= 1\n            }\n        }\n        result",
  '        return 0', "        val list = arr\n        val length = list.length\n\
    \        val half = (length + 1) / 2\n        val reversed = list.reverse\n  \
    \      var count = 0L\n        for (i <- 0 until half) {\n            if (list(i)\
    \ != reversed(i)) count += 1\n        }\n        return count", "        val q1\
    \ = Queue[Long]()\n        for (i <- 0 until arr.length / 2) q1.enqueue(arr(i))\n\
    \        val q2 = Queue[Long]()\n        for (i <- arr.length - 1 to (arr.length\
    \ + 1) / 2 by -1) q2.enqueue(arr(i))\n        var cnt = 0L\n        while (q1.length\
    \ > 0) {\n            if (q1.dequeue != q2.dequeue) cnt += 1\n        }\n    \
    \    cnt", "      if (arr.length % 2 == 0) {\n        (arr.slice(0, arr.length\
    \ / 2) zip arr.slice(arr.length / 2, arr.length).reverse).map(x => abs(x._1 -\
    \ x._2)).sum\n      } else {\n        (arr.slice(0, arr.length / 2) zip arr.slice(arr.length\
    \ / 2 + 1, arr.length).reverse).map(x => abs(x._1 - x._2)).sum\n      }", "  \
    \      if (arr.length % 2 == 0) {\n            val mid = arr.length / 2\n    \
    \        val left = arr.slice(0, mid)\n            val right = arr.slice(mid,\
    \ arr.length).reverse\n            val changes = left.zip(right).map(x => abs(x._1\
    \ - x._2))\n            changes.foldLeft(0L)(_ + _)\n        } else {\n      \
    \      val mid = arr.length / 2\n            val left = arr.slice(0, mid)\n  \
    \          val right = arr.slice(mid + 1, arr.length).reverse\n            val\
    \ changes = left.zip(right).map(x => abs(x._1 - x._2))\n            changes.foldLeft(0L)(_\
    \ + _)\n        }", "        val n = arr.length\n        val dp = Array.ofDim[(Long,\
    \ Boolean)](n, n)\n        for (start <- 0 until n; end <- 0 until n) {\n    \
    \        dp(start)(end) = (10000000, false)\n        }\n        for (start <-\
    \ 0 until n; end <- start until n) {\n            if (start == end) dp(start)(end)\
    \ = (0, true)\n            else {\n                if (arr(start) == arr(end))\
    \ dp(start)(end) = (min(dp(start)(end)._1, dp(start + 1)(end - 1)._1), true)\n\
    \                dp(start)(end) = (min(dp(start)(end)._1, dp(start + 1)(end)._1\
    \ + 1), dp(start)(end)._2)\n                dp(start)(end) = (min(dp(start)(end)._1,\
    \ dp(start)(end - 1)._1 + 1), dp(start)(end)._2)\n            }\n        }\n \
    \       dp(0)(n - 1)._1", "        val n = arr.length\n        val mirror = new\
    \ HashMap[Int, Int]\n        mirror += (0 -> 0)\n        mirror += (n - 1 -> n\
    \ - 1)\n        val dp = new Array[Int](n)\n        (1 until n / 2).foreach(i\
    \ => {\n            val m = mirror(i - 1)\n            if (m != n - 1 - i) dp(i)\
    \ = dp(m) + 1\n            if (arr(i) == arr(n - 1 - i)) mirror += (i -> (n -\
    \ 1 - i))\n            else mirror += (i -> m)\n        })\n        val m = mirror(n\
    \ / 2 - 1)\n        dp(n / 2) = dp(m) + 1\n        if (n % 2 == 1 && arr(n / 2)\
    \ == arr(n / 2 + 1)) mirror += (n / 2 -> (n / 2 + 1))\n        else mirror +=\
    \ (n / 2 -> m)\n        (n / 2 + 1 until n).foreach(i => {\n            val m\
    \ = mirror(i - 1)\n            if (m != n - 1 - i) dp(i) = dp(m) + 1\n       \
    \     if (arr(i) == arr(n - 1 - i)) mirror += (i -> (n - 1 - i))\n           \
    \ else mirror += (i -> m)\n        })\n        dp(n - 1) = dp(mirror(n - 1))\n\
    \        dp(n - 1) min (n - dp(n - 1) - 1)", "        val n = arr.length\n   \
    \     val dp = Array.ofDim[Long](n, n)\n        for (i <- n - 1 to 0 by -1) {\n\
    \            for (j <- i + 1 until n) {\n                if (arr(i) == arr(j))\
    \ dp(i)(j) = dp(i + 1)(j - 1)\n                else dp(i)(j) = 1 + min(dp(i +\
    \ 1)(j), dp(i)(j - 1))\n            }\n        }\n        return dp(0)(n - 1)"]
stop_tokens:
- "\n    }\n"
