name: HumanEval_56_correct_bracketing
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // brackets is a string of \"<\" and \">\".\n    // return True if every opening\
  \ bracket has a corresponding closing bracket.\n    // >>> correct_bracketing(\"\
  <\")\n    // False\n    // >>> correct_bracketing(\"<>\")\n    // True\n    // >>>\
  \ correct_bracketing(\"<<><>>\")\n    // True\n    // >>> correct_bracketing(\"\
  ><<>\")\n    // False\n    def correctBracketing(brackets : String) : Boolean =\
  \ {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"\
  <>\")) == (true));\n    assert(correctBracketing((\"<<><>>\")) == (true));\n   \
  \ assert(correctBracketing((\"<><><<><>><>\")) == (true));\n    assert(correctBracketing((\"\
  <><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(correctBracketing((\"<<<><>>>>\"\
  )) == (false));\n    assert(correctBracketing((\"><<>\")) == (false));\n    assert(correctBracketing((\"\
  <\")) == (false));\n    assert(correctBracketing((\"<<<<\")) == (false));\n    assert(correctBracketing((\"\
  >\")) == (false));\n    assert(correctBracketing((\"<<>\")) == (false));\n    assert(correctBracketing((\"\
  <><><<><>><>><<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>>><>\"\
  )) == (false));\n    }\n\n}\n"
completions: ["    \t// In Scala, using a List as a stack is really easy.\n    \t\
    // Using ListBuffer instead of List allows us to append\n    \t// to the end of\
    \ the list, which is much faster than prepending\n    \t// to the beginning of\
    \ the list with list1 ::: list2.\n    \tval stack = new ListBuffer[Char]\n   \
    \ \tfor (c <- brackets) {\n    \t\tif (c == '<') {\n    \t\t\tstack += c\n   \
    \ \t\t} else {\n    \t\t\tif (stack.isEmpty) {\n    \t\t\t\treturn false\n   \
    \ \t\t\t} else {\n    \t\t\t\tstack.remove(stack.length - 1)\n    \t\t\t}\n  \
    \  \t\t}\n    \t}\n    \treturn stack.isEmpty", "        var count = 0\n     \
    \   for (c <- brackets) {\n            if (c == '<') count += 1\n            else\
    \ if (c == '>') count -= 1\n            if (count < 0) return false\n        }\n\
    \        count == 0", "        val stack = new Stack[Char]\n        for (c <-\
    \ brackets) {\n            if (c == '<') stack.push(c)\n            else if (stack.isEmpty)\
    \ return false\n            else stack.pop\n        }\n        stack.isEmpty",
  "      var openBrackets = 0\n      for (b <- brackets) {\n        if (b == '<')\
    \ openBrackets += 1\n        else if (b == '>') openBrackets -= 1\n        if\
    \ (openBrackets < 0) return false\n      }\n      return openBrackets == 0", " \
    \       var stack = new Stack[Char]\n        for (c <- brackets) {\n         \
    \   if (c == '<') stack.push(c)\n            else if (c == '>') {\n          \
    \      if (stack.isEmpty) return false\n                else stack.pop\n     \
    \       }\n        }\n        return stack.isEmpty", "        var balance = 0\n\
    \        for (bracket <- brackets) {\n            if (bracket == '<') balance\
    \ += 1\n            else if (bracket == '>') balance -= 1\n            if (balance\
    \ < 0) return false\n        }\n        return balance == 0", "        if (brackets.length\
    \ % 2 == 1) return false\n        var count = 0\n        brackets.foreach(i =>\
    \ {\n            if (i == '<') count += 1\n            else count -= 1\n     \
    \       if (count < 0) return false\n        })\n        return count == 0", " \
    \       var count = 0\n        for (b <- brackets) {\n            if (b == '<')\
    \ count += 1\n            else count -= 1\n            if (count < 0) return false\n\
    \        }\n        return count == 0", "        brackets.count(_ == '<') == brackets.count(_\
    \ == '>')", "        def balance(acc : Int, brackets : List[Char]) : Boolean =\
    \ brackets match {\n            case Nil => acc == 0\n            case '<' ::\
    \ tail => balance(acc + 1, tail)\n            case '>' :: tail => acc > 0 && balance(acc\
    \ - 1, tail)\n        }\n        balance(0, brackets.toList)", "        val stack\
    \ = new Stack[Char]\n        for (i <- 0 until brackets.length) {\n          \
    \  if (brackets(i) == '<') stack.push('<')\n            else if (stack.isEmpty)\
    \ return false\n            else stack.pop\n        }\n        return stack.isEmpty",
  "        val stack = new Stack[Char]\n        for (b <- brackets) {\n          \
    \  if (b == '<') stack.push(b)\n            else if (stack.isEmpty) return false\n\
    \            else stack.pop\n        }\n        stack.isEmpty", "        var count\
    \ = 0\n        for (bracket <- brackets) {\n            if (bracket == '<') count\
    \ += 1\n            else count -= 1\n            if (count < 0) return false\n\
    \        }\n        return count == 0", "        var parentheses = 0\n       \
    \ for (i <- 0 until brackets.length) {\n            if (brackets(i) == '<') parentheses\
    \ += 1\n            else parentheses -= 1\n            if (parentheses < 0) return\
    \ false\n        }\n        parentheses == 0", "        val stack = new Stack[Char]\n\
    \        for (i <- 0 until brackets.length) {\n            if (brackets(i) ==\
    \ '<') stack.push('<')\n            else if (stack.isEmpty) return false\n   \
    \         else stack.pop\n        }\n        return stack.isEmpty", "        var\
    \ stack = new Stack[Char]\n        for (c <- brackets) {\n            if (c ==\
    \ '<') {\n                stack.push(c)\n            } else {\n              \
    \  if (stack.isEmpty) return false\n                stack.pop\n            }\n\
    \        }\n        return stack.isEmpty", "        var list = ListBuffer[Char]()\n\
    \        brackets.foreach(c => {\n            if (c == '<') list += c\n      \
    \      else {\n                if (list.size > 0) list -= list.last\n        \
    \        else return false\n            }\n        })\n        list.size == 0",
  "        // nbrackets is the number of brackets in brackets.\n        val nbrackets\
    \ = brackets.length\n        // bracketing is a queue of the brackets in brackets.\n\
    \        val bracketing = new Queue[Char]\n        // read the brackets in brackets\
    \ one by one.\n        for (bracket <- brackets) {\n            bracket match\
    \ {\n                // if the bracket is a closing bracket, check if it has a\
    \ corresponding opening bracket in bracketing.\n                case '>' => if\
    \ (bracketing.isEmpty || bracketing.dequeue != '<') return false\n           \
    \     // if the bracket is an opening bracket, add it to bracketing.\n       \
    \         case '<' => bracketing.enqueue(bracket)\n            }\n        }\n\
    \        // return True if bracketing is empty and False otherwise.\n        bracketing.isEmpty",
  "      if (brackets.length % 2 != 0) return false\n      val stack = Stack[Char]()\n\
    \      for (i <- 0 until brackets.length) {\n        if (brackets(i) == '<') stack.push('<')\n\
    \        else if (stack.isEmpty) return false\n        else stack.pop\n      }\n\
    \      return stack.isEmpty", "        def helper(brackets : String, count : Int)\
    \ : Boolean = {\n            if (brackets.length == 0) count == 0\n          \
    \  else if (brackets.head == '<') helper(brackets.tail, count + 1)\n         \
    \   else if (brackets.head == '>') count > 0 && helper(brackets.tail, count -\
    \ 1)\n            else helper(brackets.tail, count)\n        }\n        helper(brackets,\
    \ 0)"]
stop_tokens:
- "\n    }\n"
