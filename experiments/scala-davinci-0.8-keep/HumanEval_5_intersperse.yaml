name: HumanEval_5_intersperse
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Insert a number 'delimeter' between every two consecutive elements of input\
  \ list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>> intersperse([1,\
  \ 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers : List[Long], delimeter\
  \ : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
  \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
  \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
  \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
  \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
completions: ["        if (numbers.isEmpty) List()\n        else if (numbers.size\
    \ == 1) numbers\n        else numbers.head :: delimeter :: intersperse(numbers.tail,\
    \ delimeter)", "      def intersperseInner(numbers : List[Long], acc : List[Long])\
    \ : List[Long] = {\n        if (numbers.length == 0) acc\n        else if (numbers.length\
    \ == 1) acc :+ numbers(0)\n        else intersperseInner(numbers.drop(2), acc\
    \ :+ numbers(0) :+ delimeter)\n      }\n      intersperseInner(numbers, List())",
  "      val sequence : ListBuffer[Long] = new ListBuffer[Long]()\n      for (number\
    \ <- numbers) {\n        sequence += number\n        sequence += delimeter\n \
    \     }\n      sequence.toList.dropRight(1)", "    \t// Iterate over input list\
    \ from index = 1, since we want to insert an element after every element of input\
    \ list.\n    \t// Keep prepending elements of input list and 'delimeter' to ListBuffer.\n\
    \    \t// Return result after converting ListBuffer to List.\n    \t(1 until numbers.length).foldLeft(ListBuffer(numbers(0)))((b,\
    \ index) => b += delimeter += numbers(index)).toList", "        if (numbers.isEmpty)\
    \ numbers\n        else {\n            var result = new ListBuffer[Long]\n   \
    \         for (i <- 0 until numbers.length - 1) {\n                result += numbers(i)\n\
    \                result += delimeter\n            }\n            result += numbers.last\n\
    \            result.toList\n        }", "        def insertDelimeter(numbers :\
    \ List[Long], delimeter : Long, acc : List[Long]) : List[Long] = numbers match\
    \ {\n            case Nil => acc\n            case x :: Nil => insertDelimeter(Nil,\
    \ delimeter, acc :+ x)\n            case x :: xs => insertDelimeter(xs, delimeter,\
    \ acc :+ x :+ delimeter)\n        }\n        insertDelimeter(numbers, delimeter,\
    \ Nil)", "        def helper(res : List[Long], numbers : List[Long]) : List[Long]\
    \ = {\n            if (numbers.isEmpty) res\n            else if (res.isEmpty)\
    \ helper(List(numbers.head), numbers.tail)\n            else helper(res :+ delimeter\
    \ :+ numbers.head, numbers.tail)\n        }\n        helper(List(), numbers)",
  "        if (numbers.length <= 1) numbers\n        else numbers.head :: delimeter\
    \ :: intersperse(numbers.tail, delimeter)", "    \tif (numbers.length == 0) Nil\n\
    \    \telse if (numbers.length == 1) numbers\n    \telse (numbers.head :: delimeter\
    \ :: intersperse(numbers.tail, delimeter))", "        def helper(numbers : List[Long],\
    \ delimeter : Long, result : List[Long]) : List[Long] = {\n            if (numbers.isEmpty)\
    \ result.reverse\n            else if (numbers.length == 1) result.reverse :::\
    \ List(numbers.head)\n            else helper(numbers.tail, delimeter, numbers.head\
    \ :: delimeter :: result)\n        }\n        helper(numbers, delimeter, List())",
  "        if (numbers.isEmpty) return numbers\n        if (numbers.length == 1) return\
    \ numbers\n        var result = new ListBuffer[Long]\n        result += numbers(0)\n\
    \        for (i <- 1 until numbers.length) {\n            result += delimeter\n\
    \            result += numbers(i)\n        }\n        result.toList", "      \
    \  if (numbers.length <= 1) numbers\n        else numbers.head :: delimeter ::\
    \ intersperse(numbers.tail, delimeter)", "        // >>>> Fill the missing part\n\
    \        var result : List[Long] = List[Long]()\n        for (i <- 0 until numbers.length)\
    \ {\n            result = result :+ numbers(i)\n            if (i < numbers.length\
    \ - 1) {\n                result = result :+ delimeter\n            }\n      \
    \  }\n        result", "        def helper(numbers : List[Long], delimeter : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (numbers.length == 0) acc\n\
    \            else if (numbers.length == 1) acc ::: numbers\n            else helper(numbers.tail,\
    \ delimeter, acc ::: List(numbers.head, delimeter))\n        }\n        helper(numbers,\
    \ delimeter, List())", "        def intersperse(numbers : List[Long], acc : List[Long])\
    \ : List[Long] = numbers match {\n            case Nil => acc\n            case\
    \ head :: Nil => head :: acc\n            case head :: tail => intersperse(tail,\
    \ delimeter :: head :: acc)\n        }\n        intersperse(numbers, Nil).reverse",
  "        def f(result : List[Long], remained : List[Long]) : List[Long] = remained\
    \ match {\n            case Nil => result\n            case _ => f(result :+ remained.head\
    \ :+ delimeter, remained.tail)\n        }\n        f(List[Long](), numbers).init",
  "        if (numbers.isEmpty) numbers\n        else numbers.tail.foldLeft(List(numbers.head))((acc,\
    \ x) => acc :+ delimeter :+ x)", "        if (numbers.isEmpty) Nil\n        else\
    \ if (numbers.length == 1) numbers\n        else numbers.head :: delimeter ::\
    \ intersperse(numbers.tail, delimeter)", "        if (numbers.isEmpty) List()\n\
    \        else numbers.head :: delimeter :: intersperse(numbers.tail, delimeter)",
  "        if (numbers.length == 0) Nil\n        else numbers(0) :: intersperse(numbers.slice(1,\
    \ numbers.length), delimeter) ::: List(delimeter)"]
stop_tokens:
- "\n    }\n"
