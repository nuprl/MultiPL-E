name: HumanEval_100_make_a_pile
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, you have to make a pile of n levels of stones.\n\
  \    // The first level has n stones.\n    // The number of stones in the next level\
  \ is:\n    // - the next odd number if n is odd.\n    // - the next even number\
  \ if n is even.\n    // Return the number of stones in each level in a list, where\
  \ element at index\n    // i represents the number of stones in the level (i+1).\n\
  \    // Examples:\n    // >>> make_a_pile(3)\n    // [3, 5, 7]\n    def makeAPile(n\
  \ : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong,\
  \ 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong,\
  \ 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong,\
  \ 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong,\
  \ 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        def p(n : Long, l : List[Long]) : List[Long] = {\n        \
    \    if (n == 0) l\n            else if (n % 2 == 0) p(n - 1, (n - 1) :: l)\n\
    \            else p(n - 1, n :: l)\n        }\n        p(n, List())", "      val\
    \ result = ListBuffer[Long]()\n      for (i <- 1 to n.toInt) {\n        val nthTerm\
    \ = n + (2 * (i - 1))\n        result += nthTerm\n      }\n      result.toList",
  "        var stones = new ListBuffer[Long]\n        var s = n\n        stones +=\
    \ s\n        while (s > 1) {\n            if (s % 2 == 0) {\n                s\
    \ = s - 1\n            } else {\n                s = s - 2\n            }\n  \
    \          stones += s\n        }\n        stones.toList", "        val numbers\
    \ = new ListBuffer[Long]\n        var i = n\n        while (i > 0) {\n       \
    \     numbers += i\n            i = if (i % 2 == 0) i - 1 else i - 2\n       \
    \ }\n        numbers.toList", "        var cur = n\n        var rem = n - 1\n\
    \        var ans = new ListBuffer[Long]\n        while (rem > 0) {\n         \
    \   ans += cur\n            cur += 2\n            rem -= 1\n        }\n      \
    \  ans.toList", "        def makeAPile_inner(n : Long, l : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) l\n            else if (n % 2 == 0) makeAPile_inner(n\
    \ - 1, (n + 1) :: l)\n            else makeAPile_inner(n - 1, (n + 2) :: l)\n\
    \        }\n        makeAPile_inner(n, List(n))", "      val x = ListBuffer[Long]()\n\
    \      x += n\n      while (x.last % 2 == 0) x += x.last + 2\n      while (x.last\
    \ % 2 == 1) x += x.last + 2\n      x.toList", "        val res = ArrayBuffer.empty[Long]\n\
    \        var x = n\n        for (i <- 1 to n.toInt) {\n            res += x\n\
    \            if (x % 2 == 0) {\n                x += 1\n            } else {\n\
    \                x += 2\n            }\n        }\n        res.toList", "    \
    \    var pile = new ArrayBuffer[Long]\n        var level = n\n        while (level\
    \ != 0) {\n            if (level % 2 == 0) {\n                pile += level\n\
    \                level = level - 1\n            } else {\n                pile\
    \ += level\n                level = level - 2\n            }\n        }\n    \
    \    pile.toList", "        val l = new ListBuffer[Long]\n        var k = n\n\
    \        while (k > 0) {\n            l += k\n            k = if (k % 2 == 0)\
    \ k / 2 else k / 2 + 1\n        }\n        l.toList", "        val ans = ArrayBuffer[Long]()\n\
    \        var curr = n\n        while (curr > 0) {\n            ans += curr\n \
    \           if (curr % 2 == 0) curr -= 1\n            curr -= 1\n        }\n \
    \       ans.toList", "        var l = ListBuffer[Long]()\n        var x = n\n\
    \        while (x > 0) {\n            l += x\n            if (x % 2 == 0) x =\
    \ x / 2 - 1\n            else x = x / 2\n        }\n        l.toList", "     \
    \   if (n == 1) List(1)\n        else List(n) ++ makeAPile(if (n % 2 == 0) n +\
    \ 1 else n + 2)", "      def helper(n : Long, acc : List[Long]) : List[Long] =\
    \ {\n        if (n == 0) acc\n        else {\n          val level = acc.last +\
    \ 2 - (acc.last + 1) % 2\n          helper(n - 1, acc :+ level)\n        }\n \
    \     }\n      helper(n, List(n))", "        var a = n.toLong\n        var result\
    \ = List[Long]()\n        while (a != 0) {\n            result = result :+ a\n\
    \            if (a % 2 == 0) a -= 1\n            a = (a - 1) / 2\n        }\n\
    \        result.reverse", "        val list = new ListBuffer[Long]\n        list\
    \ += n\n        var current = n + (if (n % 2 == 0) 2 else 1)\n        while (current\
    \ < n * 2) {\n            list += current\n            current += (if (current\
    \ % 2 == 0) 2 else 1)\n        }\n        list.toList", "        val p = new ArrayBuffer[Long]\n\
    \        var i = n\n        while (i > 0) {\n            p += i\n            i\
    \ = if (i % 2 == 0) i / 2 else i / 2 + 1\n        }\n        p.toList", "    \
    \    var l = List[Long]()\n        var count = n\n        while (count > 0) {\n\
    \            l = count :: l\n            if (count % 2 == 0) count += 1 else count\
    \ += 2\n        }\n        l", "        val l = ListBuffer[Long]()\n        var\
    \ i = 1L\n        while (n > 0) {\n            l += i\n            n -= 1\n  \
    \          i += 2\n        }\n        l.toList", "        var list = ListBuffer[Long]()\n\
    \        list += n\n        var m = n\n        while (m > 1) {\n            if\
    \ (m % 2 == 0) m = m / 2\n            else m = (m + 1) / 2\n            list +=\
    \ m\n        }\n        list.toList"]
stop_tokens:
- "\n    }\n"
