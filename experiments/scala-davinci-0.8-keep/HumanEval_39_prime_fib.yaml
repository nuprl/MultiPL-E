name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    // >>> prime_fib(1)\n    // 2\n    // >>> prime_fib(2)\n    // 3\n    // >>>\
  \ prime_fib(3)\n    // 5\n    // >>> prime_fib(4)\n    // 13\n    // >>> prime_fib(5)\n\
  \    // 89\n    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        val ps = primeSeq()\n        val fs = fibSeq()\n        val\
    \ zs = ps.zip(fs)\n        zs.filter(p => (p._1 * p._2) % 2 == 1).map(p => p._2).take(n.toInt).last",
  "        def isPrime(n : Long) : Boolean = {\n            if (n == 1) false\n  \
    \          else if (n < 4) true\n            else if (n % 2 == 0) false\n    \
    \        else if (n < 9) true\n            else if (n % 3 == 0) false\n      \
    \      else {\n                val r = floor(sqrt(n)).toLong\n               \
    \ var f = 5L\n                while (f <= r) {\n                    if (n % f\
    \ == 0) return false\n                    if (n % (f + 2) == 0) return false\n\
    \                    f += 6\n                }\n                true\n       \
    \     }\n        }\n        var f = 2L\n        var f1 = 1L\n        var f2 =\
    \ 1L\n        var i = 2L\n        while (i < n) {\n            f = f1 + f2\n \
    \           f1 = f2\n            f2 = f\n            if (isPrime(f)) i += 1\n\
    \        }\n        f", "        var count = 0L\n        var current = 1L\n  \
    \      var previous = 0L\n        while (count < n) {\n            val temp =\
    \ current\n            current = current + previous\n            previous = temp\n\
    \            if (current.isPrime) {\n                count += 1\n            }\n\
    \        }\n        return current", "        def isPrime(n : Long) : Boolean\
    \ = {\n            var i = 2L\n            while (i * i <= n) {\n            \
    \    if (n % i == 0) return false\n                i += 1\n            }\n   \
    \         return true\n        }\n        val fibs = ArrayBuffer(1L, 2L)\n   \
    \     while (fibs.size <= n) {\n            fibs += fibs(fibs.size - 1) + fibs(fibs.size\
    \ - 2)\n        }\n        var i = 0\n        while (i < fibs.size) {\n      \
    \      if (isPrime(fibs(i))) {\n                if (i == n - 1) return fibs(i)\n\
    \                i += 1\n            } else {\n                fibs.remove(i)\n\
    \            }\n        }\n        return fibs(n - 1)", "        // TODO: implement\
    \ using tail recursion\n        def Fib_prime(a : Long, b : Long, c : Long, n\
    \ : Long) : Long = {\n            if (n == 0) c\n            else if (isPrime(a))\
    \ Fib_prime(b, a + b, a, n - 1)\n            else Fib_prime(b, a + b, c, n)\n\
    \        }\n        def isPrime(num : Long) : Boolean = {\n            if (num\
    \ == 2) true\n            else if (num % 2 == 0) false\n            else {\n \
    \               val upper : Long = ceil(sqrt(num.toDouble)).toLong\n         \
    \       var i : Long = 3\n                while (i <= upper) {\n             \
    \       if (num % i == 0) return false\n                    i += 2\n         \
    \       }\n                true\n            }\n        }\n        Fib_prime(2,\
    \ 3, 0, n)", "        val a = ArrayBuffer.empty[Long]\n        a += 2\n      \
    \  a += 3\n        var i = 4\n        var fib = 5\n        while (a.length < n)\
    \ {\n            fib = fib + a(i - 4)\n            if (isPrime(fib)) {\n     \
    \           a += fib\n            }\n            i += 1\n        }\n        return\
    \ a(n - 1)", "        var c = 1\n        var fib = 2L\n        while (c < n) {\n\
    \            fib = Helpers.nextPrimeFib(fib)\n            c += 1\n        }\n\
    \        fib", "        var pfi = Stream.from(1).map(primeFib2).zipWithIndex.find\
    \ { case (x, i) => i == n - 1 }.get._1\n        return pfi._1", "        val fibonacci\
    \ = new ArrayBuffer[Long]()\n        var a = 0L\n        var b = 1L\n        var\
    \ c = a + b\n        fibonacci += a\n        fibonacci += b\n        while (c\
    \ < 10000000000000L) {\n            c = a + b\n            fibonacci += c\n  \
    \          a = b\n            b = c\n        }\n        var count = 0L\n     \
    \   var num = 0L\n        var index = 0\n        while (count < n) {\n       \
    \     if (isPrime(fibonacci(index))) {\n                count += 1\n         \
    \       num = fibonacci(index)\n            }\n            index += 1\n      \
    \  }\n        num", "    \tval p = 50000\n    \tval max = 50000\n    \tval sieve\
    \ = Sieve(p)\n    \tvar ps = sieve.primes\n    \tvar fibs = ArrayBuffer(ps(0),\
    \ ps(1))\n    \tvar k = 2\n    \tvar fib = 0L\n    \twhile (k < max) {\n    \t\
    \tfib = fibs(k - 1) + fibs(k - 2)\n    \t\tif (fib > ps(ps.length - 1)) {\n  \
    \  \t\t\tps = sieve.primes.dropWhile(fib >= _)\n    \t\t}\n    \t\tif (ps.contains(fib))\
    \ {\n    \t\t\tfibs += fib\n    \t\t}\n    \t\tk += 1\n    \t}\n    \treturn fibs(n.toInt\
    \ - 1)", "        var (fibA, fibB) = (2L, 3L)\n        var index = 1\n       \
    \ var currentFib = fibB\n        while (index < n) {\n            currentFib =\
    \ fibA + fibB\n            fibA = fibB\n            fibB = currentFib\n      \
    \      if (Problem.isPrime(currentFib)) {\n                index += 1\n      \
    \      }\n        }\n        currentFib", "        var f1 = 1L; var f2 = 1L; var\
    \ f3 = 2L; var s = 1L\n        for (i <- 1 to n.toInt - 1) {\n            f1 =\
    \ f2; f2 = f3; f3 = f1 + f2\n            while (s < f3) {\n                if\
    \ (s.isPrime) f1 = s\n                s += 1\n            }\n        }\n     \
    \   return f1", "    \tvar a = 2L; var b = 3L; var count = 2L\n    \twhile (count\
    \ < n) {\n    \t\tvar tmp = a + b\n    \t\ta = b\n    \t\tb = tmp\n    \t\tif\
    \ (b.isPrime) count += 1\n    \t}\n    \tb", "        val fibs = Map[Long, Long]((1L,\
    \ 2L), (2L, 3L))\n        def _primeFib(m : Long) : Long = {\n            if (fibs.contains(m))\
    \ fibs(m)\n            else {\n                val fib = _primeFib(m - 1) + _primeFib(m\
    \ - 2)\n                fibs(m) = fib\n                fib\n            }\n  \
    \      }\n        var m = n\n        while (true) {\n            val fib = _primeFib(m)\n\
    \            if (Stream.range(2, sqrt(fib).toInt + 1).forall(fib % _ != 0)) return\
    \ fib\n            m += 1\n        }\n        return 0", "        val fibGen =\
    \ fibSeq(1, 1)\n        fibGen.filter(BigInt(_).isProbablePrime(100)).drop(n.toInt\
    \ - 1).next", "        var p = 2L\n        var cnt = 0L\n        while (cnt <\
    \ n) {\n            if (IsPrime(p) && IsFibonacci(p)) cnt += 1\n            p\
    \ += 1\n        }\n        return p - 1", "    \tvar count = 1\n    \tvar a =\
    \ 1L\n    \tvar b = 1L\n    \tvar c = a + b\n    \twhile (count < n) {\n    \t\
    \tif (isPrime(c)) count += 1\n    \t\tif (count == n) return c\n    \t\ta = b\n\
    \    \t\tb = c\n    \t\tc = a + b\n    \t}\n    \treturn c", "        val ps =\
    \ new PrimeSieve(10000)\n        var cnt = 0\n        var prev = 1\n        var\
    \ now = 2\n        var next = prev + now\n        while (cnt < n) {\n        \
    \    if (ps.isPrime(now)) {\n                cnt += 1\n                prev =\
    \ now\n                now = next\n                next = prev + now\n       \
    \     } else {\n                prev = now\n                now = next\n     \
    \           next = prev + now\n            }\n        }\n        prev", "    \
    \    val stream : Stream[Long] = Stream.cons(2, Stream.cons(3, Stream.from(5,\
    \ 2).filter(e => e.isPrime && (e % 5 == 0 || e % 5 == 1))))\n        fib(stream).drop(n.toInt\
    \ - 1).head", "        val primes = Sieve.sieve(1000000)\n        val map = new\
    \ HashMap[Long, Int]\n        var fib = BigInt(1)\n        var i = 0\n       \
    \ while (i < primes.length) {\n            val prime = primes(i)\n           \
    \ while (fib % prime == 0) {\n                fib /= prime\n                if\
    \ (map.contains(prime)) map(prime) += 1\n                else map(prime) = 1\n\
    \            }\n            i += 1\n        }\n        fib = BigInt(1)\n     \
    \   var j = 2\n        while (map.size < n) {\n            fib *= j\n        \
    \    j += 1\n        }\n        fib.toLong"]
stop_tokens:
- "\n    }\n"
