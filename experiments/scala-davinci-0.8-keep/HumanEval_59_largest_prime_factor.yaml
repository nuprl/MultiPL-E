name: HumanEval_59_largest_prime_factor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  \    // >>> largest_prime_factor(13195)\n    // 29\n    // >>> largest_prime_factor(2048)\n\
  \    // 2\n    def largestPrimeFactor(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestPrimeFactor((15l))\
  \ == (5l));\n    assert(largestPrimeFactor((27l)) == (3l));\n    assert(largestPrimeFactor((63l))\
  \ == (7l));\n    assert(largestPrimeFactor((330l)) == (11l));\n    assert(largestPrimeFactor((13195l))\
  \ == (29l));\n    }\n\n}\n"
completions: ["    \tvar largestFactor = 0L\n    \tvar number = n\n    \twhile (number\
    \ % 2 == 0) {\n    \t\tlargestFactor = 2\n    \t\tnumber /= 2\n    \t}\n    \t\
    var i = 3\n    \twhile (i <= sqrt(number)) {\n    \t\twhile (number % i == 0)\
    \ {\n    \t\t\tlargestFactor = i\n    \t\t\tnumber /= i\n    \t\t}\n    \t\ti\
    \ += 2\n    \t}\n    \tif (number > 2) largestFactor = number\n    \tlargestFactor",
  "        for (i <- 2L to n/2) if (n % i == 0) return largestPrimeFactor(n / i)\n\
    \        n", "        var (x, largestFactor) = (n, 1L)\n        for (i <- 2L to\
    \ round(sqrt(n)) if x > 1) {\n            while (x % i == 0) {\n             \
    \   x /= i\n                largestFactor = i\n            }\n        }\n    \
    \    if (x > 1) largestFactor = x\n        largestFactor", '        (2 to sqrt(n).toInt).filter(p
    => n % p == 0 && isPrime(p)).last', "    \t//var ret = 1L\n        var ret = if\
    \ (n % 2 == 0) 2 else 1\n        var i = 3L\n        while (i <= sqrt(n)) {\n\
    \        \tif (n % i == 0) {\n        \t\tret = i\n        \t\twhile (n % i ==\
    \ 0) n /= i\n        \t}\n        \ti += 2\n        }\n        if (n > 1) ret\
    \ = n\n        return ret", "        var primeFactors = ArrayBuffer[Long]()\n\
    \        var d = 2\n        while (n != 1) {\n            if (n % d == 0) {\n\
    \                primeFactors += d\n                n /= d\n            } else\
    \ {\n                d += 1\n            }\n        }\n        if (primeFactors.isEmpty)\
    \ 1 else primeFactors.max", "        var x = n\n        var l = 2L\n        while\
    \ (x > 1) {\n            if (x % l == 0) {\n                var p = true\n   \
    \             val m = sqrt(l).toLong\n                for (i <- 2L to m) {\n \
    \                   if (l % i == 0) {\n                        p = false\n   \
    \                     x /= i\n                        break\n                \
    \    }\n                }\n                if (p) {\n                    return\
    \ l\n                }\n            }\n            l += 1\n        }\n       \
    \ l", "        val factors = ArrayBuffer[Long]()\n        var cur = n\n      \
    \  while(cur % 2 == 0) {\n            factors += 2\n            cur /= 2\n   \
    \     }\n        var p = 3\n        while(p <= sqrt(cur).toLong) {\n         \
    \   while(cur % p == 0) {\n                factors += p\n                cur /=\
    \ p\n            }\n            p += 2\n        }\n        if(cur > 1) factors\
    \ += cur\n        factors.max", "        if (n % 2 == 0) return largestPrimeFactor(n\
    \ / 2)\n        val largest = (3 to sqrt(n).toInt by 2).find(n % _ == 0).get\n\
    \        largestPrimeFactor(n / largest) max largest", "        val max = (sqrt(n)\
    \ + 1).toLong\n        val primes = (2L to max).filter(BigInt(_).isProbablePrime(1))\n\
    \        for (i <- primes.reverse) {\n            if (n % i == 0) {\n        \
    \        return i\n            }\n        }\n        throw new RuntimeException(\"\
    shouldn't get here\")", "        var x = n\n        var i = 2L\n        while\
    \ (i <= sqrt(x)) {\n            if (x % i == 0) {\n                x /= i\n  \
    \              i -= 1\n            }\n            i += 1\n        }\n        return\
    \ x", "      var max = -1L\n      var number = n\n      while (number % 2 == 0)\
    \ {\n        max = 2\n        number /= 2\n      }\n      val sqrt = ceil(sqrt(number)).toLong\n\
    \      var factor = 3L\n      while (factor <= sqrt) {\n        if (number % factor\
    \ == 0) {\n          max = factor\n          number /= factor\n        } else\
    \ {\n          factor += 2\n        }\n      }\n      if (number > 2) max = number\n\
    \      max", "        var max = -1L\n        var cur = n\n        var i = 2L\n\
    \        while (i <= cur) {\n            if (cur % i == 0) {\n               \
    \ max = i\n                while (cur % i == 0) cur /= i\n            }\n    \
    \        i += 1\n        }\n        max", "        val ps = Prime.primeStream().takeWhile(p\
    \ => p * p <= n)\n        for (p <- ps) {\n            if (n % p == 0) {\n   \
    \             return largestPrimeFactor(n / p)\n            }\n        }\n   \
    \     n", "        val sqrt = sqrt(n).toLong\n        // Compute primes up to\
    \ sqrt(n).\n        val prime = (2L to sqrt).toArray\n        for (i <- 2L to\
    \ sqrt) {\n            if (prime(i.toInt - 2) != 0) {\n                var j =\
    \ i * i\n                while (j <= sqrt) {\n                    prime(j.toInt\
    \ - 2) = 0\n                    j += i\n                }\n            }\n   \
    \     }\n        // Find the largest prime divisor of n.\n        var i = sqrt\n\
    \        while (i >= 2 && n % i != 0) {\n            i -= 1\n        }\n     \
    \   if (i < 2) {\n            n\n        } else {\n            var largestPrimeFactor\
    \ = i\n            val quotient = n / i\n            if (prime(quotient.toInt\
    \ - 2) != 0) {\n                largestPrimeFactor = quotient\n            } else\
    \ {\n                var j = sqrt\n                while (j >= 2 && quotient %\
    \ j != 0) {\n                    j -= 1\n                }\n                if\
    \ (j >= 2) {\n                    largestPrimeFactor = j\n                }\n\
    \            }\n            largestPrimeFactor\n        }", "        var m = n\n\
    \        var factor = 2L\n        while (m % factor == 0) {\n            m /=\
    \ factor\n        }\n        factor = 3L\n        while (m > 1) {\n          \
    \  while (m % factor == 0) {\n                m /= factor\n            }\n   \
    \         factor += 2\n        }\n        factor -= 2\n        factor", "    \
    \    var primeFactors = List[Long]()\n        var number = n\n        var prime\
    \ = 2L\n        while (number > 1) {\n            if (number % prime == 0) {\n\
    \                primeFactors :+= prime\n                number /= prime\n   \
    \         } else {\n                prime += 1\n            }\n        }\n   \
    \     primeFactors.last", "        def process(n : Long, d : Long) : Long = if\
    \ (n % d == 0) process(n / d, d) else if (d * d > n) n else process(n, d + 1)\n\
    \        process(n, 2)", "      def largestPrimeFactorR(n : Long, i : Long) :\
    \ Long = {\n        if (i * i > n) n\n        else if (n % i == 0) largestPrimeFactorR(n\
    \ / i, i)\n        else largestPrimeFactorR(n, i + 1)\n      }\n      largestPrimeFactorR(n,\
    \ 2)", "        val primes = new Sieve(n.toInt / 2).primes\n        var current\
    \ = n\n        var largest = 0L\n        for (prime <- primes) {\n           \
    \ while (current % prime == 0) {\n                current /= prime\n         \
    \       largest = prime\n            }\n        }\n        largest"]
stop_tokens:
- "\n    }\n"
