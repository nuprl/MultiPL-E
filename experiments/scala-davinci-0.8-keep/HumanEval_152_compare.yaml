name: HumanEval_152_compare
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // I think we all remember that feeling when the result of some long-awaited\n\
  \    // event is finally known. The feelings and thoughts you have at that moment\
  \ are\n    // definitely worth noting down and comparing.\n    // Your task is to\
  \ determine if a person correctly guessed the results of a number of matches.\n\
  \    // You are given two arrays of scores and guesses of equal length, where each\
  \ index shows a match. \n    // Return an array of the same length denoting how\
  \ far off each guess was. If they have guessed correctly,\n    // the value is 0,\
  \ and if not, the value is the absolute difference between the guess and the score.\n\
  \    // example:\n    // compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n\
  \    // compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    def compare(game\
  \ : List[Long], guess : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
  \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
completions: ["        if (game.length == guess.length) {\n            game.zip(guess).map(t\
    \ => if (t._1 == t._2) 0 else abs(t._1 - t._2))\n        } else {\n          \
    \  Nil\n        }", "        require(game.length == guess.length)\n        for\
    \ (i <- 0 until game.length) yield abs(game(i) - guess(i))", '        game.zip(guess).map(x
    => abs(x._1 - x._2))', "      var result = new ListBuffer[Long]\n      var delta\
    \ = 0L\n      for (i <- 0 until game.length) {\n        delta = abs(game(i) -\
    \ guess(i))\n        result += delta\n      }\n      result.toList", "       \
    \ val result = ListBuffer[Long]()\n        var i = 0\n        for (e <- game)\
    \ {\n            result += abs(e - guess(i))\n            i += 1\n        }\n\
    \        result.toList", "        val a = game.zip(guess)\n        a.map(x =>\
    \ x._1 - x._2)", "        val l : ListBuffer[Long] = ListBuffer()\n        for\
    \ (i <- 0 until game.length) {\n            l += abs(game(i) - guess(i))\n   \
    \     }\n        l.toList", "        // game and guess are of equal length\n \
    \       // we want to return a list of the same length\n        // the element\
    \ in the list represents how far off the guess was\n        // absolute difference\n\
    \        val diff = for ((g,s) <- game zip guess) yield abs(g - s)\n        diff",
  "        var list = List[Long]()\n        for(i <- 0 until game.length) {\n    \
    \        if(game(i) == guess(i)) {\n                list = list :+ 0\n       \
    \     } else {\n                list = list :+ abs(game(i) - guess(i))\n     \
    \       }\n        }\n        list", '        game.zip(guess).map(g => abs(g._1
    - g._2))', "        game.zip(guess).map {\n            case (g, gs) => abs(g -\
    \ gs)\n        }", '        game.zip(guess).map(x => abs(x._1 - x._2))', '        game.zip(guess).map(p
    => abs(p._1 - p._2))', "    \t// return list of difference of each index\n   \
    \ \tgame.zip(guess).map(x => abs(x._1 - x._2))", "        // check whether the\
    \ same length\n        if (game.length != guess.length) {\n            List()\n\
    \        } else {\n            // map function : (x, y) => x - y\n           \
    \ game.zip(guess).map(Function.tupled(_ - _)).map(abs(_))\n        }", '      game.zip(guess).map(x
    => abs(x._1 - x._2))', "      var output = List[Long]()\n      for (i <- 0 until\
    \ game.length) output = (abs(game(i) - guess(i)) :: output).reverse\n      output",
  "        val res = new ListBuffer[Long]()\n        for (i <- 0 until game.length)\
    \ {\n            if (game(i) == guess(i)) res += 0\n            else res += abs(game(i)\
    \ - guess(i))\n        }\n        res.toList", "        val diff = game.zip(guess).map\
    \ { case (x, y) => abs(x - y) }\n        diff", "        // val res = for (i <-\
    \ 0 until game.length) yield abs(game(i) - guess(i))\n        // res.toList\n\
    \        // List.tabulate(game.length)(i => abs(game(i) - guess(i)))\n       \
    \ (for ((s, g) <- game zip guess) yield abs(s - g)).toList"]
stop_tokens:
- "\n    }\n"
