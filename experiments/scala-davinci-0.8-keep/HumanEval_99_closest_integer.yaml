name: HumanEval_99_closest_integer
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that takes a value (string) representing a number\n  \
  \  // and returns the closest integer to it. If the number is equidistant\n    //\
  \ from two integers, round it away from zero.\n    // Examples\n    // >>> closest_integer(\"\
  10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n    // 15\n    // Note:\n\
  \    // Rounding away from zero means that if the given number is equidistant\n\
  \    // from two integers, the one you should return is the one that is the\n  \
  \  // farthest from zero. For example closest_integer(\"14.5\") should\n    // return\
  \ 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value\
  \ : String) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
  10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
  -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
  0\")) == (0l));\n    }\n\n}\n"
completions: ["        val number = value.toDouble\n        val integer = round(number)\n\
    \        if (abs(number - integer) > 0.5)\n            if (number > 0) integer\
    \ + 1 else integer - 1\n        else integer", "        val n = value.toDouble\n\
    \        // The floor function returns the largest integer\n        // that is\
    \ less than or equal to n\n        if (n - floor(n) >= 0.5) (ceil(n)).toLong\n\
    \        else (floor(n)).toLong", "        val array = value.split(\".\")\n  \
    \      val l = array(0).toLong\n        if (array.length > 1) {\n            val\
    \ r = array(1).toLong\n            if (r >= 50) {\n                l + 1\n   \
    \         } else {\n                l\n            }\n        } else {\n     \
    \       l\n        }", "        val number = value.toDouble\n        val floor\
    \ = math.floor(number)\n        val ceil = math.ceil(number)\n        if (number\
    \ - floor < ceil - number) floor.toLong else ceil.toLong", "        val number\
    \ = value.toDouble\n        val b = BigDecimal(number)\n        val p = b.setScale(0,\
    \ BigDecimal.RoundingMode.HALF_UP)\n        p.toLong", "        // value = (a\
    \ + b) / 2 + c\n        val a = value.indexOf('.')\n        val b = value.lastIndexOf('.')\n\
    \        val c = value.substring(b + 1).toInt\n        val c1 = value.substring(0,\
    \ a).toLong\n        val c2 = value.substring(a + 1, b).toLong\n        if (c\
    \ > 5) c1 + c2 + 1\n        else c1 + c2", "        val n = value.toDouble\n \
    \       if (n > 0) n.round else n.ceil", "        val num = BigDecimal(value)\n\
    \        val int = num.toLong\n        if (num == int) return int\n        if\
    \ (num - int > 0.5) return int + 1\n        return int", "        val n = BigDecimal(value)\n\
    \        if (n < 0) {\n            -closestInteger(\"-\" + value)\n        } else\
    \ {\n            val intN = n.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n \
    \           val intNPlusOne = intN + 1\n            if (n - intN < intNPlusOne\
    \ - n) intN.toLong else intNPlusOne.toLong\n        }", "        val a = value.toDouble.abs\n\
    \        val b = if (a % 1 >= 0.5) ceil(a) else floor(a)\n        if (value.toDouble\
    \ >= 0) b.toLong else -b.toLong", "    \tval number = value.toDouble\n    \tval\
    \ bigger = ceil(number)\n    \tval smaller = floor(number)\n    \tif (abs(number\
    \ - bigger) < abs(number - smaller)) bigger.toLong else smaller.toLong", "   \
    \     val parsed = java.lang.Double.parseDouble(value)\n        if (parsed < 0)\
    \ ceil(parsed).toLong\n        else floor(parsed).toLong", "        val valueAsDouble\
    \ = value.toDouble\n        val (floor, ceil) = (floor(valueAsDouble), ceil(valueAsDouble))\n\
    \        if (abs(floor - valueAsDouble) < abs(ceil - valueAsDouble)) floor.toLong\
    \ else ceil.toLong", "        var result = 0.0\n        val (integer, decimal)\
    \ = split(value)\n        if (decimal.length == 0) {\n            result = integer.toDouble\n\
    \        } else {\n            val x = decimal.toDouble / 10.0\n            if\
    \ (x < 0.5) result = integer.toDouble else result = integer.toDouble + 1.0\n \
    \       }\n        result.toLong", "        var n = BigDecimal(value)\n      \
    \  n.setScale(0, BigDecimal.RoundingMode.HALF_UP).toLong", "        // let's consider\
    \ the rounding away from zero as equivalent to\n        // simply rounding up\n\
    \        var number = BigDecimal(value)\n        var decimalPortion = abs(number\
    \ - number.setScale(0, BigDecimal.RoundingMode.FLOOR))\n        var digits = decimalPortion.toString.split(\"\
    \\\\.\")(1).length\n        if (digits > 0) {\n            var n = BigDecimal(10).pow(digits)\n\
    \            number = number * n\n            decimalPortion = number - number.setScale(0,\
    \ BigDecimal.RoundingMode.FLOOR)\n            if (decimalPortion == BigDecimal(0.5))\
    \ {\n                if (number > 0) {\n                    number = number +\
    \ 1\n                } else {\n                    number = number - 1\n     \
    \           }\n            }\n            number = number.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n\
    \            number = number / n\n        }\n        return number.toLong", " \
    \       try {\n            round(value.toDouble).toLong\n        } catch {\n \
    \           case e : Exception => {\n                throw new Exception(s\"value\
    \ '$value' is not a number\");\n            }\n        }", "        val d = value.toDouble\n\
    \        if (d == d.toLong) d.toLong\n        else if (d > 0) if (d % 1 >= 0.5)\
    \ (d + 1).toLong else d.toLong\n        else if (d % 1 <= -0.5) (d - 1).toLong\
    \ else d.toLong", '        return round(value.toDouble).toLong', "        var\
    \ closest : Long = value.toLong;\n        if (value.contains(\".\")) {\n     \
    \       var head : Double = value.substring(0, value.indexOf(\".\")).toDouble;\n\
    \            var tail : Double = value.substring(value.indexOf(\".\") + 1).toDouble;\n\
    \            closest = round(head);\n            var plus : Double = ceil(head);\n\
    \            var minus : Double = floor(head);\n            var plusDif : Double\
    \ = plus - head;\n            var minusDif : Double = head - minus;\n        \
    \    if (tail != 0) {\n                if (plusDif <= minusDif) closest = plus.toLong;\n\
    \                else closest = minus.toLong;\n            }\n        }\n    \
    \    return closest;"]
stop_tokens:
- "\n    }\n"
