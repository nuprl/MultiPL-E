language: scala
name: HumanEval_5_intersperse
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.isEmpty)\
    \ List()\n        else if (numbers.size == 1) numbers\n        else numbers.head\
    \ :: delimeter :: intersperse(numbers.tail, delimeter)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n      def intersperseInner(numbers\
    \ : List[Long], acc : List[Long]) : List[Long] = {\n        if (numbers.length\
    \ == 0) acc\n        else if (numbers.length == 1) acc :+ numbers(0)\n       \
    \ else intersperseInner(numbers.drop(2), acc :+ numbers(0) :+ delimeter)\n   \
    \   }\n      intersperseInner(numbers, List())\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmjos0tul.scala:19)\n\tat Problem.main(tmpmjos0tul.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n      val sequence : ListBuffer[Long]\
    \ = new ListBuffer[Long]()\n      for (number <- numbers) {\n        sequence\
    \ += number\n        sequence += delimeter\n      }\n      sequence.toList.dropRight(1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n    \t// Iterate over input\
    \ list from index = 1, since we want to insert an element after every element\
    \ of input list.\n    \t// Keep prepending elements of input list and 'delimeter'\
    \ to ListBuffer.\n    \t// Return result after converting ListBuffer to List.\n\
    \    \t(1 until numbers.length).foldLeft(ListBuffer(numbers(0)))((b, index) =>\
    \ b += delimeter += numbers(index)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.intersperse(tmpgrj5yali.scala:13)\n\tat Problem$.main(tmpgrj5yali.scala:16)\n\
    \tat Problem.main(tmpgrj5yali.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.isEmpty)\
    \ numbers\n        else {\n            var result = new ListBuffer[Long]\n   \
    \         for (i <- 0 until numbers.length - 1) {\n                result += numbers(i)\n\
    \                result += delimeter\n            }\n            result += numbers.last\n\
    \            result.toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        def insertDelimeter(numbers\
    \ : List[Long], delimeter : Long, acc : List[Long]) : List[Long] = numbers match\
    \ {\n            case Nil => acc\n            case x :: Nil => insertDelimeter(Nil,\
    \ delimeter, acc :+ x)\n            case x :: xs => insertDelimeter(xs, delimeter,\
    \ acc :+ x :+ delimeter)\n        }\n        insertDelimeter(numbers, delimeter,\
    \ Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        def helper(res : List[Long],\
    \ numbers : List[Long]) : List[Long] = {\n            if (numbers.isEmpty) res\n\
    \            else if (res.isEmpty) helper(List(numbers.head), numbers.tail)\n\
    \            else helper(res :+ delimeter :+ numbers.head, numbers.tail)\n   \
    \     }\n        helper(List(), numbers)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.length\
    \ <= 1) numbers\n        else numbers.head :: delimeter :: intersperse(numbers.tail,\
    \ delimeter)\n    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n    \tif (numbers.length ==\
    \ 0) Nil\n    \telse if (numbers.length == 1) numbers\n    \telse (numbers.head\
    \ :: delimeter :: intersperse(numbers.tail, delimeter))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        def helper(numbers\
    \ : List[Long], delimeter : Long, result : List[Long]) : List[Long] = {\n    \
    \        if (numbers.isEmpty) result.reverse\n            else if (numbers.length\
    \ == 1) result.reverse ::: List(numbers.head)\n            else helper(numbers.tail,\
    \ delimeter, numbers.head :: delimeter :: result)\n        }\n        helper(numbers,\
    \ delimeter, List())\n    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp98rsnn6r.scala:19)\n\tat Problem.main(tmp98rsnn6r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.isEmpty)\
    \ return numbers\n        if (numbers.length == 1) return numbers\n        var\
    \ result = new ListBuffer[Long]\n        result += numbers(0)\n        for (i\
    \ <- 1 until numbers.length) {\n            result += delimeter\n            result\
    \ += numbers(i)\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.length\
    \ <= 1) numbers\n        else numbers.head :: delimeter :: intersperse(numbers.tail,\
    \ delimeter)\n    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        // >>>> Fill the missing\
    \ part\n        var result : List[Long] = List[Long]()\n        for (i <- 0 until\
    \ numbers.length) {\n            result = result :+ numbers(i)\n            if\
    \ (i < numbers.length - 1) {\n                result = result :+ delimeter\n \
    \           }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        def helper(numbers\
    \ : List[Long], delimeter : Long, acc : List[Long]) : List[Long] = {\n       \
    \     if (numbers.length == 0) acc\n            else if (numbers.length == 1)\
    \ acc ::: numbers\n            else helper(numbers.tail, delimeter, acc ::: List(numbers.head,\
    \ delimeter))\n        }\n        helper(numbers, delimeter, List())\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        def intersperse(numbers\
    \ : List[Long], acc : List[Long]) : List[Long] = numbers match {\n           \
    \ case Nil => acc\n            case head :: Nil => head :: acc\n            case\
    \ head :: tail => intersperse(tail, delimeter :: head :: acc)\n        }\n   \
    \     intersperse(numbers, Nil).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        def f(result : List[Long],\
    \ remained : List[Long]) : List[Long] = remained match {\n            case Nil\
    \ => result\n            case _ => f(result :+ remained.head :+ delimeter, remained.tail)\n\
    \        }\n        f(List[Long](), numbers).init\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: init of empty list\n\tat scala.collection.immutable.Nil$.init(List.scala:666)\n\
    \tat scala.collection.immutable.Nil$.init(List.scala:661)\n\tat Problem$.intersperse(tmpb1v913fe.scala:14)\n\
    \tat Problem$.main(tmpb1v913fe.scala:17)\n\tat Problem.main(tmpb1v913fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.isEmpty)\
    \ numbers\n        else numbers.tail.foldLeft(List(numbers.head))((acc, x) =>\
    \ acc :+ delimeter :+ x)\n    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.isEmpty)\
    \ Nil\n        else if (numbers.length == 1) numbers\n        else numbers.head\
    \ :: delimeter :: intersperse(numbers.tail, delimeter)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n\
    \    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)),\
    \ (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong,\
    \ 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong,\
    \ 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.isEmpty)\
    \ List()\n        else numbers.head :: delimeter :: intersperse(numbers.tail,\
    \ delimeter)\n    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
    \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1h7z480m.scala:15)\n\tat Problem.main(tmp1h7z480m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>>\
    \ intersperse([1, 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers\
    \ : List[Long], delimeter : Long) : List[Long] = {\n        if (numbers.length\
    \ == 0) Nil\n        else numbers(0) :: intersperse(numbers.slice(1, numbers.length),\
    \ delimeter) ::: List(delimeter)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
    \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
    \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
    \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe5wary_o.scala:15)\n\tat Problem.main(tmpe5wary_o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820892
