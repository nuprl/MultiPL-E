language: scala
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        var level : Long = 0\n        var maxLevel\
    \ : Long = 0\n        var groups : List[Long] = List()\n        for (i <- 0 until\
    \ paren_string.length) {\n            if (paren_string(i) == '(') {\n        \
    \        level += 1\n                maxLevel = max(maxLevel, level)\n       \
    \     } else if (paren_string(i) == ')') {\n                level -= 1\n     \
    \       } else if (paren_string(i) == ' ') {\n                groups = groups\
    \ :+ maxLevel\n                maxLevel = 0\n            }\n        }\n      \
    \  groups = groups :+ maxLevel\n        return groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        // keep track of the maximum number of consecutive\
    \ open parentheses\n        var max_open_parens = 0\n        // keep track of\
    \ the current level of nested parentheses\n        var current_open_parens = 0\n\
    \        var output = List[Long]()\n        // iterate through the string\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  current_open_parens += 1\n                max_open_parens = max(max_open_parens,\
    \ current_open_parens)\n            } else if (c == ')') {\n                current_open_parens\
    \ -= 1\n            } else if (c == ' ') {\n                output = max_open_parens\
    \ :: output\n                max_open_parens = 0\n                current_open_parens\
    \ = 0\n            }\n        }\n        // for the last one\n        output =\
    \ max_open_parens :: output\n        return output.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n      paren_string.split(\" \").map(s => {\n   \
    \   \ts.toList.foldLeft((0, List[Long]()))((tuple, ch) => {\n          ch match\
    \ {\n            case '(' => (tuple._1 + 1, tuple._2 :+ tuple._1 + 1)\n      \
    \      case ')' => (tuple._1 - 1, tuple._2)\n          }\n        })._2\n    \
    \  }).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjmrdxgr8.scala:17:9\
    \ ---------------------\e[0m\e[0m\n\e[31m10 |\e[0m      paren_string.split(\e\
    [31m\" \"\e[0m).map(\e[36ms\e[0m => {\n\e[31m11 |\e[0m      \ts.toList.foldLeft((\e\
    [31m0\e[0m, List[\e[35mLong\e[0m]()))((\e[36mtuple\e[0m, \e[36mch\e[0m) => {\n\
    \e[31m12 |\e[0m          ch \e[33mmatch\e[0m {\n\e[31m13 |\e[0m            \e\
    [33mcase\e[0m \e[31m'('\e[0m => (tuple._1 + \e[31m1\e[0m, tuple._2 :+ tuple._1\
    \ + \e[31m1\e[0m)\n\e[31m14 |\e[0m            \e[33mcase\e[0m \e[31m')'\e[0m =>\
    \ (tuple._1 - \e[31m1\e[0m, tuple._2)\n\e[31m15 |\e[0m          }\n\e[31m16 |\e\
    [0m        })._2\n\e[31m17 |\e[0m      }).toList\n\e[31m\e[31m   |\e[0m      ^\e\
    [0m\n\e[31m   |\e[0m      Found:    List[\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m]\n\e[31m   |\e[0m      Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n    \tvar paren_groups = paren_string.split(\" \"\
    )\n    \tvar result = List[Long]()\n    \tfor (group <- paren_groups) {\n    \t\
    \tvar cur_result = 1\n    \t\tvar depth = 0\n    \t\tfor (i <- 0 until group.length)\
    \ {\n    \t\t\tif (group(i) == '(') {\n    \t\t\t\tdepth += 1\n    \t\t\t\tcur_result\
    \ = max(cur_result, depth)\n    \t\t\t} else {\n    \t\t\t\tdepth -= 1\n    \t\
    \t\t}\n    \t\t}\n    \t\tresult = result :+ cur_result\n    \t}\n    \tresult\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val max_parens = new ListBuffer[Long]\n\
    \        val paren_list = paren_string.split(\" \")\n        for (paren <- paren_list)\
    \ {\n            val paren_lvl = new ListBuffer[Int]\n            for (c <- paren)\
    \ {\n                c match {\n                    case '(' => paren_lvl += 1\n\
    \                    case ')' => paren_lvl += -1\n                    case _ =>\n\
    \                }\n            }\n            max_parens += paren_lvl.max\n \
    \       }\n        max_parens.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjkevflmv.scala:26)\n\tat Problem.main(tmpjkevflmv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        paren_string.split(\" \").map(x => parseNestedParens2(x.toList,\
    \ 0, 0)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0mfa_ag9.scala:10:41 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).map(\e[36mx\e\
    [0m => parseNestedParens2(x.toList, \e[31m0\e[0m, \e[31m0\e[0m)).toList\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                         Not found: parseNestedParens2\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp0mfa_ag9.scala:10:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).map(\e[36mx\e\
    [0m => parseNestedParens2(x.toList, \e[31m0\e[0m, \e[31m0\e[0m)).toList\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \ No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m              \
    \                            where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        def parse(paren_string : String, temp :\
    \ List[Long]) : List[Long] = {\n            val paren_string_trimmed = paren_string.trim\n\
    \            if (paren_string_trimmed.isEmpty) return temp\n            val paren_string_trimmed_split\
    \ = paren_string_trimmed.split(\" \")\n            val paren_string_first = paren_string_trimmed_split(0)\n\
    \            val paren_string_rest = paren_string_trimmed_split.slice(1, paren_string_trimmed_split.length).mkString(\"\
    \ \")\n            if (paren_string_first.charAt(0) != '(') {\n              \
    \  temp :+ 0\n            } else {\n                var count = 0\n          \
    \      var max = 0\n                for (i <- 0 until paren_string_first.length)\
    \ {\n                    val c = paren_string_first.charAt(i)\n              \
    \      if (c == '(') {\n                        count += 1\n                 \
    \       max = max.max(count)\n                    } else if (c == ')') {\n   \
    \                     count -= 1\n                    }\n                }\n \
    \               parse(paren_string_rest, temp :+ max)\n            }\n       \
    \ }\n        parse(paren_string, List())\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        // Step 1: Split the string by whitespace\n\
    \        val paren_groups = paren_string.split(\" \")\n        val depths = new\
    \ ListBuffer[Long]()\n        // Step 2: For each paren group, determine its depth\n\
    \        for (group <- paren_groups) {\n            var depth = 0\n          \
    \  var max_depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    depth += 1\n                    max_depth = max(max_depth,\
    \ depth)\n                } else if (paren == ')') {\n                    depth\
    \ -= 1\n                }\n            }\n            depths += max_depth\n  \
    \      }\n        depths.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val tokens = paren_string.split(\" \")\n\
    \        var res = List[Long]()\n        for (token <- tokens) {\n           \
    \ var stack = Stack[Char]()\n            var max_depth = 0\n            var count\
    \ = 0\n            for (ch <- token) {\n                if (ch == '(') {\n   \
    \                 stack.push(ch)\n                    count += 1\n           \
    \         max_depth = max(max_depth, count)\n                } else if (ch ==\
    \ ')') {\n                    if (stack.isEmpty) throw new Exception(\"Invalid\
    \ parentheses token!\")\n                    stack.pop\n                    count\
    \ -= 1\n                }\n            }\n            if (!stack.isEmpty) throw\
    \ new Exception(\"Invalid parentheses token!\")\n            res = res :+ max_depth\n\
    \        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val parens = paren_string.toCharArray\n\
    \        val stack = new Stack[Char]\n        var stack_count = 0\n        var\
    \ max_stack_count = 0\n        for (i <- 0 until parens.length) {\n          \
    \  if (parens(i) == '(') {\n                stack.push(parens(i))\n          \
    \      stack_count += 1\n                max_stack_count = max(max_stack_count,\
    \ stack_count)\n            } else if (parens(i) == ')') {\n                stack.pop\n\
    \                stack_count -= 1\n            }\n        }\n        List(max_stack_count)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpik71hhj6.scala:27)\n\tat Problem.main(tmpik71hhj6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        var results = List[Long]()\n        for\
    \ (group <- paren_string.split(\" \")) {\n            var count = 0\n        \
    \    var level = 0\n            for (char <- group) {\n                if (char\
    \ == '(') level += 1\n                else if (char == ')') level -= 1\n     \
    \           if (level > count) count = level\n            }\n            results\
    \ = results :+ count\n        }\n        results\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val stack = new Stack[Long]\n        for\
    \ (i <- 0 until paren_string.length) {\n            paren_string(i) match {\n\
    \                case '(' => {\n                    stack.push(0)\n          \
    \      }\n                case ')' => {\n                    if (stack.isEmpty)\
    \ throw new IllegalArgumentException(\"Invalid input string - too many closing\
    \ parenthesis\")\n                    else {\n                        var total\
    \ = 0\n                        var level = 0\n                        while (!stack.isEmpty\
    \ && stack.top != -1) {\n                            level += 1\n            \
    \                total += stack.pop()\n                        }\n           \
    \             if (stack.isEmpty) throw new IllegalArgumentException(\"Invalid\
    \ input string - too many closing parenthesis\")\n                        else\
    \ {\n                            stack.pop()\n                            stack.push(total\
    \ + level)\n                        }\n                    }\n               \
    \ }\n                case ' ' => {\n                    if (stack.isEmpty) throw\
    \ new IllegalArgumentException(\"Invalid input string - too many spaces\")\n \
    \                   else {\n                        if (stack.top == -1) throw\
    \ new IllegalArgumentException(\"Invalid input string - too many spaces\")\n \
    \                       else stack.push(-1)\n                    }\n         \
    \       }\n                case _ => throw new IllegalArgumentException(\"Invalid\
    \ input string - unrecognized character\")\n            }\n        }\n       \
    \ if (stack.isEmpty) throw new IllegalArgumentException(\"Invalid input string\
    \ - too many spaces\")\n        if (stack.top != -1) throw new IllegalArgumentException(\"\
    Invalid input string - too many closing parenthesis\")\n        return stack.toList.reverse.filter(_\
    \ != -1)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcnhcc9xs.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                            total += stack.pop()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  value += is not a member of Int - did you mean Int.!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659820948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        var paren_groups = paren_string.split(\"\
    \ \")\n        var max_nested_list = new ListBuffer[Long]()\n        for (i <-\
    \ 0 until paren_groups.length) {\n            var paren_group = paren_groups(i)\n\
    \            var max_nested = 0\n            var nested = 0\n            for (c\
    \ <- paren_group) {\n                if (c == '(') nested += 1\n             \
    \   else nested -= 1\n                max_nested = max(max_nested, nested)\n \
    \           }\n            max_nested_list += max_nested\n        }\n        return\
    \ max_nested_list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val stacks = HashMap[Long, Stack[Char]]()\n\
    \        var max_level = 0L\n        paren_string.toCharArray.foreach { paren\
    \ =>\n            paren match {\n                case '(' => {\n             \
    \       max_level += 1\n                    if (!stacks.contains(max_level)) stacks\
    \ += max_level -> Stack[Char]()\n                    stacks(max_level).push(paren)\n\
    \                }\n                case ')' => {\n                    if (stacks(max_level).pop\
    \ != '(') throw new Exception(\"Invalid parenthesis!\")\n                    if\
    \ (stacks(max_level).size == 0) max_level -= 1\n                }\n          \
    \      case _ => throw new Exception(\"Invalid input!\")\n            }\n    \
    \    }\n        stacks.keys.toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.Exception: Invalid input!\n\tat Problem$.parseNestedParens$$anonfun$1(tmp_8x9kymo.scala:23)\n\
    \tat Problem$.parseNestedParens$$anonfun$adapted$1(tmp_8x9kymo.scala:24)\n\tat\
    \ scala.collection.ArrayOps$.foreach$extension(ArrayOps.scala:1333)\n\tat Problem$.parseNestedParens(tmp_8x9kymo.scala:24)\n\
    \tat Problem$.main(tmp_8x9kymo.scala:29)\n\tat Problem.main(tmp_8x9kymo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.toList.map(s => {\n            var count = 0\n   \
    \         s.foreach(c => {\n                if (c == '(') count += 1\n       \
    \         else if (c == ')') count -= 1\n            })\n            count\n \
    \       })\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_x95gsug.scala:21)\n\tat Problem.main(tmp_x95gsug.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        var result = new ListBuffer[Long]\n    \
    \    var parens = paren_string.toList\n        while (!parens.isEmpty) {\n   \
    \         var count = 0\n            var depth = 0\n            var temp = List[Char]()\n\
    \            while (!parens.isEmpty && parens.head != ' ') {\n               \
    \ temp = parens.head :: temp\n                parens = parens.tail\n         \
    \   }\n            parens = parens.tail\n            for (c <- temp) {\n     \
    \           c match {\n                    case '(' => count += 1\n          \
    \          case ')' => count -= 1\n                }\n                depth =\
    \ max(depth, count)\n            }\n            result += depth\n        }\n \
    \       result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.parseNestedParens(tmpfsbzblhi.scala:20)\n\
    \tat Problem$.main(tmpfsbzblhi.scala:33)\n\tat Problem.main(tmpfsbzblhi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_per_group = paren_groups.map(group => group.count(c\
    \ => c == '(') - group.count(c => c == ')')).toList\n        // This is the issue\
    \ ...\n        max_nesting_per_group.map(max_nesting => max_nesting / 2)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcnimtrbo.scala:16)\n\tat Problem.main(tmpcnimtrbo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n      val processed_paren_string = paren_string.replaceAll(\"\
    \ \", \"\")\n      val results = ListBuffer[Long]()\n      var max_depth = 0\n\
    \      var current_depth = 0\n      var i = 0\n      while (i < processed_paren_string.length)\
    \ {\n        if (processed_paren_string(i) == '(') {\n          current_depth\
    \ += 1\n          max_depth = max(max_depth, current_depth)\n        } else if\
    \ (processed_paren_string(i) == ')') {\n          results += max_depth\n     \
    \     current_depth = 0\n          max_depth = 0\n        }\n        i += 1\n\
    \      }\n      results.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe5kg70_6.scala:29)\n\tat Problem.main(tmpe5kg70_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val split_paren_strings = paren_string.split(\"\
    \ \")\n        val results = ArrayBuffer[Long]()\n        for (split_paren_string\
    \ <- split_paren_strings) {\n            var current_depth = 0\n            var\
    \ max_depth = 0\n            for (paren <- split_paren_string) {\n           \
    \     if (paren == '(') {\n                    current_depth += 1\n          \
    \          max_depth = max(max_depth, current_depth)\n                } else if\
    \ (paren == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            results += max_depth\n        }\n        results.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    // [2, 3, 1, 3]\n    def parseNestedParens(paren_string\
    \ : String) : List[Long] = {\n        val res = ListBuffer[Long]()\n        var\
    \ depth = 0\n        for (c <- paren_string) {\n            if (c == '(') depth\
    \ += 1\n            else if (c == ')') {\n                res += depth\n     \
    \           depth -= 1\n            }\n        }\n        res.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_w4s52xd.scala:22)\n\tat Problem.main(tmp_w4s52xd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820949
