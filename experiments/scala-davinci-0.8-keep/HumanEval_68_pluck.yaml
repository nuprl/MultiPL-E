name: HumanEval_68_pluck
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // \"Given an array representing a branch of a tree that has non-negative integer\
  \ nodes\n    // your task is to pluck one of the nodes and return it.\n    // The\
  \ plucked node should be the node with the smallest even value.\n    // If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n    // The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    // If there are no even values or the given array is empty,\
  \ return [].\n    // Example 1:\n    // Input: [4,2,3]\n    // Output: [2, 1]\n\
  \    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
  \    // Example 2:\n    // Input: [1,2,3]\n    // Output: [2, 1]\n    // Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index. \n    // Example\
  \ 3:\n    // Input: []\n    // Output: []\n    // Example 4:\n    // Input: [5,\
  \ 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n    // Explanation: 0 is the smallest value,\
  \ but  there are two zeros,\n    // so we will choose the first zero, which has\
  \ the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n\
  \    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
  \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
  \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
  \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
  \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
  \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
  \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
  \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        var min = -1L\n        var min_index = -1\n        for ((value,\
    \ index) <- arr.zipWithIndex) {\n            if (value % 2 == 0) {\n         \
    \       if (min < 0 || value < min) {\n                    min = value\n     \
    \               min_index = index\n                }\n            }\n        }\n\
    \        if (min < 0) List() else List(min, min_index)", "        var minValue\
    \ = Long.MaxValue\n        var minValueIndex = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < minValue) {\n               \
    \ minValue = arr(i)\n                minValueIndex = i\n            }\n      \
    \  }\n        if (minValue == Long.MaxValue) return List[Long]()\n        else\
    \ return List(minValue, minValueIndex)", "        // Very straightforward solution.\n\
    \        if (arr.length == 0) {\n            return List()\n        }\n      \
    \  val minimumEven = arr.minBy(_.abs)\n        if (minimumEven % 2 == 0) {\n \
    \           return List(minimumEven, arr.indexOf(minimumEven))\n        }\n  \
    \      return List()", "        if (arr.isEmpty) return List()\n        var minimum\
    \ = arr.filter(x => x % 2 == 0).min\n        var index = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) == minimum) {\n              \
    \  index = i\n                break\n            }\n        }\n        if (index\
    \ == -1) return List()\n        return List(minimum, index)", "        if (arr.length\
    \ == 0) {\n            return List()\n        }\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.length == 0) {\n            return List()\n   \
    \     }\n        val min = evens.min\n        val idx = arr.indexOf(min)\n   \
    \     List(min, idx)", "        if (arr.isEmpty) return List()\n        var mini\
    \ = arr.filter(_ % 2 == 0).map(x => (x, arr.indexOf(x))).minBy(_._1)\n       \
    \ return List(mini._1, mini._2)", "        val even = arr.filter(_ % 2 == 0)\n\
    \        if (even.isEmpty) return List()\n        val value = even.min\n     \
    \   return List(value, arr.indexOf(value).toLong)", "        val x = arr.filter(x\
    \ => x % 2 == 0).sorted\n        if (x.isEmpty) List()\n        else {\n     \
    \       val index = arr.indexOf(x.head)\n            List(x.head, index)\n   \
    \     }", "        val l = arr.filter(_ % 2 == 0).sortWith(_ < _)\n        if\
    \ (l.isEmpty) return List()\n        else {\n            val i = arr.indexOf(l.head)\n\
    \            return List(l.head, i)\n        }", "        var res = List[Long]()\n\
    \        if (arr.length == 0) return res\n        var evens = List[Long]()\n \
    \       var odds = List[Long]()\n        var evenIndices = List[Long]()\n    \
    \    var oddIndices = List[Long]()\n        var index = 0\n        for (i <- arr)\
    \ {\n            if (i % 2 == 0) {\n                evens = evens :+ i\n     \
    \           evenIndices = evenIndices :+ index\n            } else {\n       \
    \         odds = odds :+ i\n                oddIndices = oddIndices :+ index\n\
    \            }\n            index += 1\n        }\n        if (evens.length ==\
    \ 0) {\n            var minOdd = odds.reduceLeft((a, b) => if (a <= b) a else\
    \ b)\n            var index = odds.indexOf(minOdd)\n            res = res :+ minOdd\n\
    \            res = res :+ oddIndices(index)\n        } else {\n            var\
    \ minEven = evens.reduceLeft((a, b) => if (a <= b) a else b)\n            var\
    \ index = evens.indexOf(minEven)\n            res = res :+ minEven\n         \
    \   res = res :+ evenIndices(index)\n        }\n        res", "        val tree\
    \ = arr.toArray\n        val (result, _) = pluck(tree, 0)\n        result", " \
    \       if (arr.isEmpty) return List()\n        val minv = arr.min\n        val\
    \ min2 = arr.minBy(v => if (v % 2 == 0) v else Int.MaxValue)\n        if (min2\
    \ == Int.MaxValue) return List()\n        val idx = arr.indexOf(min2)\n      \
    \  List(min2, idx.toLong)", "        var min = Long.MaxValue\n        var smallestIndex\
    \ = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) < min\
    \ && arr(i) % 2 == 0) {\n                min = arr(i)\n                smallestIndex\
    \ = i\n            }\n        }\n        if (smallestIndex == -1) return List()\n\
    \        return List(min, smallestIndex)", "        // println(arr)\n        if\
    \ (arr.length == 0) {\n            return List[Long]()\n        }\n        val\
    \ newarr = arr.filter(_ % 2 == 0)\n        if (newarr.length == 0) {\n       \
    \     return List[Long]()\n        }\n        val newarr2 = newarr.sorted\n  \
    \      val index = arr.indexOf(newarr2(0))\n        if (index >= 0) {\n      \
    \      return List(newarr2(0), index)\n        }\n        return List[Long]()",
  "        var min = -1L\n        var minI = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0) {\n                if (min == -1) {\n  \
    \                  min = arr(i)\n                    minI = i\n              \
    \  } else {\n                    if (arr(i) < min) {\n                       \
    \ min = arr(i)\n                        minI = i\n                    }\n    \
    \            }\n            }\n        }\n        if (min == -1) List() else List(min,\
    \ minI)", "        var i = 0\n        var ans = List[Long]()\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n                if\
    \ (ans.length == 0) ans = List(arr(i), i.toLong)\n                else if (ans(0)\
    \ > arr(i)) ans = List(arr(i), i.toLong)\n            }\n        }\n        ans",
  "        var dict = scala.collection.mutable.Map[Long, List[Long]]()\n        for\
    \ (i <- 0 until arr.length) {\n            if (dict.contains(arr(i))) {\n    \
    \            dict(arr(i)) = dict(arr(i)) :+ i\n            } else {\n        \
    \        dict(arr(i)) = List(i)\n            }\n        }\n        var sortedKeys\
    \ = dict.keys.toList.sorted\n        var min = Long.MaxValue\n        var result\
    \ = List[Long]()\n        for (key <- sortedKeys) {\n            if (key % 2 ==\
    \ 0 && key < min) {\n                min = key\n                result = List(key,\
    \ dict(key).head)\n            }\n        }\n        if (min == Long.MaxValue)\
    \ List() else result", "        var lst = List[Long]()\n        if (arr.length\
    \ < 1) return lst\n        var evens = arr.filter(_ % 2 == 0)\n        if (evens.length\
    \ < 1) return lst\n        var min = evens.min\n        var i = arr.indexOf(min)\n\
    \        return List(min, i)", "        if (arr.size == 0) return List()\n   \
    \     var min = arr.minBy(_ % 2)\n        var minIndex = arr.indexOf(min)\n  \
    \      List(min, minIndex)", "        // Plucking one node from tree is trivial\
    \ and can be done with O(n) complexity.\n        // We are just finding the smallest\
    \ even value and then finding its index.\n        // To make the task more interesting\
    \ we can implement this using Scala Streams,\n        // and reap the benefits\
    \ of lazy evaluation.\n        // The idea is to define infinite streams for the\
    \ array elements,\n        // then filter the even values from the stream,\n \
    \       // and finally take the first element of the filtered stream.\n      \
    \  // This will run in O(1) time complexity (under the assumption that \n    \
    \    // stream operations take constant time) and consume constant space as well.\n\
    \        // Note that the task could be solved using standard Scala collections.\n\
    \        // In that case we need to first transform the array into a stream,\n\
    \        // then filter the even values and finally find the index of the first\
    \ even value.\n        // The advantage of using the stream-based solution is\
    \ to get rid of the\n        // first step. The stream-based solution will not\
    \ perform as fast as the standard\n        // Scala collections-based solution\
    \ in Big-O notation, but it can perform faster\n        // in practice if the\
    \ data set is large.\n        // We will define a stream of array elements by\
    \ creating an infinite stream\n        // and then repeat the array elements in\
    \ an infinite loop.\n        // Finally we will take the required number of elements\
    \ from the stream\n        // to make it infinite. The take() operation will take\
    \ care of that.\n        if (arr.length == 0) return List[Long]()\n        val\
    \ a = Stream.continually(arr).flatten.take(arr.length).toList\n        // Now\
    \ we will filter the even values from the stream by mapping the stream\n     \
    \   // elements to the stream itself or None, if the element is odd.\n       \
    \ // Finally we will take the first element from the stream,\n        // which\
    \ will be the first even value of the array.\n        val b = a.map(x => if (x\
    \ % 2 == 0) Some(x) else None).take(1).head\n        // In case the array doesn't\
    \ contain any even value, the result stream\n        // will contain None, we\
    \ will handle this case by returning [].\n        if (b == None) return List[Long]()\n\
    \        // Otherwise we will find"]
stop_tokens:
- "\n    }\n"
