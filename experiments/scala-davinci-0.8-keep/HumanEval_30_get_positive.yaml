name: HumanEval_30_get_positive
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return only positive numbers in the list.\n    // >>> get_positive([-1,\
  \ 2, -4, 5, 6])\n    // [2, 5, 6]\n    // >>> get_positive([5, 3, -5, 2, -3, 3,\
  \ 9, 0, 123, 1, -10])\n    // [5, 3, 2, 3, 9, 123, 1]\n    def getPositive(l : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getPositive((List[Long](-1l.toLong,\
  \ -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong,\
  \ 6l.toLong))));\n    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong,\
  \ -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
  \ 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));\n    assert(getPositive((List[Long](-1l.toLong,\
  \ -2l.toLong))).equals((List[Long]())));\n    assert(getPositive((List[Long]())).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ['        l.filter(x => x > 0)', '      l.filter(_ > 0)', "        if\
    \ (l.isEmpty) Nil\n        else {\n            val head = l.head\n           \
    \ if (head < 0) getPositive(l.tail)\n            else head :: getPositive(l.tail)\n\
    \        }", '        l.filter(x => x > 0)', "        if (l.isEmpty) {\n     \
    \       return l\n        }\n        if (l.head < 0) {\n            return getPositive(l.tail)\n\
    \        }\n        l.head :: getPositive(l.tail)", '        l.filter((x : Long)
    => (x > 0))', '        l.filter(x => x > 0)', '        return l.filter(x => x
    > 0)', '        l.filter(x => x > 0)', "      val b = l.filter(_ > 0)\n      b",
  '        l.filter(x => x > 0)', "        // 1 2 3 -4 5\n        // 2 3 -4 5\n  \
    \      // 2 3 -4\n        // 2 3\n        // 2\n        // 2 4\n        // 2 4\n\
    \        // 2 4\n        // 2 4\n        // 2 4 5\n        // 2 4 5\n        //\
    \ 2 4 5\n        // 2 4 5\n        // 2 4 5 -1\n        def g(xs : List[Long],\
    \ acc : List[Long]) : List[Long] = {\n            xs match {\n               \
    \ case Nil => acc\n                case x :: tail => {\n                    if\
    \ (x < 0) {\n                        g(tail, acc)\n                    } else\
    \ {\n                        g(tail, x :: acc)\n                    }\n      \
    \          }\n            }\n        }\n        g(l, Nil).reverse", "        var\
    \ r = List[Long]()\n        for (x <- l) {\n            if (x > 0) r ::= x\n \
    \       }\n        r.reverse", '        l.filter(_ > 0)', '        l.filter(_
    > 0)', "        var list = List[Long]()\n        for (i <- l) {\n            if\
    \ (i > 0) list = list :+ i\n        }\n        list", '        l.filter(x => x
    > 0)', '        l.filter(x => x > 0)', '        l.filter(x => x > 0)', '        l.filter(x
    => x > 0)']
stop_tokens:
- "\n    }\n"
