name: HumanEval_145_order_by_points
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function which sorts the given list of integers\n    // in ascending\
  \ order according to the sum of their digits.\n    // Note: if there are several\
  \ items with similar sum of their digits,\n    // order them based on their index\
  \ in original list.\n    // For example:\n    // >>> order_by_points([1, 11, -1,\
  \ -11, -12]) == [-1, -11, 1, -12, 11]\n    // >>> order_by_points([]) == []\n  \
  \  def orderByPoints(nums : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong,\
  \ -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));\n    assert(orderByPoints((List[Long](1234l.toLong,\
  \ 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong,\
  \ 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong,\
  \ 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong,\
  \ 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));\n\
  \    assert(orderByPoints((List[Long]())).equals((List[Long]())));\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong,\
  \ -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));\n\
  \    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong,\
  \ 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 8l.toLong, 9l.toLong))));\n    assert(orderByPoints((List[Long](0l.toLong,\
  \ 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong,\
  \ -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));\n   \
  \ }\n\n}\n"
completions: ["        val numsWithSum = nums.map(num => (num, getDigitSum(num)))\n\
    \        numsWithSum.sortWith(sortOrder).map(x => x._1)", "        if (nums.isEmpty)\
    \ return nums\n        val ds = nums.map(x => (x, sumDigits(x))).zipWithIndex\n\
    \        val sorted = ds.sortWith(cmp)\n        sorted.map(e => e._1._1)", '        nums.sortWith((x,
    y) => (getPoints(x) < getPoints()) || ((getPoints(x) == getPoints(y)) && (nums.indexOf(x)
    < nums.indexOf(y))))', "        def sumDigits(num : Long) : Long = {\n       \
    \     def helper(num : Long, accum : Long) : Long = {\n                if (num\
    \ == 0) accum\n                else helper(num / 10, accum + num % 10)\n     \
    \       }\n            helper(num, 0)\n        }\n        if (nums.isEmpty) nums\n\
    \        else nums.zipWithIndex.sortBy(x => (sumDigits(x._1), x._2)).map(_._1)",
  '        nums.zipWithIndex.sortBy(x => (x._1.toString.map(_.asDigit).sum, x._2)).map(_._1)',
  "      val sortedMap = nums.map(num => (num, num.toString.map(_.asDigit).sum)).sortBy(_._2)\n\
    \      sortedMap.map(_._1)", "        def sumDigits(num : Long) : Long = {\n \
    \           if (num == 0) return 0\n            else return num % 10 + sumDigits(num\
    \ / 10)\n        }\n        return nums.sortWith((x, y) => sumDigits(x) < sumDigits(y)\
    \ || (sumDigits(x) == sumDigits(y) && nums.indexOf(x) < nums.indexOf(y)))", " \
    \       val map = new HashMap[Long, Long]()\n        nums.foreach(x => map +=\
    \ (x -> sumOfDigits(x)))\n        nums.sortWith((x, y) => (map(x) < map(y)) ||\
    \ ((map(x) == map(y)) && (nums.indexOf(x) < nums.indexOf(y))))", "        val\
    \ l = for (i <- nums.indices) yield (nums(i), i)\n        val l2 = l.sortWith((x,\
    \ y) => if (x._1.toString.map(_.asDigit).sum == y._1.toString.map(_.asDigit).sum)\
    \ (x._2 < y._2) else (x._1.toString.map(_.asDigit).sum < y._1.toString.map(_.asDigit).sum))\n\
    \        l2.map(_._1)", "        val nums_with_points = nums.map(x => (x, x.toString.toList.map(x\
    \ => x.asDigit).sum))\n        nums_with_points.sortWith((x, y) => (x._2 != y._2\
    \ && x._2 < y._2) || (x._2 == y._2 && nums.indexOf(x._1) < nums.indexOf(y._1))).map(x\
    \ => x._1)", "        val indexes = nums.zipWithIndex.sortBy(x => sumDigits(x._1)).map(_._2)\n\
    \        nums.zipWithIndex.sortBy(x => indexes.indexOf(x._2)).map(_._1)", "  \
    \      var x = ListBuffer[(Long, Long)]()\n        for (i <- 0 until nums.length)\
    \ x += ((nums(i), getDigitSum(nums(i))))\n        x.toList.sortWith((a, b) =>\
    \ if (a._2 == b._2) a._1 < b._1 else a._2 < b._2).map(a => a._1)", "        val\
    \ p = scala.collection.mutable.Map[Long, Int]()\n        for ((x, i) <- nums.zipWithIndex)\
    \ p(x) = i\n        nums.sortWith((x, y) => {\n            val sumX = x.toString.toCharArray.map(_.toString.toInt).sum\n\
    \            val sumY = y.toString.toCharArray.map(_.toString.toInt).sum\n   \
    \         if (sumX == sumY) p(x) < p(y) else sumX < sumY\n        })", "     \
    \   def orderByPointsHelper(nums : List[Long], digitSums : List[(Long, Int)])\
    \ : List[Long] = {\n            if (nums.isEmpty) Nil\n            else {\n  \
    \              val maxSum = digitSums.maxBy(_._1)._1\n                val maxSumIndices\
    \ = digitSums.zipWithIndex.filter(_._1._1 == maxSum).map(_._2)\n             \
    \   if (maxSumIndices.length == 1) {\n                    nums(maxSumIndices.head)\
    \ :: orderByPointsHelper(nums.patch(maxSumIndices.head, Nil, 1), digitSums.patch(maxSumIndices.head,\
    \ Nil, 1))\n                } else {\n                    val minIndex = maxSumIndices.min\n\
    \                    nums(minIndex) :: orderByPointsHelper(nums.patch(minIndex,\
    \ Nil, 1), digitSums.patch(minIndex, Nil, 1))\n                }\n           \
    \ }\n        }\n        def digitSum(num : Long) : Long = {\n            var sum\
    \ = 0L\n            var n = num\n            while (n != 0) {\n              \
    \  sum += n % 10\n                n /= 10\n            }\n            sum\n  \
    \      }\n        val digitSums = nums.map(num => (digitSum(num), nums.indexOf(num)))\n\
    \        orderByPointsHelper(nums, digitSums)", "        nums.sortWith((a, b)\
    \ => {\n            val aSum = a.toString.map(x => (x - '0').toLong).sum\n   \
    \         val bSum = b.toString.map(x => (x - '0').toLong).sum\n            if\
    \ (aSum < bSum) true\n            else if (aSum > bSum) false\n            else\
    \ nums.indexOf(a) < nums.indexOf(b)\n        })", "        val sums = nums.map\
    \ { x => (x, x.toString.map { _.asDigit }.sum) }\n        sums.sortWith { (x,\
    \ y) => if (x._2 == y._2) x._1 < y._1 else x._2 < y._2 }.map { _._1 }", "    \
    \    // can't use Map with Long key here, will get\n        // Exception in thread\
    \ \"main\" java.lang.ClassCastException: scala.Long cannot be cast to java.lang.Long\n\
    \        //val dp = new HashMap[Long, List[Long]]()\n        val dp = new HashMap[Int,\
    \ List[Long]]()\n        def getSum(num : Long) : Int = {\n            if (num\
    \ == 0) return 0\n            return (num % 10).toInt + getSum(num / 10)\n   \
    \     }\n        for (i <- 0 until nums.length) {\n            val key = getSum(nums(i))\n\
    \            if (!dp.contains(key)) dp(key) = List()\n            dp(key) = nums(i)\
    \ :: dp(key)\n        }\n        val sortedPoints = dp.keySet.toList.sorted\n\
    \        var ans = List[Long]()\n        for (point <- sortedPoints) {\n     \
    \       ans = dp(point) ::: ans\n        }\n        return ans", '        nums.zipWithIndex.sortBy(x
    => (x._1.toString.toList.map(_.asDigit).sum, x._2)).map(_._1)', '        nums.zipWithIndex.sortBy(x
    => (x._1.toString.map(_.asDigit).sum, x._2)).map(_._1)', "        val n = nums.length\n\
    \        if (n == 0) return nums\n        val sum = Array.fill(n)(0)\n       \
    \ for (i <- 0 until n) {\n            var num = nums(i)\n            while (num\
    \ != 0) {\n                sum(i) += num % 10\n                num /= 10\n   \
    \         }\n        }\n        val d = Array.fill(n)(0)\n        var z = 0\n\
    \        var i = 0\n        while (i < n) {\n            val j = sum.indexOf(sum.min)\n\
    \            sum(j) = Int.MaxValue\n            d(z) = nums(j)\n            z\
    \ += 1\n            i += 1\n        }\n        d.toList"]
stop_tokens:
- "\n    }\n"
