language: scala
name: HumanEval_130_tri
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        def tri_help(n : Long, result : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) result\n            else {\n                val\
    \ l = result.length\n                tri_help(n - 1, result :+ (if (n % 2 == 0)\
    \ n / 2 else result(l - 1) + result(l - 2) + result(l - 3)))\n            }\n\
    \        }\n        tri_help(n, List(1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri_help$1(tmp6khbdygo.scala:24)\n\tat Problem$.tri(tmp6khbdygo.scala:27)\n\
    \tat Problem$.main(tmp6khbdygo.scala:30)\n\tat Problem.main(tmp6khbdygo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        val buffer = new ArrayBuffer[Long]\n        buffer\
    \ += 1\n        buffer += 3\n        buffer += 2\n        var i = 0\n        while\
    \ (i < n) {\n            val num = buffer(i)\n            if (num % 2 == 0) {\n\
    \                buffer += (1 + num / 2)\n            } else {\n             \
    \   buffer += (buffer(i - 1) + buffer(i - 2) + buffer(i + 1))\n            }\n\
    \            i += 1\n        }\n        buffer.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:98)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri(tmptpm8kpw7.scala:30)\n\
    \tat Problem$.main(tmptpm8kpw7.scala:37)\n\tat Problem.main(tmptpm8kpw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        if (n == 0) return List(1)\n        val t = new Array[Long](n.toInt\
    \ + 1)\n        t(0) = 1\n        t(1) = 3\n        t(2) = 2\n        for (i <-\
    \ 3 to n.toInt) {\n            if (i % 2 == 0) t(i) = 1 + i / 2\n            else\
    \ t(i) = t(i - 1) + t(i - 2) + t(i + 1)\n        }\n        t.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmp0ppoxwy9.scala:27)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp0ppoxwy9.scala:28)\n\
    \tat Problem$.main(tmp0ppoxwy9.scala:32)\n\tat Problem.main(tmp0ppoxwy9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        def solve(n : Long, cache : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) {\n                cache\n            } else {\n\
    \                val t = if (n % 2 == 0) (1 + n / 2) else (cache(0) + cache(1)\
    \ + cache(2))\n                solve(n - 1, t :: cache)\n            }\n     \
    \   }\n        solve(n, List(3, 1, 2)).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ftppd97.scala:31)\n\tat Problem.main(tmp2ftppd97.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        // tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1),\
    \ if n is odd.\n        // tri(n - 1) = tri(n - 2) + tri(n - 3) + tri(n)\n   \
    \     // tri(n) = tri(n - 1) + tri(n - 2) + tri(n - 3) + tri(n - 2) + tri(n -\
    \ 3) + tri(n - 1)\n        // = 2 * tri(n - 1) + tri(n - 3)\n        val m = n\
    \ + 1\n        val a = Array.fill(m.toInt)(0L)\n        a(0) = 1\n        a(1)\
    \ = 3\n        a(2) = 2\n        for (i <- 3 to m.toInt - 1) {\n            a(i)\
    \ = 2 * a(i - 1) + a(i - 3)\n        }\n        a.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoh6rg2v8.scala:35)\n\tat Problem.main(tmpoh6rg2v8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        def triImpl(i : Long, a : Long, b : Long, c : Long)\
    \ : List[Long] = {\n            if (i == n) List(a, b, c)\n            else if\
    \ (i % 2 == 0) triImpl(i + 1, b, c, 1 + i / 2)\n            else triImpl(i + 1,\
    \ b, c, a + b + c)\n        }\n        triImpl(1, 1, 3, 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb6_8j9yk.scala:28)\n\tat Problem.main(tmpb6_8j9yk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        val a : Array[Long] = Array(1, 3, 2)\n        def\
    \ f(n : Long) : List[Long] = {\n            if (n == 1) return List(a(0))\n  \
    \          else if (n == 2) return List(a(0), a(1))\n            else if (n ==\
    \ 3) return List(a(0), a(1), a(2))\n            else {\n                for (i\
    \ <- 4 to n.toInt) {\n                    if (i % 2 == 0) a(2) = 1 + i / 2\n \
    \                   else a(2) = a(0) + a(1) + a(2)\n                    a(0) =\
    \ a(1)\n                    a(1) = a(2)\n                }\n                return\
    \ a.toList\n            }\n        }\n        return f(n)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqi88rvb8.scala:38)\n\tat Problem.main(tmpqi88rvb8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n    \tif (n == 0) List(1)\n    \telse {\n    \t\tval result\
    \ = new ListBuffer[Long]\n    \t\tresult += 1\n    \t\tresult += 3\n    \t\tresult\
    \ += 2\n    \t\tvar i = 2\n    \t\twhile (i < n) {\n    \t\t\tval k = result(i)\n\
    \    \t\t\tval j = result(i - 1)\n    \t\t\tval l = result(i - 2)\n    \t\t\t\
    result += (k + j + l)\n    \t\t\ti += 1\n    \t\t}\n    \t\tresult.toList\n  \
    \  \t}\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6xccx2pq.scala:38)\n\tat Problem.main(tmp6xccx2pq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        val cache = new HashMap[Long, Long]()\n        def\
    \ tri(n : Long) : Long = {\n            if (n == 1) 3\n            else if (n\
    \ == 2) 2\n            else if (n == 3) 8\n            else if (cache.contains(n))\
    \ cache(n)\n            else {\n                val result = if (n % 2 == 0) 1\
    \ + n / 2 else tri(n - 1) + tri(n - 2) + tri(n + 1)\n                cache(n)\
    \ = result\n                result\n            }\n        }\n        (1 to n\
    \ + 1).map(tri).toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpct3r1lp4.scala:32:14\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri).toList\n\e[31m\e[31m   |\e[0m              ^^^^^\e[0m\n\
    \e[31m   |\e[0m              Found:    Long\n\e[31m   |\e[0m              Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpct3r1lp4.scala:32:25\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri).toList\n\e[31m\e[31m   |\e[0m                       \
    \  ^^^\e[0m\n\e[31m   |\e[0m                         Found:    \e[1m\e[31mLong\e\
    [0m => Long\n\e[31m   |\e[0m                         Required: \e[1m\e[32mInt\e\
    [0m => Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n    \tval s = new Queue[Long]\n    \ts += 1\n    \tif (n >\
    \ 0) s += 3\n    \tif (n > 1) s += 2\n    \tif (n > 2) for (i <- 3 to n) s +=\
    \ s(i - 3) + s(i - 2) + s(i - 1)\n    \ts.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsv7dk7u2.scala:24:34\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m    \t\e[33mif\e[0m (n > \e[31m2\e\
    [0m) \e[33mfor\e[0m (i <- \e[31m3\e[0m to n) s += s(i - \e[31m3\e[0m) + s(i -\
    \ \e[31m2\e[0m) + s(i - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m    \t           \
    \               ^\e[0m\n\e[31m   |\e[0m    \t                          Found:\
    \    (n : Long)\n\e[31m   |\e[0m    \t                          Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        val memo = new HashMap[Long, Long]\n        memo(1)\
    \ = 3\n        memo(2) = 2\n        memo(3) = 8\n        def compute(n : Long)\
    \ : Long = {\n            if (memo.contains(n)) memo(n)\n            else {\n\
    \                val result = if (n % 2 == 0) (1 + n / 2) else (compute(n - 1)\
    \ + compute(n - 2) + compute(n + 1))\n                memo(n) = result\n     \
    \           result\n            }\n        }\n        List.range(1, n + 2).map(compute(_))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpf8jwo744.scala:32:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        List.range(\e[31m1\e[0m, n + \e[31m2\e[0m).map(compute(_))\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       No implicit Ordering defined for AnyVal.\n1 error found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        val a = Array.fill(n.toInt + 1)(0)\n        a(0) =\
    \ 1\n        a(1) = 3\n        a(2) = 2\n        for (i <- 3 to n.toInt) {\n \
    \           a(i) = if (i % 2 == 0) a(i - 1) + a(i - 2) + a(i + 1) else (1 + i\
    \ / 2)\n        }\n        a.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp64hhc_cf.scala:27:10\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        a.toList\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e\
    [31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n    \tif (n == 0) return List(1)\n    \tif (n == 1) return\
    \ List(1, 3)\n    \tif (n == 2) return List(1, 3, 2)\n    \tvar res = List(1,\
    \ 3, 2)\n    \tvar i = 3\n    \twhile (i <= n) {\n    \t\tif (i % 2 == 0) res\
    \ = res :+ (1 + i / 2)\n    \t\telse res = res :+ (res(i - 1) + res(i - 2) + res(i\
    \ + 1))\n    \t\ti += 1\n    \t}\n    \tres\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6xpdxiab.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m    \tres\n\e[31m\e[31m   |\e\
    [0m    \t^^^\e[0m\n\e[31m   |\e[0m    \tFound:    (res : List[Int])\n\e[31m  \
    \ |\e[0m    \tRequired: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        if (n == 0) return List(1)\n        val cache = new\
    \ Array[Long](n.toInt + 1)\n        cache(0) = 1\n        cache(1) = 3\n     \
    \   cache(2) = 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 ==\
    \ 0) cache(i) = 1 + i / 2\n            else cache(i) = cache(i - 1) + cache(i\
    \ - 2) + cache(i + 1)\n        }\n        return cache.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpzxp6ovgs.scala:27)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpzxp6ovgs.scala:28)\n\
    \tat Problem$.main(tmpzxp6ovgs.scala:32)\n\tat Problem.main(tmpzxp6ovgs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        var map = Map[Long, Long]()\n        map(1) = 3\n\
    \        def loop(i : Long) : Long = {\n            if (map.contains(i)) map(i)\n\
    \            else {\n                val result = if (i % 2 == 0) 1 + i / 2 else\
    \ loop(i - 1) + loop(i - 2) + loop(i + 1)\n                map(i) = result\n \
    \               result\n            }\n        }\n        List.range(1, n + 2).map(loop(_))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1daa2ell.scala:30:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        List.range(\e[31m1\e[0m, n + \e[31m2\e[0m).map(loop(_))\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       No implicit Ordering defined for AnyVal.\n1 error found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        var memo = new HashMap[Long, Long]\n        memo(1)\
    \ = 3\n        memo(2) = 2\n        for (i <- 3 to n) {\n            if (i % 2\
    \ == 0) memo(i) = 1 + i / 2\n            else memo(i) = memo(i - 1) + memo(i -\
    \ 2) + memo(i + 1)\n        }\n        List(1) ++ (for (i <- 0 to n.toInt) yield\
    \ memo(i)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd16sa_ti.scala:23:23\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m3\e[0m to n) {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       Found:    (n : Long)\n\e[31m   |\e[0m    \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpd16sa_ti.scala:27:8 ---------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        List(\e[31m1\e[0m) ++ (\e[33mfor\e[0m (i <- \e[31m0\e[0m to n.toInt)\
    \ \e[33myield\e[0m memo(i)).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        val cache = new HashMap[Long, Long]\n        cache\
    \ += 1 -> 3\n        def triHelper(index : Long) : Long = cache.get(index) match\
    \ {\n            case Some(value) => value\n            case None => {\n     \
    \           val value = if (index % 2 == 0) index / 2 + 1 else triHelper(index\
    \ - 1) + triHelper(index - 2) + triHelper(index + 1)\n                cache +=\
    \ index -> value\n                value\n            }\n        }\n        (1\
    \ to n + 1).map(x => triHelper(x)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqkigw9hu.scala:21:17\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        cache += \e[31m1\e[0m\
    \ -> \e[31m3\e[0m\n\e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                 Found:    (Int, Int)\n\e[31m   |\e[0m              \
    \   Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqkigw9hu.scala:30:14 --------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        (\e[31m1\e[0m to n + \e[31m1\e[0m).map(\e[36mx\e[0m => triHelper(x)).toList\n\
    \e[31m\e[31m   |\e[0m              ^^^^^\e[0m\n\e[31m   |\e[0m              Found:\
    \    Long\n\e[31m   |\e[0m              Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        var result = List[Long]()\n        var a = 1\n   \
    \     var b = 3\n        var c = 2\n        result = result :+ 1\n        if (n\
    \ > 0) {\n            result = result :+ 3\n            if (n > 1) {\n       \
    \         result = result :+ 2\n                if (n > 2) {\n               \
    \     for (i <- 3 to n.toInt) {\n                        if (i % 2 == 0) {\n \
    \                           var d = a + 1 + i / 2\n                          \
    \  result = result :+ d\n                            a = b\n                 \
    \           b = c\n                            c = d\n                       \
    \ } else {\n                            var d = a + b + c\n                  \
    \          result = result :+ d\n                            a = b\n         \
    \                   b = c\n                            c = d\n               \
    \         }\n                    }\n                }\n            }\n       \
    \ }\n        return result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyuq2gza9.scala:51)\n\tat Problem.main(tmpyuq2gza9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        var result = ListBuffer[Long]()\n        if (n <=\
    \ 1) {\n            result += 1\n            result += 2\n            result +=\
    \ 3\n        } else {\n            var a = 1L\n            var b = 2L\n      \
    \      var c = 3L\n            result += a\n            result += b\n        \
    \    result += c\n            for (i <- 3L to n) {\n                val newnum\
    \ = if (i % 2 == 0) 1 + i / 2 else a + b + c\n                result += newnum\n\
    \                a = b\n                b = c\n                c = newnum\n  \
    \          }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl3sbjry5.scala:43)\n\tat Problem.main(tmpl3sbjry5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long)\
    \ : List[Long] = {\n        val a = Array.fill(n.toInt + 1)(0L)\n        a(0)\
    \ = 1\n        a(1) = 3\n        for (i <- 2 to n.toInt) {\n            a(i) =\
    \ if (i % 2 == 0) 1 + i / 2\n            else a(i - 1) + a(i - 2) + a(i + 1)\n\
    \        }\n        a.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpsi8fjheh.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpsi8fjheh.scala:26)\n\
    \tat Problem$.main(tmpsi8fjheh.scala:30)\n\tat Problem.main(tmpsi8fjheh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820888
