name: HumanEval_70_strange_sort_list
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of integers, return list in strange order.\n    // Strange sorting,\
  \ is when you start with the minimum value,\n    // then maximum of the remaining\
  \ integers, then minimum and so on.\n    // Examples:\n    // strange_sort_list([1,\
  \ 2, 3, 4]) == [1, 4, 2, 3]\n    // strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
  \ 5]\n    // strange_sort_list([]) == []\n    def strangeSortList(lst : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(strangeSortList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong,\
  \ 7l.toLong))));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong,\
  \ 8l.toLong, 6l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong,\
  \ 5l.toLong))));\n    assert(strangeSortList((List[Long]())).equals((List[Long]())));\n\
  \    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong,\
  \ 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long](0l.toLong,\
  \ 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong,\
  \ 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n\
  \    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        var ans = List[Long]()\n        var lstCopy = lst.sorted\n\
    \        while (lstCopy.size > 0) {\n            if (lstCopy.size > 1) {\n   \
    \             ans = lstCopy.head :: ans\n                ans = lstCopy.last ::\
    \ ans\n            } else {\n                ans = lstCopy.head :: ans\n     \
    \       }\n            lstCopy = lstCopy.drop(1).dropRight(1)\n        }\n   \
    \     ans.reverse", "        var nums = lst.sorted\n        var odd = true\n \
    \       var result = List[Long]()\n        while (nums.length > 0) {\n       \
    \     if (odd) {\n                result = result :+ nums.head\n             \
    \   nums = nums.tail\n            } else {\n                result = result :+\
    \ nums.last\n                nums = nums.init\n            }\n            odd\
    \ = !odd\n        }\n        result", "        var l = lst.sortWith(_ < _)\n \
    \       var min = l.head\n        var max = l.last\n        var min_index = l.indexOf(min)\n\
    \        var max_index = l.indexOf(max)\n        var d = l.size / 2\n        var\
    \ lst_new = ListBuffer[Long]()\n        for (i <- 0 until d) {\n            lst_new\
    \ += min\n            lst_new += max\n            l = l.slice(0, min_index) ++\
    \ l.slice(min_index + 1, l.size)\n            l = l.slice(0, max_index) ++ l.slice(max_index\
    \ + 1, l.size)\n            min = l.head\n            max = l.last\n         \
    \   min_index = l.indexOf(min)\n            max_index = l.indexOf(max)\n     \
    \   }\n        if (l.size > 0) lst_new += l.head\n        lst_new.toList", " \
    \       val lst2 = SortedSet[Long]() ++ lst\n        val lst3 = SortedSet[Long]()\
    \ ++ lst\n        val n = lst.length\n        val N = if (n % 2 == 0) n / 2 else\
    \ n / 2 + 1\n        var result = List[Long]()\n        for (i <- 0 until N) {\n\
    \            val x = lst2.min\n            val y = lst3.max\n            result\
    \ = result :+ x :+ y\n            lst2 -= x\n            lst3 -= y\n        }\n\
    \        result", "        val sorted = lst.sorted\n        val n = sorted.length\n\
    \        if (n == 0) return List()\n        val evens = sorted.drop(1).sliding(2,\
    \ 2).map(_(0)).toList\n        val odds = sorted.drop(1).sliding(2, 2).map(_(1)).toList\n\
    \        if (n % 2 == 0) return List(sorted(0)) ++ evens ++ odds\n        else\
    \ return List(sorted(0)) ++ odds ++ evens", "        if (lst.isEmpty) return lst\n\
    \        var list = lst.sorted\n        var min = list.head\n        var max =\
    \ list.last\n        var output = ListBuffer[Long]()\n        output += min\n\
    \        while (list.nonEmpty) {\n            if (list.head == min) {\n      \
    \          output += max\n                list = list.tail\n            } else\
    \ if (list.head == max) {\n                output += min\n                list\
    \ = list.tail\n            } else {\n                var min_idx = list.indexOf(list.min)\n\
    \                var max_idx = list.indexOf(list.max)\n                var min_val\
    \ = list(min_idx)\n                var max_val = list(max_idx)\n             \
    \   if (abs(min_idx - max_idx) % 2 == 0) {\n                    output += min_val\n\
    \                    output += max_val\n                } else {\n           \
    \         output += max_val\n                    output += min_val\n         \
    \       }\n                list = list.patch(min_idx, Nil, 1)\n              \
    \  list = list.patch(max_idx - 1, Nil, 1)\n            }\n        }\n        output.toList",
  "        // First, sort the array.\n        val sorted = lst.sorted\n        //\
    \ Then, get starting index where the maximum first.\n        var start = 0\n \
    \       var end = sorted.length - 1\n        var isMax = true\n        val result\
    \ = new ArrayBuffer[Long]\n        while (start < end) {\n            if (isMax)\
    \ {\n                result += sorted(end)\n                end -= 1\n       \
    \     } else {\n                result += sorted(start)\n                start\
    \ += 1\n            }\n            isMax = !isMax\n        }\n        if (start\
    \ == end) result += sorted(start)\n        result.toList", "        def strangeSort(lst\
    \ : List[Long], sorted : List[Long]) : List[Long] = {\n            if (lst.length\
    \ == 0) return sorted\n            val min = lst.min\n            val max = lst.max\n\
    \            strangeSort(lst.filter(_ != min).filter(_ != max), min :: max ::\
    \ sorted)\n        }\n        strangeSort(lst, List()).reverse", "    \tif (lst.isEmpty)\
    \ Nil\n    \telse {\n    \t\tval m = lst.min\n    \t\tval l = lst.max\n    \t\t\
    val r = lst.filter(x => x != m && x != l)\n    \t\tval r1 = strangeSortList(r)\n\
    \    \t\tm :: l :: r1\n    \t}", "        val sorted = lst.sorted\n        def\
    \ loop(start : Int, end : Int, result : List[Long]) : List[Long] = {\n       \
    \     if (start == end) result.reverse\n            else {\n                val\
    \ min = sorted(start)\n                val max = sorted(end)\n               \
    \ loop(start + 1, end - 1, min :: max :: result)\n            }\n        }\n \
    \       if (lst.isEmpty) List()\n        else if (lst.size == 1) List(lst.head)\n\
    \        else if (lst.size == 2) List(lst.min, lst.max)\n        else loop(0,\
    \ sorted.size - 1, List())", "        if (lst.isEmpty) return lst\n        var\
    \ list = lst.sorted\n        var result = new ListBuffer[Long]\n        result\
    \ += list.head\n        result += list.last\n        list = list.drop(1).dropRight(1)\n\
    \        while (list.nonEmpty) {\n            result += list.min\n           \
    \ result += list.max\n            list = list.drop(1).dropRight(1)\n        }\n\
    \        result.toList", "        var res = List[Long]()\n        val buf = ListBuffer[Long]()\n\
    \        buf ++= lst\n        while (buf.length > 0) {\n            val p = buf.indexOf(buf.min)\n\
    \            val q = buf.indexOf(buf.max)\n            res = buf(p) :: res\n \
    \           buf.remove(p)\n            if (p != q) {\n                res = buf(q\
    \ - 1) :: res\n                buf.remove(q - 1)\n            }\n        }\n \
    \       res", "        if (lst.length == 0) return List()\n        val sortedList\
    \ = lst.sorted\n        val startIndex = sortedList.length / 2\n        var leftIndex\
    \ = startIndex\n        var rightIndex = startIndex - 1\n        val b = new ListBuffer[Long]\n\
    \        var i = 0\n        while (i < sortedList.length) {\n            if (i\
    \ % 2 == 0) {\n                b += sortedList(leftIndex)\n                leftIndex\
    \ += 1\n            } else {\n                b += sortedList(rightIndex)\n  \
    \              rightIndex -= 1\n            }\n            i += 1\n        }\n\
    \        b.toList", "        def strangeSortListRecur(min : Long, lst : List[Long],\
    \ minFlag : Boolean) : List[Long] = {\n            if (lst.isEmpty) Nil\n    \
    \        else if (minFlag) min :: strangeSortListRecur(lst.min, lst diff List(lst.min),\
    \ false)\n            else lst.max :: strangeSortListRecur(lst.min, lst diff List(lst.max),\
    \ true)\n        }\n        if (lst.isEmpty) Nil\n        else strangeSortListRecur(lst.min,\
    \ lst diff List(lst.min), false)", "        def helper(lst : List[Long], acc :\
    \ List[Long]) : List[Long] = {\n            if (lst.isEmpty) return acc\n    \
    \        val sorted = lst.sorted\n            val min = sorted.head\n        \
    \    val max = sorted.last\n            val newMin = sorted.filter(_ != min).filter(_\
    \ != max)\n            val newAcc = acc :+ min :+ max\n            helper(newMin,\
    \ newAcc)\n        }\n        helper(lst, List())", "        if (lst.length ==\
    \ 0) return lst\n        lst.sortWith(_ < _)\n        val l = lst.length\n   \
    \     val front = lst.slice(0, l / 2)\n        val back = lst.slice(l / 2, l)\n\
    \        var i = 0\n        var result = List[Long]()\n        while (i < l /\
    \ 2) {\n            result = result :+ front(i)\n            result = result :+\
    \ back(i)\n            i += 1\n        }\n        if (l % 2 == 1) result = result\
    \ :+ front(i)\n        result", "        if (lst.length == 0) lst\n        else\
    \ {\n            var (min, max) = (lst.min, lst.max)\n            var newlst =\
    \ lst.filter(x => x != min && x != max)\n            List(min) ::: List(max) :::\
    \ strangeSortList(newlst)\n        }", "        var map = Map[Long, List[Long]]()\n\
    \        var res = List[Long]()\n        var min = Long.MaxValue\n        var\
    \ max = Long.MinValue\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) = map(i) :+ i\n            else map += (i -> List(i))\n            min\
    \ = min min i\n            max = max max i\n        }\n        while (res.length\
    \ < lst.length) {\n            if (map.contains(min)) {\n                res =\
    \ res :+ map(min).head\n                map(min) = map(min).tail\n           \
    \     if (map(min).length == 0) map -= min\n            }\n            if (map.contains(max))\
    \ {\n                res = res :+ map(max).head\n                map(max) = map(max).tail\n\
    \                if (map(max).length == 0) map -= max\n            }\n       \
    \     min = map.keys.min\n            max = map.keys.max\n        }\n        res",
  "      val n = lst.length\n      val (l, r) = lst.splitAt(n / 2)\n      if (n ==\
    \ 0) List()\n      else if (n == 1) lst\n      else {\n        val sl = strangeSortList(l)\n\
    \        val sr = strangeSortList(r)\n        var i = 0\n        var (xl, xr)\
    \ = (0, 0)\n        var result = List[Long]()\n        for (i <- 0 until n) {\n\
    \          if (i % 2 == 0) {\n            result = result :+ sl(xl)\n        \
    \    xl += 1\n          } else {\n            result = result :+ sr(xr)\n    \
    \        xr += 1\n          }\n        }\n        result\n      }", "        if\
    \ (lst.length % 2 == 0) {\n            val p = lst.sortWith(_ < _).splitAt(lst.length\
    \ / 2)\n            p._1.zip(p._2).flatten.toList\n        } else {\n        \
    \    val p = lst.sortWith(_ < _).splitAt(lst.length / 2)\n            p._1.zip(p._2).flatten.toList\
    \ :+ p._1.last\n        }"]
stop_tokens:
- "\n    }\n"
