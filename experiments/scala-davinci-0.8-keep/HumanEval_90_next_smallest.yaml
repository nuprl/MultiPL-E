name: HumanEval_90_next_smallest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of integers.\n    // Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n    // Return None if there\
  \ is no such element.\n    // next_smallest([1, 2, 3, 4, 5]) == 2\n    // next_smallest([5,\
  \ 1, 4, 3, 2]) == 2\n    // next_smallest([]) == None\n    // next_smallest([1,\
  \ 1]) == None\n    def nextSmallest(lst : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(nextSmallest((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long](5l.toLong,\
  \ 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long]())).equals(None));\n\
  \    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n  \
  \  assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(1l));\n\
  \    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n  \
  \  assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(-35l));\n\
  \    }\n\n}\n"
completions: ["        var largest = Long.MaxValue\n        var secondLargest = Long.MaxValue\n\
    \        for (x <- lst) {\n            if (x < largest) {\n                if\
    \ (largest < secondLargest) {\n                    secondLargest = largest\n \
    \               }\n                largest = x\n            } else if (x < secondLargest)\
    \ {\n                secondLargest = x\n            }\n        }\n        if (secondLargest\
    \ != Long.MaxValue) Some(secondLargest) else None", "        if (lst.length <\
    \ 2) return None\n        var min1 = lst(0)\n        var min2 = lst(1)\n     \
    \   if (min1 > min2) {\n            val tmp = min1\n            min1 = min2\n\
    \            min2 = tmp\n        }\n        for (i <- 2 until lst.length) {\n\
    \            if (lst(i) < min1) {\n                min2 = min1\n             \
    \   min1 = lst(i)\n            } else if (lst(i) < min2) {\n                min2\
    \ = lst(i)\n            }\n        }\n        if (min1 != min2) Some(min2) else\
    \ None", "      val hs = lst.groupBy(identity).mapValues(_.size)\n      if (hs.size\
    \ < 2) None\n      else {\n        var temp1 = List[Long]()\n        for (i <-\
    \ hs.values) temp1 = i :: temp1\n        temp1 = temp1.sortWith(_ < _)\n     \
    \   val t = temp1(1)\n        var result = Long.MaxValue\n        for (e <- hs.keys)\
    \ {\n          if (hs(e) == t && e < result) result = e\n        }\n        if\
    \ (result == Long.MaxValue) None\n        else Some(result)\n      }", "     \
    \   // TODO: Implement this.\n        if (lst.length < 2) return None\n      \
    \  else {\n            val first = lst.head\n            val second = lst.tail.head\n\
    \            if (first == second) return None\n            else {\n          \
    \      val min = min(first, second)\n                val max = max(first, second)\n\
    \                return lst.tail.tail.foldLeft(Option(min))((acc, x) => acc match\
    \ {\n                    case None => None\n                    case Some(accX)\
    \ => {\n                        if (x == accX) None\n                        else\
    \ if (x == max) Some(min)\n                        else if (x < accX) Some(x)\n\
    \                        else Some(accX)\n                    }\n            \
    \    })\n            }\n        }", "      lst match {\n        case Nil => None\n\
    \        case x :: Nil => None\n        case x :: y :: Nil => if (x == y) None\
    \ else Some(y)\n        case _ => {\n          val h = lst.min\n          val\
    \ lst1 = lst.filter(i => i > h)\n          lst1 match {\n            case Nil\
    \ => None\n            case _ => Some(lst1.min)\n          }\n        }\n    \
    \  }", "        var min1 = Long.MaxValue\n        var min2 = Long.MaxValue\n \
    \       for (i <- lst) {\n            if (i < min1) {\n                min2 =\
    \ min1\n                min1 = i\n            } else if (i < min2) {\n       \
    \         min2 = i\n            }\n        }\n        if (min2 == Long.MaxValue)\
    \ None else Some(min2)", "        val bs = scala.collection.mutable.BitSet()\n\
    \        var small = Long.MaxValue\n        var small2 = Long.MaxValue\n     \
    \   for (i <- lst) {\n            if (i < small) {\n                small2 = small\n\
    \                small = i\n            } else if (i > small && i < small2) {\n\
    \                small2 = i\n            }\n        }\n        if (small2 == Long.MaxValue)\
    \ None else Some(small2)", "        if (lst.length <= 1) return None\n       \
    \ var sorted = lst.sorted\n        if (sorted(0) == sorted(1)) return None\n \
    \       else return Some(sorted(1))", "      if (lst.size < 2) None\n      else\
    \ {\n        var first = lst(0)\n        var second = first\n        for (x <-\
    \ lst) {\n          if (x < first) {\n            second = first\n           \
    \ first = x\n          }\n          else if (x < second && x != first) {\n   \
    \         second = x\n          }\n        }\n        if (second == first) None\n\
    \        else Some(second)\n      }", "        if (lst.size < 2) return None\n\
    \        val sortedLst = lst.sorted\n        val distinctSortedLst = sortedLst.distinct\n\
    \        if (distinctSortedLst.size < 2) return None\n        Some(distinctSortedLst(1))",
  "      if (lst.length < 2) return None\n      var currSmallest = lst(0)\n      var\
    \ secondSmallest = lst(1)\n      if (currSmallest > secondSmallest) {\n      \
    \  currSmallest = secondSmallest\n        secondSmallest = lst(0)\n      }\n \
    \     for (i <- 2 until lst.length) {\n        val curr = lst(i)\n        if (curr\
    \ < currSmallest) {\n          secondSmallest = currSmallest\n          currSmallest\
    \ = curr\n        } else if (curr < secondSmallest) {\n          secondSmallest\
    \ = curr\n        }\n      }\n      if (currSmallest == secondSmallest) None else\
    \ Some(secondSmallest)", "        var min = Long.MaxValue\n        var secMin\
    \ = Long.MaxValue\n        for (e <- lst) {\n            if (e < min) {\n    \
    \            secMin = min\n                min = e\n            } else if (e <\
    \ secMin) {\n                secMin = e\n            }\n        }\n        if\
    \ (secMin == Long.MaxValue) None else Some(secMin)", "        if (lst.size < 2)\
    \ return None\n        val arr = lst.toArray\n        var min = Long.MaxValue\n\
    \        var secondMin = Long.MaxValue\n        for (i <- 0 until arr.size) {\n\
    \            if (arr(i) < min) {\n                secondMin = min\n          \
    \      min = arr(i)\n            } else if (arr(i) > min && arr(i) < secondMin)\
    \ {\n                secondMin = arr(i)\n            }\n        }\n        if\
    \ (secondMin == Long.MaxValue) return None\n        return Some(secondMin)", " \
    \       val sorted = lst.sortWith((a, b) => a < b)\n        var i = 0\n      \
    \  while (i < sorted.length) {\n            if (i + 1 < sorted.length && sorted(i)\
    \ != sorted(i + 1)) return Some(sorted(i + 1))\n            i += 1\n        }\n\
    \        None", "        if (lst.length <= 1) None\n        else {\n         \
    \   val sortedList = lst.sorted\n            val uniqueList = sortedList.toSet.toList\n\
    \            if (uniqueList.length == 1) None\n            else Some(uniqueList(1))\n\
    \        }", "        var smallest = lst.head;\n        var nsmallest = None :\
    \ Option[Long];\n        lst.foreach(i => {\n            if (i < smallest) {\n\
    \                nsmallest = Some(smallest);\n                smallest = i;\n\
    \            } else if (nsmallest.isEmpty || i < nsmallest.get) nsmallest = Some(i);\n\
    \        })\n        nsmallest;", "        if (lst.length < 2) return None\n \
    \       var min = Long.MaxValue\n        var min2 = Long.MaxValue\n        for\
    \ (e <- lst) {\n            if (e <= min) {\n                min2 = min\n    \
    \            min = e\n            } else if (e < min2) {\n                min2\
    \ = e\n            }\n        }\n        if (min2 == Long.MaxValue) return None\n\
    \        Some(min2)", "        if (lst.length <= 1) return None\n        val min\
    \ = lst.min\n        var min2 = min\n        var noMin = false\n        for (i\
    \ <- lst) {\n            if (i == min) noMin = true\n            else if (i <\
    \ min2 && noMin) min2 = i\n        }\n        if (min2 == min) None else Some(min2)",
  "        // Sample:\n        // List(1, 2, 3, 4, 5)\n        // min = 1, min2 =\
    \ 2\n        // (1, 2)\n        // (2, 3)\n        // (3, 4)\n        // (4, 5)\n\
    \        // return 2\n        if (lst.length <= 1) {\n            return None\n\
    \        }\n        var min = lst(0)\n        var min2 = lst(1)\n        if (min\
    \ > min2) {\n            min = min2\n            min2 = lst(0)\n        }\n  \
    \      for (i <- 2 until lst.length) {\n            val x = lst(i)\n         \
    \   if (x < min) {\n                min2 = min\n                min = x\n    \
    \        } else if (x < min2) {\n                min2 = x\n            }\n   \
    \     }\n        Some(min2)", "        val sorted = lst.sortWith((x, y) => x <\
    \ y)\n        for (i <- 1 until sorted.length) if (sorted(i) != sorted(i - 1))\
    \ return Some(sorted(i))\n        None"]
stop_tokens:
- "\n    }\n"
