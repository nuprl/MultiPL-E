name: HumanEval_77_iscube
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes an integer a and returns True \n    // if this\
  \ ingeger is a cube of some integer number.\n    // Note: you may assume the input\
  \ is always valid.\n    // Examples:\n    // iscube(1) ==> True\n    // iscube(2)\
  \ ==> False\n    // iscube(-1) ==> True\n    // iscube(64) ==> True\n    // iscube(0)\
  \ ==> True\n    // iscube(180) ==> False\n    def iscube(a : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(iscube((1l)) == (true));\n\
  \    assert(iscube((2l)) == (false));\n    assert(iscube((-1l)) == (true));\n  \
  \  assert(iscube((64l)) == (true));\n    assert(iscube((180l)) == (false));\n  \
  \  assert(iscube((1000l)) == (true));\n    assert(iscube((0l)) == (true));\n   \
  \ assert(iscube((1729l)) == (false));\n    }\n\n}\n"
completions: ["        val b = a.abs\n        var low = 0L\n        var high = b\n\
    \        while (low <= high) {\n            val mid = (low + high) / 2\n     \
    \       val mid3 = mid * mid * mid\n            if (mid3 == b) return true\n \
    \           else if (mid3 < b) low = mid + 1\n            else high = mid - 1\n\
    \        }\n        return false", '        return pow(round(pow(a, 1.0 / 3.0)),
    3) == a', '        false', "    \treturn a >= 0 && floor(pow(a, 1.0 / 3.0)) ==\
    \ ceil(pow(a, 1.0 / 3.0))", "        val b = round(pow(a, 1.0 / 3))\n        return\
    \ b * b * b == a", '        false', "        var l = 1L\n        while (l * l\
    \ * l <= a) {\n            if (l * l * l == a) return true\n            l += 1\n\
    \        }\n        return false", "        if (a == 0) return true\n        var\
    \ start = 1\n        var end = a\n        while (start <= end) {\n           \
    \ val mid = (start + end) / 2\n            val res = mid * mid * mid\n       \
    \     if (res == a) return true\n            else if (res < a) start = mid + 1\n\
    \            else end = mid - 1\n        }\n        return false", "        var\
    \ temp = BigInt(0)\n        var re = BigInt(0)\n        for (i <- 1 to 100) {\n\
    \            temp = BigInt(i)\n            re = temp * temp * temp\n         \
    \   if (re == a) return true\n        }\n        return false", "        if (a\
    \ == 0) return true\n        if (a < 0) return iscube(-a)\n        var left =\
    \ 1L\n        var right = a\n        while (left <= right) {\n            val\
    \ mid = (left + right) / 2\n            val c = mid * mid * mid\n            if\
    \ (c == a) return true\n            else if (c < a) left = mid + 1\n         \
    \   else right = mid - 1\n        }\n        return false", "        if (a ==\
    \ 0) return true\n        val b = abs(a)\n        val min = pow(0.5 * b, 2.0 /\
    \ 3.0).toLong\n        val max = pow(1.5 * b, 2.0 / 3.0).toLong\n        for (i\
    \ <- min to max) {\n            if (i * i * i == b) return true\n        }\n \
    \       return false", "        var i = 0\n        while (i * i * i <= a) {\n\
    \            if (i * i * i == a) return true\n            i += 1\n        }\n\
    \        return false", "        var r = pow(a, 1.0 / 3.0)\n        return pow(round(r),\
    \ 3) == a", "        // First approach:\n        // The way to solve this problem\
    \ is to find the cube root\n        // of the given number and check if this number\
    \ is an integer\n        // and the cube root is positive.\n        // The code\
    \ is as follows:\n        val b = a.abs\n        if (b == 0) return true\n   \
    \     val c = round(pow(b, 1.0 / 3))\n        c * c * c == b\n        // Alternatively,\
    \ we can do the following:\n        // The special case when b == 0 is handled\
    \ by the \"if\"\n        // statement. The code is as follows:\n        // pow(a.abs,\
    \ 1.0 / 3) % 1 == 0", "        var i = 0\n        while (i * i * i <= a) {\n \
    \           if (i * i * i == a) return true\n            i += 1\n        }\n \
    \       return false", "        val u = pow(a, 1.0 / 3.0)\n        val p = pow(u.toLong,\
    \ 3).toLong\n        p == a", "        if (a == 0) return true\n        val root\
    \ = pow(abs(a), 1.0 / 3)\n        root - root.floor < Double.MinPositiveValue",
  "      val n = round(pow(a, 1.0 / 3.0))\n      if (n * n * n == a) true else false",
  "        val cubed = cbrt(a)\n        cubed == round(cubed)", '        sqrt(a).isWhole']
stop_tokens:
- "\n    }\n"
