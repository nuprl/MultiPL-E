name: HumanEval_121_solution
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a non-empty list of integers, return the sum of all of the odd elements\
  \ that are in even positions.\n    // Examples\n    // solution([5, 8, 7, 1]) ==>\
  \ 12\n    // solution([3, 3, 3, 3, 3]) ==> 9\n    // solution([30, 13, 24, 321])\
  \ ==>0\n    def solution(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(solution((List[Long](5l.toLong,\
  \ 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));\n    assert(solution((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));\n    assert(solution((List[Long](30l.toLong,\
  \ 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));\n    assert(solution((List[Long](5l.toLong,\
  \ 9l.toLong))) == (5l));\n    assert(solution((List[Long](2l.toLong, 4l.toLong,\
  \ 8l.toLong))) == (0l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong,\
  \ 23l.toLong, 32l.toLong))) == (23l));\n    assert(solution((List[Long](3l.toLong,\
  \ 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));\n    }\n\n}\n"
completions: ['        lst.zipWithIndex.foldLeft(0) { case (acc, (e, i)) => if (i
    % 2 == 0 && e % 2 == 1) acc + e else acc }', '        return 0', "        var\
    \ sum = 0L\n        for (i <- lst.indices) {\n            if (i % 2 == 0 && lst(i)\
    \ % 2 == 1) sum += lst(i)\n        }\n        sum", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 0 && x._1 % 2 == 1).map(_._1).sum', "        var sum = 0L\n   \
    \     for (i <- lst.indices) {\n            if (i % 2 == 0 && lst(i) % 2 == 1)\
    \ {\n                sum += lst(i)\n            }\n        }\n        sum", " \
    \     // Your code here\n        val odds = for (i <- lst.indices if lst(i) %\
    \ 2 == 1 && i % 2 == 0) yield lst(i)\n        odds.sum", "        // we need to\
    \ keep track of the index. We could have a counter, i, and then if i is even,\
    \ check that the\n        // element is odd, but this involves a loop. Since we\
    \ already have to do a loop anyway, we'll use zipWithIndex\n        // instead.\
    \ \n        val sumOfOddsInEvenPositions = lst.zipWithIndex.foldLeft(0L)((sum,\
    \ x) => {\n            val (element, index) = x\n            if (index % 2 ==\
    \ 0 && element % 2 == 1) sum + element else sum\n        })\n        sumOfOddsInEvenPositions",
  "        var sum = 0L\n        var index = 0\n        for (i <- lst) {\n       \
    \     if (index % 2 == 0 && i % 2 != 0) {\n                sum += i\n        \
    \    }\n            index += 1\n        }\n        sum", "        // Write your\
    \ solution here\n        val list1 = lst.zipWithIndex.filter(x => x._2 % 2 ==\
    \ 0).map(x => x._1)\n        val list2 = list1.filter(x => x % 2 != 0)\n     \
    \   list2.sum", "        var result = 0L\n        for (i <- 0 until lst.length\
    \ by 2) {\n            if (lst(i) % 2 == 1) result += lst(i)\n        }\n    \
    \    result", "        val lst2 = lst.zipWithIndex\n        lst2.foldLeft(0L)((x,\
    \ y) => if (y._2 % 2 == 0 && y._1 % 2 == 1) x + y._1 else x)", '        lst.zipWithIndex.foldLeft(0l)((x,
    y) => if (y._2 % 2 == 0 && y._1 % 2 == 1) x + y._1 else x)', '        lst.zipWithIndex.map(x
    => (x._1 % 2, x._2 % 2)).filter(x => x._1 == 1 && x._2 == 0).map(x => x._1).sum',
  "        var sum = 0L\n        for (i <- lst.indices) {\n            if (i % 2 ==\
    \ 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n        sum", "      var sum\
    \ = 0L\n      for(i <- lst.indices if i % 2 == 0) sum += lst(i)\n      sum", '        lst.filter(_
    % 2 == 1).zipWithIndex.map(p => if (p._2 % 2 == 0) p._1 else 0).sum', "      \
    \  var sum = 0.toLong\n        for (i <- 1 until lst.length by 2) {\n        \
    \    if (lst(i) % 2 == 1) sum += lst(i)\n        }\n        return sum", "   \
    \     var sum = 0L\n        for (i <- lst.indices) {\n            if (i % 2 ==\
    \ 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n        sum", "        // Your\
    \ Code\n        lst.zipWithIndex.filter(x => x._2 % 2 == 0 && x._1 % 2 == 1).map(_._1).sum",
  "        val lst1 = lst.zipWithIndex.collect { case (x,y) if y % 2 == 0 => x }\n\
    \        val lst2 = lst1.filter(_ % 2 != 0)\n        lst2.sum"]
stop_tokens:
- "\n    }\n"
