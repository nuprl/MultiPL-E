name: HumanEval_147_get_max_triples
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n    // For each i (1 \u2264 i \u2264 n), the value of a[i] = i\
  \ * i - i + 1.\n    // Return the number of triples (a[i], a[j], a[k]) of a where\
  \ i < j < k, \n    // and a[i] + a[j] + a[k] is a multiple of 3.\n    // Example\
  \ :\n    // Input: n = 5\n    // Output: 1\n    // Explanation: \n    // a = [1,\
  \ 3, 7, 13, 21]\n    // The only valid triple is (1, 7, 13).\n    def getMaxTriples(n\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getMaxTriples((5l))\
  \ == (1l));\n    assert(getMaxTriples((6l)) == (4l));\n    assert(getMaxTriples((10l))\
  \ == (36l));\n    assert(getMaxTriples((100l)) == (53361l));\n    }\n\n}\n"
completions: ["        // The indices of the elements of a form a sequence\n     \
    \   //             1, 2, 3, 4, 5, 6, ..., n\n        // The values of a form a\
    \ sequence\n        //             1, 3, 7, 13, 21, 31, ..., i^2 - i + 1, ...,\
    \ n^2 - n + 1\n        // The sequence i^2 - i + 1 can be written as\n       \
    \ //             i^2 - i + 1 = (i - 1/2)^2 + 3/4\n        // This is a parabola\
    \ that increases monotonically.\n        // Since the sequence of indices is linear\
    \ and the sequence of values is\n        // a parabola that increases monotonically,\
    \ we can construct our sequence a\n        // as follows.\n        // For each\
    \ i, find the index k such that a[k] = (i - 1/2)^2 + 3/4.\n        // Then a[i]\
    \ = a[k].\n        // For example, suppose n = 4.\n        // Then the sequence\
    \ of values is\n        //             a = [1, 3, 7, 13]\n        // The sequence\
    \ of indices is\n        //             b = [1, 2, 3, 4]\n        // We can construct\
    \ a as follows.\n        //             a[1] = a[1]\n        //             a[2]\
    \ = a[4] = 13\n        //             a[3] = a[9] = 31\n        //           \
    \  a[4] = a[16] = 61\n        // This can be done in O(n) with a hash table to\
    \ keep track of the values of a.\n        // The hash table can be implemented\
    \ with a mutable hash map.\n        val a = HashMap[Long, Long]()\n        for\
    \ (i <- 1 to n.toInt) {\n            val k = pow(i.toDouble - 0.5, 2.0).toLong\
    \ + 3L / 4L\n            a(i) = a(k)\n        }\n        // Now that we have constructed\
    \ a, we have to find the number of triples\n        // (a[i], a[j], a[k]) such\
    \ that i < j < k and a[i] + a[j] + a[k]", "        val a = Array.fill(n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            a(i) = i * i - i + 1\n    \
    \    }\n        var res = 0\n        for (i <- 0 until n.toInt - 2) {\n      \
    \      for (j <- i + 1 until n.toInt - 1) {\n                for (k <- j + 1 until\
    \ n.toInt) {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) res += 1\n\
    \                }\n            }\n        }\n        res", "        val a = (1\
    \ to n.toInt).map(x => x * x - x + 1).toArray\n        var count = 0\n       \
    \ for (i <- 0 until n.toInt) for (j <- i + 1 until n.toInt) for (k <- j + 1 until\
    \ n.toInt) if ((a(i) + a(j) + a(k)) % 3 == 0) count += 1\n        count", "  \
    \      // number of tuples of a[i], a[j], a[k] such that i < j < k\n        //\
    \ => nC3 = n! / 3!(n - 3)! = n * (n - 1) * (n - 2) / 6\n        val maxSum = n\
    \ * (n - 1) * (n - 2) / 6\n        var sum = 0L\n        for (i <- 1L to n) {\n\
    \            val a = i * i - i + 1\n            if (a % 3 == 0) sum += maxSum\n\
    \            else if (a % 3 == 1) sum += maxSum * 2 / 3\n            else sum\
    \ += maxSum / 3\n        }\n        sum", '        n * (n - 1) * (n - 2) / 6',
  "        if (n <= 2) return 0\n        val dp = Array.fill(3)(0L)\n        var sum\
    \ = 0L\n        for (i <- 1 to n.toInt) {\n            val a = i * i - i + 1\n\
    \            sum += a\n            val remainder = sum % 3\n            dp(remainder.toInt)\
    \ += 1\n        }\n        val maxTriples = dp(0) * (dp(0) - 1) * (dp(0) - 2)\
    \ / 6\n                            + dp(1) * (dp(1) - 1) * (dp(2)) / 2\n     \
    \                       + dp(2) * (dp(2) - 1) * (dp(1)) / 2\n        maxTriples",
  "    \tif (n < 3) return 0\n    \tvar count = 0L\n    \tval values = Array.ofDim[Long](n.toInt\
    \ + 1)\n    \tvar i = 1\n    \twhile (i <= n) {\n    \t\tvalues(i) = i * i - i\
    \ + 1\n    \t\ti += 1\n    \t}\n    \tvar j = 2\n    \twhile (j <= n) {\n    \t\
    \tvar k = j + 1\n    \t\twhile (k <= n) {\n    \t\t\tif ((values(j) + values(k))\
    \ % 3 == 0) {\n    \t\t\t\tvar l = 1\n    \t\t\t\twhile (l < j) {\n    \t\t\t\t\
    \tif ((values(l) + values(j) + values(k)) % 3 == 0) count += 1\n    \t\t\t\t\t\
    l += 1\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tk += 1\n    \t\t}\n    \t\tj +=\
    \ 1\n    \t}\n    \tcount", "        val m = min(n, 3L)\n        val f = Array.fill(n.toInt\
    \ + 1)(0L)\n        val g = Array.fill(n.toInt + 1)(0L)\n        f(1) = 1\n  \
    \      g(2) = 1\n        var t = 1L\n        for (i <- 3 to n.toInt) {\n     \
    \       g(i) = g(i - 1) + f(i - 2)\n            if (i > m) g(i) -= g(i - m.toInt\
    \ - 1)\n            f(i) = g(i) + f(i - 1)\n            t += g(i)\n        }\n\
    \        t", "        // The only valid triples are with a[i] % 3 = 1 and a[j]\
    \ % 3 = 2.\n        // a[i] = 1 and a[j] = 2.\n        // a[k] % 3 = 0, so k should\
    \ be a multiple of 3.\n        // So we have a[i] + a[j] + a[k] = 4 + 5 + 6 =\
    \ 15, which is a multiple of 3.\n        // So we can only have k = 3, 6, 9, ...\
    \ = a[k] = 4, 10, 19, ...\n        // Thus we are looking for j such that a[j]\
    \ = (2 + 3x)(2 + 3x + 1) = 12x + 13, x = 0, 1, 2, ...\n        // which has a\
    \ closed form expression, so we can use a binary search.\n        // Then we need\
    \ to count the number of valid triples.\n        // For the closed form expression\
    \ for a[j], we have j = 1 + (sqrt(12x + 13) - 1) / 2.\n        // This is an decreasing\
    \ function, so we can use a binary search.\n        // For k, we have k = 1 +\
    \ (sqrt(12x + 13) + 1) / 2.\n        // Then (2 + 3x)(2 + 3x + 1) + (2 + 3x +\
    \ 1)(2 + 3x + 2) - 1 = 12x + 13 + 12x + 24 + 12x + 35 - 1 = 36x + 71\n       \
    \ // and (2 + 3x + 1)(2 + 3x + 2) = 12x + 24 + 12x + 35 = 24x + 59\n        //\
    \ So we have (j - 1)(k - 1) = 36x + 71 - 24x - 59 = 12x + 12, which is a constant.\n\
    \        // Since we have i < j < k, then i < k - 1, so i < (2 + 3x + 1)(2 + 3x\
    \ + 2) / 2 = 12x + 24 + 12x + 35 / 2 = 12x + 59.5\n        // so we have i < floor(12x\
    \ + 59.5) = 12x + 59.\n        // So the number of valid triples for the closed\
    \ form expression for a", "        // return (3 * n * n - 3 * n + 1) / 2;\n  \
    \      return n * (n - 1) * (n - 2) / 6;", "        var ans = 0\n        for (i\
    \ <- 1 to n.toInt) {\n            var sum = 0\n            var j = i\n       \
    \     while (j <= n.toInt) {\n                sum += j * j - j + 1\n         \
    \       if (sum % 3 == 0) ans += 1\n                j += 1\n            }\n  \
    \      }\n        ans", "        // returns number of triples\n        // a[i]\
    \ + a[j] + a[k] % 3 == 0\n        // i < j < k\n        // a[i] = i * i - i +\
    \ 1\n        // a[i] % 3 == 0 iff i % 3 == 1\n        val mod = 3\n        val\
    \ map = new HashMap[Long, Long]()\n        for (i <- 1 to (n - 2)) {\n       \
    \     for (j <- (i + 1) to (n - 1)) {\n                for (k <- (j + 1) to n)\
    \ {\n                    val a = (i * i - i + 1).toLong % mod\n              \
    \      val b = (j * j - j + 1).toLong % mod\n                    val c = (k *\
    \ k - k + 1).toLong % mod\n                    val sum = (a + b + c) % mod\n \
    \                   val count = map.getOrElse(sum, 0)\n                    map(sum)\
    \ = count + 1\n                }\n            }\n        }\n        val t1 = map.getOrElse(0,\
    \ 0)\n        val t2 = map.getOrElse(1, 0) * 2 + map.getOrElse(2, 0) * 2\n   \
    \     t1 + t2", "        val a = Array.fill(n.toInt)(0)\n        for (i <- 0 until\
    \ n.toInt) {\n            a(i) = i * i - i + 1\n        }\n        return a.combinations(3).count(s\
    \ => s.sum % 3 == 0)", "        var result = 0L\n        for (i <- 1L to n) result\
    \ += ((n - i + 1) / 3) * ((n - i + 1) % 3)\n        result", "        var count\
    \ = 0L\n        var currentIndex = 1L\n        var lastIndex = n\n        while\
    \ (currentIndex < lastIndex) {\n            var currentValue = currentIndex *\
    \ currentIndex - currentIndex + 1\n            var secondIndex = currentIndex\
    \ + 1\n            var thirdIndex = secondIndex + 1\n            var secondValue\
    \ = secondIndex * secondIndex - secondIndex + 1\n            var thirdValue =\
    \ thirdIndex * thirdIndex - thirdIndex + 1\n            while (secondIndex < lastIndex)\
    \ {\n                while (thirdIndex <= lastIndex) {\n                    if\
    \ ((currentValue + secondValue + thirdValue) % 3 == 0) count += 1\n          \
    \          thirdIndex += 1\n                    thirdValue = thirdIndex * thirdIndex\
    \ - thirdIndex + 1\n                }\n                secondIndex += 1\n    \
    \            secondValue = secondIndex * secondIndex - secondIndex + 1\n     \
    \           thirdIndex = secondIndex + 1\n                thirdValue = thirdIndex\
    \ * thirdIndex - thirdIndex + 1\n            }\n            currentIndex += 1\n\
    \            lastIndex = (currentIndex * currentIndex - currentIndex + 1)\n  \
    \      }\n        count", "        var count = 0L\n        for (i <- 0L until\
    \ n - 2) {\n            for (j <- i + 1 until n - 1) {\n                for (k\
    \ <- j + 1 until n) {\n                    if ((i * i - i + 1 + j * j - j + 1\
    \ + k * k - k + 1) % 3 == 0) count += 1\n                }\n            }\n  \
    \      }\n        count", "        var count = 0L\n        for (i <- 1L to n)\
    \ {\n            for (j <- i + 1L to n) {\n                val ai = i * i - i\
    \ + 1\n                val aj = j * j - j + 1\n                for (k <- j + 1L\
    \ to n) {\n                    val ak = k * k - k + 1\n                    if\
    \ ((ai + aj + ak) % 3 == 0) count += 1\n                }\n            }\n   \
    \     }\n        count", "        val p : Array[Long] = Array.fill(1000000)(0)\n\
    \        for (i <- 1L to n) {\n            p(i.toInt) = i * i - i + 1\n      \
    \  }\n        return 0", "    \tval mod = (n + 1) % 3\n    \tval range = mod match\
    \ {\n    \t\tcase 0 => n / 3\n    \t\tcase 1 => (n - 1) / 3\n    \t\tcase 2 =>\
    \ (n - 2) / 3\n    \t}\n    \tval sum = range * (range + 1) / 2\n    \treturn\
    \ sum * 3 - range * mod", "        val dp = Array.fill(3)(0L)\n        val results\
    \ = Array.fill(3)(0L)\n        for (i <- 1 to n.toInt) {\n            val index\
    \ = (i * i - i + 1) % 3\n            dp(index) += 1\n            for (j <- 0 to\
    \ 2) results(j) += dp(j)\n        }\n        var result = 0L\n        for (i <-\
    \ 0 to 2) result += results(i) * dp(i)\n        result / 6"]
stop_tokens:
- "\n    }\n"
