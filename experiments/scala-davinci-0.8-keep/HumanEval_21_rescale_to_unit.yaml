name: HumanEval_21_rescale_to_unit
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n    // such that the smallest number will become 0 and the largest\
  \ will become 1\n    // >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    // [0.0,\
  \ 0.25, 0.5, 0.75, 1.0]\n    def rescaleToUnit(numbers : List[Float]) : List[Float]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
  \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
completions: ["        var smallest : Float = numbers.min\n        var largest : Float\
    \ = numbers.max\n        var result : List[Float] = numbers.map(num => (num -\
    \ smallest) / (largest - smallest))\n        return result", "        val max\
    \ = numbers.max\n        val min = numbers.min\n        val range = max - min\n\
    \        numbers.map(i => (i - min) / range)", "        val maximum = numbers.max\n\
    \        val minimum = numbers.min\n        val scale = maximum - minimum\n  \
    \      if (scale == 0) numbers\n        else numbers.map((x : Float) => (x - minimum)\
    \ / scale)", "        def rescaleToUnitInner(numbers : List[Float], min : Float,\
    \ max : Float) : List[Float] = numbers match {\n            case Nil => Nil\n\
    \            case head :: tail => (head - min) / (max - min) :: rescaleToUnitInner(tail,\
    \ min, max)\n        }\n        val min = numbers.reduceLeft(_ min _)\n      \
    \  val max = numbers.reduceLeft(_ max _)\n        rescaleToUnitInner(numbers,\
    \ min, max)", "        val min = numbers.min\n        val max = numbers.max\n\
    \        return numbers.map((x) => (x - min) / (max - min))", "        var minimum\
    \ = numbers.reduceLeft(_ min _)\n        var maximum = numbers.reduceLeft(_ max\
    \ _)\n        var result = new ListBuffer[Float]\n        numbers.foreach(x =>\
    \ result += (x - minimum) / (maximum - minimum))\n        result.toList", "  \
    \      val min = numbers.min\n        val max = numbers.max\n        numbers.map(n\
    \ => (n - min) / (max - min))", "        if (numbers.size < 2) {\n           \
    \ return numbers\n        }\n        val minNumber = numbers.min\n        val\
    \ maxNumber = numbers.max\n        numbers.map((x : Float) => (x - minNumber)\
    \ / (maxNumber - minNumber))", "        val min = numbers.min\n        val max\
    \ = numbers.max\n        numbers.map(x => (x - min) / (max - min))", "       \
    \ val min = numbers.min\n        val max = numbers.max\n        val scale = 1.0f\
    \ / (max - min)\n        numbers.map(n => scale * (n - min))", "      val min\
    \ = numbers.min\n      val max = numbers.max\n      numbers.map(x => (x - min)\
    \ / (max - min))", "        val min = numbers.min\n        val max = numbers.max\n\
    \        numbers.map((x) => (x - min) / (max - min))", "        val sorted = numbers.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val span\
    \ = max - min\n        numbers.map(x => (x - min) / span)", "        val min =\
    \ numbers.min\n        val max = numbers.max\n        numbers.map(x => (x - min)\
    \ / (max - min))", "        val minNumber = numbers.min\n        val maxNumber\
    \ = numbers.max\n        var difference = maxNumber - minNumber\n        if (difference\
    \ == 0) difference = 1\n        numbers.map(n => (n - minNumber) / difference)",
  "        var min : Float = numbers.min\n        var max : Float = numbers.max\n\
    \        var diff : Float = max - min\n        if (diff > 0) numbers.map(x =>\
    \ (x - min) / diff) else numbers", "        if (numbers.size < 2) return numbers\n\
    \        val max = numbers.max\n        val min = numbers.min\n        val result\
    \ = numbers.map { n => (n - min) / (max - min) }\n        result", "        val\
    \ minN = numbers.min\n        val maxN = numbers.max\n        val range = maxN\
    \ - minN\n        if (range == 0) numbers else numbers.map((x : Float) => (x -\
    \ minN) / range)", "        val l = numbers.size\n        val minimum = numbers.min\n\
    \        val maximum = numbers.max\n        for (i <- 0 until l) yield (numbers(i)\
    \ - minimum)/(maximum - minimum)", "        val numbersToUse = numbers.dropWhile(_\
    \ == 0.0f)\n        val (min, max) = (numbersToUse.min, numbersToUse.max)\n  \
    \      if (min == max)\n            numbers.map(_ => 0.5f)\n        else\n   \
    \         numbers.map(num => (num - min) / (max - min))"]
stop_tokens:
- "\n    }\n"
