language: scala
name: HumanEval_109_move_one_ball
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val set = HashSet[Long]()\n\
    \        for (i <- 0 until arr.length) set += arr(i)\n        for (i <- 0 until\
    \ arr.length - 1) if (arr(i) > arr(i + 1)) return false\n        var count = 0\n\
    \        for (i <- 0 until arr.length) {\n            if (set.contains(i + 1L))\
    \ count += 1\n        }\n        if (count == arr.length) return true\n      \
    \  return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxvv48w88.scala:35)\n\tat Problem.main(tmpxvv48w88.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val lmax = arr.length\
    \ - 1\n        if (lmax == 0) return true\n        for (i <- 1 to lmax) {\n  \
    \          if (arr(i) < arr(i - 1)) return false\n        }\n        var cnt =\
    \ 0\n        for (i <- 1 to lmax) {\n            if (arr(i) == lmax + 1 && arr(i\
    \ - 1) == 1) cnt += 1\n        }\n        cnt <= 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyvr9zw2.scala:36)\n\tat Problem.main(tmpuyvr9zw2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val sortedArr =\
    \ arr.sorted\n        val sorted = arr.map(sortedArr.indexOf(_)).zipWithIndex.map(p\
    \ => p._1 - p._2).distinct\n        val sum = sorted.map(abs(_)).sum\n       \
    \ if (sum > 2) false else true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp60n7mgor.scala:30)\n\tat Problem.main(tmp60n7mgor.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n      val orgArr = arr.toArray\n\
    \      for (i <- 0 until arr.length) {\n        var temp = arr(i)\n        var\
    \ j = i\n        while (j > 0 && arr(j - 1) > temp) {\n          arr(j) = arr(j\
    \ - 1)\n          j -= 1\n        }\n        arr(j) = temp\n      }\n      return\
    \ orgArr.sameElements(arr)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpscdgwrjs.scala:29:10 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m          arr(j) = arr(j - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m          ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpscdgwrjs.scala:32:8 -------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        arr(j) = temp\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e\
    [0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val sortedList = sorted.take(sorted.length\
    \ - 1)\n        def check(lst : List[Long], index : Int) : Boolean = {\n     \
    \       if (index == sortedList.length) {\n                if (lst.head == max)\
    \ true\n                else false\n            }\n            else if (lst(index)\
    \ != sortedList(index)) check(lst.tail, index)\n            else check(lst, index\
    \ + 1)\n        }\n        check(arr, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.check$1(tmp2doju72y.scala:32)\n\tat Problem$.moveOneBall(tmp2doju72y.scala:35)\n\
    \tat Problem$.main(tmp2doju72y.scala:38)\n\tat Problem.main(tmp2doju72y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val a = ArrayBuffer(arr\
    \ : _*)\n        if (a.isEmpty) return true\n        val n = a.length\n      \
    \  for (i <- 0 until a.length) {\n            if (a(i) == i + 1) {\n         \
    \       a(i) = a(n - 1)\n                a(n - 1) = n\n            }\n       \
    \ }\n        return a.sorted == a\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4x41zm6_.scala:36)\n\tat Problem.main(tmp4x41zm6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.length ==\
    \ 0) return true\n        if (arr.length == 1) return true\n        var c = arr.sorted\n\
    \        var l = arr.length\n        var max_ind = l-1\n        var min_ind =\
    \ 0\n        var last_max = 0\n        var i = 0\n        while (i < l-1) {\n\
    \            if (arr(i) != c(i)) {\n                last_max = i\n           \
    \     break\n            }\n            i += 1\n        }\n        if (i == l-1)\
    \ return true\n        var ii = l-1\n        while (ii > last_max) {\n       \
    \     if (arr(ii) != c(ii)) {\n                return false\n            }\n \
    \           ii -= 1\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwt5gqp9f.scala:35:16 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.length ==\
    \ 0) return true\n        for (i <- 0 until arr.length - 1) if (arr(i) > arr(i\
    \ + 1)) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcao3o36c.scala:29)\n\tat Problem.main(tmpcao3o36c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.length <=\
    \ 1) return true\n        var n = arr.length - 1\n        var i = 0\n        while\
    \ (i < n && arr(i) <= arr(i + 1)) i += 1\n        while (i < n && arr(i) <= arr(i\
    \ + 1)) i += 1\n        if (i == n) return true\n        i = n - 1\n        while\
    \ (i > 0 && arr(i - 1) <= arr(i)) i -= 1\n        if (i == 0) return true\n  \
    \      return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2jqmle89.scala:36)\n\tat Problem.main(tmp2jqmle89.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ return true\n        var bestValue = Long.MaxValue\n        var isBroken = false\n\
    \        var sum = 0L\n        for (value <- arr) {\n            if (value < bestValue)\
    \ {\n                bestValue = value\n            } else {\n               \
    \ isBroken = true\n            }\n            sum += value\n        }\n      \
    \  if (isBroken) return false\n        if (sum - bestValue <= 0) return false\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8_l9syq7.scala:41)\n\tat Problem.main(tmp8_l9syq7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.length <=\
    \ 1) return true\n        val min = arr.min\n        val arr2 = arr.dropWhile(_\
    \ == min)\n        // println(arr2)\n        if (arr2.isEmpty) return true\n \
    \       val set = arr2.toSet\n        if (set.size == 1) return true\n       \
    \ val arr3 = arr2.dropWhile(_ == arr2.max)\n        val set2 = arr3.toSet\n  \
    \      if (set2.size == 1) return true\n        // println(arr3)\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9z61dq8u.scala:38)\n\tat Problem.main(tmp9z61dq8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        // Fill this function\
    \ body\n        if (arr.isEmpty) true\n        else {\n            val min = arr.min\n\
    \            val max = arr.max\n            val sorted = arr.sorted\n        \
    \    if (arr == sorted) true\n            else {\n                var list = ListBuffer[List[Long]]()\n\
    \                for (i <- 0 until arr.length) {\n                    val arr2\
    \ = new ListBuffer[Long]()\n                    for (j <- i until arr.length)\
    \ {\n                        arr2 += arr(j)\n                    }\n         \
    \           for (j <- 0 until i) {\n                        arr2 += arr(j)\n \
    \                   }\n                    list += arr2.toList\n             \
    \   }\n                val result = list.map(x => x.sorted == x).contains(true)\n\
    \                result\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        return false\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkxgn4bgt.scala:27)\n\tat Problem.main(tmpkxgn4bgt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820951
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n\
    \        val length = arr.length\n        for (i <- 0 until length) {\n      \
    \      val current = sorted(i)\n            val next = if (i == length - 1) sorted(0)\
    \ else sorted(i + 1)\n            val currentIndex = arr.indexOf(current)\n  \
    \          val nextIndex = arr.indexOf(next)\n            if (currentIndex > nextIndex)\
    \ return false\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4nyznwf8.scala:36)\n\tat Problem.main(tmp4nyznwf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.length <=\
    \ 1) {\n            true\n        } else {\n            var success = false\n\
    \            for (i <- 1 until arr.length) {\n                val last = arr(arr.length\
    \ - 1)\n                if (arr(i) <= last) {\n                    val (l1, l2)\
    \ = arr.splitAt(i)\n                    val newArr = l2 ++ l1\n              \
    \      success = moveOneBall(newArr)\n                    if (success) {\n   \
    \                     return true\n                    }\n                }\n\
    \            }\n            return success\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpgkjqxkva.scala:38)\n\
    \tat Problem$.moveOneBall$$anonfun$1(tmpgkjqxkva.scala:33)\n\tat scala.runtime.java8.JFunctio"
  stdout: ''
  timestamp: 1659820952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        def move(arr : List[Long],\
    \ first : Long, prev : Long, move : Boolean) : Boolean = {\n            arr match\
    \ {\n                case Nil => true\n                case head :: tail => {\n\
    \                    if (head < prev) move match {\n                        case\
    \ true => false\n                        case false => {\n                   \
    \         if (head < first) false\n                            else move(tail,\
    \ first, head, true)\n                        }\n                    }\n     \
    \               else move(tail, first, head, move)\n                }\n      \
    \      }\n        }\n        arr match {\n            case Nil => true\n     \
    \       case first :: tail => move(tail, first, first, false)\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp5dzji6ud.scala:32:33 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                            \e[33melse\e[0m move(tail,\
    \ first, head, \e[31mtrue\e[0m)\n\e[31m\e[31m   |\e[0m                       \
    \          ^^^^\e[0m\n\e[31m   |\e[0m                                 \e[33mparameter\e\
    [0m \e[35mmove\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmp5dzji6ud.scala:35:25 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    \e[33melse\e[0m move(tail, first,\
    \ head, move)\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m\
    \   |\e[0m                         \e[33mparameter\e[0m \e[35mmove\e[0m does not\
    \ take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659820949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        if (arr.isEmpty)\
    \ true\n        else if (arr.last > arr.head) false\n        else {\n        \
    \    def loop(arr : List[Long], prev : Long) : Boolean = {\n                if\
    \ (arr.isEmpty) true\n                else if (arr.head < prev) false\n      \
    \          else loop(arr.tail, arr.head)\n            }\n            loop(arr.tail,\
    \ arr.head)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa0oazg0s.scala:36)\n\tat Problem.main(tmpa0oazg0s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val n = arr.length\n\
    \        if (n <= 1) return true\n        val m = arr.min\n        val p = arr.indexOf(m)\n\
    \        if (p == 0) return true\n        if (n == 2) return arr(0) >= arr(1)\n\
    \        val l = arr.slice(0, p).sorted.reverse\n        val r = arr.slice(p,\
    \ n).sorted\n        return l.zip(r).forall(x => x._1 >= x._2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyk308r29.scala:37)\n\tat Problem.main(tmpyk308r29.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val (n, m) = (arr.length,\
    \ arr.max)\n        if (n == 0) true\n        else if (n == 1) true\n        else\
    \ {\n            var max = -1\n            var (left, right) = (0, 0)\n      \
    \      for (i <- 0 until n) {\n                if (arr(i) < max) {\n         \
    \           left = i\n                    break\n                }\n         \
    \       else max = arr(i)\n            }\n            max = -1\n            for\
    \ (i <- n - 1 to 0 by -1) {\n                if (arr(i) < max) {\n           \
    \         right = i\n                    break\n                }\n          \
    \      else max = arr(i)\n            }\n            if (left == 0 && right ==\
    \ 0) true\n            else {\n                if (left < right) false\n     \
    \           else if (left + 1 == right) true\n                else {\n       \
    \             if (arr(left) < arr(right)) true\n                    else false\n\
    \                }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp18worb32.scala:33:20 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp18worb32.scala:35:30\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33melse\e\
    [0m max = arr(i)\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Found:    Long\n\e[31m   |\e[0m    \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp18worb32.scala:41:20 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m                    break\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp18worb32.scala:43:30\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                \e[33melse\e\
    [0m max = arr(i)\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Found:    Long\n\e[31m   |\e[0m    \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // move_one_ball([3, 4, 5, 1, 2])==>True\n\
    \    // Explanation: By performin 2 right shift operations, non-decreasing order\
    \ can\n    // be achieved for the given array.\n    // move_one_ball([3, 5, 4,\
    \ 1, 2])==>False\n    // Explanation:It is not possible to get non-decreasing\
    \ order for the given\n    // array by performing any number of right shift operations.\n\
    \    def moveOneBall(arr : List[Long]) : Boolean = {\n        val minValue = arr.min\n\
    \        val indexOfMinValue = arr.indexOf(minValue)\n        val maxValue = arr.max\n\
    \        val indexOfMaxValue = arr.indexOf(maxValue)\n        if (indexOfMinValue\
    \ == 0) {\n            true\n        } else if (indexOfMaxValue == arr.length\
    \ - 1) {\n            true\n        } else {\n            false\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpku70vhmy.scala:37)\n\tat Problem.main(tmpku70vhmy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
