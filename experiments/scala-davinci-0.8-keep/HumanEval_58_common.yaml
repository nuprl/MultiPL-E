name: HumanEval_58_common
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return sorted unique common elements for two lists.\n    // >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    // [1, 5, 653]\n    // >>>\
  \ common([5, 3, 2, 8], [3, 2])\n    // [2, 3]\n    def common(l1 : List[Long], l2\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong,\
  \ 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong,\
  \ 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n"
completions: ["      var common_elems = List[Long]()\n      var l1_map = Map[Long,\
    \ Int]()\n      for (i <- l1) {\n        if (l1_map.contains(i)) l1_map(i) +=\
    \ 1\n        else l1_map += (i -> 1)\n      }\n      for (i <- l2) {\n       \
    \ if (l1_map.contains(i)) {\n          if (l1_map(i) > 0) {\n            common_elems\
    \ = i :: common_elems\n            l1_map(i) -= 1\n          }\n        }\n  \
    \    }\n      common_elems.sorted", "        val x = l1.toSet\n        val y =\
    \ l2.toSet\n        return x.intersect(y).toList.sorted", "        val l3 = l1\
    \ intersect l2\n        l3.sorted", '        (l1.sorted.toSet & l2.sorted.toSet).toList.sorted',
  "        val h1 = l1.toSet.toList\n        val h2 = l2.toSet.toList\n        val\
    \ s = h1.intersect(h2)\n        s.sortWith(_ < _)", "        val d1 = new HashMap[Long,\
    \ Long]()\n        val d2 = new HashMap[Long, Long]()\n        for (i <- l1) {\n\
    \            if (d1.contains(i)) d1(i) += 1\n            else d1(i) = 1\n    \
    \    }\n        for (i <- l2) {\n            if (d2.contains(i)) d2(i) += 1\n\
    \            else d2(i) = 1\n        }\n        val d3 = new HashMap[Long, Long]()\n\
    \        for (key <- d1.keys) {\n            if (d2.contains(key)) {\n       \
    \         d3(key) = 1\n            }\n        }\n        d3.keys.toList.sorted",
  "        var l = ListBuffer[Long]()\n        for (i <- l1.sorted) if (l2.contains(i))\
    \ l += i\n        return l.toList.sorted.distinct", "        val map = HashMap[Long,\
    \ Long]()\n        for (i <- l1) map(i) = 1\n        for (i <- l2) map(i) = map.getOrElse(i,\
    \ 0) + 1\n        map.toList.filter(_._2 == 2).map(_._1).sorted", "        //\
    \ Note that solution could be made more efficient by sorting one list.\n     \
    \   val table1 = HashMap[Long, Long]()\n        val table2 = HashMap[Long, Long]()\n\
    \        for (i <- l1) {\n            if (table1.contains(i)) table1(i) += 1\n\
    \            else table1(i) = 1\n        }\n        for (i <- l2) {\n        \
    \    if (table2.contains(i)) table2(i) += 1\n            else table2(i) = 1\n\
    \        }\n        val table3 = HashMap[Long, Long]()\n        for (i <- table1.keys)\
    \ {\n            if (table2.contains(i)) {\n                val m = min(table1(i),\
    \ table2(i))\n                if (m > 0) table3(i) = m\n            }\n      \
    \  }\n        val result = new ListBuffer[Long]()\n        for (i <- table3.keys)\
    \ for (j <- 1 to table3(i).toInt) result += i\n        result.toList.sorted",
  "        val m1 = Array.fill(100)(0)\n        val m2 = Array.fill(100)(0)\n    \
    \    for (i <- l1) m1(i.toInt / 100) += 1\n        for (i <- l2) m2(i.toInt /\
    \ 100) += 1\n        var i = 0\n        val l = new ListBuffer[Long]\n       \
    \ while (i < 100) {\n            if (m1(i) > 0 && m2(i) > 0) {\n             \
    \   l ++= common2(l1.filter(x => x >= i * 100 && x < (i + 1) * 100), l2.filter(x\
    \ => x >= i * 100 && x < (i + 1) * 100))\n            }\n            i += 1\n\
    \        }\n        l.toList", "        val commonList = new ListBuffer[Long]()\n\
    \        l1.map(n => {\n            if (l2.contains(n)) commonList += n\n    \
    \    })\n        return commonList.toList.sorted", "        val s = new HashSet[Long]\n\
    \        for (e <- l1) {\n            s += e\n        }\n        l2.filter(e =>\
    \ s.contains(e)).sorted", "        val h : HashMap[Long, Int] = new HashMap[Long,\
    \ Int]\n        for (i <- l1) {\n            if (h.contains(i)) h(i) += 1\n  \
    \          else h(i) = 1\n        }\n        val r : HashMap[Long, Int] = new\
    \ HashMap[Long, Int]\n        for (i <- l2) {\n            if (h.contains(i))\
    \ {\n                if (r.contains(i)) r(i) += 1\n                else r(i) =\
    \ 1\n            }\n        }\n        var l : List[Long] = Nil\n        for ((x,\
    \ y) <- r) {\n            for (i <- 1 to min(y, h(x))) l = x :: l\n        }\n\
    \        l.sorted", "        val l = l1.intersect(l2)\n        l.sorted", '        l1.toSet.intersect(l2.toSet).toList.sorted',
  "        val l1Map = HashMap.empty[Long, Int]\n        for (i <- l1) {\n       \
    \     l1Map.get(i) match {\n                case Some(count) => l1Map.put(i, count\
    \ + 1)\n                case None => l1Map.put(i, 1)\n            }\n        }\n\
    \        val l2Map = HashMap.empty[Long, Int]\n        for (i <- l2) {\n     \
    \       l2Map.get(i) match {\n                case Some(count) => l2Map.put(i,\
    \ count + 1)\n                case None => l2Map.put(i, 1)\n            }\n  \
    \      }\n        var list = List.empty[Long]\n        for ((key, value) <- l1Map)\
    \ {\n            l2Map.get(key) match {\n                case Some(count) => list\
    \ = (0 until min(value, count)).foldLeft(list)((z, i) => key :: z)\n         \
    \       case None =>\n            }\n        }\n        list.sorted", "      \
    \  // Return the unique list of common elements.\n        def unique(l : List[Long])\
    \ : List[Long] = {\n            var output = List[Long]()\n            var set\
    \ = HashSet[Long]()\n            for (i <- l) {\n                if (!set.contains(i))\
    \ {\n                    output ::= i\n                    set += i\n        \
    \        }\n            }\n            output.reverse\n        }\n        // Sort\
    \ the two lists (in place).\n        def sort(l : List[Long]) : List[Long] = {\n\
    \            var array = l.toArray\n            java.util.Arrays.sort(array)\n\
    \            array.toList\n        }\n        var list1 = sort(l1)\n        var\
    \ list2 = sort(l2)\n        var output = List[Long]()\n        while (list1.length\
    \ > 0 && list2.length > 0) {\n            if (list1.head < list2.head) list1 =\
    \ list1.tail\n            else if (list1.head > list2.head) list2 = list2.tail\n\
    \            else {\n                output ::= list1.head\n                list1\
    \ = list1.tail\n                list2 = list2.tail\n            }\n        }\n\
    \        output.reverse", "        val commonElements = ArrayBuffer[Long]()\n\
    \        for (x <- l1) {\n            if (l2.contains(x)) {\n                commonElements\
    \ += x\n            }\n        }\n        commonElements.toList.sorted", "   \
    \     var s1 = SortedSet[Long]() ++ l1\n        var s2 = SortedSet[Long]() ++\
    \ l2\n        s1.intersect(s2).toList", "        val s = l1.toSet\n        l2.toSet.filter(s.contains(_)).toList.sorted"]
stop_tokens:
- "\n    }\n"
