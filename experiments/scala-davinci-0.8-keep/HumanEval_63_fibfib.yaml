name: HumanEval_63_fibfib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // The FibFib number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n    // fibfib(0) == 0\n    // fibfib(1) == 0\n   \
  \ // fibfib(2) == 1\n    // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\
  \    // Please write a function to efficiently compute the n-th element of the fibfib\
  \ number sequence.\n    // >>> fibfib(1)\n    // 0\n    // >>> fibfib(5)\n    //\
  \ 4\n    // >>> fibfib(8)\n    // 24\n    def fibfib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(fibfib((2l)) == (1l));\n\
  \    assert(fibfib((1l)) == (0l));\n    assert(fibfib((5l)) == (4l));\n    assert(fibfib((8l))\
  \ == (24l));\n    assert(fibfib((10l)) == (81l));\n    assert(fibfib((12l)) == (274l));\n\
  \    assert(fibfib((14l)) == (927l));\n    }\n\n}\n"
completions: ["        var dp = ArrayBuffer.fill(3)(0L)\n        for (i <- 0 until\
    \ n) {\n            dp(i % 3) = if (i < 2) i else dp(0) + dp(1) + dp(2)\n    \
    \    }\n        dp(n % 3)", "    \trequire(n >= 0)\n    \tif (n == 0) 0\n    \t\
    else if (n == 1) 0\n    \telse if (n == 2) 1\n    \telse fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3)", "        if (n < 2) 0\n        else if (n == 2) 1\n \
    \       else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", "        var a =\
    \ 0L\n        var b = 0L\n        var c = 1L\n        var i = 2L\n        while\
    \ (i <= n) {\n            a = b\n            b = c\n            c = a + b + c\n\
    \            i += 1\n        }\n        c", "        if (n == 0) return 0\n  \
    \      if (n == 1) return 0\n        if (n == 2) return 1\n        val fibfib\
    \ = new Array[Long](n.toInt)\n        fibfib(0) = 0\n        fibfib(1) = 0\n \
    \       fibfib(2) = 1\n        for (i <- 3 to n.toInt) {\n            fibfib(i)\
    \ = fibfib(i - 1) + fibfib(i - 2) + fibfib(i - 3)\n        }\n        fibfib(n.toInt\
    \ - 1)", "        // Fill up this function body\n        // You can add another\
    \ function as well, if required\n        var l : List[Long] = List(0, 0, 1)\n\
    \        if (n < l.length) l(n.toInt)\n        else {\n            for (i <- l.length\
    \ to n.toInt) {\n                l = l :+ (l(i - 1) + l(i - 2) + l(i - 3))\n \
    \           }\n            l(n.toInt)\n        }", "        var a = 0L\n     \
    \   var b = 0L\n        var c = 1L\n        for (i <- 3 to n.toInt) {\n      \
    \      var t = a + b + c\n            a = b\n            b = c\n            c\
    \ = t\n        }\n        return c", "        val arr = Array.fill(n.toInt + 1)(0L)\n\
    \        arr(0) = 0\n        arr(1) = 0\n        arr(2) = 1\n        for (i <-\
    \ 3 to n.toInt) {\n            arr(i) = arr(i - 1) + arr(i - 2) + arr(i - 3)\n\
    \        }\n        arr(n.toInt)", "        require(n >= 0)\n        var c = -1L\n\
    \        var b = 0L\n        var a = 0L\n        for (i <- 0L to n) {\n      \
    \      if (i == 0) {\n                c = 0\n            } else if (i == 1) {\n\
    \                c = 0\n            } else if (i == 2) {\n                c =\
    \ 1\n            } else {\n                c = a + b + c\n                a =\
    \ b\n                b = c\n            }\n        }\n        c", "        var\
    \ a = 0L\n        var b = 0L\n        var c = 1L\n        for (i <- 2 to n.toInt)\
    \ {\n            a = b\n            b = c\n            c = a + b + c\n       \
    \ }\n        return c", "        val m = 1000000007\n        val mat = Array(Array(1,\
    \ 1, 1), Array(1, 0, 0), Array(0, 1, 0))\n        def matpow(mat : Array[Array[Long]],\
    \ n : Long) : Array[Array[Long]] = {\n            if (n == 1) mat\n          \
    \  else {\n                val half = matpow(mat, n / 2)\n                if (n\
    \ % 2 == 0) mul(half, half)\n                else mul(mul(half, half), mat)\n\
    \            }\n        }\n        def mul(x : Array[Array[Long]], y : Array[Array[Long]])\
    \ : Array[Array[Long]] = {\n            val res = Array.ofDim[Long](3, 3)\n  \
    \          for (i <- 0 until 3; j <- 0 until 3) {\n                res(i)(j) =\
    \ 0\n                for (k <- 0 until 3) res(i)(j) = (res(i)(j) + x(i)(k) * y(k)(j))\
    \ % m\n            }\n            res\n        }\n        if (n <= 2) 1\n    \
    \    else {\n            val res = matpow(mat, n - 2)\n            (res(0)(0)\
    \ + res(0)(1) + res(0)(2)) % m\n        }", "        n match {\n            case\
    \ 0 => 0\n            case 1 => 0\n            case 2 => 1\n            case _\
    \ =>\n                val p = 2L\n                val N = n\n                def\
    \ loop(i : Long, n0 : Long, n1 : Long, n2 : Long) : Long = {\n               \
    \     i match {\n                        case i if (i == N) => n0\n          \
    \              case _ => loop(i + 1, n0 + n1 + n2, n0, n1)\n                 \
    \   }\n                }\n                loop(p, 1, 0, 0)\n        }", "    \
    \    var fib : Array[Long] = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n\
    \        fib(1) = 0\n        fib(2) = 1\n        for (i <- 3 to n.toInt) fib(i)\
    \ = fib(i - 1) + fib(i - 2) + fib(i - 3)\n        fib(n.toInt)", "        // Fill\
    \ in the body of this function.\n        0", "        // TODO: solve it!!!\n \
    \       return 0", "        var map = Map[Long, Long]()\n        map += (0L ->\
    \ 0L)\n        map += (1L -> 0L)\n        map += (2L -> 1L)\n        def fibfib(n\
    \ : Long) : Long = {\n            if (map.contains(n)) map(n)\n            else\
    \ {\n                val m = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n \
    \               map += (n -> m)\n                m\n            }\n        }\n\
    \        fibfib(n)", "\t    var a : Long = 0\n\t    var b : Long = 0\n\t    var\
    \ c : Long = 1\n\t    var d : Long = 1\n\t    if (n == 0) return 0\n\t    if (n\
    \ == 1) return 0\n\t    if (n == 2) return 1\n\t    var i : Long = 3\n\t    while\
    \ (i <= n) {\n\t\t    d = a + b + c\n\t\t    a = b\n\t\t    b = c\n\t\t    c =\
    \ d\n\t\t    i += 1\n\t    }\n\t    return d", "        var a = 0L\n        var\
    \ b = 0L\n        var c = 1L\n        for (i <- 1L to n) {\n            val d\
    \ = a + b + c\n            a = b\n            b = c\n            c = d\n     \
    \   }\n        return c", "\t\tvar first = 0L\n\t\tvar second = 0L\n\t\tvar third\
    \ = 1L\n\t\tvar nth = 1L\n\t\tfor (i <- 3 to n.toInt) {\n\t\t\tnth = first + second\
    \ + third\n\t\t\tfirst = second\n\t\t\tsecond = third\n\t\t\tthird = nth\n\t\t\
    }\n\t\tnth", "        // Fill in the missing code here.\n        0"]
stop_tokens:
- "\n    }\n"
