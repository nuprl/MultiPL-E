name: HumanEval_96_count_up_to
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Implement a function that takes an non-negative integer and returns an array\
  \ of the first n\n    // integers that are prime numbers and less than n.\n    //\
  \ for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11) => [2,3,5,7]\n\
  \    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
  \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n   \
  \ def countUpTo(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
  \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
  \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
  \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
  \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
  \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
  \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
  \ 97l.toLong))));\n    }\n\n}\n"
completions: ["        def isPrime(x : Long) : Boolean = {\n            if (x == 2)\
    \ return true\n            if (x % 2 == 0) return false\n            for (i <-\
    \ 3L to sqrt(x).toLong by 2) {\n                if (x % i == 0) return false\n\
    \            }\n            return true\n        }\n        var result = List[Long]()\n\
    \        if (n < 2) return result\n        result = 2L :: result\n        for\
    \ (i <- 3L to n) {\n            if (isPrime(i)) result = i :: result\n       \
    \ }\n        return result", '        ???', "        def isPrime(x : Long) : Boolean\
    \ = {\n            if (x == 1) return false\n            for (i <- 2L to x-1L)\
    \ {\n                if (x % i == 0) return false\n            }\n           \
    \ return true\n        }\n        val result = new ListBuffer[Long]\n        for\
    \ (i <- 2L to n-1L) {\n            if (isPrime(i)) result += i\n        }\n  \
    \      return result.toList", "        if (n < 0) {\n            Nil\n       \
    \ } else {\n            val li = (0L to n).toList.filter(isPrime)\n          \
    \  li.filter(_ < n)\n        }", "      def sieve(candidates : List[Long], primes\
    \ : List[Long]) : List[Long] = {\n        val head = candidates.head\n       \
    \ val (notPrimes, primes2) = candidates.span(x => x % head != 0)\n        val\
    \ newPrimes = head :: primes2\n        if (newPrimes.size >= n)\n          newPrimes.take(n.toInt)\n\
    \        else\n          sieve(notPrimes, newPrimes)\n      }\n      if (n < 2)\n\
    \        Nil\n      else\n        sieve(2L to n toList, Nil)", '        // your
    code here', "        def isPrime(num : Long) : Boolean = {\n            if (num\
    \ <= 3) true\n            else if (num % 2 == 0 || num % 3 == 0) false\n     \
    \       else {\n                var i = 5\n                while (i*i <= num)\
    \ {\n                    if (num % i == 0 || num % (i + 2) == 0) return false\n\
    \                    i += 6\n                }\n                true\n       \
    \     }\n        }\n        def countDown(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) acc\n            else if (isPrime(n)) countDown(n\
    \ - 1, n :: acc)\n            else countDown(n - 1, acc)\n        }\n        countDown(n,\
    \ List[Long]())", "        // Time Complexity : O(n)\n        // Space Complexity\
    \ : O(n)\n        if (n < 2) return List()\n        val primes = Array.fill(n.toInt)(true)\n\
    \        primes(0) = false\n        primes(1) = false\n        for (i <- (2 to\
    \ sqrt(n).toInt)) if (primes(i)) for (j <- Range(i * i, n.toInt, i)) primes(j)\
    \ = false\n        val list = Buffer[Long]()\n        for (i <- Range(2, n.toInt))\
    \ if (primes(i)) list += i\n        list.toList", '      (1L to n).filter(isPrime(_)).toList',
  "        def isPrime(n : Long) : Boolean = {\n            if (n < 2) {\n       \
    \         return false\n            }\n            else if (n == 2) {\n      \
    \          return true\n            }\n            else {\n                for\
    \ (i <- 2 until n) {\n                    if (n % i == 0) {\n                \
    \        return false\n                    }\n                }\n            \
    \    return true\n            }\n        }\n        val buf = new ArrayBuffer[Long]\n\
    \        for (i <- 2L until n) {\n            if (isPrime(i)) {\n            \
    \    buf += i\n            }\n        }\n        buf.toList", "        // faster\
    \ than countUpTo1\n        // faster than countUpTo2\n        val hash = HashMap[Long,\
    \ Boolean]()\n        def isPrime(m : Long) : Boolean = {\n            if (hash.contains(m))\
    \ hash(m)\n            else {\n                val result = (2L to m / 2L).forall(x\
    \ => m % x != 0)\n                hash += m -> result\n                result\n\
    \            }\n        }\n        (2L to n).filter(isPrime).toList", "      \
    \  var primes = new ListBuffer[Long]\n        if (n <= 1) return List()\n    \
    \    if (n == 2) return List(2)\n        if (n == 3) return List(2, 3)\n     \
    \   primes += 2\n        primes += 3\n        var current = 5\n        while (current\
    \ < n) {\n            if (current % 6 == 1) {\n                var flag = true\n\
    \                for (divisor <- primes) {\n                    if (divisor *\
    \ divisor > current) break\n                    if (current % divisor == 0) {\n\
    \                        flag = false\n                        break\n       \
    \             }\n                }\n                if (flag) primes += current\n\
    \            }\n            current += 2\n        }\n        primes.toList", " \
    \       /**\n          * Determine whether the given number is prime\n       \
    \   * @param number  a positive integer\n          * @return boolean indicates\
    \ whether a number is prime\n          */\n        def isPrime(number : Long)\
    \ : Boolean = {\n            val squareRoot = ceil(sqrt(number))\n           \
    \ if (number <= 1) {\n                false\n            } else if (number ==\
    \ 2) {\n                true\n            } else {\n                val candidateDivisors\
    \ = 2 to squareRoot.toInt\n                val isDivisible = (candidateDivisors.find(number\
    \ % _ == 0) == None)\n                isDivisible\n            }\n        }\n\
    \        if (n <= 1) {\n            List()\n        } else {\n            val\
    \ numbers = 2L to n\n            val primeNumbers = numbers.filter(isPrime(_))\n\
    \            primeNumbers.toList\n        }", "\t\tvar a : List[Long] = Nil\n\t\
    \tfor (i <- 2L to n) {\n\t\t\tif (isPrime(i)) {\n\t\t\t\ta = i :: a\n\t\t\t}\n\
    \t\t}\n\t\ta.reverse", "      def isPrime(num : Long) : Boolean = {\n        num\
    \ match {\n          case 1 => false\n          case 2 => true\n          case\
    \ _ => {\n            if(num % 2 == 0) return false\n            for(i <- 3L to\
    \ sqrt(num).toLong by 2) {\n              if(num % i == 0) return false\n    \
    \        }\n            true\n          }\n        }\n      }\n      if(n < 2)\
    \ return List()\n      val result = Buffer[Long]()\n      for(i <- 2L to n) {\n\
    \        if(isPrime(i)) result += i\n      }\n      result.toList", "        if\
    \ (n <= 1) List()\n        else {\n            (2L to n).filter(isPrime(_)).toList\n\
    \        }", "\t\tval primes = ListBuffer[Long]()\n\t\tfor (num <- 2L to n) {\n\
    \t\t\tif (isPrime(num)) primes += num\n\t\t}\n\t\tprimes.toList", "        if\
    \ (n <= 1) List[Long]()\n        else if (n == 2) List[Long](2)\n        else\
    \ {\n            var foundPrimes = List[Long](2)\n            var current = 3\n\
    \            while (current < n) {\n                var isPrime = true\n     \
    \           for (prime <- foundPrimes) {\n                    if (current % prime\
    \ == 0) {\n                        isPrime = false\n                        break\n\
    \                    }\n                }\n                if (isPrime) foundPrimes\
    \ ::= current\n                current += 2\n            }\n            foundPrimes.reverse\n\
    \        }", "        require(n >= 0)\n        if (n == 0) return List()\n   \
    \     if (n == 1) return List()\n        def isPrime(n : Long) : Boolean = {\n\
    \            if (n == 2) return true\n            for (i <- 2 until sqrt(n).toInt\
    \ + 1) if (n % i == 0) return false\n            return true\n        }\n    \
    \    val primes = ArrayBuffer[Long]()\n        for (i <- 2 to n.toInt) if (isPrime(i))\
    \ primes += i\n        return primes.toList", "        def isPrime(p : Long) :\
    \ Boolean = {\n            if (p < 2) return false\n            if (p == 2) return\
    \ true\n            val sqrtP = sqrt(p).asInstanceOf[Long]\n            for (i\
    \ <- 2L to sqrtP) {\n                if (p % i == 0) return false\n          \
    \  }\n            return true\n        }\n        def countUpToRec(n : Long, acc\
    \ : List[Long]) : List[Long] = {\n            if (n < 2) return acc\n        \
    \    if (isPrime(n)) return countUpToRec(n - 1, n :: acc)\n            else return\
    \ countUpToRec(n - 1, acc)\n        }\n        return countUpToRec(n, List())"]
stop_tokens:
- "\n    }\n"
