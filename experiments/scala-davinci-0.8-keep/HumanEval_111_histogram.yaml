name: HumanEval_111_histogram
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a string representing a space separated lowercase letters, return\
  \ a dictionary\n    // of the letter with the most repetition and containing the\
  \ corresponding count.\n    // If several letters have the same occurrence, return\
  \ all of them.\n    // Example:\n    // histogram('a b c') == {'a': 1, 'b': 1, 'c':\
  \ 1}\n    // histogram('a b b a') == {'a': 2, 'b': 2}\n    // histogram('a b c a\
  \ b') == {'a': 2, 'b': 2}\n    // histogram('b b b b a') == {'b': 4}\n    // histogram('')\
  \ == {}\n    def histogram(test : String) : Map[String,Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(histogram((\"a b\
  \ b a\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"\
  a b c a b\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"\
  a b c d g\")).equals((Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l, \"\
  d\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"\
  r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"b b b b a\")).equals((Map[String,Long](\"\
  b\" -> 4l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\"\
  \ -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"\")).equals((Map[String,Long]())));\n\
  \    assert(histogram((\"a\")).equals((Map[String,Long](\"a\" -> 1l))));\n    }\n\
  \n}\n"
completions: ["        val r = test.split(\" \").groupBy(x => x).map(x => (x._1, x._2.length))\n\
    \        val max = r.values.max\n        val max_keys = r.filter(x => x._2 ==\
    \ max).keySet\n        r.filter(x => max_keys.contains(x._1))", "        val results\
    \ = new MapBuilder[String,Long,Map[String,Long]](Map())\n        val letters =\
    \ test.split(\" \")\n        letters.foreach(letter => results += letter -> (results.result.getOrElse(letter,\
    \ 0L) + 1L))\n        results.result", '        return test.split(" ").groupBy(x
    => x).mapValues(_.length).filter(_._2 == test.split(" ").groupBy(x => x).mapValues(_.length).values.max)',
  "        val words = test.split(\" \")\n        val map = Map[String,Long]()\n \
    \       words.foreach(w => {\n            if (map.contains(w)) {\n           \
    \     map.put(w, map(w) + 1)\n            } else {\n                map.put(w,\
    \ 1)\n            }\n        })\n        val max = map.values.max\n        map.filter(p\
    \ => p._2 == max)", '        test.split(" ").groupBy(x => x).map(x => (x._1, x._2.length.toLong)).filter(x
    => x._2 == test.split(" ").groupBy(x => x).map(x => (x._1, x._2.length.toLong)).maxBy(x
    => x._2)._2)', '        test.split(" ").groupBy(e => e).map(p => (p._1, p._2.length.toLong)).filter(p
    => p._2 == test.split(" ").groupBy(e => e).map(p => (p._1, p._2.length.toLong)).map(x
    => x._2).max)', "        // convert the string into a list of strings\n      \
    \  val strArr = test.split(\" \")\n        // Create a dictionary of the elements\
    \ in the string and their corresponding\n        // count of occurence.\n    \
    \    val hist = strArr.groupBy(identity).mapValues(_.size)\n        // Create\
    \ a dictionary of the elements with the maximum occurrence.\n        // hist.maxBy(_._2)\
    \ returns a tuple (element, count)\n        val max = hist.maxBy(_._2)\n     \
    \   // Create a dictionary of the element, count pairs with the maximum count.\n\
    \        // The filter function goes through the histogram, finds the element/count\n\
    \        // pairs with the maximum count, and puts them in a dictionary.\n   \
    \     // The map function maps the dictionary to the pair's first element\n  \
    \      // (the element name) as the key and the pair's second element (the count)\n\
    \        // as the value.\n        val maxDict = hist.filter(_._2 == max._2).map(x\
    \ => (x._1, x._2))\n        return maxDict", "        var map = new scala.collection.mutable.HashMap[String,Long]\n\
    \        for (i <- test.split(\" \")) {\n            if (map.contains(i)) map(i)\
    \ += 1 else map(i) = 1\n        }\n        map.toMap", "        if (test.isEmpty)\
    \ return Map()\n        val words = test.split(\" \")\n        return words.groupBy(identity).mapValues(_.length).filter(_._2\
    \ == words.map(c => words.count(_ == c)).max)", '        return test.split(" ").groupBy(identity).mapValues(_.length).filter(_._2
    == test.split(" ").groupBy(identity).mapValues(_.length).values.max)', "     \
    \ // a map of maps\n      val result = new HashMap[String, Long]()\n      for\
    \ (c <- test.split(\" \")) {\n        if (result.contains(c)) result(c) += 1\n\
    \        else result(c) = 1\n      }\n      val maxValue = result.values.max\n\
    \      val maxKeys = result.filter(_._2 == maxValue).keys\n      val res = new\
    \ HashMap[String, Long]()\n      for (k <- maxKeys) res(k) = maxValue\n      res",
  "        val chars = test.split(\" \")\n        val all = chars.map(s => (s,1))\n\
    \        var map = all.toMap\n        val totals = new HashMap[String,Long]\n\
    \        for (k <- map.keys) {\n            val count = map.count(x => x._1 ==\
    \ k)\n            totals += (k -> count)\n        }\n        val max = totals.values.max\n\
    \        val maxes = totals.filter(x => x._2 == max)\n        maxes", "      \
    \  // Match each one lowercase letter in a group, and then find the max count\n\
    \        val alphabet = 'a' to 'z'\n        val regex = \"[\" + alphabet.mkString\
    \ + \"]+\"\n        val groups = test.split(\" \").filter(x => x.matches(regex))\n\
    \        val counts = groups.map(x => x.groupBy(y => y).map(z => (z._1.toString,\
    \ z._2.length.toLong)))\n        // Make the map from the counts\n        val\
    \ result = new HashMap[String,Long]\n        for (count <- counts) {\n       \
    \     for ((k,v) <- count) {\n                result(k) = max(result.getOrElse(k,\
    \ 0L), v)\n            }\n        }\n        result.toMap", "    \tdef count(ch\
    \ : String, list : List[String]) : Long = {\n    \t\tif (list.isEmpty) 0\n   \
    \ \t\telse if (list.head == ch) 1 + count(ch, list.tail)\n    \t\telse count(ch,\
    \ list.tail)\n    \t}\n    \tval strList = test.split(\" \").toList\n    \tval\
    \ chList = strList.distinct\n    \tval result = chList.map(x => (x, count(x, strList))).toMap\n\
    \    \tval max = result.values.max\n    \tresult.filter(x => x._2 == max)", " \
    \       if (test.length == 0) return Map[String,Long]()\n        var map = Map[String,Long]()\n\
    \        test.split(\" \").foreach(x => {\n            val i = map.getOrElse(x,\
    \ 0)\n            map += (x -> (i + 1))\n        })\n        var maxCount = map.values.max\n\
    \        var values = ArrayBuffer[String]()\n        map.keys.foreach(x => {\n\
    \            if (map(x) == maxCount) values += x\n        })\n        return values.toMap.mapValues(x\
    \ => maxCount)", "        val letters = test.split(\" \")\n        var counts\
    \ = scala.collection.mutable.Map[String,Long]()\n        for (l <- letters) {\n\
    \            if (counts.contains(l)) counts(l) += 1\n            else counts(l)\
    \ = 1\n        }\n        val max = counts.values.max\n        var result = scala.collection.mutable.Map[String,Long]()\n\
    \        for ((k,v) <- counts) {\n            if (v == max) result(k) = v\n  \
    \      }\n        result.toMap", "        var occurrences = new HashMap[String,Long]()\n\
    \        for (char <- test.split(\" \")) {\n            if (occurrences.contains(char))\
    \ occurrences(char) += 1\n            else occurrences += (char -> 1)\n      \
    \  }\n        var maxOccurrence = occurrences.values.max\n        return occurrences.filter((char\
    \ : (String,Long)) => char._2 == maxOccurrence)", "      val array = test.split(\"\
    \ \")\n      val map = scala.collection.mutable.Map[String,Long]()\n      for\
    \ (i <- 0 until array.length) {\n        if (map.contains(array(i))) {\n     \
    \     map(array(i)) += 1\n        } else {\n          map += (array(i) -> 1)\n\
    \        }\n      }\n      var max = 0\n      for (a <- map) {\n        if (a._2\
    \ > max) max = a._2.toInt\n      }\n      val res = scala.collection.mutable.Map[String,Long]()\n\
    \      for (a <- map) {\n        if (a._2 == max) res += (a._1 -> a._2)\n    \
    \  }\n      res.toMap", "        val list = test.split(\" \").filter(_ != \"\"\
    ).toList.map(x => x.toLong)\n        val map : Map[String, Long] = Map()\n   \
    \     list.foldLeft(map)((map, e) => map.updated(e.toString, map.getOrElse(e.toString,\
    \ 0) + 1))", "      var dict = Map[String,Long]()\n      for (c <- test.split(\"\
    \ \")) {\n        if (dict.contains(c)) {\n          dict(c) += 1\n        } else\
    \ {\n          dict(c) = 1\n        }\n      }\n      dict.filter(x => x._2 ==\
    \ dict.values.max)"]
stop_tokens:
- "\n    }\n"
