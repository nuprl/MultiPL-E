name: HumanEval_85_add
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a non-empty list of integers lst. add the even elements that are at\
  \ odd indices..\n    // Examples:\n    // add([4, 2, 6, 7]) ==> 2\n    def add(lst\
  \ : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(add((List[Long](4l.toLong,\
  \ 88l.toLong))) == (88l));\n    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));\n    assert(add((List[Long](4l.toLong,\
  \ 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));\n    assert(add((List[Long](4l.toLong,\
  \ 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));\n    }\n\n}\n"
completions: ["        var evens = List[Long]()\n        var odds = List[Long]()\n\
    \        for (i <- lst.indices) {\n            if (i % 2 == 0) {\n           \
    \     evens = evens :+ lst(i)\n            } else {\n                odds = odds\
    \ :+ lst(i)\n            }\n        }\n        var sum = 0L\n        for (x <-\
    \ evens) {\n            sum += x\n        }\n        return sum", "        val\
    \ indices = for(i <- 1 until lst.length by 2) yield i\n        indices.map(x =>\
    \ lst(x)).filter(x => x % 2 == 0).sum", "        //var sum = 0\n        //for\
    \ (i <- 0 until lst.length) {\n        //    if (i % 2 == 1 && lst(i) % 2 == 0)\
    \ {\n        //        sum += lst(i)\n        //    }\n        //}\n        //sum\n\
    \        lst.zipWithIndex.filter(e => e._2 % 2 == 1 && e._1 % 2 == 0).map(_._1).sum",
  "        def iter(lst : List[Long], sum : Long, index : Int) : Long = {\n      \
    \      if (lst.isEmpty) sum\n            else if (index % 2 == 1) iter(lst.tail,\
    \ sum + lst.head, index + 1)\n            else iter(lst.tail, sum, index + 1)\n\
    \        }\n        iter(lst, 0, 0)", '        lst.zipWithIndex.map(i => if(i._2
    % 2 == 1) i._1 else 0).sum', "        var l = lst.zipWithIndex.map(x => (x._1,\
    \ x._2 % 2)).filter(x => x._2 == 1).map(x => x._1).filter(x => x % 2 == 0).sum\n\
    \        return l", "        // My solution\n        // var index = 0\n      \
    \  // var sum = 0L\n        // for (num <- lst) {\n        //     if (index %\
    \ 2 == 1 && num % 2 == 0) {\n        //         sum += num\n        //     }\n\
    \        //     index += 1\n        // }\n        // sum\n        // Best solution\n\
    \        // lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).filter(_ % 2 == 0).sum\n\
    \        // lst.zipWithIndex.filter(x => x._2 % 2 == 1 && x._1 % 2 == 0).map(_._1).sum\n\
    \        lst.zipWithIndex.filter(x => x._2 % 2 == 1 && x._1 % 2 == 0).map(_._1).sum",
  "        var total = 0L\n        for (i <- 0 until lst.length) {\n            if\
    \ (i % 2 == 1 && lst(i) % 2 == 0) total += lst(i)\n        }\n        return total",
  '        lst.indices.filter(_ % 2 == 1).map(lst(_)).filter(_ % 2 == 0).sum', " \
    \       var sum = 0L\n        for (x <- lst.indices) {\n            if (x % 2\
    \ == 1 && lst(x) % 2 == 0) sum += lst(x)\n        }\n        sum", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 1 && x._1 % 2 == 0).map(_._1).sum', "        var sum = 0L\n   \
    \     for (i <- 0 until lst.length) {\n            if (i % 2 == 1 && lst(i) %\
    \ 2 == 0) sum += lst(i)\n        }\n        sum", "        // code goes here.\n\
    \        lst.filter((x, i) => (x % 2 == 0 && i % 2 == 1)).sum", '      lst.zipWithIndex.map(x
    => if (x._2 % 2 == 1) x._1 else 0).sum', "        val l = lst.zipWithIndex.filter(x\
    \ => x._2 % 2 == 1 && x._1 % 2 == 0).map(_._1)\n        l.foldLeft(0L)(_ + _)",
  '        lst.zipWithIndex.filter { case (x, i) => (x % 2 == 0) && (i % 2 == 1) }.map
    { _._1 }.sum', '        (0 until lst.length).filter(_ % 2 == 1).filter(i => lst(i)
    % 2 == 0).map(i => lst(i)).sum', "      lst.zipWithIndex.foldLeft(0L)((a,b) =>\
    \ {\n        if (b._2 % 2 == 1 && b._1 % 2 == 0)\n          a + b._1\n       \
    \ else\n          a\n      })", "        var counter = 1;\n        var sum = 0;\n\
    \        for (i <- lst) {\n            if (counter % 2 == 1) {\n             \
    \   sum += i;\n            }\n            counter += 1;\n        }\n        return\
    \ sum;", "        var sum = 0L\n        for (i <- 0 until lst.length) {\n    \
    \        if (i % 2 == 1 && lst(i) % 2 == 0) sum += lst(i)\n        }\n       \
    \ sum"]
stop_tokens:
- "\n    }\n"
