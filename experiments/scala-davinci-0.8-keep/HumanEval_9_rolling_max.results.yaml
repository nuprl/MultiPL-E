language: scala
name: HumanEval_9_rolling_max
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var maximums = List[Long]()\n      \
    \  var currentMaximum = Long.MinValue\n        for (number <- numbers) {\n   \
    \         currentMaximum = max(currentMaximum, number)\n            maximums ::=\
    \ currentMaximum\n        }\n        maximums.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var max = numbers(0)\n        var result\
    \ = ArrayBuffer[Long]()\n        result += max\n        for (i <- 1 until numbers.length)\
    \ {\n            if (numbers(i) > max) {\n                max = numbers(i)\n \
    \           }\n            result += max\n        }\n        result.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmppczutthv.scala:9)\n\tat Problem$.main(tmppczutthv.scala:21)\n\
    \tat Problem.main(tmppczutthv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var max = numbers(0)\n        var result\
    \ = new ListBuffer[Long]\n        for (i <- 0 until numbers.length) {\n      \
    \      max = max max numbers(i)\n            result += max\n        }\n      \
    \  result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpvvumml0j.scala:9)\n\tat Problem$.main(tmpvvumml0j.scala:18)\n\
    \tat Problem.main(tmpvvumml0j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        val result = ListBuffer.empty[Long]\n\
    \        var max = Long.MinValue\n        for (num <- numbers) {\n           \
    \ max = max max num\n            result += max\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var currentMax = 0L\n        numbers.foldLeft(List[Long]())\
    \ {\n            (r, c) => {\n                currentMax = max(currentMax, c)\n\
    \                r :+ currentMax\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        val maxQueue = new PriorityQueue[Long]()(Ordering[Long].reverse)\n\
    \        var maxStack = new Stack[Long]()\n        for (number <- numbers) {\n\
    \            maxQueue.enqueue(number)\n            if (maxQueue.head != number)\
    \ {\n                maxStack.push(maxQueue.head)\n            } else {\n    \
    \            maxStack.push(number)\n            }\n        }\n        maxStack.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07sftp9i.scala:23)\n\tat Problem.main(tmp07sftp9i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var maxValue = 0L\n        var results\
    \ = List[Long]()\n        for (number <- numbers) {\n            maxValue = max(maxValue,\
    \ number)\n            results = results :+ maxValue\n        }\n        results\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var res = new ListBuffer[Long]\n   \
    \     var max = Long.MinValue\n        for (n <- numbers) {\n            max =\
    \ if (n > max) n else max\n            res += max\n        }\n        res.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var max = numbers(0)\n        numbers.map(number\
    \ => {\n            if (number > max) max = number\n            max\n        })\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp496zucqc.scala:9)\n\tat Problem$.main(tmp496zucqc.scala:16)\n\
    \tat Problem.main(tmp496zucqc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        def helper(result : List[Long], numbers\
    \ : List[Long], current : Long) : List[Long] = {\n            if (numbers.isEmpty)\
    \ result.reverse\n            else helper(max(current, numbers.head) :: result,\
    \ numbers.tail, current)\n        }\n        helper(List(), numbers, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4qtjiuhn.scala:18)\n\tat Problem.main(tmp4qtjiuhn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        val result = new ListBuffer[Long]()\n\
    \        var m = Long.MinValue\n        for (n <- numbers) {\n            if (n\
    \ > m) {\n                m = n\n            }\n            result += m\n    \
    \    }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var currentMax = 0L\n        numbers.map\
    \ { x =>\n            if (x > currentMax) currentMax = x\n            currentMax\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var max : Long = Long.MinValue\n   \
    \     numbers.foldLeft(List[Long]()) {(a,b) => max = max(b, max); a :+ max}\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp_8bbnn7u.scala:10:55 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        numbers.foldLeft(List[\e[35mLong\e[0m]()) {(\e\
    [36ma\e[0m,\e[36mb\e[0m) => max = max(b, max); a :+ max}\n\e[31m\e[31m   |\e[0m\
    \                                                       ^^^\e[0m\n\e[31m   |\e\
    [0m                                   \e[33mvariable\e[0m \e[35mmax\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659820948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n      val maxes = scala.collection.mutable.ListBuffer[Long]()\n\
    \      var currentMax = Long.MinValue\n      for (num <- numbers) {\n        if\
    \ (num > currentMax) currentMax = num\n        maxes += currentMax\n      }\n\
    \      maxes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        var max = 0L\n        var list = new\
    \ ListBuffer[Long]\n        for (i <- 0 until numbers.length) {\n            if\
    \ (max < numbers(i)) {\n                max = numbers(i)\n            }\n    \
    \        list += max\n        }\n        list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        val maxValues = new ListBuffer[Long]()\n\
    \        var maxValue = 0L\n        for (number <- numbers) {\n            maxValue\
    \ = max(maxValue, number)\n            maxValues += maxValue\n        }\n    \
    \    maxValues.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        def loop(numbers : List[Long], max_so_far\
    \ : Long, result : List[Long]) : List[Long] = {\n            if (numbers.isEmpty)\
    \ {\n                result\n            } else {\n                val current_num\
    \ = numbers.head\n                loop(numbers.tail, max(max_so_far, current_num),\
    \ result :+ max(max_so_far, current_num))\n            }\n        }\n        loop(numbers,\
    \ 0, List())\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        val maximums = new ListBuffer[Long]\n\
    \        for (i <- 0 until numbers.length) {\n            var max : Long = numbers(i)\n\
    \            for (j <- i until numbers.length) {\n                if (numbers(j)\
    \ > max) max = numbers(j)\n            }\n            maximums += max\n      \
    \  }\n        maximums.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbvotljcx.scala:21)\n\tat Problem.main(tmpbvotljcx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) return Nil\n  \
    \      val max = numbers.foldLeft(numbers.head) {\n            (acc, elem) =>\n\
    \                if (elem > acc) elem\n                else acc\n        }\n \
    \       max :: rollingMax(numbers.tail)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp23rr7j59.scala:19)\n\tat Problem.main(tmp23rr7j59.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers\
    \ : List[Long]) : List[Long] = {\n        val stack = new Stack[(Long, Long)]()\n\
    \        var currentMax = numbers.head\n        stack.push((currentMax, 1))\n\
    \        val output = new ListBuffer[Long]()\n        output.append(currentMax)\n\
    \        for (i <- 1 until numbers.length) {\n            if (numbers(i) >= currentMax)\
    \ {\n                currentMax = numbers(i)\n                stack.push((currentMax,\
    \ 1))\n            } else {\n                while (!stack.isEmpty && stack.top._1\
    \ < numbers(i)) {\n                    stack.pop()\n                }\n      \
    \          if (stack.isEmpty) currentMax = numbers(i)\n                else stack.top._2\
    \ += 1\n                stack.push((numbers(i), 1))\n            }\n         \
    \   output.append(currentMax)\n        }\n        output.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvtlhms9l.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33melse\e[0m stack.top._2 += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  value += is not a member of Long - did you mean _2.!=?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659820951
