language: scala
name: HumanEval_96_count_up_to
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        def isPrime(x : Long) :\
    \ Boolean = {\n            if (x == 2) return true\n            if (x % 2 == 0)\
    \ return false\n            for (i <- 3L to sqrt(x).toLong by 2) {\n         \
    \       if (x % i == 0) return false\n            }\n            return true\n\
    \        }\n        var result = List[Long]()\n        if (n < 2) return result\n\
    \        result = 2L :: result\n        for (i <- 3L to n) {\n            if (isPrime(i))\
    \ result = i :: result\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp72vuvk5c.scala:31)\n\tat Problem.main(tmp72vuvk5c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821254
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        ???\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.countUpTo(tmp_h9504z8.scala:14)\n\tat Problem$.main(tmp_h9504z8.scala:17)\n\
    \tat Problem.main(tmp_h9504z8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        def isPrime(x : Long) :\
    \ Boolean = {\n            if (x == 1) return false\n            for (i <- 2L\
    \ to x-1L) {\n                if (x % i == 0) return false\n            }\n  \
    \          return true\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (i <- 2L to n-1L) {\n            if (isPrime(i)) result += i\n  \
    \      }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n\
    \    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n\
    \    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n \
    \   assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong,\
    \ 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong,\
    \ 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n         \
    \   Nil\n        } else {\n            val li = (0L to n).toList.filter(isPrime)\n\
    \            li.filter(_ < n)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n\
    \    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n\
    \    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n \
    \   assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong,\
    \ 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong,\
    \ 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprq34cori.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mli\e[0m = (\e[31m0L\e\
    [0m to n).toList.filter(isPrime)\n\e[31m\e[31m   |\e[0m                      \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                     Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n      def sieve(candidates : List[Long],\
    \ primes : List[Long]) : List[Long] = {\n        val head = candidates.head\n\
    \        val (notPrimes, primes2) = candidates.span(x => x % head != 0)\n    \
    \    val newPrimes = head :: primes2\n        if (newPrimes.size >= n)\n     \
    \     newPrimes.take(n.toInt)\n        else\n          sieve(notPrimes, newPrimes)\n\
    \      }\n      if (n < 2)\n        Nil\n      else\n        sieve(2L to n toList,\
    \ Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp_h8trux.scala:26:28 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        sieve(\e[31m2L\e[0m to n toList, Nil)\n\e[31m\e\
    [31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m             \
    \               expression expected but \e[31m','\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        // your code here\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcy9454_l.scala:13:43\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mcountUpTo\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e\
    [31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m \
    \  |\e[0m                                           Found:    Unit\n\e[31m   |\e\
    [0m                                           Required: List[Long]\n\e[31m14 |\e\
    [0m        \e[34m// your code here\e[0m\n\e[31m15 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659821253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        def isPrime(num : Long)\
    \ : Boolean = {\n            if (num <= 3) true\n            else if (num % 2\
    \ == 0 || num % 3 == 0) false\n            else {\n                var i = 5\n\
    \                while (i*i <= num) {\n                    if (num % i == 0 ||\
    \ num % (i + 2) == 0) return false\n                    i += 6\n             \
    \   }\n                true\n            }\n        }\n        def countDown(n\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n  \
    \          else if (isPrime(n)) countDown(n - 1, n :: acc)\n            else countDown(n\
    \ - 1, acc)\n        }\n        countDown(n, List[Long]())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1eytowpy.scala:34)\n\tat Problem.main(tmp1eytowpy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        // Time Complexity : O(n)\n\
    \        // Space Complexity : O(n)\n        if (n < 2) return List()\n      \
    \  val primes = Array.fill(n.toInt)(true)\n        primes(0) = false\n       \
    \ primes(1) = false\n        for (i <- (2 to sqrt(n).toInt)) if (primes(i)) for\
    \ (j <- Range(i * i, n.toInt, i)) primes(j) = false\n        val list = Buffer[Long]()\n\
    \        for (i <- Range(2, n.toInt)) if (primes(i)) list += i\n        list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n      (1L to n).filter(isPrime(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvbruwctz.scala:14:23 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m      (\e[31m1L\e[0m to n).filter(isPrime(_)).toList\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        def isPrime(n : Long) :\
    \ Boolean = {\n            if (n < 2) {\n                return false\n      \
    \      }\n            else if (n == 2) {\n                return true\n      \
    \      }\n            else {\n                for (i <- 2 until n) {\n       \
    \             if (n % i == 0) {\n                        return false\n      \
    \              }\n                }\n                return true\n           \
    \ }\n        }\n        val buf = new ArrayBuffer[Long]\n        for (i <- 2L\
    \ until n) {\n            if (isPrime(i)) {\n                buf += i\n      \
    \      }\n        }\n        buf.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n\
    \    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n\
    \    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n \
    \   assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong,\
    \ 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong,\
    \ 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphscu46gy.scala:22:34\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                \e[33mfor\e[0m\
    \ (i <- \e[31m2\e[0m until n) {\n\e[31m\e[31m   |\e[0m                       \
    \           ^\e[0m\n\e[31m   |\e[0m                                  Found:  \
    \  (n : Long)\n\e[31m   |\e[0m                                  Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        // faster than countUpTo1\n\
    \        // faster than countUpTo2\n        val hash = HashMap[Long, Boolean]()\n\
    \        def isPrime(m : Long) : Boolean = {\n            if (hash.contains(m))\
    \ hash(m)\n            else {\n                val result = (2L to m / 2L).forall(x\
    \ => m % x != 0)\n                hash += m -> result\n                result\n\
    \            }\n        }\n        (2L to n).filter(isPrime).toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi5phd6i5.scala:28)\n\tat Problem.main(tmpi5phd6i5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        var primes = new ListBuffer[Long]\n\
    \        if (n <= 1) return List()\n        if (n == 2) return List(2)\n     \
    \   if (n == 3) return List(2, 3)\n        primes += 2\n        primes += 3\n\
    \        var current = 5\n        while (current < n) {\n            if (current\
    \ % 6 == 1) {\n                var flag = true\n                for (divisor <-\
    \ primes) {\n                    if (divisor * divisor > current) break\n    \
    \                if (current % divisor == 0) {\n                        flag =\
    \ false\n                        break\n                    }\n              \
    \  }\n                if (flag) primes += current\n            }\n           \
    \ current += 2\n        }\n        primes.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n\
    \    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n\
    \    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n\
    \    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n \
    \   assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong,\
    \ 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong,\
    \ 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd23nkk79.scala:25:53 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mif\e[0m (divisor * divisor\
    \ > current) break\n\e[31m\e[31m   |\e[0m                                    \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                     Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpd23nkk79.scala:28:24 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                        break\n\e[31m\e[31m   |\e[0m     \
    \                   ^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        /**\n          * Determine\
    \ whether the given number is prime\n          * @param number  a positive integer\n\
    \          * @return boolean indicates whether a number is prime\n          */\n\
    \        def isPrime(number : Long) : Boolean = {\n            val squareRoot\
    \ = ceil(sqrt(number))\n            if (number <= 1) {\n                false\n\
    \            } else if (number == 2) {\n                true\n            } else\
    \ {\n                val candidateDivisors = 2 to squareRoot.toInt\n         \
    \       val isDivisible = (candidateDivisors.find(number % _ == 0) == None)\n\
    \                isDivisible\n            }\n        }\n        if (n <= 1) {\n\
    \            List()\n        } else {\n            val numbers = 2L to n\n   \
    \         val primeNumbers = numbers.filter(isPrime(_))\n            primeNumbers.toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjouhlsb5.scala:40)\n\tat Problem.main(tmpjouhlsb5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n\t\tvar a : List[Long] = Nil\n\t\
    \tfor (i <- 2L to n) {\n\t\t\tif (isPrime(i)) {\n\t\t\t\ta = i :: a\n\t\t\t}\n\
    \t\t}\n\t\ta.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyg3xksbl.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent   :\
    \ 4 spaces\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyg3xksbl.scala:16:4\
    \ -------------------------\e[0m\e[0m\n\e[31m16 |\e[0m\t\t\t\e[33mif\e[0m (isPrime(i))\
    \ {\n\e[31m\e[31m   |\e[0m\t\t\t    ^^^^^^^\e[0m\n\e[31m   |\e[0m\t\t\t    Not\
    \ found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n      def isPrime(num : Long) :\
    \ Boolean = {\n        num match {\n          case 1 => false\n          case\
    \ 2 => true\n          case _ => {\n            if(num % 2 == 0) return false\n\
    \            for(i <- 3L to sqrt(num).toLong by 2) {\n              if(num % i\
    \ == 0) return false\n            }\n            true\n          }\n        }\n\
    \      }\n      if(n < 2) return List()\n      val result = Buffer[Long]()\n \
    \     for(i <- 2L to n) {\n        if(isPrime(i)) result += i\n      }\n     \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph3s32qg7.scala:35)\n\tat Problem.main(tmph3s32qg7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        if (n <= 1) List()\n   \
    \     else {\n            (2L to n).filter(isPrime(_)).toList\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpza1bkh75.scala:16:29 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            (\e[31m2L\e[0m to n).filter(isPrime(_)).toList\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n\t\tval primes = ListBuffer[Long]()\n\
    \t\tfor (num <- 2L to n) {\n\t\t\tif (isPrime(num)) primes += num\n\t\t}\n\t\t\
    primes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpinjojhz0.scala:19:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent   :\
    \ 4 spaces\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpinjojhz0.scala:16:4\
    \ -------------------------\e[0m\e[0m\n\e[31m16 |\e[0m\t\t\t\e[33mif\e[0m (isPrime(num))\
    \ primes += num\n\e[31m\e[31m   |\e[0m\t\t\t    ^^^^^^^\e[0m\n\e[31m   |\e[0m\t\
    \t\t    Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        if (n <= 1) List[Long]()\n\
    \        else if (n == 2) List[Long](2)\n        else {\n            var foundPrimes\
    \ = List[Long](2)\n            var current = 3\n            while (current < n)\
    \ {\n                var isPrime = true\n                for (prime <- foundPrimes)\
    \ {\n                    if (current % prime == 0) {\n                       \
    \ isPrime = false\n                        break\n                    }\n    \
    \            }\n                if (isPrime) foundPrimes ::= current\n       \
    \         current += 2\n            }\n            foundPrimes.reverse\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1t6i0xkj.scala:24:24 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821251
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        require(n >= 0)\n      \
    \  if (n == 0) return List()\n        if (n == 1) return List()\n        def isPrime(n\
    \ : Long) : Boolean = {\n            if (n == 2) return true\n            for\
    \ (i <- 2 until sqrt(n).toInt + 1) if (n % i == 0) return false\n            return\
    \ true\n        }\n        val primes = ArrayBuffer[Long]()\n        for (i <-\
    \ 2 to n.toInt) if (isPrime(i)) primes += i\n        return primes.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgvr4fcl0.scala:27)\n\tat Problem.main(tmpgvr4fcl0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821253
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Implement a function that takes an non-negative integer and returns\
    \ an array of the first n\n    // integers that are prime numbers and less than\
    \ n.\n    // for example:\n    // count_up_to(5) => [2,3]\n    // count_up_to(11)\
    \ => [2,3,5,7]\n    // count_up_to(0) => []\n    // count_up_to(20) => [2,3,5,7,11,13,17,19]\n\
    \    // count_up_to(1) => []\n    // count_up_to(18) => [2,3,5,7,11,13,17]\n \
    \   def countUpTo(n : Long) : List[Long] = {\n        def isPrime(p : Long) :\
    \ Boolean = {\n            if (p < 2) return false\n            if (p == 2) return\
    \ true\n            val sqrtP = sqrt(p).asInstanceOf[Long]\n            for (i\
    \ <- 2L to sqrtP) {\n                if (p % i == 0) return false\n          \
    \  }\n            return true\n        }\n        def countUpToRec(n : Long, acc\
    \ : List[Long]) : List[Long] = {\n            if (n < 2) return acc\n        \
    \    if (isPrime(n)) return countUpToRec(n - 1, n :: acc)\n            else return\
    \ countUpToRec(n - 1, acc)\n        }\n        return countUpToRec(n, List())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
    \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
    \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
    \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
    \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
    \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
    \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
    \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
    \ 97l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_m2038oo.scala:31)\n\tat Problem.main(tmp_m2038oo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821253
