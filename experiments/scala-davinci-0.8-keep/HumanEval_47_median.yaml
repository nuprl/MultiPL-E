name: HumanEval_47_median
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return median of elements in the list l.\n    // >>> median([3, 1, 2, 4,\
  \ 5])\n    // 3\n    // >>> median([-10, 4, 6, 1000, 10, 20])\n    // 15.0\n   \
  \ def median(l : List[Long]) : Float = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(median((List[Long](3l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);\n    assert(median((List[Long](-10l.toLong,\
  \ 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));\n  \
  \  assert(median((List[Long](5l.toLong))) == 5l);\n    assert(median((List[Long](6l.toLong,\
  \ 5l.toLong))) == (5.5f));\n    assert(median((List[Long](8l.toLong, 1l.toLong,\
  \ 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);\n    }\n\n}\n"
completions: ["        var m : Float = 0\n        val h = l.sortWith(_ < _)\n    \
    \    val h2 = h.zipWithIndex\n        val n = h.length\n        if (n % 2 == 0)\
    \ {\n            m = (h(n / 2 - 1) + h(n / 2)) / 2.0f\n        } else {\n    \
    \        m = h(n / 2)\n        }\n        return m", '        l.sortWith(_ < _)(l.length
    / 2)', "        val x = l.sorted\n        if (x.length % 2 == 0) {\n         \
    \   val a = x(x.length / 2)\n            val b = x(x.length / 2 - 1)\n       \
    \     (a + b).toFloat / 2\n        } else x(x.length / 2).toFloat", "        val\
    \ sorted = l.sorted\n        val n = sorted.length\n        if (n % 2 == 0) {\n\
    \            val middle = n / 2\n            (sorted(middle - 1) + sorted(middle))\
    \ / 2.0f\n        } else {\n            sorted(n / 2)\n        }", "        val\
    \ m = l.sorted\n        if (m.length % 2 == 0)\n            ((m(m.length / 2)\
    \ + m(m.length / 2 - 1)).toFloat / 2)\n        else\n            m(m.length /\
    \ 2).toFloat", "        val l2 = l.sorted\n        if (l2.length % 2 == 0) {\n\
    \            val len = l2.length\n            (l2(len / 2) + l2(len / 2 - 1)).toFloat\
    \ / 2\n        } else {\n            l2(l2.length / 2).toFloat\n        }", " \
    \       if (l.length % 2 == 0) {\n            (l(l.length / 2) + l(l.length /\
    \ 2 - 1)).toFloat / 2\n        } else {\n            l(l.length / 2).toFloat\n\
    \        }", "      val (lower, upper) = l.sortWith(_<_).splitAt(l.size / 2)\n\
    \      if (l.size % 2 == 0) (lower.last + upper.head) / 2.0f else upper.head",
  "        if (l.size % 2 == 0) ((l(l.size / 2 - 1).toFloat + l(l.size / 2).toFloat)\
    \ / 2)\n        else l(l.size / 2).toFloat", "        val n = l.length\n     \
    \   val sorted = l.sorted\n        if (n % 2 == 0) (sorted(n / 2) + sorted(n /\
    \ 2 - 1)) / 2.0f\n        else sorted(n / 2)", "        val sorted = l.sorted\n\
    \        val n = sorted.length\n        if (n % 2 == 0) (sorted(n / 2) + sorted(n\
    \ / 2 - 1)) / 2.0f\n        else sorted(n / 2)", '        l.sortWith(_ < _).apply(l.length
    / 2)', "        val sorted = l.sorted\n        val size = sorted.size\n      \
    \  if (size % 2 == 0) (sorted(size / 2) + sorted(size / 2 - 1)) / 2\n        else\
    \ sorted(size / 2)", "        def sortMerge(l1 : List[Long], l2 : List[Long])\
    \ : List[Long] = {\n            (l1, l2) match {\n                case (Nil, _)\
    \ => l2\n                case (_, Nil) => l1\n                case (x1 :: t1,\
    \ x2 :: t2) =>\n                    if (x1 < x2) x1 :: sortMerge(t1, l2)\n   \
    \                 else x2 :: sortMerge(l1, t2)\n            }\n        }\n   \
    \     def sortMergeSort(l : List[Long]) : List[Long] = {\n            l match\
    \ {\n                case Nil => Nil\n                case h :: Nil => l\n   \
    \             case _ =>\n                    val (l1, l2) = l.splitAt(l.length\
    \ / 2)\n                    sortMerge(sortMergeSort(l1), sortMergeSort(l2))\n\
    \            }\n        }\n        val sorted = sortMergeSort(l)\n        if (sorted.length\
    \ % 2 == 0) {\n            val a = sorted(sorted.length / 2 - 1)\n           \
    \ val b = sorted(sorted.length / 2)\n            (a + b).toFloat / 2\n       \
    \ } else sorted(sorted.length / 2).toFloat", "        val n = l.length\n     \
    \   val (f, s) = l.sortWith(_ < _).splitAt(n / 2)\n        if (n % 2 == 0) (f.last\
    \ + s.head) / 2.0f else s.head", "        var ls = l.sorted\n        var s = ls.size\n\
    \        if (s % 2 == 0) {\n            (ls(s / 2) + ls(s / 2 - 1)).toFloat /\
    \ 2\n        } else {\n            ls(s / 2).toFloat\n        }", "        if\
    \ (l.size == 0) return 0.0f\n        val sorted = l.sorted\n        if (sorted.size\
    \ % 2 == 0) ((sorted(sorted.size / 2) + sorted(sorted.size / 2 - 1)).toFloat /\
    \ 2)\n        else sorted(sorted.size / 2).toFloat", "        val sl = l.sorted\n\
    \        val n = sl.length\n        if (n % 2 == 0)\n            (sl(n / 2) +\
    \ sl(n / 2 - 1)) / 2.0f\n        else\n            sl(n / 2)", "        val sl\
    \ = l.sorted\n        if (sl.length % 2 == 0) {\n            (sl(sl.length / 2)\
    \ + sl(sl.length / 2 - 1)).toFloat / 2\n        } else {\n            sl(sl.length\
    \ / 2).toFloat\n        }", "        var (low, high) = (0, l.length)\n       \
    \ while (low < high) {\n            val middle = (low + high) / 2\n          \
    \  if (middle == low) return ((l(low) + l(high)) / 2).toFloat\n            if\
    \ (l(middle) < l(low)) {\n                var tmp = l(middle)\n              \
    \  l(middle) = l(low)\n                l(low) = tmp\n            }\n         \
    \   if (l(high) < l(low)) {\n                var tmp = l(high)\n             \
    \   l(high) = l(low)\n                l(low) = tmp\n            }\n          \
    \  if (l(high) < l(middle)) {\n                var tmp = l(high)\n           \
    \     l(high) = l(middle)\n                l(middle) = tmp\n            }\n  \
    \          var (i, j) = (low + 1, high - 1)\n            var pivot = l(middle)\n\
    \            for (;;) {\n                do { i += 1 } while (l(i) < pivot)\n\
    \                do { j -= 1 } while (pivot < l(j))\n                if (i < j)\
    \ {\n                    var tmp = l(i)\n                    l(i) = l(j)\n   \
    \                 l(j) = tmp\n                } else {\n                    high\
    \ = j\n                    low = i\n                    break\n              \
    \  }\n            }\n        }\n        return (l(high) + l(low)) / 2"]
stop_tokens:
- "\n    }\n"
