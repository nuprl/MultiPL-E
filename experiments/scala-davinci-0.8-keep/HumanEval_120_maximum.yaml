name: HumanEval_120_maximum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n\
  \    // Input: arr = [-3, -4, 5], k = 3\n    // Output: [-4, -3, 5]\n    // Example\
  \ 2:\n    // Input: arr = [4, -4, 4], k = 2\n    // Output: [4, 4]\n    // Example\
  \ 3:\n    // Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    // Output: [2]\n\
  \    // Note:\n    // 1. The length of the array will be in the range of [1, 1000].\n\
  \    // 2. The elements in the array will be in the range of [-1000, 1000].\n  \
  \  // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
  \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
  \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
  \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
  \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
  \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
  \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
  \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong,\
  \ 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong,\
  \ -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
  \ -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong,\
  \ 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ['        arr.sorted.takeRight(k.toInt)', "        val maxHeap = new\
    \ MaxHeap(arr.toArray)\n        var result = List[Long]()\n        for (i <- 1\
    \ to k.toInt) {\n            result = maxHeap.pop() :: result\n        }\n   \
    \     result", "      val sorted = arr.sorted\n      val maximum = arr.sorted.reverse.take(k.toInt)\n\
    \      maximum", "        val pq = new PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](-_))\n        for (e <- arr) {\n            pq.enqueue(e)\n          \
    \  if (pq.size > k) pq.dequeue\n        }\n        pq.toList", "        val pq\
    \ = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (e <- arr) {\n   \
    \         pq.enqueue(e)\n            if (pq.size > k) pq.dequeue\n        }\n\
    \        pq.toList.sorted", "        val length = arr.length\n        var heap\
    \ = arr.toArray\n        for (i <- 0 to length - 1) heap(i) = heap(i) * -1\n \
    \       val siftDown = (k : Long) => {\n            var left = k * 2 + 1\n   \
    \         var right = k * 2 + 2\n            while (left < length) {\n       \
    \         var max = k\n                if (heap(left.toInt) > heap(max.toInt))\
    \ max = left\n                if (right < length && heap(right.toInt) > heap(max.toInt))\
    \ max = right\n                if (max == k) return\n                val tmp =\
    \ heap(k.toInt)\n                heap(k.toInt) = heap(max.toInt)\n           \
    \     heap(max.toInt) = tmp\n                k = max\n                left = k\
    \ * 2 + 1\n                right = k * 2 + 2\n            }\n        }\n     \
    \   val siftUp = (k : Long) => {\n            var parent = (k - 1) / 2\n     \
    \       while (parent >= 0) {\n                if (heap(parent.toInt) >= heap(k.toInt))\
    \ return\n                val tmp = heap(k.toInt)\n                heap(k.toInt)\
    \ = heap(parent.toInt)\n                heap(parent.toInt) = tmp\n           \
    \     k = parent\n                parent = (k - 1) / 2\n            }\n      \
    \  }\n        // build heap\n        for (i <- floor(length / 2).toLong to 0 by\
    \ -1) siftDown(i)\n        // extract max\n        for (i <- length - 1 to length\
    \ - k.toInt by -1) {\n            val tmp = heap(0)\n            heap(0) = heap(i)\n\
    \            heap(i) = tmp\n            siftDown(0)\n        }\n        // get\
    \ result\n        heap.toList.drop(length - k.toInt).map(x => x * -1)", "    \
    \    // we can use either min heap or max heap and then reverse the output\n \
    \       // min heap lets us keep minimum elements as we pop off maximum elements\n\
    \        // aka if we want the top k largest elements we pop off k elements from\
    \ a minheap\n        val minHeap = new PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](-_))\n        arr.foreach(x => {\n            if (minHeap.size < k) minHeap.enqueue(x)\n\
    \            else if (x > minHeap.head) {\n                minHeap.dequeue\n \
    \               minHeap.enqueue(x)\n            }\n        })\n        val result\
    \ = minHeap.toList\n        result.reverse", "        val heap = scala.collection.mutable.PriorityQueue[Long]()\n\
    \        arr.map(i => {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        })\n        heap.dequeueAll.toList.sorted", '        arr.sorted.reverse.take(k.toInt)',
  "        val pq = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (e <- arr) {\n            pq.enqueue(e)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList", "        if (k == 0) return\
    \ List[Long]()\n        val heap = new BinaryHeap[Long](arr, k)\n        for (i\
    \ <- (k).toLong until arr.length) heap.add(arr(i.toInt))\n        return heap.heap.toList",
  "        var pq = new PriorityQueue[Long]()(Ordering.by((x : Long) => -x))\n   \
    \     arr.foreach(x => pq.enqueue(x))\n        var res = List[Long]()\n      \
    \  for (i <- 0L until k) {\n            res = pq.dequeue :: res\n        }\n \
    \       res", "        val result = new ListBuffer[Long]\n        val pq = new\
    \ PriorityQueue[Long]()(Ordering.by(-_))\n        for (num <- arr) {\n       \
    \     pq.enqueue(num)\n            if (pq.size > k) pq.dequeue\n        }\n  \
    \      for (i <- 1 to k.toInt) result.prepend(pq.dequeue)\n        result.toList",
  "        if (k == 0) {\n            return Nil\n        }\n        if (k >= arr.length)\
    \ {\n            return arr.sorted\n        }\n        // divide and conquer\n\
    \        def helper(arr : List[Long], k : Long) : List[Long] = {\n           \
    \ // arr.sortWith(_ < _).reverse.take(k.toInt)\n            if (k == 1) {\n  \
    \              return List(arr.max)\n            }\n            val n = arr.length\n\
    \            val left = helper(arr.slice(0, (n / 2).toInt), k / 2)\n         \
    \   val right = helper(arr.slice((n / 2).toInt, n), k - k / 2)\n            val\
    \ result = new ListBuffer[Long]\n            for (i <- 0 until left.length) {\n\
    \                var j = 0\n                while (j < right.length && result.length\
    \ < k) {\n                    result += left(i)\n                    result +=\
    \ right(j)\n                    j += 1\n                }\n                if\
    \ (result.length == k) {\n                    return result.toList\n         \
    \       }\n            }\n            for (i <- 0 until right.length) {\n    \
    \            var j = 0\n                while (j < left.length && result.length\
    \ < k) {\n                    result += right(i)\n                    result +=\
    \ left(j)\n                    j += 1\n                }\n                if (result.length\
    \ == k) {\n                    return result.toList\n                }\n     \
    \       }\n            return result.toList\n        }\n        val result = helper(arr,\
    \ k)\n        // println(result)\n        return result.sorted.reverse.take(k.toInt)",
  "        val arrSorted = arr.sorted\n        var m : List[Long] = List()\n     \
    \   for (i <- arrSorted.length - 1 to 0 by -1) {\n            if (m.length < k)\
    \ m = arrSorted(i) :: m\n        }\n        m", "        def loop(arr : List[Long],\
    \ k : Long, ret : List[Long]) : List[Long] = {\n            if (arr.isEmpty ||\
    \ k == 0) return ret\n            if (ret.isEmpty) loop(arr.tail, k - 1, List(arr.head))\n\
    \            else {\n                val num = arr.head\n                val pos\
    \ = (ret.indexWhere(_ < num) + 1).max(1)\n                loop(arr.tail, k - 1,\
    \ ret.slice(0, pos - 1) ::: List(num) ::: ret.slice(pos - 1, ret.length))\n  \
    \          }\n        }\n        loop(arr, k, List())", "        val s = SortedSet[Long]()\n\
    \        for (e <- arr) {\n            s += e\n            if (s.size > k) s -=\
    \ s.first\n        }\n        s.toList", "        val q = PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (e <- arr) {\n            q.enqueue(e)\n         \
    \   if (q.size > k) q.dequeue\n        }\n        var result = new ListBuffer[Long]\n\
    \        while (q.nonEmpty) result += q.dequeue\n        result.toList", "   \
    \     val results = new ListBuffer[Long]\n        val pq = new PriorityQueue[Long]()(Ordering.by((e\
    \ : Long) => -e))\n        arr.foreach(e => {\n            pq.enqueue(e)\n   \
    \         if (pq.size > k) pq.dequeue\n        })\n        return pq.toList",
  "        val pq = new collection.mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (x <- arr) {\n            pq.enqueue(x)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted"]
stop_tokens:
- "\n    }\n"
