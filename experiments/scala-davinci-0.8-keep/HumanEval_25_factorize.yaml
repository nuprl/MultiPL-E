name: HumanEval_25_factorize
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return list of prime factors of given integer in the order from smallest\
  \ to largest.\n    // Each of the factors should be listed number of times corresponding\
  \ to how many times it appeares in factorization.\n    // Input number should be\
  \ equal to the product of all factors\n    // >>> factorize(8)\n    // [2, 2, 2]\n\
  \    // >>> factorize(25)\n    // [5, 5]\n    // >>> factorize(70)\n    // [2, 5,\
  \ 7]\n    def factorize(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(factorize((2l)).equals((List[Long](2l.toLong))));\n\
  \    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(factorize((8l)).equals((List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong))));\n    assert(factorize((57l)).equals((List[Long](3l.toLong,\
  \ 19l.toLong))));\n    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong,\
  \ 19l.toLong, 19l.toLong))));\n    assert(factorize((185193l)).equals((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((20577l)).equals((List[Long](3l.toLong,\
  \ 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((18l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong))));\n    }\n\n}\n"
completions: ["        def calc(m : Long, sq : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (m == 1) acc\n            else if (m % sq == 0) calc(m /\
    \ sq, sq, sq :: acc)\n            else calc(m, sq + 1, acc)\n        }\n     \
    \   calc(n, 2, Nil)", "        def factorizeIter(n : Long, p : Long, e : Int)\
    \ : List[Long] = {\n            if (n == 1) {\n                if (e == 0) Nil\
    \ else List.fill(e)(p)\n            } else {\n                if (n % p == 0)\
    \ factorizeIter(n / p, p, e + 1)\n                else if (p > n) Nil\n      \
    \          else factorizeIter(n, nextPrime(p), e)\n            }\n        }\n\
    \        factorizeIter(n, 2, 0)", "        def factorizeIter(n : Long, primes\
    \ : Stream[Long]) : List[Long] = {\n            if (n <= 1) List()\n         \
    \   else if (n % primes.head == 0) primes.head :: factorizeIter(n / primes.head,\
    \ primes)\n            else factorizeIter(n, primes.tail)\n        }\n       \
    \ factorizeIter(n, 2 #:: Stream.from(3, 2).filter(i => (2 to sqrt(i).toInt).forall(j\
    \ => i % j != 0)))", "    \tdef factorizeR(n : Long, p : Long) : List[Long] =\
    \ {\n    \t\tif (n == 1) Nil\n    \t\telse if (n % p == 0) p :: factorizeR(n /\
    \ p, p)\n    \t\telse factorizeR(n, p + 1)\n    \t}\n    \tfactorizeR(n, 2)",
  "        val primes = getPrimes(n)\n        val result = new ListBuffer[Long]\n\
    \        for (p <- primes) {\n            var n = n\n            while (n % p\
    \ == 0) {\n                result += p\n                n /= p\n            }\n\
    \        }\n        result.toList", "        // Find factor of given number by\
    \ finding the smallest number that divides it\n        def findFactor(n : Long)\
    \ : Long = {\n            val limit = sqrt(n).toLong\n            val primes =\
    \ Primes.primesTo(limit)\n            for (p <- primes) if (n % p == 0) return\
    \ p\n            n\n        }\n        def factorizeRecursive(n : Long, k : Long)\
    \ : List[Long] = {\n            if (n == 1) Nil\n            else {\n        \
    \        val factor = findFactor(n)\n                if (factor == n) List(n)\n\
    \                else factor :: factorizeRecursive(n / factor, factor)\n     \
    \       }\n        }\n        factorizeRecursive(n, 2)", "      val sqrt = sqrt(n).toLong\n\
    \      def rec(d : Long, n : Long) : List[Long] = {\n        if (n == 1) Nil\n\
    \        else if (n % d == 0) d :: rec(d, n / d)\n        else rec(d + 1, n)\n\
    \      }\n      rec(2, n)", "        // Search for factors of given prime\n  \
    \      def search(p : Long, f : Long, r : Long) : List[Long] = {\n           \
    \ if (r == 1) Nil\n            else if (r % p == 0) p :: search(p, p, r / p)\n\
    \            else f :: factorize(r)\n        }\n        // Find next prime starting\
    \ from p\n        def nextPrime(p : Long) : Long = {\n            if (p == 2)\
    \ 3\n            else {\n                val sqrt = ceil(sqrt(p)).toLong\n   \
    \             var i = p + 2\n                while (i <= sqrt && (i % 2 == 0 ||\
    \ i % 3 == 0 || i % 5 == 0 || i % 7 == 0)) i += 2\n                if (i > sqrt)\
    \ p\n                else {\n                    var j = 11\n                \
    \    while (j <= sqrt && i % j != 0) j += 2\n                    if (j > sqrt)\
    \ i\n                    else nextPrime(i + 2)\n                }\n          \
    \  }\n        }\n        n match {\n            case 1 => Nil\n            case\
    \ 2 => List(2)\n            case 3 => List(3)\n            case 5 => List(5)\n\
    \            case 7 => List(7)\n            case _ => {\n                if (n\
    \ % 2 == 0) 2 :: search(2, 2, n / 2)\n                else if (n % 3 == 0) 3 ::\
    \ search(3, 3, n / 3)\n                else if (n % 5 == 0) 5 :: search(5, 5,\
    \ n / 5)\n                else if (n % 7 == 0) 7 :: search(7, 7, n / 7)\n    \
    \            else {\n                    var prime = 11\n                    while\
    \ (prime <= ceil(sqrt(n)).toLong && n % prime != 0) prime = nextPrime(prime +\
    \ 2)\n                    if (prime > ceil(sqrt(n)).toLong) List(n)\n        \
    \            else prime :: search(prime, prime, n / prime)\n                }\n\
    \            }\n        }", "        var m = n\n        var l = List[Long]()\n\
    \        for (i <- 2L to (n+1L)) {\n            while (m % i == 0) {\n       \
    \         l = i :: l\n                m /= i\n            }\n        }\n     \
    \   l", "        if (n == 1) return List(1)\n        var product = n\n       \
    \ var result = List[Long]()\n        for (i <- 2 to sqrt(n).toInt) {\n       \
    \     while (product % i == 0) {\n                result = i :: result\n     \
    \           product /= i\n            }\n        }\n        if (product != 1)\
    \ result = product :: result\n        return result", "        var number = n\n\
    \        var result = new ListBuffer[Long]\n        var p = 2L\n        while\
    \ (number > 1 && p <= number) {\n            while (number % p == 0) {\n     \
    \           result += p\n                number /= p\n            }\n        \
    \    p += 1\n        }\n        result.toList", "        if (n == 1) return List(1)\n\
    \        var res = List[Long]()\n        var tmp = n\n        for (i <- 2 to sqrt(n).toInt\
    \ if tmp % i == 0) {\n            var cnt = 0\n            while (tmp % i == 0)\
    \ {\n                cnt += 1\n                tmp /= i\n            }\n     \
    \       res = res ::: List.fill(cnt)(i)\n        }\n        if (tmp != 1) res\
    \ = res ::: List(tmp)\n        res", "        var result = List[Long]()\n    \
    \    var d = 2L\n        var u = n\n        while (d <= u) {\n            while\
    \ (u % d == 0) {\n                result ::= d\n                u /= d\n     \
    \       }\n            d += 1\n        }\n        result", "        var factors\
    \ = new ListBuffer[Long]\n        var d = 2\n        while (n > 1) {\n       \
    \     while (n % d == 0) {\n                factors += d\n                n /=\
    \ d\n            }\n            d += 1\n        }\n        factors.toList", " \
    \       var f : List[Long] = Nil\n        var k = n\n        var i = 2L\n    \
    \    while (i * i <= k) {\n            while (k % i == 0) {\n                f\
    \ = i :: f\n                k /= i\n            }\n            i += 1\n      \
    \  }\n        if (k > 1) f = k :: f\n        f", "        // isPrime(i) = true\
    \ if i is prime and false otherwise\n        // isPrimeList(n) = isPrime(i) where\
    \ i is the index of the value\n        def isPrimeList(n : Long) : Array[Boolean]\
    \ = {\n            val isPrime = Array.fill(n.toInt + 1)(true)\n            isPrime(0)\
    \ = false\n            isPrime(1) = false\n            var i = 2\n           \
    \ while (i <= sqrt(n).toInt) {\n                if (isPrime(i)) {\n          \
    \          var j = i * i\n                    while (j <= n) {\n             \
    \           isPrime(j) = false\n                        j += i\n             \
    \       }\n                }\n                i += 1\n            }\n        \
    \    isPrime\n        }\n        // primeList(n) = the list of all primes not\
    \ greater than n\n        def primeList(n : Long) : List[Long] = {\n         \
    \   val isPrime = isPrimeList(n)\n            var list = List[Long]()\n      \
    \      for (i <- isPrime.indices) {\n                if (isPrime(i)) list = i\
    \ :: list\n            }\n            list.reverse\n        }\n        // factors(n)\
    \ = the list of factors of n in the order from smallest to largest\n        def\
    \ factors(n : Long) : List[Long] = {\n            var list = List[Long]()\n  \
    \          val primes = primeList(n)\n            for (p <- primes) {\n      \
    \          while (n % p == 0) {\n                    list = p :: list\n      \
    \              n /= p\n                }\n            }\n            list.reverse\n\
    \        }\n        factors(n)", "        val res = ArrayBuffer[Long]()\n    \
    \    var x = n\n        var i = 2L\n        while (i * i <= x) {\n           \
    \ while (x % i == 0) {\n                res += i\n                x /= i\n   \
    \         }\n            i += 1\n        }\n        if (x > 1) res += x\n    \
    \    res.toList", "        var result = List[Long]()\n        var copy = n\n \
    \       var i = 2L\n        while (i <= copy) {\n            if (copy % i == 0)\
    \ {\n                result = result :+ i\n                copy /= i\n       \
    \     } else {\n                i += 1\n            }\n        }\n        result",
  "        def rec(n : Long, p : Long) : List[Long] = {\n            if (n == 1) Nil\n\
    \            else if (n % p == 0) p :: rec(n / p, p)\n            else rec(n,\
    \ p + 1)\n        }\n        rec(n, 2)", "        val factors = new ArrayBuffer[Long]\n\
    \        def divide(n : Long, factor : Long) : Unit = {\n            if (n % factor\
    \ == 0) {\n                factors += factor\n                divide(n / factor,\
    \ factor)\n            }\n        }\n        if (n > 1) {\n            var i =\
    \ 2\n            var maxFactor = n\n            while (i <= maxFactor) {\n   \
    \             if (n % i == 0) {\n                    maxFactor = n / i\n     \
    \               divide(n, i)\n                }\n                i += 1\n    \
    \        }\n        }\n        factors.toList"]
stop_tokens:
- "\n    }\n"
