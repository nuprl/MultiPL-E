name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
  \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers :\
  \ List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        var maximums = List[Long]()\n        var currentMaximum = Long.MinValue\n\
    \        for (number <- numbers) {\n            currentMaximum = max(currentMaximum,\
    \ number)\n            maximums ::= currentMaximum\n        }\n        maximums.reverse",
  "        var max = numbers(0)\n        var result = ArrayBuffer[Long]()\n      \
    \  result += max\n        for (i <- 1 until numbers.length) {\n            if\
    \ (numbers(i) > max) {\n                max = numbers(i)\n            }\n    \
    \        result += max\n        }\n        result.toList", "        var max =\
    \ numbers(0)\n        var result = new ListBuffer[Long]\n        for (i <- 0 until\
    \ numbers.length) {\n            max = max max numbers(i)\n            result\
    \ += max\n        }\n        result.toList", "        val result = ListBuffer.empty[Long]\n\
    \        var max = Long.MinValue\n        for (num <- numbers) {\n           \
    \ max = max max num\n            result += max\n        }\n        result.toList",
  "        var currentMax = 0L\n        numbers.foldLeft(List[Long]()) {\n       \
    \     (r, c) => {\n                currentMax = max(currentMax, c)\n         \
    \       r :+ currentMax\n            }\n        }", "        val maxQueue = new\
    \ PriorityQueue[Long]()(Ordering[Long].reverse)\n        var maxStack = new Stack[Long]()\n\
    \        for (number <- numbers) {\n            maxQueue.enqueue(number)\n   \
    \         if (maxQueue.head != number) {\n                maxStack.push(maxQueue.head)\n\
    \            } else {\n                maxStack.push(number)\n            }\n\
    \        }\n        maxStack.toList", "        var maxValue = 0L\n        var\
    \ results = List[Long]()\n        for (number <- numbers) {\n            maxValue\
    \ = max(maxValue, number)\n            results = results :+ maxValue\n       \
    \ }\n        results", "        var res = new ListBuffer[Long]\n        var max\
    \ = Long.MinValue\n        for (n <- numbers) {\n            max = if (n > max)\
    \ n else max\n            res += max\n        }\n        res.toList", "      \
    \  var max = numbers(0)\n        numbers.map(number => {\n            if (number\
    \ > max) max = number\n            max\n        })", "        def helper(result\
    \ : List[Long], numbers : List[Long], current : Long) : List[Long] = {\n     \
    \       if (numbers.isEmpty) result.reverse\n            else helper(max(current,\
    \ numbers.head) :: result, numbers.tail, current)\n        }\n        helper(List(),\
    \ numbers, 0)", "        val result = new ListBuffer[Long]()\n        var m =\
    \ Long.MinValue\n        for (n <- numbers) {\n            if (n > m) {\n    \
    \            m = n\n            }\n            result += m\n        }\n      \
    \  result.toList", "        var currentMax = 0L\n        numbers.map { x =>\n\
    \            if (x > currentMax) currentMax = x\n            currentMax\n    \
    \    }", "        var max : Long = Long.MinValue\n        numbers.foldLeft(List[Long]())\
    \ {(a,b) => max = max(b, max); a :+ max}", "      val maxes = scala.collection.mutable.ListBuffer[Long]()\n\
    \      var currentMax = Long.MinValue\n      for (num <- numbers) {\n        if\
    \ (num > currentMax) currentMax = num\n        maxes += currentMax\n      }\n\
    \      maxes.toList", "        var max = 0L\n        var list = new ListBuffer[Long]\n\
    \        for (i <- 0 until numbers.length) {\n            if (max < numbers(i))\
    \ {\n                max = numbers(i)\n            }\n            list += max\n\
    \        }\n        list.toList", "        val maxValues = new ListBuffer[Long]()\n\
    \        var maxValue = 0L\n        for (number <- numbers) {\n            maxValue\
    \ = max(maxValue, number)\n            maxValues += maxValue\n        }\n    \
    \    maxValues.toList", "        def loop(numbers : List[Long], max_so_far : Long,\
    \ result : List[Long]) : List[Long] = {\n            if (numbers.isEmpty) {\n\
    \                result\n            } else {\n                val current_num\
    \ = numbers.head\n                loop(numbers.tail, max(max_so_far, current_num),\
    \ result :+ max(max_so_far, current_num))\n            }\n        }\n        loop(numbers,\
    \ 0, List())", "        val maximums = new ListBuffer[Long]\n        for (i <-\
    \ 0 until numbers.length) {\n            var max : Long = numbers(i)\n       \
    \     for (j <- i until numbers.length) {\n                if (numbers(j) > max)\
    \ max = numbers(j)\n            }\n            maximums += max\n        }\n  \
    \      maximums.toList", "        if (numbers.isEmpty) return Nil\n        val\
    \ max = numbers.foldLeft(numbers.head) {\n            (acc, elem) =>\n       \
    \         if (elem > acc) elem\n                else acc\n        }\n        max\
    \ :: rollingMax(numbers.tail)", "        val stack = new Stack[(Long, Long)]()\n\
    \        var currentMax = numbers.head\n        stack.push((currentMax, 1))\n\
    \        val output = new ListBuffer[Long]()\n        output.append(currentMax)\n\
    \        for (i <- 1 until numbers.length) {\n            if (numbers(i) >= currentMax)\
    \ {\n                currentMax = numbers(i)\n                stack.push((currentMax,\
    \ 1))\n            } else {\n                while (!stack.isEmpty && stack.top._1\
    \ < numbers(i)) {\n                    stack.pop()\n                }\n      \
    \          if (stack.isEmpty) currentMax = numbers(i)\n                else stack.top._2\
    \ += 1\n                stack.push((numbers(i), 1))\n            }\n         \
    \   output.append(currentMax)\n        }\n        output.toList"]
stop_tokens:
- "\n    }\n"
