language: scala
name: HumanEval_73_smallest_change
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val palindrome = (arr.take(arr.length\
    \ / 2) ::: arr.takeRight(arr.length / 2).reverse).toList\n        arr.zip(palindrome).map(x\
    \ => math.abs(x._1 - x._2)).sum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnexgcq5i.scala:16)\n\tat Problem.main(tmpnexgcq5i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      // dp(i)(j) is the number of changes needed to make the array palindromic\n\
    \        // in the range i..j\n        val dp = Array.ofDim[Long](n, n)\n    \
    \    for (size <- 1 to n) {\n            for (left <- 0 to n - size) {\n     \
    \           val right = left + size - 1\n                if (size == 1) dp(left)(right)\
    \ = 0\n                else if (size == 2) dp(left)(right) = if (arr(left) ==\
    \ arr(right)) 0 else 1\n                else if (arr(left) == arr(right)) dp(left)(right)\
    \ = dp(left + 1)(right - 1)\n                else dp(left)(right) = min(dp(left\
    \ + 1)(right), dp(left)(right - 1)) + 1\n            }\n        }\n        dp(0)(n\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp98_53p25.scala:28)\n\tat Problem.main(tmp98_53p25.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        var left = 0\n        var\
    \ right = arr.length - 1\n        var ans = 0\n        while (left < right) {\n\
    \            if (arr(left) != arr(right)) {\n                ans += 1\n      \
    \      }\n            left += 1\n            right -= 1\n        }\n        ans\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        def solve(i : Int, j :\
    \ Int) : Long = {\n            if (i >= j) 0\n            else if (arr(i) == arr(j))\
    \ solve(i + 1, j - 1)\n            else min(solve(i + 1, j), solve(i, j - 1))\
    \ + 1\n        }\n        solve(0, arr.length - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuh96d4fm.scala:20)\n\tat Problem.main(tmpuh96d4fm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val dp = Array.ofDim[Long](n, n)\n        for (l <- 2 to n) {\n       \
    \     for (i <- 0 to n - l) {\n                val j = i + l - 1\n           \
    \     dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1)) + 1\n                if (arr(i)\
    \ == arr(j)) dp(i)(j) = min(dp(i)(j), dp(i + 1)(j - 1))\n            }\n     \
    \   }\n        dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk0sus88u.scala:24)\n\tat Problem.main(tmpk0sus88u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val left = new Array[Long](n + 1)\n        left(0) = 0\n        for (i\
    \ <- 1 to n) left(i) = left(i - 1) + arr(i - 1)\n        val right = new Array[Long](n\
    \ + 1)\n        right(n) = 0\n        for (i <- n - 1 to 0 by -1) right(i) = right(i\
    \ + 1) + arr(i)\n        var res = Long.MaxValue\n        for (i <- 0 to n) {\n\
    \            val s = left(i) + right(i)\n            res = min(res, s)\n     \
    \   }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfxvpz1zq.scala:27)\n\tat Problem.main(tmpfxvpz1zq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        def loop(l : List[Long],\
    \ r : List[Long], c : Long) : Long = (l, r) match {\n            case (Nil, Nil)\
    \ => c\n            case (x :: xs, y :: ys) => if (x == y) loop(xs, ys, c) else\
    \ loop(xs, ys, c + 1)\n            case _ => c\n        }\n        loop(arr, arr.reverse,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpasuzyo50.scala:20)\n\tat Problem.main(tmpasuzyo50.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val dp = Array.ofDim[Long](n, n)\n        for (len <- 1 to n - 1) {\n \
    \           for (i <- 0 to n - len - 1) {\n                val j = i + len\n \
    \               if (arr(i) == arr(j)) dp(i)(j) = dp(i + 1)(j - 1)\n          \
    \      else dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1)) + 1\n            }\n  \
    \      }\n        dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmg18lf55.scala:24)\n\tat Problem.main(tmpmg18lf55.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        def loop(left : Int, right\
    \ : Int, count : Long) : Long = {\n            if (left >= right) return count\n\
    \            if (arr(left) == arr(right)) return loop(left + 1, right - 1, count)\n\
    \            val l = loop(left + 1, right, count + 1)\n            val r = loop(left,\
    \ right - 1, count + 1)\n            min(l, r)\n        }\n        if (arr.length\
    \ % 2 == 0) loop(0, arr.length - 1, 0)\n        else loop(0, arr.length - 2, 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ixtb0ni.scala:23)\n\tat Problem.main(tmp9ixtb0ni.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val firstHalf = arr.slice(0,\
    \ arr.length / 2)\n        val secondHalf = arr.slice(arr.length / 2 + (if (arr.length\
    \ % 2 == 0) 0 else 1), arr.length)\n        val pairwiseDifferences = firstHalf.zip(secondHalf.reverse).map(x\
    \ => abs(x._1 - x._2))\n        pairwiseDifferences.sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplm7_5zz1.scala:18)\n\tat Problem.main(tmplm7_5zz1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        def reverse(l : List[Long])\
    \ : List[Long] = {\n            if (l.isEmpty) l\n            else reverse(l.tail)\
    \ :+ l.head\n        }\n        def countChanges(a : List[Long], b : List[Long])\
    \ : Long = {\n            if (a.isEmpty) 0\n            else if (a.head == b.head)\
    \ countChanges(a.tail, b.tail)\n            else 1 + countChanges(a.tail, b.tail)\n\
    \        }\n        countChanges(arr, reverse(arr))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_drt9oyd.scala:24)\n\tat Problem.main(tmp_drt9oyd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        // Compute how many elements\
    \ are missing from the left and right sides of the array\n        val mid = arr.length\
    \ / 2\n        var leftIndex = 0\n        var rightIndex = arr.length - 1\n  \
    \      var result = 0L\n        for (i <- 0 until mid) {\n            if (arr(leftIndex)\
    \ != arr(rightIndex)) {\n                if (arr(leftIndex) < arr(rightIndex))\
    \ {\n                    result += arr(rightIndex) - arr(leftIndex)\n        \
    \            leftIndex += 1\n                } else {\n                    result\
    \ += arr(leftIndex) - arr(rightIndex)\n                    rightIndex -= 1\n \
    \               }\n            } else {\n                leftIndex += 1\n    \
    \            rightIndex -= 1\n            }\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_ti4ux1.scala:34)\n\tat Problem.main(tmpj_ti4ux1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        return 0\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp04bxcs2_.scala:15)\n\tat Problem.main(tmp04bxcs2_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val list = arr\n      \
    \  val length = list.length\n        val half = (length + 1) / 2\n        val\
    \ reversed = list.reverse\n        var count = 0L\n        for (i <- 0 until half)\
    \ {\n            if (list(i) != reversed(i)) count += 1\n        }\n        return\
    \ count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val q1 = Queue[Long]()\n\
    \        for (i <- 0 until arr.length / 2) q1.enqueue(arr(i))\n        val q2\
    \ = Queue[Long]()\n        for (i <- arr.length - 1 to (arr.length + 1) / 2 by\
    \ -1) q2.enqueue(arr(i))\n        var cnt = 0L\n        while (q1.length > 0)\
    \ {\n            if (q1.dequeue != q2.dequeue) cnt += 1\n        }\n        cnt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n      if (arr.length % 2 == 0)\
    \ {\n        (arr.slice(0, arr.length / 2) zip arr.slice(arr.length / 2, arr.length).reverse).map(x\
    \ => abs(x._1 - x._2)).sum\n      } else {\n        (arr.slice(0, arr.length /\
    \ 2) zip arr.slice(arr.length / 2 + 1, arr.length).reverse).map(x => abs(x._1\
    \ - x._2)).sum\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwseris_n.scala:19)\n\tat Problem.main(tmpwseris_n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        if (arr.length % 2 == 0)\
    \ {\n            val mid = arr.length / 2\n            val left = arr.slice(0,\
    \ mid)\n            val right = arr.slice(mid, arr.length).reverse\n         \
    \   val changes = left.zip(right).map(x => abs(x._1 - x._2))\n            changes.foldLeft(0L)(_\
    \ + _)\n        } else {\n            val mid = arr.length / 2\n            val\
    \ left = arr.slice(0, mid)\n            val right = arr.slice(mid + 1, arr.length).reverse\n\
    \            val changes = left.zip(right).map(x => abs(x._1 - x._2))\n      \
    \      changes.foldLeft(0L)(_ + _)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnqj7x36e.scala:27)\n\tat Problem.main(tmpnqj7x36e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val dp = Array.ofDim[(Long, Boolean)](n, n)\n        for (start <- 0 until\
    \ n; end <- 0 until n) {\n            dp(start)(end) = (10000000, false)\n   \
    \     }\n        for (start <- 0 until n; end <- start until n) {\n          \
    \  if (start == end) dp(start)(end) = (0, true)\n            else {\n        \
    \        if (arr(start) == arr(end)) dp(start)(end) = (min(dp(start)(end)._1,\
    \ dp(start + 1)(end - 1)._1), true)\n                dp(start)(end) = (min(dp(start)(end)._1,\
    \ dp(start + 1)(end)._1 + 1), dp(start)(end)._2)\n                dp(start)(end)\
    \ = (min(dp(start)(end)._1, dp(start)(end - 1)._1 + 1), dp(start)(end)._2)\n \
    \           }\n        }\n        dp(0)(n - 1)._1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpetogntol.scala:28)\n\tat Problem.main(tmpetogntol.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val mirror = new HashMap[Int, Int]\n        mirror += (0 -> 0)\n      \
    \  mirror += (n - 1 -> n - 1)\n        val dp = new Array[Int](n)\n        (1\
    \ until n / 2).foreach(i => {\n            val m = mirror(i - 1)\n           \
    \ if (m != n - 1 - i) dp(i) = dp(m) + 1\n            if (arr(i) == arr(n - 1 -\
    \ i)) mirror += (i -> (n - 1 - i))\n            else mirror += (i -> m)\n    \
    \    })\n        val m = mirror(n / 2 - 1)\n        dp(n / 2) = dp(m) + 1\n  \
    \      if (n % 2 == 1 && arr(n / 2) == arr(n / 2 + 1)) mirror += (n / 2 -> (n\
    \ / 2 + 1))\n        else mirror += (n / 2 -> m)\n        (n / 2 + 1 until n).foreach(i\
    \ => {\n            val m = mirror(i - 1)\n            if (m != n - 1 - i) dp(i)\
    \ = dp(m) + 1\n            if (arr(i) == arr(n - 1 - i)) mirror += (i -> (n -\
    \ 1 - i))\n            else mirror += (i -> m)\n        })\n        dp(n - 1)\
    \ = dp(mirror(n - 1))\n        dp(n - 1) min (n - dp(n - 1) - 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpazbpmgks.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        mirror += (n - \e[31m1\e[0m -> n - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue - is not a member of (Int, Int), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659821315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val dp = Array.ofDim[Long](n, n)\n        for (i <- n - 1 to 0 by -1) {\n\
    \            for (j <- i + 1 until n) {\n                if (arr(i) == arr(j))\
    \ dp(i)(j) = dp(i + 1)(j - 1)\n                else dp(i)(j) = 1 + min(dp(i +\
    \ 1)(j), dp(i)(j - 1))\n            }\n        }\n        return dp(0)(n - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptyid39ia.scala:23)\n\tat Problem.main(tmptyid39ia.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821315
