name: HumanEval_126_is_sorted
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list of numbers, return whether or not they are sorted\n    // in\
  \ ascending order. If list has more than 1 duplicate of the same\n    // number,\
  \ return False. Assume no negative numbers and only integers.\n    // Examples\n\
  \    // is_sorted([5]) \u279E True\n    // is_sorted([1, 2, 3, 4, 5]) \u279E True\n\
  \    // is_sorted([1, 3, 2, 4, 5]) \u279E False\n    // is_sorted([1, 2, 3, 4, 5,\
  \ 6]) \u279E True\n    // is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n    // is_sorted([1,\
  \ 3, 2, 4, 5, 6, 7]) \u279E False\n    // is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
  \    // is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\n    def isSorted(lst : List[Long])\
  \ : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(isSorted((List[Long](5l.toLong)))\
  \ == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));\n\
  \    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong,\
  \ 6l.toLong, 7l.toLong))) == (false));\n    assert(isSorted((List[Long]())) == (true));\n\
  \    assert(isSorted((List[Long](1l.toLong))) == (true));\n    assert(isSorted((List[Long](3l.toLong,\
  \ 2l.toLong, 1l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    }\n\n}\n"
completions: ["        var original = lst\n        var sorted = lst.sorted\n     \
    \   original.sorted == sorted && original.toSet.size == original.size", "    \
    \    var prev = 0\n        var count = 0\n        for (i <- lst) {\n         \
    \   if (i == prev) {\n                count += 1\n                if (count >\
    \ 1) return false\n            }\n            else prev = i\n        }\n     \
    \   return true", '        lst.foldLeft((true, lst.head))((flag, n) => (flag._1
    && (n >= flag._2), n))._1', "        var previous = lst(0)\n        var duplicate\
    \ = false\n        for (i <- 1 until lst.length) {\n            if (lst(i) < previous)\
    \ return false\n            if (lst(i) == previous) duplicate = true\n       \
    \     previous = lst(i)\n        }\n        !duplicate", "        // return lst.toSet.size\
    \ == lst.size && lst.zip(lst.tail).forall(x => x._1 <= x._2)\n        var prev\
    \ = lst.head\n        for (i <- lst.tail) {\n            if (i < prev) return\
    \ false\n            prev = i\n        }\n        return true", "        val lstSorted\
    \ = lst.sorted\n        var index = 0\n        var result = true\n        if (lst.length\
    \ == 1) {\n            return true\n        }\n        for (index <- 0 until lst.length)\
    \ {\n            if (lst(index) != lstSorted(index)) {\n                result\
    \ = false\n            }\n        }\n        return result", '        // Write
    your code here', "        if (lst.size == 1) return true\n        for (i <- 0\
    \ until lst.size - 1) {\n            if (lst(i) > lst(i + 1)) return false\n \
    \       }\n        return true", "        //numbers in a list is unique, and sorted\
    \ in ascending order\n        var a = lst.sorted\n        for (i <- 1 until a.length)\
    \ {\n            if (a(i) == a(i - 1)) return false\n        }\n        true",
  "        if (lst.length == 1) {\n            return true\n        }\n        var\
    \ unique = ArrayBuffer[Long]()\n        unique += lst(0)\n        for (i <- 1\
    \ until lst.length) {\n            if (lst(i) == lst(i - 1)) {\n             \
    \   return false\n            }\n            else {\n                unique +=\
    \ lst(i)\n            }\n        }\n        if (unique(0) > unique(1)) {\n   \
    \         return unique.reverse.sliding(2).forall(x => x(0) >= x(1))\n       \
    \ }\n        else {\n            return unique.sliding(2).forall(x => x(0) <=\
    \ x(1))\n        }", "    \tvar hasDuplicate = false\n    \tval sortedLst = lst.sorted\n\
    \    \tlst.sorted.sliding(2).foreach(p => if (p(0) == p(1)) hasDuplicate = true)\n\
    \    \tif (hasDuplicate) false\n    \telse sortedLst == lst", "        for (i\
    \ <- 0 until lst.length - 1) {\n            if (lst(i) >= lst(i + 1)) {\n    \
    \            return false\n            }\n        }\n        return true", " \
    \     var result = true\n      for (i <- 0 until lst.length - 1) {\n        val\
    \ current = lst(i)\n        val next = lst(i + 1)\n        if (current >= next)\
    \ {\n          result = false\n        }\n      }\n      result", "        var\
    \ sorted = true\n        if (lst.size == 1) true\n        else {\n           \
    \ var list = lst.sorted\n            for (i <- 1 until list.size) {\n        \
    \        if (list(i) == list(i - 1)) sorted = false\n            }\n         \
    \   sorted\n        }", "        for (i <- 1 until lst.length) {\n           \
    \ if (lst(i) <= lst(i - 1)) return false\n        }\n        true", "        var\
    \ sorted = true\n        var prev = -1L\n        for (x <- lst) {\n          \
    \  if (x < prev) {\n                sorted = false\n                return sorted\n\
    \            }\n            prev = x\n        }\n        sorted", "        val\
    \ m = HashMap[Long, Long]()\n        lst.foreach(x => m(x) = m.getOrElse(x, 0)\
    \ + 1)\n        lst.toSet.size == lst.size && lst.sorted == lst", "        //\
    \ Given a list of numbers, return whether or not they are sorted\n        // in\
    \ ascending order. If list has more than 1 duplicate of the same\n        // number,\
    \ return False. Assume no negative numbers and only integers.\n        // Examples\n\
    \        // is_sorted([5]) \u279E True\n        // is_sorted([1, 2, 3, 4, 5])\
    \ \u279E True\n        // is_sorted([1, 3, 2, 4, 5]) \u279E False\n        //\
    \ is_sorted([1, 2, 3, 4, 5, 6]) \u279E True\n        // is_sorted([1, 2, 3, 4,\
    \ 5, 6, 7]) \u279E True\n        // is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279E False\n\
    \        // is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n        // is_sorted([1,\
    \ 2, 2, 2, 3, 4]) \u279E False\n        // lst.distinct.sort(_ < _) == lst.sort(_\
    \ < _)\n        // lst.distinct.sorted == lst.sorted\n        lst.distinct.sorted\
    \ == lst.sorted", "        val set = lst.toSet\n        if (set.size != lst.size)\
    \ return false\n        for (i <- 1 until lst.size) {\n            if (lst(i)\
    \ < lst(i - 1)) return false\n        }\n        true", "        if (lst.length\
    \ <= 1) return true\n        var result = true\n        var curr = lst(0)\n  \
    \      for (i <- 1 until lst.length) {\n            if (lst(i) < curr) result\
    \ = false\n            curr = lst(i)\n        }\n        return result"]
stop_tokens:
- "\n    }\n"
