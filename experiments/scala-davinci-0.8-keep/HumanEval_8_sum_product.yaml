name: HumanEval_8_sum_product
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // For a given list of integers, return a tuple consisting of a sum and a product\
  \ of all the integers in a list.\n    // Empty sum should be equal to 0 and empty\
  \ product should be equal to 1.\n    // >>> sum_product([])\n    // (0, 1)\n   \
  \ // >>> sum_product([1, 2, 3, 4])\n    // (10, 24)\n    def sumProduct(numbers\
  \ : List[Long]) : Tuple2[Long, Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumProduct((List[Long]())).equals(((0l,\
  \ 1l))));\n    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l,\
  \ 1l))));\n    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l,\
  \ 0l))));\n    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l,\
  \ 105l))));\n    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));\n\
  \    }\n\n}\n"
completions: ["        val s = numbers.sum\n        val p = numbers.product\n    \
    \    (s, p)", "        if (numbers.length == 0) {\n            return (0, 1)\n\
    \        }\n        var sum = 0L\n        var product = 1L\n        for (i <-\
    \ 0 until numbers.length) {\n            sum += numbers(i)\n            product\
    \ *= numbers(i)\n        }\n        return (sum, product)", '        numbers.foldLeft((0l,
    1l))((a, b) => (a._1 + b, a._2 * b))', "      var sum = 0L\n      var product\
    \ = 1L\n      for (i <- numbers) {\n        sum += i\n        product *= i\n \
    \     }\n      (sum, product)", '        numbers.foldLeft(0L, 1L)((x, y) => (x._1
    + y, x._2 * y))', "        var sum = 0L\n        var product = 1L\n        for\
    \ (number <- numbers) {\n            sum += number\n            product *= number\n\
    \        }\n        return (sum, product)", '        return (numbers.sum, numbers.product)',
  "        var s = 0l\n        var p = 1l\n        for (n <- numbers) {\n        \
    \    s += n\n            p *= n\n        }\n        Tuple2(s, p)", "        var\
    \ s = 0L\n        var p = 1L\n        for (number <- numbers) {\n            s\
    \ += number\n            p *= number\n        }\n        (s, p)", "        var\
    \ sum = 0L\n        var product = 1L\n        numbers.foreach(sum += _)\n    \
    \    numbers.foreach(product *= _)\n        (sum, product)", "        val (sum,\
    \ product) = numbers.foldLeft((0L, 1L))((acc, x) => (acc._1 + x, acc._2 * x))\n\
    \        (sum, product)", '        return (numbers.sum, numbers.product)', '        numbers.foldLeft(0L,
    1L)((t, v) => (t._1 + v, t._2 * v))', '        return (numbers.sum, numbers.product)',
  '        (numbers.sum, numbers.product)', '        (numbers.sum, numbers.product)',
  "        var sum = 0L\n        var product = 1L\n        numbers.foreach(sum +=\
    \ _)\n        numbers.foreach(product *= _)\n        (sum, product)", "      \
    \  var sum = 0L\n        var product = 1L\n        for (i <- numbers) {\n    \
    \        sum += i\n            product *= i\n        }\n        (sum, product)",
  '        return (numbers.sum, numbers.product)', "        val s = numbers.sum\n\
    \        val p = numbers.product\n        (s, p)"]
stop_tokens:
- "\n    }\n"
