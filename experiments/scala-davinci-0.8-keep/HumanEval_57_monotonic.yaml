name: HumanEval_57_monotonic
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return True is list elements are monotonically increasing or decreasing.\n\
  \    // >>> monotonic([1, 2, 4, 20])\n    // True\n    // >>> monotonic([1, 20,\
  \ 4, 10])\n    // False\n    // >>> monotonic([4, 1, 0, -10])\n    // True\n   \
  \ def monotonic(l : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 10l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 20l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 20l.toLong, 4l.toLong, 10l.toLong))) == (false));\n    assert(monotonic((List[Long](4l.toLong,\
  \ 1l.toLong, 0l.toLong, -10l.toLong))) == (true));\n    assert(monotonic((List[Long](4l.toLong,\
  \ 1l.toLong, 1l.toLong, 0l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));\n    assert(monotonic((List[Long](9l.toLong,\
  \ 9l.toLong, 9l.toLong, 9l.toLong))) == (true));\n    }\n\n}\n"
completions: ["        if (l.length <= 1) return true\n        val o = l(0) < l(1)\n\
    \        for (i <- 1 until l.length - 1) if (o != (l(i) < l(i + 1))) return false\n\
    \        true", "        var i = 0\n        while (i < l.length - 1) {\n     \
    \       if (l(i) == l(i + 1)) i += 1\n            else if (l(i) < l(i + 1)) return\
    \ decreasing(l.slice(i + 1, l.length))\n            else return increasing(l.slice(i\
    \ + 1, l.length))\n        }\n        true", "        if (l.size <= 1) return\
    \ true\n        val first = l.head\n        val rest = l.tail\n        val second\
    \ = rest.head\n        val inc = second > first\n        val change_in_sign =\
    \ (rest, inc).zipped.map((x, inc) => x > first == inc)\n        return change_in_sign.forall(_\
    \ == true)", "        val diffs = l.zip(l.tail).map(x => x._2 - x._1)\n      \
    \  if (diffs.filter(x => x == 0).size == diffs.size) true\n        else if (diffs.filter(x\
    \ => x >= 0).size == diffs.size) true\n        else if (diffs.filter(x => x <=\
    \ 0).size == diffs.size) true\n        else false", "        if (l.length == 0)\
    \ return true\n        var diff = l(1) - l(0)\n        for (i <- 2 until l.length)\
    \ {\n            if (diff != 0 && l(i) - l(i - 1) != diff) return false\n    \
    \    }\n        return true", "        if (l.length == 1) return true\n      \
    \  else {\n            val ls = l.zip(l.tail)\n            ls.forall(p => p._1\
    \ <= p._2) || ls.forall(p => p._1 >= p._2)\n        }", "        if (l.length\
    \ == 1) true\n        else if (l.length == 2) true\n        else {\n         \
    \   val diffs = l.sliding(2).map(x => x(1) - x(0)).toList\n            val directions\
    \ = diffs.filter(_ != 0).groupBy(d => d).keys.toList\n            directions.length\
    \ <= 1\n        }", "        val (increasing, decreasing) = l.sliding(2).foldLeft((true,\
    \ true))((a, b) => (a._1 && b._1 <= b._2, a._2 && b._1 >= b._2))\n        return\
    \ increasing || decreasing", "        def aux(l : List[Long], b : Boolean) : Boolean\
    \ = l match {\n            case Nil => true\n            case h :: Nil => true\n\
    \            case h1 :: h2 :: t => if (h1 < h2) {\n                if (b) false\
    \ else aux(h2 :: t, false)\n            } else if (h1 > h2) {\n              \
    \  if (b) false else aux(h2 :: t, true)\n            } else {\n              \
    \  aux(h2 :: t, b)\n            }\n        }\n        aux(l, false)", "      \
    \  var increasing = true\n        var decreasing = true\n        for (i <- 1 until\
    \ l.length) {\n            if (l(i) > l(i - 1)) decreasing = false\n         \
    \   if (l(i) < l(i - 1)) increasing = false\n        }\n        increasing ||\
    \ decreasing", "        if (l.length <= 1) true\n        else {\n            if\
    \ (l(0) == l(1)) monotonic(l.tail)\n            else {\n                val incre\
    \ = (l(0) < l(1))\n                def loop(l : List[Long]) : Boolean = {\n  \
    \                  if (l.length <= 1) true\n                    else {\n     \
    \                   if (incre) (l(0) < l(1)) && loop(l.tail)\n               \
    \         else (l(0) > l(1)) && loop(l.tail)\n                    }\n        \
    \        }\n                loop(l)\n            }\n        }", "        if (l.size\
    \ == 1) true\n        else {\n            var increasing = true\n            var\
    \ decreasing = true\n            for (i <- 0 until l.size - 1) {\n           \
    \     if (l(i) > l(i + 1)) increasing = false\n                if (l(i) < l(i\
    \ + 1)) decreasing = false\n            }\n            increasing || decreasing\n\
    \        }", "        if (l.length == 0) return true\n        var direction =\
    \ l(0) < l(1)\n        for (i <- 1 until l.length - 1) {\n            if (direction)\
    \ {\n                if (l(i) > l(i + 1)) return false\n            } else {\n\
    \                if (l(i) < l(i + 1)) return false\n            }\n        }\n\
    \        return true", "      if (l.size <= 1) return true\n      if (l(0) < l(1))\
    \ {\n        for (i <- 0 until l.size - 1) {\n          if (l(i) > l(i + 1)) return\
    \ false\n        }\n      } else {\n        for (i <- 0 until l.size - 1) {\n\
    \          if (l(i) < l(i + 1)) return false\n        }\n      }\n      return\
    \ true", "        if (l.length <= 1) return true\n        var (a, b) = (l(0),\
    \ l(1))\n        var monotonic = true\n        for (i <- 2 until l.length) {\n\
    \            if (a < b) {\n                if (b < l(i)) monotonic = false\n \
    \           } else if (a > b) {\n                if (b > l(i)) monotonic = false\n\
    \            }\n            a = b\n            b = l(i)\n        }\n        monotonic",
  "        if (l.size <= 1) true\n        else {\n            val direction = (l(1)\
    \ - l(0))\n            def isMonotonic(old : Long, x : Long) : Boolean = {\n \
    \               val newDiff = (x - old)\n                if (newDiff != 0 && newDiff\
    \ * direction < 0) false\n                else if (x == l.last) true\n       \
    \         else isMonotonic(x, l(l.indexOf(x) + 1))\n            }\n          \
    \  isMonotonic(l(0), l(1))\n        }", "        if (l.length <= 1) true\n   \
    \     else {\n            val p = l.zip(l.tail)\n            val t = p.map {case\
    \ (x, y) => (x - y) * (x - y)}\n            val s = t.sum\n            s == 0\
    \ || s == p.length - 1\n        }", "        if (l.length <= 1)\n            return\
    \ true\n        val sign = signum(l(1) - l(0))\n        for (i <- 0 until l.length\
    \ - 1)\n            if (signum(l(i + 1) - l(i)) != sign)\n                return\
    \ false\n        return true", "        if (l.length <= 1) return true\n     \
    \   var (flag, curr) = (l(1) > l(0), l(0))\n        for (x <- l) {\n         \
    \   if (flag) {\n                if (x < curr) return false\n            } else\
    \ {\n                if (x > curr) return false\n            }\n            curr\
    \ = x\n        }\n        return true", "        val s = l.sorted\n        if\
    \ (s == l) true\n        else if (s.reverse == l) true\n        else false"]
stop_tokens:
- "\n    }\n"
