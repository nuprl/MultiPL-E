name: HumanEval_88_sort_array
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given an array of non-negative integers, return a copy of the given array\
  \ after sorting,\n    // you will sort the given array in ascending order if the\
  \ sum( first index value, last index value) is odd,\n    // or sort it in descending\
  \ order if the sum( first index value, last index value) is even.\n    // Note:\n\
  \    // * don't change the given array.\n    // Examples:\n    // * sort_array([])\
  \ => []\n    // * sort_array([5]) => [5]\n    // * sort_array([2, 4, 3, 0, 1, 5])\
  \ => [0, 1, 2, 3, 4, 5]\n    // * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4,\
  \ 3, 2, 1, 0]\n    def sortArray(array : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
  \    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n\
  \    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong,\
  \ 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong,\
  \ 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong,\
  \ 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
  \ 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong,\
  \ 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
  \ 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong,\
  \ 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong,\
  \ 14l.toLong, 11l.toLong))));\n    }\n\n}\n"
completions: ["        val first = array.head\n        val last = array.last\n   \
    \     val isOdd = (first + last) % 2 == 1\n        if (isOdd) array.sorted else\
    \ array.sorted.reverse", "        //\n        // Your code should be written here\n\
    \        //\n        return array.sorted", "        def sortArrayHelper(array\
    \ : List[Long], length : Int) : List[Long] = {\n            if (length < 2) {\n\
    \                array\n            } else {\n                val (x, xs) = array.splitAt(length\
    \ / 2)\n                merge(sortArrayHelper(x, x.length), sortArrayHelper(xs,\
    \ xs.length))\n            }\n        }\n        def merge(left : List[Long],\
    \ right : List[Long]) : List[Long] = {\n            if (left.isEmpty) {\n    \
    \            right\n            } else if (right.isEmpty) {\n                left\n\
    \            } else if (left.head < right.head) {\n                left.head ::\
    \ merge(left.tail, right)\n            } else {\n                right.head ::\
    \ merge(left, right.tail)\n            }\n        }\n        val length = array.length\n\
    \        if (length == 0) {\n            return array\n        }\n        if (length\
    \ == 1) {\n            return array\n        }\n        val sortedArray = sortArrayHelper(array,\
    \ length)\n        if ((array.head + array.last) % 2 == 0) {\n            sortedArray.reverse\n\
    \        } else {\n            sortedArray\n        }", "        val range = List.range(0,\
    \ array.length)\n        if ((array.head + array.last) % 2 == 0) array.sorted.reverse\
    \ else array.sorted", "        // (1) array is Nil?\n        if (array.isEmpty)\
    \ return array\n        // (2) get first and last values\n        val v1 = array.head\n\
    \        val v2 = array.last\n        // (3) create a new sorted array\n     \
    \   val newArray = array.sorted\n        // (4) get new first and last values\n\
    \        val v3 = newArray.head\n        val v4 = newArray.last\n        // (5)\
    \ return new array based on the sum (v1 + v2)\n        (v1 + v2) % 2 match {\n\
    \            case 0 => List(v4) ++ newArray.init\n            case _ => newArray.tail\
    \ ++ List(v3)\n        }", "        if(array.isEmpty) array\n        else {\n\
    \            val order = (array.head + array.last) % 2\n            val temp =\
    \ array.sorted\n            if(order == 0) temp.reverse\n            else temp\n\
    \        }", "        def oddSort(lst : List[Long]) : List[Long] = {\n       \
    \     lst.sortWith(_ < _)\n        }\n        def evenSort(lst : List[Long]) :\
    \ List[Long] = {\n            lst.sortWith(_ > _)\n        }\n        val isOdd\
    \ = array.head + array.last match {\n            case v if (v % 2 == 0) => false\n\
    \            case _ => true\n        }\n        if (isOdd) oddSort(array) else\
    \ evenSort(array)", "        if (array.isEmpty) return List[Long]()\n        else\
    \ if (array.length == 1) return array\n        val isEven = (array.head + array.last)\
    \ % 2 == 0\n        var i = 0\n        var j = array.length - 1\n        var result\
    \ = List[Long]()\n        while (i <= j) {\n            if (isEven) {\n      \
    \          val max = array.max\n                result = result :+ max\n     \
    \           array = array.filter(x => x != max)\n                j -= 1\n    \
    \        } else {\n                val min = array.min\n                result\
    \ = result :+ min\n                array = array.filter(x => x != min)\n     \
    \           i += 1\n            }\n        }\n        result", "        if (array.size\
    \ == 0) return array\n        val a = array.sortWith(_ > _)\n        if ((a.head\
    \ + a.last) % 2 == 0) {\n            a\n        } else {\n            array.sortWith(_\
    \ < _)\n        }", "        val i = array.head\n        val j = array.last\n\
    \        if ((i + j) % 2 == 0) array.sorted.reverse else array.sorted", "    \
    \    val reversed = array.reverse\n        (array.sum % 2 == 0) match {\n    \
    \        case true => reversed\n            case false => reversed.reverse\n \
    \       }", "      def sort(s : List[Long], t : List[Long]) : List[Long] = s match\
    \ {\n        case Nil => t\n        case h :: tail => sort(tail, head(h, t))\n\
    \      }\n      def head(x : Long, xs : List[Long]) : List[Long] = xs match {\n\
    \        case Nil => List(x)\n        case h :: tail => if (x < h) x :: xs else\
    \ h :: head(x, tail)\n      }\n      if (array.length == 0) List()\n      else\
    \ if (array.length == 1) array\n      else if ((array.head + array.last) % 2 ==\
    \ 0) sort(array, List()).reverse\n      else sort(array, List())", "        def\
    \ asc() : Boolean = {\n            val sum = array.head + array.last\n       \
    \     sum % 2 == 1\n        }\n        if (array.length == 0) array\n        else\
    \ if (array.length == 1) array\n        else if (asc()) array.sorted\n       \
    \ else array.sorted.reverse", "        val arrayHasEvenElements = array.size %\
    \ 2 == 0\n        val sortedArray = array.sorted\n        val result = if (arrayHasEvenElements)\
    \ sortedArray.reverse else sortedArray\n        result", "        val sum = array.zipWithIndex.map(x\
    \ => x._1 + x._2).sum\n        if (sum % 2 == 0) {\n            array.sorted.reverse\n\
    \        } else {\n            array.sorted\n        }", "        if (array.length\
    \ == 0) {\n            return array\n        }\n        var arr = array.toArray\n\
    \        if ((arr(0) + arr(arr.length - 1)) % 2 == 0) {\n            arr = arr.sortWith(_\
    \ > _)\n        } else {\n            arr = arr.sortWith(_ < _)\n        }\n \
    \       arr.toList", "    \tval n = array.length\n    \tif (n % 2 == 0) array.sorted.reverse\n\
    \    \telse array.sorted", "    \tif (array.length == 0) return List[Long]()\n\
    \    \tif (array.length == 1) return array\n    \tval first = array.head\n   \
    \ \tval last = array.last\n    \tval sorted = (first + last) % 2 match {\n   \
    \ \t\tcase 0 => array.sorted.reverse\n    \t\tcase 1 => array.sorted\n    \t}\n\
    \    \tsorted", "        if (array.isEmpty) {\n            return List[Long]()\n\
    \        }\n        else if (array.length == 1) {\n            return array\n\
    \        }\n        else {\n            val indexes = array.indices.toList\n \
    \           if ((array.head + array.last) % 2 == 0) {\n                return\
    \ (indexes zip array.sorted).sortBy(_._2).map(_._1).map(index => array(index))\n\
    \            }\n            else {\n                return (indexes zip array.sorted.reverse).sortBy(_._2).map(_._1).map(index\
    \ => array(index))\n            }\n        }", "        val temp = array.map(_.toInt)\n\
    \        if (temp.size <= 1) return array\n        var odd = new ListBuffer[Int]\n\
    \        var even = new ListBuffer[Int]\n        for (i <- temp) {\n         \
    \   if (i % 2 == 0) even += i\n            else odd += i\n        }\n        odd\
    \ = odd.sorted\n        even = even.sorted\n        val result = new ListBuffer[Int]\n\
    \        if ((temp.head + temp.last) % 2 == 0) {\n            for (i <- odd.size\
    \ - 1 to 0 by -1) result += odd(i)\n            for (i <- even.size - 1 to 0 by\
    \ -1) result += even(i)\n        } else {\n            for (i <- odd) result +=\
    \ i\n            for (i <- even) result += i\n        }\n        result.toList.map(_.toLong)"]
stop_tokens:
- "\n    }\n"
