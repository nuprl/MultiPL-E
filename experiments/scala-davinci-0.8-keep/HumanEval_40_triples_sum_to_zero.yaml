name: HumanEval_40_triples_sum_to_zero
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // triples_sum_to_zero takes a list of integers as an input.\n    // it returns\
  \ True if there are three distinct elements in the list that\n    // sum to zero,\
  \ and False otherwise.\n    // >>> triples_sum_to_zero([1, 3, 5, 0])\n    // False\n\
  \    // >>> triples_sum_to_zero([1, 3, -2, 1])\n    // True\n    // >>> triples_sum_to_zero([1,\
  \ 2, 3, 7])\n    // False\n    // >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n\
  \    // True\n    // >>> triples_sum_to_zero([1])\n    // False\n    def triplesSumToZero(l\
  \ : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, -1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 5l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong)))\
  \ == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong,\
  \ -100l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](100l.toLong,\
  \ 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    }\n\n}\n"
completions: ["        // iterate through the list and store the data in hash-table\
    \ (dictionary)\n        // key = number, value = number of times it occurs\n \
    \       val hashTable = scala.collection.mutable.HashMap[Long, Int]()\n      \
    \  for (n <- l) {\n            if (hashTable.contains(n)) {\n                val\
    \ oldValue = hashTable(n)\n                hashTable(n) = oldValue + 1\n     \
    \       } else {\n                hashTable(n) = 1\n            }\n        }\n\
    \        for (i <- 0 until l.length) {\n            for (j <- i + 1 until l.length)\
    \ {\n                val needed = -(l(i) + l(j))\n                if (hashTable.contains(needed))\
    \ {\n                    if (needed == l(i) && hashTable(needed) < 2) {\n    \
    \                    return false\n                    } else if (needed == l(j)\
    \ && hashTable(needed) < 2) {\n                        return false\n        \
    \            } else if (needed != l(i) && needed != l(j)) {\n                \
    \        return true\n                    }\n                }\n            }\n\
    \        }\n        return false", "        val n = l.length\n        for (i <-\
    \ 0 until n; j <- i + 1 until n; k <- j + 1 until n) {\n            if (l(i) +\
    \ l(j) + l(k) == 0) return true\n        }\n        return false", "        val\
    \ l2 = l.filter(x => x != 0)\n        val l3 = l2.combinations(3).toList\n   \
    \     val l4 = l3.map(x => x.sum)\n        l4.contains(0)", "        // fill in\
    \ here with your answer.\n        true", "        val a = new ArrayBuffer[Long]()\n\
    \        val b = new ArrayBuffer[Long]()\n        val c = new ArrayBuffer[Long]()\n\
    \        val t = new ArrayBuffer[Long]()\n        var i = 0\n        val s = l.toSet\n\
    \        for (x <- s) {\n            if (x == 0) {\n                if (t.contains(0))\
    \ {\n                    return true\n                } else {\n             \
    \       t += 0\n                }\n            } else if (x < 0) {\n         \
    \       if (t.contains(-x)) {\n                    return true\n             \
    \   } else {\n                    t += -x\n                }\n               \
    \ a += x\n            } else {\n                if (t.contains(-x)) {\n      \
    \              return true\n                } else {\n                    t +=\
    \ -x\n                }\n                b += x\n            }\n        }\n  \
    \      a.sortInPlace()\n        b.sortInPlace()\n        i = 0\n        var j\
    \ = 0\n        while (i < a.length && j < b.length) {\n            if (a(i) +\
    \ b(j) == 0) {\n                return true\n            } else if (a(i) + b(j)\
    \ < 0) {\n                i += 1\n            } else {\n                j += 1\n\
    \            }\n        }\n        false", "        if (l.length < 3) return false\n\
    \        val l2 = l.sortWith(_ < _)\n        for (i <- 0 until l2.length - 2)\
    \ {\n            var left = i + 1\n            var right = l2.length - 1\n   \
    \         while (left < right) {\n                if (l2(i) + l2(left) + l2(right)\
    \ == 0) return true\n                else if (l2(i) + l2(left) + l2(right) < 0)\
    \ left += 1\n                else right -= 1\n            }\n        }\n     \
    \   return false", "        val map = new HashMap[Long, Int]()\n        for (e\
    \ <- l) {\n            if (map.contains(e)) map(e) += 1\n            else map\
    \ += (e -> 1)\n        }\n        val found = new HashSet[Long]()\n        for\
    \ (i <- 0 until l.length) {\n            for (j <- i + 1 until l.length) {\n \
    \               val sum = l(i) + l(j)\n                if (map.contains(-sum))\
    \ {\n                    if (-sum == l(i) && map(-sum) > 1) return true\n    \
    \                if (-sum == l(j) && map(-sum) > 1) return true\n            \
    \        if (-sum != l(i) && -sum != l(j)) return true\n                }\n  \
    \          }\n        }\n        false", "        var s : Set[Long] = Set()\n\
    \        for (x <- l) s += x\n        for (i <- 0 until l.length) {\n        \
    \    for (j <- i + 1 until l.length) {\n                if (s.contains(-l(i) -\
    \ l(j))) return true\n            }\n        }\n        return false", "     \
    \ l.sortBy(x => x)\n      if (l.length < 3) false\n      else {\n        var i\
    \ = 0\n        while (i < l.length - 2) {\n          var j = i + 1\n         \
    \ var k = l.length - 1\n          while (j < k) {\n            if (l(i) + l(j)\
    \ + l(k) == 0) return true\n            else if (l(i) + l(j) + l(k) < 0) j +=\
    \ 1\n            else k -= 1\n          }\n          i += 1\n        }\n     \
    \   false\n      }", "        // YOUR CODE HERE\n        false", "        if (l.length\
    \ <= 2) return false\n        val map = new HashMap[Long, Int]\n        val count\
    \ = Array.fill(3)(0)\n        for (x <- l) {\n            val y = -x\n       \
    \     count(0) += 1\n            if (map.contains(y) && count(0) - map(y) >= 2)\
    \ return true\n            if (map.contains(x)) count(map(x)) += 1\n         \
    \   else map += (x -> 1)\n        }\n        if (map.contains(0) && map(0) >=\
    \ 3) return true\n        return false", "        if (l.length < 3) return false\n\
    \        for (x <- l) {\n            for (y <- l) {\n                for (z <-\
    \ l) {\n                    if (x != y && y != z && x != z && x + y + z == 0)\
    \ return true\n                }\n            }\n        }\n        return false",
  "        // brute force-ish \n        for (i <- 0 until l.length) {\n          \
    \  for (j <- i + 1 until l.length) {\n                for (k <- j + 1 until l.length)\
    \ {\n                    if (l(i) + l(j) + l(k) == 0) {\n                    \
    \    return true\n                    }\n                }\n            }\n  \
    \      }\n        return false", "\tval s = l.toSet\n\tval m = l.map(x => (-1\
    \ * x, x)).toMap\n\tl.foreach(x => l.foreach(y => if (m.contains(x + y)) return\
    \ true))\n\treturn false", "        for (i <- 0 until l.length - 2) {\n      \
    \      for (j <- i + 1 until l.length - 1) {\n                for (k <- j + 1\
    \ until l.length) {\n                    if (l(i) + l(j) + l(k) == 0) return true\n\
    \                }\n            }\n        }\n        return false", "      val\
    \ dict = Map[Long, Boolean]()\n      for (x <- l) dict += x -> true\n      for\
    \ (x <- l) {\n        for (y <- l) {\n          if (dict.contains(-x - y)) return\
    \ true\n        }\n      }\n      return false", "        // number of distinct\
    \ elements\n        val n = l.distinct.length\n        if (n < 3) false\n    \
    \    else {\n            // sort the list\n            val l_sorted = l.sorted\n\
    \            // get a list of distinct elements and their indices in the original\
    \ list\n            val l_distinct = l_sorted.distinct.zipWithIndex\n        \
    \    // if there are less than 3 distinct elements, return false\n           \
    \ // get the unique combinations of 3 numbers.\n            val combinations =\
    \ l_distinct.combinations(3)\n            // check each combination\n        \
    \    combinations.exists(l => {\n                val comb = l.map(x => x._1)\n\
    \                val ind = l.map(x => x._2)\n                // if the sum of\
    \ any of the three distinct elements is zero, return true\n                if\
    \ (comb.sum == 0) true\n                // if the sum of any two elements is equal\
    \ to the negation of the third element, return true\n                else if (ind.forall(i\
    \ => ind.contains(i + 1) || ind.contains(i - 1))) comb.toSet.subsets(2).exists(x\
    \ => {\n                    if (comb.sum - x.sum == 0) true\n                \
    \    else false\n                })\n                // if none of the above is\
    \ true, return false\n                else false\n            })\n        }",
  "        val lSet = l.toSet\n        val n = l.length\n        val r = new scala.util.Random\n\
    \        val s = lSet.size\n        for (i <- 1 to min(1000, n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\
    \ * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n", "    \
    \    val sorted = l.sorted\n        for (i <- 0 until sorted.length - 2) {\n \
    \           var p = i + 1\n            var q = sorted.length - 1\n           \
    \ while (p < q) {\n                val sum = sorted(i) + sorted(p) + sorted(q)\n\
    \                if (sum == 0) {\n                    return true\n          \
    \      } else if (sum < 0) {\n                    p += 1\n                } else\
    \ {\n                    q -= 1\n                }\n            }\n        }\n\
    \        return false", "        if (l.length < 3) return false\n        val l2\
    \ = l.sorted\n        for (i <- 0 until l2.length - 2) {\n            var j =\
    \ i + 1\n            var k = l2.length - 1\n            while (j < k) {\n    \
    \            if (l2(i) + l2(j) + l2(k) == 0) return true\n                else\
    \ if (l2(i) + l2(j) + l2(k) < 0) j += 1\n                else k -= 1\n       \
    \     }\n        }\n        return false"]
stop_tokens:
- "\n    }\n"
