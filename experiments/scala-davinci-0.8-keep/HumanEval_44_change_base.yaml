name: HumanEval_44_change_base
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Change numerical base of input number x to base.\n    // return string representation\
  \ after the conversion.\n    // base numbers are less than 10.\n    // >>> change_base(8,\
  \ 3)\n    // '22'\n    // >>> change_base(8, 2)\n    // '1000'\n    // >>> change_base(7,\
  \ 2)\n    // '111'\n    def changeBase(x : Long, base : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(changeBase((8l),\
  \ (3l)).equals((\"22\")));\n    assert(changeBase((9l), (3l)).equals((\"100\")));\n\
  \    assert(changeBase((234l), (2l)).equals((\"11101010\")));\n    assert(changeBase((16l),\
  \ (2l)).equals((\"10000\")));\n    assert(changeBase((8l), (2l)).equals((\"1000\"\
  )));\n    assert(changeBase((7l), (2l)).equals((\"111\")));\n    assert(changeBase((2l),\
  \ (3l)).equals((\"2\")));\n    assert(changeBase((3l), (4l)).equals((\"3\")));\n\
  \    assert(changeBase((4l), (5l)).equals((\"4\")));\n    assert(changeBase((5l),\
  \ (6l)).equals((\"5\")));\n    assert(changeBase((6l), (7l)).equals((\"6\")));\n\
  \    assert(changeBase((7l), (8l)).equals((\"7\")));\n    }\n\n}\n"
completions: ["        if (x == 0) {\n            \"0\"\n        } else {\n      \
    \      val changeDigit = (n : Long) => (if (n < 10) n + '0' else n - 10 + 'A').toChar\n\
    \            (Stream.iterate(x)(n => n / base).takeWhile(_ != 0).map(n => changeDigit(n\
    \ % base)).reverse).mkString\n        }", "        var r : Long = x % base\n \
    \       var q : Long = x / base\n        var result : String = r.toString\n  \
    \      while (q != 0) {\n            r = q % base\n            q = q / base\n\
    \            result = r.toString + result\n        }\n        return result",
  "        val s = new StringBuilder\n        def loop(rem : Long) {\n           \
    \ if (rem == 0) {\n                s.append(0)\n            } else {\n       \
    \         s.append(rem % base)\n                loop(rem / base)\n           \
    \ }\n        }\n        loop(x)\n        s.reverse.toString", "        var res\
    \ = \"\"\n        var y = x\n        while (y > 0) {\n            res = (y % base).toString\
    \ + res\n            y /= base\n        }\n        res", "        if (x == 0)\
    \ {\n            \"0\"\n        } else {\n            val s = new StringBuilder\n\
    \            var remain = x\n            while (remain > 0) {\n              \
    \  s.append(remain % base)\n                remain /= base\n            }\n  \
    \          s.reverse.toString\n        }", "        if (x == 0) return \"0\"\n\
    \        val sb = new StringBuilder\n        var x2 = x\n        while (x2 > 0)\
    \ {\n            sb.append(x2 % base)\n            x2 /= base\n        }\n   \
    \     sb.reverse.toString", "        var y = x\n        var result = \"\"\n  \
    \      while (y != 0) {\n            val digit = y % base\n            y = y /\
    \ base\n            result = digit.toString() + result\n        }\n        return\
    \ result", "        var r = \"\"\n        var n = x\n        while (n > 0) {\n\
    \            r = (n % base).toString + r\n            n /= base\n        }\n \
    \       r", "        var s = \"\";\n        var y = x;\n        while (y > 0)\
    \ {\n            s = (y % base).toString + s;\n            y /= base;\n      \
    \  }\n        return s;", "        def changeBaseHelper(x : Long, base : Long,\
    \ output : String) : String = x match {\n            case 0 => output\n      \
    \      case _ => changeBaseHelper(x / base, base, (x % base).toString + output)\n\
    \        }\n        changeBaseHelper(x, base, \"\")", "        var r = x\n   \
    \     var ret = \"\"\n        while (r > 0) {\n            val c = r % base\n\
    \            ret = c.toString() + ret\n            r = r / base\n        }\n \
    \       ret", "        var res = x\n        var ans = \"\"\n        while (res\
    \ != 0) {\n            ans = (res % base).toString + ans\n            res /= base\n\
    \        }\n        ans", "        var cur = x\n        var result = \"\"\n  \
    \      while (cur > 0) {\n            result = (cur % base).toString + result\n\
    \            cur /= base\n        }\n        return result", "        var ans\
    \ = \"\"\n        var t = x\n        while (t > 0) {\n            ans = (t % base).toString\
    \ + ans\n            t /= base\n        }\n        ans", "        val r = new\
    \ ListBuffer[Long]\n        var n = x\n        while (n > 0) {\n            r\
    \ += n % base\n            n /= base\n        }\n        r.reverse.mkString",
  "        var result = \"\"\n        var rem = x\n        while (rem > 0) {\n   \
    \         result = (rem % base).toString + result\n            rem /= base\n \
    \       }\n        return result", "        def getIndex(x : Long, base : Long)\
    \ : Int = {\n            if (x < base) return 0\n            return 1 + getIndex(x\
    \ / base, base)\n        }\n        def getString(x : Long, base : Long, index\
    \ : Int) : String = {\n            if (index == 0) return (x % base).toString\n\
    \            return getString(x, base, index - 1) + (x % base).toString\n    \
    \    }\n        return getString(x, base, getIndex(x, base))", "        def cal(x\
    \ : Long, base : Long) : String = {\n            if (x == 0) return \"\"\n   \
    \         val mod = x % base\n            val rest = x / base\n            cal(rest,\
    \ base) + mod.toString\n        }\n        cal(x, base)", "      var m = x\n \
    \     var n = base\n      var s = new StringBuilder\n      while (m > 0) {\n \
    \       s.append(m % n)\n        m /= n\n      }\n      s.reverse.toString", " \
    \       val sb = new StringBuilder\n        var n = x\n        while (n > 0) {\n\
    \            sb.append(n % base)\n            n /= base\n        }\n        sb.reverse.toString"]
stop_tokens:
- "\n    }\n"
