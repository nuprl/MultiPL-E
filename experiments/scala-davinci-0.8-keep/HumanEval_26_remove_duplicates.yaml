name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n    // [1, 3, 4]\n    def removeDuplicates(numbers : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["      val counts = ListBuffer[Long]()\n      for (number <- numbers)\
    \ {\n        if (!counts.contains(number)) counts += number\n      }\n      return\
    \ counts.toList", "      val map = HashMap[Long, Long]()\n      numbers.foreach(number\
    \ => {\n        map(number) = map.getOrElse(number, 0) + 1\n      })\n      numbers.filter(number\
    \ => map(number) == 1)", '        numbers.toSet.toList', "        val set = mutable.HashSet[Long]()\n\
    \        val result = mutable.ListBuffer[Long]()\n        for (number <- numbers)\
    \ {\n            if (!set.contains(number)) {\n                set += number\n\
    \                result += number\n            }\n        }\n        result.toList",
  '        return numbers.distinct', "        val numbersAsHashMap = new HashMap[Long,\
    \ Boolean]\n        numbers.foreach(n => numbersAsHashMap += n -> true)\n    \
    \    numbersAsHashMap.keys.toList", '        numbers.toSet.toList', "        val\
    \ m = scala.collection.mutable.Map[Long, Boolean]()\n        for (number <- numbers)\
    \ {\n            if (m.contains(number)) m(number) = true\n            else m(number)\
    \ = false\n        }\n        val result = ListBuffer[Long]()\n        for (number\
    \ <- numbers) {\n            if (!m(number)) result += number\n        }\n   \
    \     result.toList", "        val hm = new HashMap[Long, Boolean]\n        val\
    \ result = new ListBuffer[Long]\n        for (n <- numbers) {\n            if\
    \ (!hm.contains(n)) {\n                hm.put(n, true)\n                result\
    \ += n\n            }\n        }\n        result.toList", "        val numbersCounts\
    \ = numbers.groupBy(identity).mapValues(_.size)\n        numbers.filter(numbersCounts(_)\
    \ == 1)", '        numbers.filter((number : Long) => numbers.count((x : Long)
    => x == number) == 1)', "    \tvar distinct = new ListBuffer[Long]\n    \tvar\
    \ occurrenceCount = new HashMap[Long, Long]\n    \tfor (i <- numbers) {\n    \t\
    \tif (occurrenceCount.contains(i)) occurrenceCount(i) += 1\n    \t\telse occurrenceCount(i)\
    \ = 1\n    \t}\n    \tfor (i <- numbers) {\n    \t\tif (occurrenceCount(i) ==\
    \ 1) distinct += i\n    \t}\n    \tdistinct.toList", "        // scala doesn't\
    \ have a set\n        return numbers.distinct", "        val map = new HashMap[Long,\
    \ Boolean]\n        for (number <- numbers) map.put(number, !map.contains(number))\n\
    \        for (number <- numbers if map(number)) yield number", "        val index\
    \ = numbers.foldLeft(Map[Long, Int]())((map, n) => map + (n -> (map.getOrElse(n,\
    \ 0) + 1)))\n        numbers.filter(n => index(n) == 1)", "        var hm = Map[Long,\
    \ Boolean]()\n        for (number <- numbers) {\n            if (hm.contains(number))\
    \ hm += (number -> false)\n            else hm += (number -> true)\n        }\n\
    \        var result = List[Long]()\n        for (number <- numbers) if (hm(number))\
    \ result = number :: result\n        result.reverse", "      var hashtable = new\
    \ HashMap[Long, Boolean]()\n      var newlist = new ListBuffer[Long]()\n     \
    \ for (n <- numbers) {\n        if (!hashtable.contains(n)) {\n          hashtable.put(n,\
    \ true)\n          newlist += n\n        }\n      }\n      newlist.toList", " \
    \       if (numbers.isEmpty) Nil\n        else {\n            val (left, right)\
    \ = numbers.span(_ == numbers.head)\n            if (left.length > 1) removeDuplicates(right)\n\
    \            else left.head :: removeDuplicates(right)\n        }", "        val\
    \ map = new HashMap[Long, Boolean]\n        numbers.foreach(x => map(x) = true)\n\
    \        map.keySet.toList", '        numbers.distinct']
stop_tokens:
- "\n    }\n"
