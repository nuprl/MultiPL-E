name: HumanEval_139_special_factorial
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // The Brazilian factorial is defined as:\n    // brazilian_factorial(n) =\
  \ n! * (n-1)! * (n-2)! * ... * 1!\n    // where n > 0\n    // For example:\n   \
  \ // >>> special_factorial(4)\n    // 288\n    // The function will receive an integer\
  \ as input and should return the special\n    // factorial of this integer.\n  \
  \  def specialFactorial(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(specialFactorial((4l))\
  \ == (288l));\n    assert(specialFactorial((5l)) == (34560l));\n    assert(specialFactorial((7l))\
  \ == (125411328000l));\n    assert(specialFactorial((1l)) == (1l));\n    }\n\n}\n"
completions: ["        if (n == 0) {\n            1\n        } else {\n          \
    \  n * factorial(n - 1)\n        }", "        if (n == 0) return 1\n        n\
    \ * specialFactorial(n - 1)", "        var result = 1L\n        for (i <- 1L to\
    \ n) {\n            result *= factorial(i)\n        }\n        result", "    \t\
    if (n == 0) 1 else n * specialFactorial(n - 1)", "        val factorials = ArrayBuffer[Long]()\n\
    \        factorials += 1\n        (1 to n).foreach(i => factorials += factorials(i\
    \ - 1) * i)\n        factorials.reduce(_ * _)", "        def factorial(n : Long)\
    \ : Long = if (n == 0) 1 else n * factorial(n - 1)\n        var fact = 1L\n  \
    \      for (i <- 0 until n.toInt) fact *= factorial(n - i)\n        fact", " \
    \       var x : Long = 1\n        for (i <- n to 1 by -1) {\n            x *=\
    \ i\n        }\n        for (i <- n - 1 to 1 by -1) {\n            x *= i\n  \
    \      }\n        x", "        var m = n\n        var ans = 1L\n        while\
    \ (m >= 1) {\n            ans *= m * (m - 1)\n            m -= 2\n        }\n\
    \        ans", "        var p = BigInt(1)\n        for (i <- 1 to n.toInt) p *=\
    \ i\n        for (i <- 1 to n.toInt - 1) p *= i\n        for (i <- 1 to n.toInt\
    \ - 2) p *= i\n        p.toLong", "    \tvar factorials = new Array[Long](n.toInt)\n\
    \    \tfactorials(0) = 1\n    \tfor (i <- 1 to n.toInt - 1) factorials(i) = factorials(i\
    \ - 1) * i\n    \tfactorials.product", "        def specialFactorial(n : Long,\
    \ k : Long) : Long = {\n            if (k == 1) n else (n * specialFactorial(n\
    \ - 1, k - 1)) % 1000000007\n        }\n        specialFactorial(n, n)", "   \
    \     if (n == 0) return 1\n        else return (1 to n.toInt).map(BigInt(_)).product.toLong",
  "        var prod = 1L\n        for (i <- 2 to n.toInt) {\n            prod *= factorial(i)\n\
    \        }\n        prod", "        if (n == 0) return 1\n        var result =\
    \ specialFactorial(n - 1)\n        for (i <- 1 to n) result *= i\n        result",
  "        val t = Array.ofDim[Long](n.toInt, n.toInt)\n        t(0)(0) = 1\n    \
    \    t(1)(0) = 2\n        t(1)(1) = 1\n        for (i <- 2 to n.toInt - 1) {\n\
    \            t(i)(0) = i + 1\n            for (j <- 1 to i) {\n              \
    \  t(i)(j) = t(i - 1)(j - 1) + t(i - 1)(j) * t(i)(0)\n            }\n        }\n\
    \        t(n.toInt - 1)(0)", '        (1L to n).map(x => factorial(x)).product',
  "        var result = 1L\n        for (i <- 1L to n) {\n            result *= i\
    \ * specialFactorial(i - 1)\n        }\n        result", "    \t//def factorial(n\
    \ : Long) : Long = n match {\n    \t//\tcase 1 => 1\n    \t//\tcase _ => n * factorial(n\
    \ - 1)\n    \t//}\n    \t//Stream.range(1, n + 1).map(factorial).reduceLeft(_\
    \ * _)\n    \tvar f = new Array[Long](100)\n    \tf(0) = 1\n    \tf(1) = 1\n \
    \   \tfor (i <- 2 to n.toInt) {\n    \t\tf(i) = i * f(i - 1)\n    \t}\n    \t\
    f.reduceLeft(_ * _)", '        (BigInt(1) to BigInt(n)).product.toLong', "   \
    \     var mul = 1L\n        val b = scala.collection.mutable.Queue(1L)\n     \
    \   for (i <- 2 to n.toInt) {\n            mul *= i\n            b.enqueue(mul)\n\
    \        }\n        b.reverse.foldLeft(1L)(_ * _)"]
stop_tokens:
- "\n    }\n"
